---
title:  병렬 프로그램 구조 잡기
categories:
- Java Concurrency In Practice
feature_text: |
  ## 병렬 프로그램 구조 잡기
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---

### 6. 작업 실행
<br/>
+ 작업(task)  
추상적이면서 명확하게 구분된 업무의 단위  

#### 6.1. 스레드에서 작업 실행
<br/>
애플리케이션에 부하가 가해지는 상황에서 그냥 죽어버려서는 안 되고, 부하에 따라 성능이 점진적으로 떨어지도록 설계돼 있어야 한다. 애플리케이션이 위와 같은 특성을 갖게 하려면 작업 단위의 범위를 적절하게 설정하고, 작업을 실행하는 정책(task execution policy)을 면밀하게 구성해 둘 필요가 있다.  

##### 6.1.3. 스레드를 많이 생성할 때의 문제점
<br/>
+ 스레드 라이프 사이클 문제  
스레드를 생성하고 제거하는 작업에도 자원이 소모된다. 스레드를 생성하고 제거하는 데 실제로 얼마만큼의 자원을 소모하는지는 운영체제에 따라 다르지만, 어쨌거나 스레드를 생성하는 과정에는 일정량의 시간이 필요하다. 따라서 클라이언트의 요청을 처리할 때 기본적인 딜레이가 생기고, 그 동안 JVM과 운영체제는 몇 가지 기초적인 작업을 진행한다. 만약 클라이언트의 요청 내용이 간단하면서 자주 발생하는 유형이라면 요청이 들어올 때마다 매번 새로운 스레드를 생성하는 일이 상대적으로 전체 작업에서 많은 부분을 차지할 수 있다.  

+ 자원 낭비  
실행 중인 스레드는 시스템의 자원, 특히 메모리를 소모한다. 하드웨어에 실제로 장착되어 있는 프로세서보다 많은 수의 스레드가 만들어져 동작 중이라면, 실제로는 대부분의 스레드가 대기(idle) 상태에 머무른다. 이렇게 대기 상태에 머무르는 스레드가 많아지면 많아질수록 많은 메모리를 필요로 하며, JVM의 가비지 콜렉터에 가해지는 부하가 늘어날 뿐만 아니라 CPU를 사용하기 위해 여러 스레드가 경쟁하는 모양이 되기 대문에 메모리 이외에도 많은 자원을 소모한다. 만약 시스템에 꽂혀 있는 CPU의 개수에 해당하는 스레드가 동작 중이라면, 스레드를 더 만들어 낸다 해도 성능이 직접적으로 개선되지 않을 수 있으며 오히려 악영향을 미칠 가능성도 있다.  

+ 안정성 문제  
모든 시스템에는 생성할 수 있는 스레드의 개수가 제한되어 있다. 몇 개까지 만들 수 있는지는 플랫폼과 운영체제마다 다르고, JVM을 실행할 때 지정하는 인자나 Thread 클래스에 필요한 스택의 크기에 따라서 달라지기도 한다. 만약 제한된 양을 모두 사용하고 나면 아마도 OutOfMemoryError가 발생한다. 이처럼 OutOfMemoryError가 발생한 상황에서 해당하는 오류를 바로잡을 수 있는 방법은 별로 없으며, 가능하다 해도 안정적으로 처리하기가 어렵다. 결국 프로그램이 제한된 값 안에서 동작하도록 작성해 OutOfMemoryError가 발생하지 않도록 미연에 방지하는 방법이 훨씬 쉽다.  

32비트 시스템이라면 가장 큰 제약 요소는 바로 스레드 스택에 적요되는 주소 공간이다. 자바 코드의 네이티브 코드를 실행할 수 있도록 모든 스레드는 두 개의 스택을 갖는다. 일반적인 JVM의 기본값으로 보면 두 개의 스택을 더한 용량이 대략 0.5MB 정도 된다(이 값은 JVM을 실행할 때 -Xss 옵션을 지정하거나 Thread 클래스를 생성할 때 생성 메소드에 지정하는 값으로 변경할 수 있다). 예를 들어 스레드별 스택 크기를 2³²로 나눈 값으로 설정하면, 수천 개나 수만 개의 스레드를 사용할 수 있다. 운영체제 등에서 제한하는 여러 가지 제약 조건은 훨씬 엄격하게 적용될 수 있다.  

#### 6.2. Executor 프레임웍
<br/>
##### 6.2.2. 실행 정책
<br/>
작업을 등록하는 부분과 실행하는 부분을 서로 분리시켜두면 특정 작업을 실행하고자 할 때 코드를 많이 변경하거나 기타 여러 가지 어려운 상황에 맞닥뜨리지 않으면서도 실행 정책(execution policy)을 언제든지 쉽게 변경할 수 있다는 장점이 있다. 실행 정책은 다음과 같이 '무엇을, 어디에서, 언제, 어떻게' 실행하는지를 지정할 수 있다.  

+ 작업을 어느 스레드에서 실행할 것인가?
+ 작업을 어떤 순서로 실행할 것인가?(FIFO, LIFO, 기타 다양한 우선순위 정책)
+ 동시에 몇 개의 작업을 병렬로 실행할 것인가?
+ 최대 몇 개까지의 작업이 큐에서 실행을 대기할 수 있게 할 것인가?
+ 시스템에 부하가 많이 걸려서 작업을 거절해야 하는 경우, 어떤 작업을 희생양으로 삼아야 할 것이며, 작업을 요청하는 프로그램에 어떻게 알려야 할 것인가?
+ 작업을 실행하기 직전이나 실행한 직후에 어떤 동작이 있어야 하는가?  

실행 정책은 일종의 자원 관리 도구라고도 할 수 있다. 가장 최적화된 실행 정책을 찾으려면 하드에어나 소프트웨어적인 자원을 얼머나 확보할 수 있는지 확인해야 하고, 더불어 애플리케이션의 성능과 반응 속도과 요구사항에 얼마만큼 명시되어 있는지도 알아야 한다. 병렬로 실행되는 스레드이 수를 제한한다면 아마도 애플리케이션에서 자원이 모자라는 상황에 다다르거나 제한된 자원을 서로 사용하기 위해 각 작업이 경쟁하느라 애플리케이션의 성능이 떨어지는 일은 별로 보기 어려울 것이다. 실행 정책과 작업 등록 부분을 명확하게 분리시켜두면 애플리케이션을 실제 상황에 적용하려 할 때 설치할 하드웨어와 기타 자원의 양에 따라 직절한 실행 정책을 임의로 지정할 수 있다.  

이런 일은 엔타프라이즈급 애플리케이션에서 트랜잭션 모니터가 담당하는 부분과 유사하다. 트랜잭션 모니터는 트랜잭션이 처리되는 속도에 제한을 가할 수 있으며, 따라서 제한된 자원을 사용하면서 자원 부족 상황이나 부하에 시달리지 않도록 해준다.  

프로그램 어디에서든 간에

```java
new Thread(runnable).start()
```

와 같은 코드가 남아 있다면 조만간 이런 부분에 유연한 실행 정책을 적용할 준비를 해야할 것이며, 나중을 위해서 Executor를 사용해 구현하는 방안을 심각하게 고려해봐야 한다.  

##### 6.2.3. 스레드 풀
<br/>
스레드 풀(thread pool)은 이름 그대로 작업을 처리할 수 있는 동일한 형태의 스레드를 풀의 형태로 관리한다. 그리고 일반적으로 스레드 풀은 풀 내부의 스레드로 처리할 작업을 쌓아둬야 하기 때문에 작업 큐(work queue)와 굉장히 밀접한 관련이 있다. 작업 스레드는 아주 간단한 주기로 동작하는데, 먼저 작업 큐에서 실행할 다음 작업을 가져오고, 작업을 실행하고, 가져와 실행할 다음 작업이 나타날 때까지 대기하는 일을 반복한다.  

풀 내부의 스레드를 사용해 작업을 실행하는 방법을 사용하면, 작업별로 매번 스레드를 생성해 처리하는 방법보다 굉장히 많은 장점이 있다. 매번 스레드를 생성하는 대신 이전에 사용했던 스레드를 재상용하기 때문에 스레드를 계속해서 생성할 필요가 없고, 더군다나 클라이언트가 요청을 보냈을 때 해당 요청을 처리할 스레드가 이미 만들어진 상태로 대기하고 있기 때문에 작업을 실행하는 데 딜에이가 발생하지 않아 전체적인 반응 속도도 향상된다. 스레드 풀의 크기를 적절히 조절해두면 하드웨어 프로세서가 쉬지 않고 동작하도록 할 수 있으며, 하드웨어 프로세서가 바쁘게 동작하는 와중에도 메모리를 전부 소모하거나 여러 스레드가 한정된 자원을 두고 서로 경쟁하느라 성능을 까먹는 현상도 없앨 수 있다.  

자바 클래스 라이브러리에서는 흔히 사용하는 여러 가지 설정 상태에 맞춰 몇 가지 종류의 스레드 풀을 제공하고 있다. 미리 정의되어 있는 스레드 풀을 사용하려면 Executors 클래스에 만들어져 있는 다음과 같은 메소드를 호출하자.  

+ newFixedThreadPool  
처리할 작업이 등록되면 그에 따라 실제 작업할 스레드를 하나씩 생성한다. 생성할 수 있는 스레드의 최대 개수는 제한되어 있으며 제한된 개수까지 스레드를 생성하고 나면 더 이상 생성하지 않고 스레드 수를 유지한다(만약 스레드가 작업하는 도중에 예상치 못한 예외가 발생해서 스레드가 종료되거나 하면 하나씩 더 생성하기도 한다).  

+ newCachedThreadPool  
캐시 스레드 풀은 현재 풀에 갖고 있는 스레드의 수가 처리할 작업의 수보다 많아서 쉬는 스레드가 많이 발생핧 때 쉬는 스레드를 종료시켜 훨씬 유연하게 대응할 수 있으며, 처리할 작업의 수가 많아지면 필요한 만큼 스레드를 새로 생성한다. 반면에 스레드의 수에는 제한을 두지 않는다.  

+ newSingleThreadExecutor  
단일 스레드로 동작하는 Executor로서 작업을 처리하는 스레드가 단 하나뿐이다. 만약 작업 중에 Exception이 발생해 비정상적으로 종료되면 새로운 스레드를 하나 생성해 나머지 작업을 실행한다. 등록된 작업은 설정된 큐에서 지정하는 순서(FIFO, LIFO, 우선순위)에 따라 반드시 순차적으로 처리된다.  

단일 스레드로 실행되는 Executor 역시 내부적으로 충분한 동기화 기법을 적용하고 있으며, 따라서 특정 작업이 진행되는 동안 메모리에 남겨진 기록을 다음에 실행되는 작업에서 가져다 사용할 수 있다. 이것은 여러 작업이 모두 하나의 스레드에 제한된 상태로 실행되기 때문에 가능하며, 간혹 작업 실행 스레드가 종료되어 새로운 스레드를 만들어 실행하는 경우에도 똑같이 적용된다.  

+ newScheduledThreadPool  
일정 시간 이후에 실행하거나 주기적으로 작업을 실행할 수 있으며, 스레드의 수가 고정되어 있는 형태의 Executor.Timer 클래스의 기능과 유사하다.  

newFixedThreadPool과 newCachedThreadPool 팩토리 메소드는 일반화된 형태로 구현되어 있는 ThreadPoolExecutor 클래스의 인스턴스를 생성한다. 생성된 ThreadPoolExecutor 인스턴스에 설정 값을 조절해 필요한 형태를 갖추고 사용할 수도 있다.  

##### 6.2.4. Executor 동작 주기
<br/>
Executor를 구현하는 클래스는 대부분 작업을 처리하기 위한 스레드를 생성하도록 되어 있다. 하지만 JVM은 모든 스레드가 종료되기 전에는 종료하지 않고 대기하기 때문에 Executor를 제대로 종료시키지 않으면 JVM 자체가 종료되지 않고 대기하기도 한다.  

Executor는 작어븡 비동기적으로 실행하기 때문에 앞서 실행시켰던 작업의 상태를 특정 시점에 정확하게 파악하기 어렵다. 어떤 작업은 이미 완료됐을 수도 있고, 또 몇 개의 작업은 아직 실행 중일 수 있고, 또 다른 작업은 아직 큐에서 대기 상태에 머물러 있을 수도 있다. 애플리케이션을 종료하는 과정을 보면 안전한 종료 방법(graceful, 작업을 새로 등록하지는 못하고 시작된 모든 작업을 끝낼 때까지 기다림)이 있겠고, 또 한편으로는 강제적인 종료(abrupt, 예를 들어 플러그가 빠져 전원이 꺼지는 경우) 방법이 있겠다. 물론 안전한 종료 방법과 강제 종료 사이에 위치시킬 수 있는 여러 가지 종료 방법이 있다. Executor가 애플리케이션에 스레드 풀 등의 서비스를 제공한다는 관점으로 생각해 본다면, Executor 역시 안전한 방법이건 강제적인 방법이건 종료 절차를 밟아야 할 필요가 있다. 그리고 종료 절차를 밟는 동안 실행 중이거나 대기 중이던 작업을 어떻게 처리햇는지를 작업을 맡겼던 애플리케이션에게 알려줄 의무가 있다.  

이처럼 서비스를 실행하는 동작 주기와 관련해 Executor를 상송받은 ExecutorService 인터페이스에는 동작 주기를 관리할 수 있는 여러 가지 메소드가 추가되어 있다(이와 함께 작업을 등록하는 방법도 몇 가지 더 갖고 있다).  

내부적으로 ExecutorService가 갖고 있는 동작 주기에는 실행 중(running), 종료 중(shutting down), 종료(terminated)의 세 가지 상태가 있다. ExecutorService를 처음 생성했을 때에는 실행 중 상태로 동작한다. 어느 시점엔가 shutdown 메소드를 실행하면 안전한 종료 절차를 진행하며 종료중 상태로 들어간다. 이 상태에서는 새로운 작업을 등록받지 않으며, 이전에 등록되어 있던 작업(실행되지 않고 대기중이던 작업도 포함)까지는 모두 끝마칠 수 있다. shutdownNow 메소드를 실행하면 가제 종료 절차를 진행한다. 현재 진행 중인 작어보 가능한 한 취소시키고, 실행되지 않고 대기 중이던 작업은 더이상 실행시키지 않는다.  

ExecutorService의 하위 클래스의 ThreadPoolExecutor는 이미 종료 절차가 시작되거나 종료된 이후에 새로운 작업을 등록하려 하면 실행 거절 핸들러(rejected execution handler)를 통해 오류로 처리한다. 실행 거절 핸들러에 따라 다르지만 등록하려 했던 작업을 조용히 무시할 수도 있고, RejectedExecutionException을 발생시켜 오류로 처리하도록 할 수도 있다. 종료 절차가 시작된 이후 실행 중이거나 대기 중이던 작업을 모두 끝내고 나면 ExecutorService는 종료 상태로 들어간다. ExecutorService가 종료 상태로 들어갈 때까지 기다리고자 한다면 awaitTermination 메소드로 대기할 수도 있고, isTerminated 메소드를 주기적으로 호출해 종료 상태로 들어갔는지 확인할 수도 있다. 일반적으로는 shutdown 메소드를 실행한 이후 바로 awaitTermination을 실행하면 마치 ExecutorService를 직접 종료시키는 것과 비슷한 효과를 얻을 수 있다.  

##### 6.2.5. 지연 작업, 주기적 작업
<br/>
자바 라이브러리에 포함된 Timer 클래스를 사용하면 특정 시간 이후에 원하는 작업을 실행("이 작업을 100밀리초 이후에 실행하라")하는 지연 작업이나 주기적인 작업("매 10밀리초마다 이 작업을 실행하라")을 실행할 수 있다. 하지만 Timer는 그 자체로 약간의 단점이 있기 때문에 가능하다면 ScheduledThreadPoolExecutor를 사용하는 방법을 생각해 보는 것이 좋겠다. Timer 클래스는 상대 시각만 지원할 뿐만 아니라 절대 시간도 지원한다. 따라서 절대 시간을 사용하는 경우 시스템 하드웨어의 시각을 변경시키면 Timer에 스케줄된 작업도 함께 변경된다. 하지만 ScheduledThreadPoolExecutor는 상대 시각만 지원한다는 점을 주의하자. ScheduledThreadPoolExecutor를 생성하려면 직접 ScheduledThreadPoolExecutor 클래스의 생성 메소드를 호출해 생성하는 방법이 있고, 아니면 newScheduledThreadPool 팩토리 메소드를 사용해 생성하는 방법이 있다.  

Timer 클래스는 등록된 작업을 실행시키는 스레드를 하나만 생성해 사용한다. 만약 Timer에 등록된 특정 작업이 너무 오래 실행된다면 등록된 다른 TimerTask 작업이 예정된 시각에 실행되지 못할 가능성이 높다. ScheduledThreadPoolExecutor를 사용하면 지연 작업과 주기적 작업마다 여러 개의 스레드를 할당해 작업을 실행하느라 각자의 실행 예정 시각을 벗어나는 일이 없도록 조절해준다.  

Timer 클래스의 또 다른 단점을 들자면, TimerTask가 동작하던 도중에 예상치 못한 Exception을 던져버리는 경우에 예측하지 못한 상태로 넘어갈 수 있다는 점이다. Timer 스레드는 예외 상황을 전혀 처리하지 않기 때문에 TimerTask가 Exception을 던지면 Timer 스레드 자체가 멈춰 버릴 가능성도 있다. 더군다나 Timer 클래스는 오류가 발생해 스레드가 종료된 상황에서도 자동으로 새로운 스레드를 생성해주는 않는다. 이런 상황에 다다르면 해당 Timer에 등록되어 있던 모든 작업이 취소된 상황이라고 간주해야 하며, 그 동안 등록됐던 TimerTask는 전현 실행되지 않고 물론 새로운 작업을 등록할 수도 없다.  

만약 특별한 스케줄 방법을 지원하는 스케줄링 서비스를 구현해야 할 필요가 있다면, BlockingQueue를 구현하면서 ScheduledThreadPoolExecutor와 비슷한 기능을 제공하는 DelayQueue 클래스를 사용해 보는 것이 좋겠다. DelayQueue는 큐 내부에 여러 개의 Delayed 객체로 작업을 관리하며, 각각의 Delayed 객체는 저마다의 시각을 갖고 있다. DelayedQueue를 사용하면 Delayed 내부의 시각이 만료된 객체만 take 메소드로 가져갈 수 있다. DelayedQueue에서 뽑아내는 객체는 객체마다 지정되어 있던 시각 순서로 정렬되어 뽑아진다.  

#### 6.3. 병렬로 처리할 만한 작업
<br/>
##### 6.3.2. 결과가 나올 때까지 대기: Callable과 Future
<br/>
Executor 프레임웍에서는 작업을 표현하는 방법을 Runnable 인터페이스를 사용한다. Runnable을 들여다 보면 충분한 기능을 제공하지 못하는 경우가 많다. run 메소드는 실행이 끝난 다음 뭔가 결과 값을 리턴해 줄 수도 없고, 예외가 발생할 숟 있다고 throws 구문으로 표현할 수도 없다. 만약 결과 값을 만들어 냈다면 어딘가 공유된 저장소에 저장해야 하고, 오류가 발생했다면 로그 파일에 오류 내용을 기록하는 정도가 일반적인 처리 방법이다.  

결과를 받아올 때가지 시간이 걸리는 작업이 꽤나 많다. 데이터베이스에 쿼리를 보내 결과를 받는 경우도 그렇고, 네트웍상의 데이터를 받아오는 경우도 그렇고, 물론 아주 복잡한 계산을 하는 경우에도 그렇다. 이와 같이 결과를 얻는 데 시간이 걸리는 기능은 Runnable 대신 Callable을 사용하는 게 모양새가 좋다. Callable 인터페이스에서는 핵심 메소드인 call을 실행하고 나면 결과 값을 돌려받을 수 있으며, Exception도 발생시킬 수 있도록 되어 있다. 결과 값을 리턴하지 않는 작업을 Callable로 지정하려면 Callable<Void>와 같이 표현할 수 있다. Executor에는 Callable뿐만 아니라 Runnable이나 java.security.PrivilegedAction 등 여러 가지 유형의 작업을 실행할 수 있는 기능이 들어 있다.  

Runnable과 Callable은 둘 다 어떤 작업을 추상화하기 위한 도구이다. 작업은 일반적으로 유한한 성격을 갖고 있다. 다시 말해 시작하는 지점이 명확하고, 언젠가는 작업이 끝나게 되어 있다. Executor에서 실행한 작업은 생성(created), 등록(submitted), 실행(started), 종료(completed)와 같은 네 가지의 상태를 통과한다. 작업은 상당한 시간 동안 실행도기 마련이므로 작업을 중간에 취소할 수 있는 기능이 있어야 한다. Executor 프레임웍에서는 먼저 등록됐지만 시작되지 않은 작업은 언제든지 실행하지 않도록 취소시킬 수 있다. 그리고 이미 시작한 작업은 그 내부 구조가 인터럽트를 처리하도록 잘 만들어져 있는 경우에 한해 취소시킬 수 있다. 물론 이미 끝난 작업을 취소하는 것은 아무런 의미가 없는 행동이다.  

Future는 특정 작업이 정상적으로 완료됐는지, 아니면 취소됐는지 등에 대한 정보를 확인할 수 있도록 만들어진 클래스이다. Future가 동작하는 사이클에서 염두에 둬야 할 점은, 한 번 지나간 상태는 되돌릴 수 없다는 점이다. 이렇게 사이클을 되돌릴 수 없다는 것은 ExecutorService와 동일하다. 일단 완료된 작업은 완료 상태에 영원히 머무른다.  

get 메소드는 작업이 진행되는 상태(시작되지 않은 상태, 시작한 상태, 완료된 상태 등)에 따라 다른 유형으로 동작한다. 작업이 완료 상태에 들어가 있다면 get 메소드를 호출했을 때 즉시 결과 값을 리턴하거나 Exception을 발생시킨다. 반면 아직 작업을 시작하지 않았거나 작업이 실행되고 있는 상태라면 작업이 완료될 때까지 대기한다. 작업실행이 모두 끝난 상태에서 Exception이 발생했었다면 get 메소드는 원래 발생했던 Exception을 ExecutionException이라는 예외 클래스에 담아 던진다. 작업이 중간에 취소됐다면 get 메소드에서 CancellactionException이 발생한다. get 메소드에서 ExecutionException이 발생한 경우 원래 발생했던 오류는 ExecutionException의 getCause 메소드로 확인할 수 있다.

실행하고자 하는 작업을 나타내는 Future 클래스는 여러 가지 방법으로 만들어 낼 수 있다. ExecutorService 클래스의 submit 메소드는 모두 Future 인스턴스를 리턴한다. 따라서 Executor에 Runnable이나 Callable을 등록하면 Future 인스턴스를 받을 수 있고, 받은 Future 인스턴스를 사용해 작업의 결과를 확인하거나 실행 도중에 작업을 취소할 수도 있다. 아니면 Runnable이나 Callable을 사용해 직접 FutureTask 인스턴스를 생성하는 방법도 있다(알고보면 FutureTask 자체가 Runnable을 상속받ㅇ고 있기 때문에 Executor에 넘겨 바로 실행시킬 수도 있고, 아니면 run 메소드를 직접 호출해 실행시킬 수도 있다).  

자바 6부터는 ExecutorService를 구현하는 클래스에서 AbstractExecutorService에 정의된 newTaskFor라는 메소드를 오버라이드할 수 있도록 되어 있으며, newTaskFor 오버라이드해 등록된 Runnable이나 Callable에 따라 Future를 생성하는 기능에 직접 관여할 수 있다.  

Executor에 Runnable이나 Callable을 넘겨 등록하는 것은 Runnable이나 Callable을 처음 생성했던 스레드에서 실제 작업을 실행할 스레드로 안전하게 공개하는 과정을 거치도록 되어 있다. 이와 유사하게 Future에 결과 값을 설정하는 부분 역시 작업을 실행했던 스레드에서 get 메소드로 결과 값을 가져가려는 스레드로 결과 객체를 안전하게 공개하도록 되어 있다.  

작업의 진행 상태에 따라 다르게 동작하는 get 메소드의 특징을 설명하긴 했지만, 그렇다고 해서 작업 결과를 기다리는 코드가 작업 진행 상태를 반드시 알아야 할 필요는 없다. 그리고 작업을 등록할 때 안전한 공개 방법을 사용하고 결과를 받아올 때 역시 안전한 공개 방법을 사용하기 때문에 Future를 활용하는 작업이 스레드 안전성을 확보했다고 할 수 있다. Future.get 메소드를 감싸고 있는 오류 처리 구문에서는 발생할 수 있는 두 가지 가능성에 모두 대응할 수 있어야 한다. 첫 번째는 Exception이 발생하는 경우이고, 두번째는 결과 값을 얻기 전에 get 메소드를 호출해 대기하던 메인 스레드가 인터럽트되는 경우이다.  

##### 6.3.4. 다양한 형태의 작업을 볍렬로 처리하는 경우의 단점
<br/>
특정 스레드에 일정한 유형의 작업을 모두 맡겨버리는 정책은 그다지 확장성이 좋지 않다. 유사한 작업 가운데 훨씬 세부적인 작업으로 병렬성을 높이지 못할 바에야, 이런 방법은 전체적인 성능을 떨어뜨리는 결과를 가져올 수 있다.  

다양한 종류의 작업을 여러 작업 스레드에서 나눠 처리하도록 할 때는 나눠진 작업이 일정한 크기를 유지하지 못할 수 있다는 단점도 있다.  

프로그램이 해야 할 일을 작은 작업으로 쪼개 실행할 때 실제적인 성능상의 이점을 얻으려면, 프로그램이 하는 일을 대량의 동일한 작업으로 재정의해 병렬로 처리할 수 있어야 한다.  

##### 6.3.5. CompletionService: Executor와 BlockingQueue의 연합
<br/>
처리해야 할 작업을 갖고 있고, 이 작업을 모두 Executor에 등록해 실행시킨 다음 각 작업에서 결과가 나오는 즉시 그 값을 가져다 사용하고자 한다면, 등록한 각 작업별로 Future 객체를 정리해두고, 타임아웃에 0을 지정해 get 메소드를 호출하면서 결과가 나왔는지를 폴링(polling)해 결과를 찾아올 수 있겠다. 물론 이렇게 해도 동작하기는 하지만, 깔끔한 방법은 아니다. 다행스럽게도 이런 작업을 위해 미리 만들어져 있는 방법이 있다. 바로 완료 서비스(completion service)이다.  

CompletionService는 Executor의 기능과 BlockingQueue의 기능을 하나로 모은 인터페이스이다. 필요한 Callable 작업을 등록해 실행시킬 수 있고, take나 poll과 같은 큐 메소드를 사용해 작업이 완료되는 순간 완료된 작업의 Future 인스턴스를 받아들일 수 있다. CompletionService를 구현한 클래스로는 ExecutorCompletionService가 있는데, 등록된 작업은 Executor를 통해 실행한다.  

ExecutorCompletionService의 구현 내용을 보면 괸장히 직관적이다. 생성 메소드에서 완료된 결과 값을 쌓아 둘 BlockingQueue를 생성한다. FutureTask에는 done 메소드가 있는데, FutureTask의 작업이 모두 완료되면 done 메소드가 한 번씩 호출된다. 작업을 처음 등록하면 먼저 FutureTask를 상속받은 QueueingFuture라는 클래스로 변환하는데 QueueingFuture의 done 메소드에서는 결과를 BlockingQueue에 추가하도록 되어 있다. take와 poll 메소드를 호출하면 그대로 BlockingQueue의 해당 메소드로 넘겨 처리한다.  

##### 6.3.7. 작업 실행 시간 제한
<br/>
일정한 시간 이내에만 작업을 처리하도록 만들고자 할 때 가장 중요한 부분은 결과를 만들어 내지 못하건 결과를 만들어 낼 수 없다고 결론을 내리건 간에 지정된 시간이 지나면 더 이상 기다려 줄 수 없다는 점이다. 타임아웃을 지정할 수 있는 Future.get 메소드를 사용하면 이와 같은 시간 제한 요구사항을 만족할 수 있다. 즉 결과가 나오는 즉시 리턴되는 것은 타임아웃을 지정하지 않는 경우와 같지만, 지정한 시간이 지나도 결과를 만들어 내지 못하면 TimeoutException을 던지면서 실행이 멈추게 되어 있다.  

시간이 제한된 상태에서 작업을 실행할 때 발생하는 두 번째 문제는 제한된 시간을 넘었을 때 해당 작업을 실제로 멈추도록 해서 더 이상 시스템의 자원을 소모하지 않도록 해야 한다는 점이다. 이 부분은 해당 작업 내부에서 스스로 얼마의 시간 안에 결과를 만들어 내야 하는지를 관리하고, 제한된 시간이 되면 스스로 작동을 멈추도록 해야 한다. 그렇지 않다면 제한된 시간이 넘었을 때 강제로 취소시키는 방법도 있다. 여기세어도 Future를 유용하게 사용할 수 있는데, 시간 제한을 걸어둔 get 메소드에서 TimeoutException이 발생하면, 해당 Future의 작업을 직접 취소시킬 수 있다. 애초에 작업을 구현할 때 취소할 수 있도록 만들었다면, 취소하는 즉시 더 이상 시스템 자원을 잡아먹지 않고 깔끔하게 멈춘다.  

invokeAll 메소드는 작업 객체가 담긴 컬렉션 객체를 넘겨받으며, 그에 해당하는 Future 객체가 담긴 컬렉션 객체를 리턴한다. 물론 인자로 넘긴 작업 컬렉션과 결과로 받은 컬렉션의 구조가 동일하기 때문에 작업을 등록한 모듈은 어떤 작업에서 어떤 결과가 나오는지 알 수 있다. 시간 제한이 있는 invokeAll 메소드는 등록된 모든 작업이 완료됐거나, 작업을 등록한 스레드에 인터럽트가 걸리거나, 지정된 제한 시간이 지날 때까지 대기하다가 리턴된다. 제한 시간이 지날 때까지 실행 중이던 작업은 모두 실행이 취소된다. invokeAll 메소드가 리턴되면 등록된 모든 작업은 완료되어 결과 값을 가지고 있거나 취소되거나 두 가지 상태 가운데 하나이다. 작업을 등록했던 스레드는 모든 작업을 대상으로 get 메소드를 호출하거나 isCancelled 메소드를 사용해 작업이 완료되거나 취소된 상태를 확인할 수 있다.  

### 6장 요약
<br/>
애플리케이션을 작업이라는 단위로 구분해 실행할 수 있도록 구조를 잡으면 개발 과정을 간소화하고 병렬성을 확보해 병렬성을 높일 수 있다. Executor 프레임웍을 사용하면 작업을 생성하는 부분과 작업을 실행하는 부분을 분리해 실행 정책을 수립할 수 있으며, 원하는 형태의 실행 정책을 쉽게 만들어 사용할 수 있다. 작업을 처리하는 부분에서 스레드를 생성하도록 되어 있다면, 스레드를 직접 사용하는 대신 Executor를 사용해보자. 애플리케이션이 하는 일을 개볋 작업으로 구분해 처리할 때는 작업의 범위를 적절하게 잡아야 한다. 웬만한 애플리케이션에서는 일반적인 작업 범위가 잘 적용되지만, 일부 애플리케이션에서는 스레드를 사용해 병렬로 처리시킨 이득을 보려면 약간의 분석을 통해 병렬로 처리할 작업을 찾아낼 필요가 있다.  

### 7. 중단 및 종료
<br/>
작업이나 스레드를 시작시키기는 쉽다. 하지만 대부분의 경우 시작된 작업이 언제 멈출지는 그 작업이 끝가지 실행돼 봐야 알 수 있게 되어 있다. 애플리케이션을 작성하다 보면 작업이나 스레드가 알아서 멈추기 전에 미리 멈추도록 해야 할 필요가 생긴다. 사용자가 작업을 멈추라고 지시했을 수도 있고, 애플리케이션이 얼른 종료해야 하는 경우도 있다.  

작업이나 스레드를 안전하고 빠르고 안정적으로 멈추게 하는 것은 어려운 일이다. 더군다나 자바에는 스레드가 작업을 실행하고 있을 때 강제로 멈추도록 하는 방법이 없다. 예전에는 있었지만 지금은 사용하지 않는 Thread.stop과 Thread.suspend 메소드는 이런 기능을 제공하려고 시도했던 기능이다. 하지만 기능을 만든 지 얼마 되지 않아 문제가 많다는 사실을 깨달았고, 이제는 사용하지 말아야 할 기능이 됐다. 대신 인터럽트(interrupt)라는 방법을 사용할 수 있게 되어 있는데, 인터럽트는 특정 스레드에게 작업을 멈춰 달라고 요청하는 형태이다.  

실제 상황에서 특정 스레드나 서비스를 '즉시' 멈춰야 할 경우는 거의 없고, 강제로 종료하면 공유되어 있는 여러 가지 상태가 비정상적인 상태에 놓을 수 있기 때문에 스레드 간의 협력을 통한 접근 방법이 올바르다고 할 수 있다. 다시 말하면 작업이나 서비스를 실행하는 부분의 코드를 작성할 때 멈춰달라는 요청을 받으면 진행 중이던 작업을 모두 정리한 다음 종료하도록 만들어야 한다. 실행 중이던 일을 중단할 때 정상적인 상태에서 마무리하려면 작업을 진행하던 스레드가 직접 마무리하는 것이 가장 적절한 방법이다. 따라서 작업이나 스레드가 스스로 작업을 멈출 수 있도록 구성해두면 시스템의 유연성이 크게 늘어날 것이다.  

실행 사이클을 종료하는 문제를 제대로 구현하려면 작업이나 서비스, 애플리케이션 등의 설계가 굉장히 복잡해질 수 있기 때문에 굉장히 중요한 부분임에도 불구하고 무시해 버리는 경우가 많다. 오류가 발생하는 경우, 종료하는 경우, 작업을 취소하는 경우에 적절하게 대응하는 프로그램은 그렇지 못하고 그저 동작하는 수준의 프로그램과 비교할 때 품질의 차이가 현저하게 나타난다.  

#### 7.1. 작업 중단
<br/>
외부 프로그램이 특정 작업의 정상적인 실행 상태 진행 순서를 뛰어 넘어 종료 상태에 이르도록 할 수 있다면, 해당 작업은 취소 가능하다고 한다. 실행 중인 작업을 취소하고자 하는 요구 사항은 여러 가지 경우에 나타난다.  

+ 사용자가 취소하기를 요청한 경우  
사용자가 GUI 화면에서 '취소' 버튼을 클릭하거나, JMX(Java Management Extension) 등의 관리 인터페이스를 통해 작업을 취소하도록 요청한 경우  

+ 시간이 제한된 작업  
일정한 시간 이내에 답이 될만한 결과를 계속해서 찾고 있다가, 제한된 시간이 지나면 그 동안 찾았던 결과 가운데 가장 좋은 값을 사용하도록 프로그램을 작성하는 경우도 있다. 제한된 시간이 지나면 그 시점에 계속 동작 중이던 작업은 모두 취소된다.  

+ 애플리케이션 이벤트  
원하는 결과를 얻기 위해 다양한 조건을 지정해 여러 작업을 동시에 실행시킨다. 특정 작업 결과로 딱 원하던 값을 얻었다면, 나머지 실행중이던 작업은 모두 취소된다.  

+ 오료  
특정 작업에서 오류(예를 들어 디스크가 가득 차서 파일을 저장할 수 없는 경우)가 발생하면, 다른 작업도 모두 취소시켜야 한다. 물론 나중에 오류 상황을 정리하고 계속해서 실행할 수 있도록 현재 진행 중이던 작업이 무엇인지 기록하는 작업은 필요할 수도 있다.  

+ 종료  
애플리케이션이나 서비스를 종료할 때에는 현재 처리하는 중이었던 작업에 대한 내용이건, 아니면 처리하기 위해 큐에서 대기하던 항목이건 간에 마무리하는 절차가 필요하다. 종료 절차가 안전하게 진행되려면 현재 실행되고 있던 작업은 모두 종료될 때까지 기다려야 할 수 있다. 훨씬 급하게 종료해야 하는 경우라면 실행 중이던 작업을 모두 취소시켜야 할 수도 있다.  

앞서 소개했던 것처럼 자바 언어에서 특정 스레드를 명확하게 종료시킬 수 있는 방법은 없으며, 다시 말해서 특정 작업을 임의로 종료시킬 수 있는 방법이 없다는 말이다. 결국 작업을 실행하는 스레드와 작업을 취소했으면 한다고 요청하는 스레드가 함께 작업을 멈추는 협력적인 방법을 사용해야만 한다.  

협력적인 방법 가운데 가장 기본적인 형태는 바로 '취소 요청이 들어왔다'는 플래그를 설정하고, 실행 중인 작업은 취소 요청 플래그를 주기적으로 확인하는 방법이다. 실행 중인 상태에서 취소 요청이 들어왔다는 프래그가 설정되면, 실행하던 작업을 멈추도록 프로그램되어 있다.  

작업을 쉽게 취소시킬 수 있도록 만들려면 작업을 취소하려 할 때 '어떻게', '언제', '어떤 일'을 해야 하는지, 이른바 취소 정책(cancellation policy)을 명확히 정의해야 한다. 다시 말하면 외부 프로그램에서 작업을 취소하려 할 때 어떤 방법으로 취소 요청을 보낼 수 있는지, 작업 내부에서 취소 요청이 들어 왔는지를 언제 확인하는지, 취소 요청이 들어오면 실행 중이던 작업이 어떤 형태로 동작하는지 등에 대한 정보를 제공해야 안전하게 사용할 수 있다.  

##### 7.1.1. 인터럽트
<br/>
API나 언어 명세 어디를 보더라도 인터럽트가 작업을 취소하는 과정에 어떤 역할 을 하는지에 대해 명시되어 있는 부분은 없다. 하지만 실제 상황에서는 작업을 중단하고자 하는 부분이 아닌 다른 부분에 인터럽트를 사용한다면 오류가 발생하기 쉬울 수밖에 없으며, 애플리케이션 규모가 커질수록 관리하기도 어려워진다.  

모든 스레드는 불린 값으로 인터럽트 상태를 갖고 있다. 스레드에 인터럽트를 걸면 인터럽트 상태 변수의 값이 true로 설정된다. Thread 클래스에는 해당 스레드에 인터럽트를 거는 메소드를 갖고 있으며, 인터럽트가 걸린 상태인지를 확인할 수 있는 메소드도 있다. interrupt 메소드는 해당하는 스레드에 인터럽트를 거는 역할 을 하고, isInterrupted 메소드는 해당 스레드에 인터럽트가 걸려 있는지를 알려준다. 스태틱으로 선언된 interrupted 메소드를 호출하면 현재 스레드의 인터럽트 상태를 해제하고, 해제하기 이전의 값이 무엇이었는지를 알려준다(interrupted라는 이름으로는 유추하기 어려운 기능이다). interrupted 메소드는 인터럽트 상태를 해제할 수 있는 유일한 방법이다.  

Thread.sleep이나 Object.wait 메소드와 같은 블로킹 메소드는 인터럽트 상태를 확인하고 있다가 인터럽트가 걸리면 즉시 리턴된다. Thread.sleep이나 Object.wait 메소드에서 대기하던 중에 인터럽트가 걸리면 인터럽트 상태를 해제하면서 InterruptedException을 던진다. 여기서 던지는 InterruptedException은 인터럽트가 발생해 대기 중이던 상태가 예상보다 빨리 끝났다는 것을 뜻한다. Thread.sleep이나 Object.wait 메소드에서 인터럽트가 걸렸을 때, 인터럽트가 걸렸다는 사실을 얼마나 빠르게 확인하는지는 JVM에서도 아무런 보장을 하지 않는다. 하지만 일반적으로 볼 때 무리하게 늦게 반응하는 경우는 없다고 본다.  

스레드가 블록되어 있지 않은 실행 상테에서 인터럽트가 걸린다면, 먼저 인터럽트 상태 변수가 설정되긴 하지만 인터럽트가 걸렸는지 확인하고, 인터럽트가 걸렸을 경우 그에 대응하는 일은 해당 스레드에서 알아서 해야 한다. 말하자면 잊지 말아야 할 일을 책상 앞에 메모해 붙여 둔 것과 같다. InterruptedException이 발생하거나 하지 않기 때문에 해야 할 일을 확인하고 처리하는 것은 당사자가 알아서 할 일이며, 누군가 메모지를 몰래 떼어간다면 해야 할 일이 있는지조차 알지 못할 수 있다.  

특정 스레드의 interrupt 메소드를 호출한다 해도 해당 스레드가 처리하던 작업을 멈추지는 않는다. 단지 해당 스레드에게 인터럽트 요청이 있었다는 요청이 있었다는 메시지를 전달할 뿐이다.  

인터럽트를 이해하고자 할 때 중요한 사항이 있는데, 바로 실행 중인 스레드에 실제적인 제한을 가해 멈추도록 하지 않는다는 것이다. 단지 해당하는 스레드가 상황을 봐서 스스로 멈춰주기를 요청하는 것뿐이다(스레드가 멈추기 좋은 상황을 취소 포인트(cancellaction point)라고 한다). wait, sleep, join과 같은 메소드는 인터럽트 요청을 굉장히 심각하게 처리하는데, 실제로 인터럽트 요청을 받거나 실행할 때 인터럽트 상태라고 지정했던 시점이 되는 순간 예외를 띄운다. 인터럽트에 잘 대응하도록 만들어져 있는 메소드는 인터럽트가 걸리는 상황을 정확하게 기록해뒀다가 자신을 호출한 메소드가 인터럽트 상태에 따라서 다른 방법으로 동작할 수 있도록 정보를 제공하기도 한다. 하지만 인터럽트에 제대로 대응하지 못하는 메소드는 인터럽트 요청을 통채로 삼켜버리고는, 호출한 메소드에서도 인터럽트 상황을 전혀 알지 못하게 막아버리기도 한다.  

static interrupted 메소드는 현재 스레드의 인터럽트 상태를 초기화하기 때문에 사용할 때에 상당히 주의를 기울여야 한다. interrupted 메소드를 호출했는데 결과 값으로 true가 넘어왔다고 해보자. 만약 인터럽트 요청을 꿀꺽 삼켜버릴 생각이 아니라면 인터럽트에 대응하는 어떤 작업을 진행해야 한다.  

직접 작성한 작업 스레드가 인터럽트 요청에 빠르게 반응하도록 하려면 먼저 인터럽트를 사용해 작업을 취소할 수 있도록 준비해야 하고, 다양한 자바 라이브러리 클래스에서 제공하는 인터럽트 관련 기능을 충분히 지원해야 한다.  

작업 취소 기능을 구현하고자 할 때는 인터럽트가 가장 적절한 방법이라고 볼 수 있다.  

##### 7.1.2. 인터럽트 정책
<br/>
단일 작업마다 해당 작업을 멈출 수 있는 취소 정책이 있는 것처럼 스레드 역시 인터럽트 처리 정책이 있어야 한다. 인터럽트 처리 정책은 인터럽트 요청이 들어 왔을 때, 해당 스레드가 인터럽트를 어떻게 처리해야 하는지에 대한 지침이다. 예를 들어 인터럽트가 걸렸다는 사실을 확인하고 나면, 어디에서 무슨 일을 하고, 인터럽트에 대비해 단일 연산으로 보호할 수 있는 범위가 어디기지인지도 확인해야 하며, 인터럽트가 발생했을 때 해당하는 인터럽트에 어떻게 재빠르게 대응할 지의 지침을 뜻한다.  

일반적으로 가장 범용적인 인터럽트 정책은 스레드 수준이나 서비스 수준에서 작업 중단 기능을 제공하는 것이다. 실질적인 수준에서 최대한 빠르게 중단시킬 수 있고, 사용하던 자원은 적절하게 정리하고, 심지어는 가능하다면 작업 중단을 요청한 스레드에게 작업을 중단하고 있다는 사실을 어떻게든 알려줄 수 있다면 가장 좋겠다. 물론 작업을 멈췄다가 다시 재시작할 수 있는 등의 다른 인터럽트 정책을 정의해 사용할 수 있겠지만, 스레드나 스레드풀에서 이와 같이 덜 표준적인 인터럽트 정책을 사용하려 할 때에는 이런 특이한 인터럽트 정책에 맞도록 만들어진 작업만 처리할 수 있을 가능성이 높다.  

그리고 작업(task)과 스레드(thread)가 인터럽트 상황에서 서로 어떻게 동작해야 하는지를 명확히 구분할 필요가 있다. 인터럽트 요청 하나로 중단시키고자 하는 대상이 여럿일 수 있는데, 예를 들어 스레드 풀에서 작업을 실행하는 스레드에 인터럽트를 거는 것은 '현재 작업을 중단하라'는 의미일 수도 있고, '작업 스레드를 중단시켜라'는 뜻일 수도 있다.  

작업은 그 작업을 소유하는 스레드에서 실행되지 않고, 스레드 풀과 같이 실행만 전담하는 스레드를 비려 사용하게 된다. 실제로 작업을 실행하는 스레드를 갖고 있지 않은 프로그램(스레드 풀을 예로 들자면 스레드 풀에 작업을 넘기는 모든 클래스)은 작업을 실행하는 스레드의 인터럽트 상태를 그대로 유지해 스레드를 소유하는 프로그램이 인터럽트 상태에 직접 대응할 수 있도록 해야 한다. 스레드에서 실행되는 작업이 인터럽트를 처리하도록 되어 있다 해도 말이다(누군가 집을 비웠을 때 그 집응 잠시 봐주는 상황을 생각해보자. 원래 주인이 자리를 비웠을 때 우편물이 배달되면 우편물을 고이 모아뒀다가 주인이 돌아왔을 때 전달하는 게 상식적인 행동이다. 만약 잡지 등을 미리 읽어봤다고 해도, 결국에는 주인이 볼 수 있게 전달해줘야 한다).  

대부분의 블로킹 메소드에서 인터럽트가 걸렸을 때 InterruptedException을 던지도록 되어 있는 이유가 바로 이것 때문이다. 블로킹 메소드를 스스로의 스레드에서 실행하는 일은 전혀 없기 때문에 외부 작업이나 자바 내부의 라이브러리 메소드에서 동시에 적용할 수 있는 가장 적절한 인터럽트 정책, 즉 실행 중에 최대한 빨리 작업을 중단하고 자신을 호출한 스레드에게 전달받은 인터럽트 요청을 넘겨 인터럽트에 대응해 추가적인 작업을 할 수 있도록 배려하는 정책을 구현하고 있다.  

그렇다고 해서 인터럽트가 발생했을 때 실행되고 있던 작업이 모든 것을 포기하고 작업을 중단해야만 하는 것은 아니다. 일단 인터럽트 요청을 받았다는 사실을 기억해두고, 실행 중이던 작업을 끝까지 마친 다음 요청받은 인터럽트에 대해 InterruptedException을 던지거나 기타 다른 방법으로 인터럽트에 대응할 수도 있다. 이런 기법을 활용하면 작업을 실행하는 과정에서 비정상적으로 작업을 종료하느라 처리하던 데이터가 깨지거나 날아가는 오류 상황을 예방할 수 있다.  

개별 작업은 스스로가 특별한 인터럽트 정책에 대응하도록 만들어져 있지 않은 한 자신을 실행하는 스레드에서 적용하고 있는 인터럽트 정책에 대해 어떠한 가정도 해서는 안 된다. 작업 실행 도중에 인터럽트가 걸렸을 때 인터럽트 상황을 작업 중단이라는 의미로 해석할 수도 있고 아니면 인터럽트에 대응해 뭔가 작업을 처리할 수도 있는데, 어찌 됐건 작업을 실행중인 스레드의 인터럽트 상태는 그래도 유지시켜야 한다. 가장 일반적인 방법은 InterruptedException을 던지는 것인데, 그렇게 하지 못한다해도 다음과 같은 코드를 실행해 스레드의 인터럽트 상태를 유지해야 한다.  

```java
Thread.currentThread().interrupt();
```

작업을 실행하는 스레드에서 인터럽트가 발생했을 때 어떤 의미를 갖는지를 작업 클래스의 코드에서 아무렇게나 가정해서는 안 되는 것처럼, 작업 취소 기능을 담당하는 코드 역시 각종 스레드에 대한 인터럽트 정책이 어떻다고 섣불리 가정하면 안 된다. 스레드에는 해당 스레드를 소유하는 클래스에서만 인터럽트를 걸어야 한다. 스레드를 소유하는 클래스는 shutdown과 같은 메소드에서 적절한 작업 중단 방법과 함께 스레드의 인터럽트 정책을 확립해 내부적으로 적용하고 있기 때문이다.  

각 스레드는 각자의 인터럽트 정책을 갖고 있다. 따라서 해당 스레드에서 인터럽트 요청을 받았을 때 어떻게 동작할지를 정확하게 알고 있지 않은 경우에는 함수로 인터럽트를 걸어서는 안 된다.  

자바에서 제공하는 인터럽트 기능과 관련해서 여러 가지 비판적인 의견이 있었는데, 선점형(preemptive) 인터럽트 기능을 제공하지 않을 뿐더러 개발자로 하여금 직접 InterruptedException을 처리하도록 강요하고 있기 때문이다. 비판적인 의견에도 불구하고 인터럽트에 대한 실제적인 중단 시점을 개발자가 임의로 늦출 수도 있도록 하는 것은 프로그램의 요구사항에 지정되어 있는 응답성과 안정성을 능동적으로 관리할 수 있는 기회를 제공하는 셈이다.  

##### 7.1.3. 인터럽트에 대한 대응
<br/>
Thread.sleep이나 BlockingQueue.put 메소드와 같이 인터럽트를 걸 수 있는 블로킹 메소드를 호출하는 경우에 InterruptedException이 발생했을 때 처리할 수 있는 실질적인 방법에는 대략 두 가지가 있다.  

+ 발생한 예외를 호출 스택의 상위 메소드로 전달한다(물론 최소한의 마무리 작업을 거쳐도 좋다). 이 방법을 사용하는 메소드 역시 인터럽트를 걸 수 있는 블로킹 메소드가 된다.
+ 호출 스택의 상단에 위치한 메소드가 직접 처리할 수 있도록 인터럽트 상태를 유지한다.  

InterruptedException을 호출 스택의 상위 메소드에 전달하도록 처리하는 방법은 해당 메소드의 throws 부분에 InterruptedException을 지정하는 것만으로 충분하다.  

InterruptedException을 상위 메소드로 전달할 수 없거나(Runnable 인터페이스를 구현해 작업을 정의한 경우) 전달하지 않고자 하는 상황이라면 인터럽트 요청이 들어왔다는 것을 유지할 수 있는 다른 방법을 찾아야 한다. 인터럽트 상태를 유지할 수 있는 가장 일반적인 방법은 interrupt 메소드를 다시 한 번 호출하는 것이다. 반대로 catch 블록에서 InterruptedException을 잡아낸 다음 아무런 행동을 취하지 않고 말 그대로 예외를 먹어버리는 일은 하지 말아야 한다(만약 스레드의 인터럽트 정책을 개별 작업에서 정확하게 구현하고 있다면 아무 일도 하지 않아도 좋다). 대부분의 프로그램 코드는 자신이 어느 스레드에서 동작할지 모르기 때문에 인터럽트 상태를 최대한 그대로 유지해야 한다.  

스레드의 인터럽트 처리 정책을 정확하게 구현하는 작업만이 인터럽트 요청을 삼켜버릴 수 있다. 일반적인 용도로 작성된 작업이나 라이브러리 메소드는 인터럽트 요청을 그냥 삼켜버려서는 안 된다.  

작업 중단 기능을 지원하지 않으면서 인터럽트를 걸 수 있는 블로킹 메소드를 호출하는 작업은 인터럽트가 걸렸을 때 블로킹 메소드의 기능을 자동으로 재시도하도록 반복문 내부에서 블로킹 메소드를 호출하도록 구성하는 것이 좋다. 이런 경우 InterruptedException이 발생하는 즉시 인터럽트 상태를 지정하는 대신 인터럽트 상태를 내부적으로 보관하고 있다가 메소드가 리턴되기 직전에 인터럽트 상태를 원래대로 복구하고 리턴되도록 해야 한다. 인터럽트를 걸 수 있는 블로킹 메소드는 대부분 실행되자마자 가장 먼저 인터럽트 상태를 확인하며 인터럽트가 걸린 상태라면 즉시 InterruptedException을 던지는 경우가 많기 때문에, 인터럽트 상태를 너무 일찍 지정하면 반복문이 무한반복에 빠질 수 있다(인터럽트가 걸릴 수 있는 메소드는 일반적으로 대기 상태에 들어가기 전이나 복잡한 작업을 시작히기 전에 인터럽트 상태를 확인하도록 되어 있는데, 시간이 오래 걸리는 작업 이전에 인터럽트 상태를 한 번 확인해야 인터럽트에 대한 응답 속도를 최대한 높일 수 있기 때문이다).  

작업 코드에서 인터럽트가 걸릴 수 있는 블로킹 메소드를 전혀 사용하지 않는다해도 작업이 진행되는 과정 곳곳에서 현재 스레드의 인터럽트 상태를 확인해준다면 인터럽트에 대한 응답 속도를 크게 높일 수 있다. 인터럽트 상태를 얼마만에 한 번씩 확인할 것인지 주기를 결정할 때에는 응답 속도와 효율성 측면에서 적절한 타협점을 찾아야 한다. 만약 응답 속도가 굉장히 중요한 애플리케이션을 만들고 있다면 인터럽트에 재빠르게 응답하지 않으면서 오래 실행되는 메소드를 호출하지 않는 것이 좋은데, 이런 요구 사항을 필요한 만큼 충족시키려다 보면 자바 라이브러리 메소드 가운데에서도 호출하지 않아야 할 것들이 눈에 띌 수 있다.  

작업 중단 기능은 인터럽트 상태뿐만 아니라 여러 가지 다른 상태와 관련이 있을 수 있다. 인터럽트는 해당 스레드의 주의를 끄는 정도로만 사용하고, 인터럽트를 요청하는 스레드가 갖고 있는 다른 상태 값을 사용해 인터럽트가 걸린 스레드가 어떻게 동작해야 하는지를 지정하는 경우도 있다(물론 자신의 상태 값을 다른 스레드가 읽어가도록 열어둘 때에는 해당 상태 값의 동기화에 신경 써야 한다).  

예를 들어 ThreadPoolExecutor 내부의 풀에 등록되어 있는 스레드에 인터럽트가 걸렸다면, 인터럽트가 걸린 스레드는 전체 스레드 풀이 종료되는 상태인지를 먼저 확인한다. 스레드 풀 자체가 종료되는 상태였다면 스레드를 종료하기 전에 스레드 풀을 정리하는 작업을 실행하고, 스레드 풀이 종료되는 상태가 아니라면 스레드 풀에서 동작하는 스레드의 수를 그대로 유지시킬 수 있도록 새로운 스레드를 하나 생성해 풀에 등록시킨다.  

##### 7.1.5. Future를 사용해 작업 중단
<br/>
ExecutorService.submit 메소드를 실행하면 등록한 작업을 나타내는 Future 인스턴스를 리턴받는다. Future에는 cancel 메소드가 있는데 mayInterruptIfRunning이라는 불린 값을 하나 넘겨 받으며, 취소 요청에 따른 작업 중단 시도가 성공적이었는지를 알려주는 결과 값을 리턴받을 수 있다(여기에서 작업 중단 시도가 성공적이었다는 의미는 인터럽트를 제대로 걸었다는 의미이며, 해당 작업이 인터럽트에 반응해 실제로 작업을 중단했다는 것을 뜻하지는 않는다). cancel 메소드를 호출할 때 mayInterruptIfRunning 값으로 true를 넘겨줬고 작업이 어느 스레드에서건 실행되고 있었다면, 해당 스레드에 인터럽트가 걸린다. mayInterruptedIfRunning 값으로 false를 넘겨주면 "아직 실행하지 않았다면 실행시키지 말아라"는 의미로 해석되며 인터럽트에 대응하도록 만들어지지 않은 작업에는 항상 false를 넘겨줘야 한다.  

앞에서 특정 스레드의 인터럽트 정책을 잘 알고 있지 않은 상태라면 해당 스레드에 인터럽트를 걸어서는 안 된다는 점을 언급했었는데, 그렇다면 cancel 메소드에 true 인자를 넣어 호출해도 좋은 경우는 어떤 경우일까? Executor에서 기본적으로 작업을 실행하기 위해 생성하는 스레드는 인터럽트가 걸렸을 때 작업을 중단할 수 있도록 하는 인터럽트 정책을 사용한다. 따라서 기본 Executor에 작업을 등록하고 넘겨받은 Future에서는 cancel 메소드에 mayInterruptIfRunning 값으로 true를 넘겨 호출해도 아무런 문제가 없다. 물론 스레드 풀에 들어 있는 스레드에 함부로 인터럽트를 거는 일은 여전히 안 되는데, 해당 스레드에 인터럽트가 걸리는 시점에 어떤 작업을 실행하고 있을지 알 수 없기 때문이다. 따라서 작업을 중단하려 할 때는 항상 스레드에 직접 인터럽트를 거는 대신 Future의 cancel 메소드를 사용해야 한다. 작업을 구현할 때 인터럽트가 걸리면 작업을 중단하라는 요청으로 해석하고 그에 따라 행동하도록 만들어야 하는 또 다른 이유라고 볼 수 있는데, 그러면 Future를 통해 쉽게 작업을 중단시킬 수 있기 때문이다.  

Future.get 메소드에서 InterruptedException이 발생하거나 TimeoutException이 발생했을 때, 만약 예외 상황이 발생한 작업의 결과는 필요가 없다고 한다면 해당 작업에 대해 Future.cancel 메소드를 호출해 작업을 중단시키자.  

##### 7.1.6. 인터럽트에 응답하지 않는 블로킹 작업 다루기
<br/>
자바 라이브러이에 포함된 여러 블로킹 메소드는 대부분 인터럽트가 발생하는 즉시 멈추면서 InterruptedException을 띄우도록 되어 있으며, 따라서 작업 중단 요청에 적절하게 대응하는 작업을 쉽게 구현할 수 있다. 글너데 잘 살펴보면 모든 블로킹 메소드가 인터럽트에 대응하도록 되어 있지는 않다. 예를 들어 동기적인 소켓 I/O를 실행하는 도중에 스레드가 멈춰 있는 경우라던가 암묵적인(intrinsic) 락을 확보하기 위해 대기하는 등의 작업에 멈춰있는 경우라면, 인터럽트를 거는 것이 인터럽트 상태 변수의 값을 설정하는 것 말고는 아무런 실제적 효과가 없다. 일부 상황에서는 인터럽트와 유사한 기법을 활용해 인터럽트에 반응하지 않는 블로킹 메소드에서 대기 중인 스레드가 작업을 멈추도록 할 수 있긴 하지만, 이런 작업을 하고자 할 때에는 해당 스레드가 대기 상태에 멈춰 있는 이유가 무엇인지를 훨씬 정확하게 이해해야 한다.  

+ java.io 패키지의 동기적 소켓 I/O  
서버 애플리케이션에서 가장 대표적인 블로킹 I/O의 예는 바로 소켓에서 데이터를 읽어오거나 데이터를 쓰는 부분이다. InputStream 클래스의 read 메소드와 OutputStream의 write 메소드가 인터럽트에 반응하지 않도록 되어 있다는 단점이 있지만, 해당 스트림이 연결된 소켓을 직접 닫으면 대기 중이던 read나 write 메소드가 중단되면서 SocketException이 발생한다.  

+ java.nio 패키지의 동기적 I/O  
InterruptibleChannel에서 대기하고 있는 스레드에 인터럽트를 걸면 ClosedByInterruptException이 발생하면서 해당 채널이 닫힌다(더불어 해당 채널에서 대기하고 있던 모든 스레드에서 ClosedByInterruptException이 발생한다). InterruptibleChannel을 닫으면 해당 채널로 작업을 실행하던 스레드에서 AsynchronousCloseException이 발생한다. 대부분의 표준 Channel은 모두 InterruptibleChannel을 구현한다.  

+ Selector를 사용한 비동기적 I/O  
스레드가 Selector 클래스(java.nio.channels 패키지)의 select 메소드에서 대기 중인 경우, close 메소드를 호출하면 ClosedSelectorException을 발생시키면서 즉시 리턴된다.  

+ 락 확보  
스레드가 암묵적인 락을 확보하기 위해 대기 상태에 들어가 있는 경우 언젠가 락을 확보할 수 있을 것이라는 보장을 하지 못할 뿐더러 어떤 방법으로든 다음 상태로 진행시켜 스레드의 주의를 끌 수 없기 때문에 어떻게 해 볼 방법이 없다. 하지만 Lock 인터페이스를 구현한 락 클래스의 lockInterruptibly 메소드를 사용하면 락을 확보할 때까지 대기하면서 인터럽트에도 응답하도록 구현할 수 있다.  

##### 7.1.7. newTaskFor 메소드로 비표준적인 중단 방법 처리
<br/>
표준을 따르지 않는 중단 방법을 표준의 범주 내에서 사용할 수 있도록 하는 기법은 자바 6 버전의 ThreadPoolExecutor 클래스에 newTaskFor라는 메소드로 정리해 추가됐다. ExecutorService 클래스에 Callable 인스턴스를 등록할 때 submit 메소드를 호출하면 그 결과로 해당하는 작업을 취소시킬 수 있는 Future 객체를 받아온다. newTaskFor 메소드 역시 등록된 작업을 나타내는 Future 객체를 리턴해주는데, 이전과는 다른 RunnableFuture 객체를 리턴한다. RunnableFuture 인터페이스는 Future와 Runnable 인터페이스를 모두 상속받으며, FutureTask는 자바 5에서 Future를 구현했었지만 자바 6에서는 RunnableFuture를 구현한다.  

Future.cancel 메소드를 오버라이드하면 작업 중단 과정을 원하는 대로 변경할 수 있다. 이를테면 작업 중단 과정에서 필요한 내용을 로그 파일로 남긴다거나 몇 가지 통계 값을 보관하는 등의 작업을 할 수 있고, 인터럽트에 제대로 대응하지 않는 작업을 중단하도록 할 수도 있다.  

#### 7.2. 스레드 기반 서비스 중단
<br/>
스레드 풀과 같이 내부적으로 스레드를 생성하는 스레드 기반의 서비스를 사용하는 일은 애플리케이션을 제작할 때 흔히 발생하는 일이고, 이와 같은 서비스는 서비스를 시작시킨 메소드보다 오랜 시간 동안 실행되는 경우가 일반적이다. 애플리케이션을 깔끔하게 종료시키려면 이와 같은 스레드 기반의 서비스 내부에 생성되어 있는 스레드를 안전하게 종료시킬 필요가 있다. 그런데 스레드를 선점적인 방법으로 강제로 종료시킬 수는 없기 때문에 스레드에게 알아서 종료해달라고 부탁할 수밖에 없다.  

스레드를 활용하는 여러 가지 애플리케이션의 예를 보면서 얻을 수 있는 교훈 가운데 하나는 바로 스레드를 직접 소유하고 있지 않는 한 해당 스레드에 인터럽트를 걸거나 우선 순위를 조정하는 등의 작업을 해서는 안 된다는 것이다. 하지만 현재 만들어져 있는 스레드 API 수준에서 볼 때 스레드 소유권에 대한 별 다른 준비는 되어 있지 않은 상태이다. 스레드는 Thread라는 클래스로 표현할 수 있으며, Thread 클래스의 인스턴스는 다른 어떤 객체에서건 자유롭게 소유된다는 개념을 사용할 수 있다면 상당한 도움을 얻을 수 있으며, 스레드를 소유하는 객체는 대부분 해당 스레드를 생성한 객체라고 볼 수 있다. 스레드 풀을 예로 들면, 스레드 풀에 들어 있는 모든 작업 스레드는 해당하는 스레드 풀이 소유한다고 볼 수 있고, 따라서 개별 스레드에 인터럽트를 걸어야하는 상황이 된다면 그 작업 스레드를 소유한 스레드 풀에서 책임을 져야 한다.  

기능을 모아 캡슐화한 객체를 보면 스레드 소유권은 이전할 수 없다는 것을 알 수 있다. 애플리케이션은 스레드 기반 서비스를 생성해 사용하며 스레드 기반 서비스는 필요한 개별 스레드를 생성해 사용하지만, 애플리케이션은 개별 스레드를 직접 소유하고 있지 않기 때문에 개별 스레드를 직접 조작하는 일이 없어야 한다. 애플리케이션이 개별 스레드에 직접 액세스하는 대신 스레드 기반 서비스가 스레드이 시작부터 종료까지 모든 기능에 해당하는 메소드를 직접 제공해야 한다. 그러면 애플리케이션이 스레드 기반 서비스만 종료시키면 스레드 기반 서비스는 스스로가 소유한 모든 작업 스레드를 종료시키게 된다. ExecutorService 인터페이스는 shutdown 메소드와 shutdownNow 메소드를 제공하고 있으며, 다른 스레드 기반의 서비스 역시 이와 같은 종료 기능을 제공해야 한다.  

스레드 기반 서비스를 생성한 메소드보다 생성된 스레드 기반 서비스가 오래 실행될 수 있는 상황이라면, 스레드 기반 서비스에서는 항상 종료시키는 방법을 제공해야 한다.  

##### 7.2.2. ExecutorService 종료
<br/>
ExecutorService를 종료하는 두 가지 방법에는 shutdown 메소드를 사용해 안전하게 종료하는 방법이 있고, shutdownNow 메소드를 사용해 강제로 종료하는 방법이 있다. shutdownNow를 사용해 강제로 종료시키고 나면 먼저 실행 중인 모든 작업을 중단하도록 한 다음 아직 시작하지 않은 작업의 목록을 그 결과로 리턴해준다. 위에서 언급한 두 가지 종료 방법은 안전성과 응답성의 측면에서 서로 장단점을 갖고 있다. 강제로 종료하는 방법은 응답이 훨씬 빠르지만 실행 도중에 스레드에 인터럽트를 걸어야 하기 때문에 작업이 중단되는 과정에서 여러 가지 문제가 발생할 가능성이 있고, 안전하게 종료하는 방법은 종료 속도가 느리지만 큐에 등록된 모든 작업을 처리할 때까지 스레드를 종료시키지 않고 놔두기 때문에 작업을 잃을 가능성이 없어 안전하다. 내부적으 스레드를 소유하고 동작하는 서비스를 구현할 때에는 이와 비슷하게 종료 방법을 선택할 수 있도록 준비하는 것이 좋다.  

단순한 프로그램의 경우에는 main 메소드에서 전역 변수의 형태로 잡아 둔 ExecutorService 인스턴스를 시작하고 종료하는 부분까지 모두 직접 사용할 수도 있다. 그리고 좀더 복잡한 고급 프로그램에서는 ExecutorService를 직접 활용하는 대신 다른 클래스의 내부에 캡슐화해서 시작과 종료 등의 기능을 연결해 호출할 수 있다.

##### 7.2.3. 독약
<br/>
프로듀서-컨슈머 패턴으로 구성된 서비스를 종료시키도록 종용하는 또 다른 방법으로 독약(poison pill)이라고 불리는 방법이 있다. 이 방법은 특정 객체를 큐에 쌓도록 되어 있으며, 이 객체는 "이 객체를 받았다면, 종료해야 한다"는 의미를 갖고 있다. FIFO 유형의 큐를 사용하는 경우에는 독약 객체를 사용했을 때 컨슈머가 쌓여 있던 모든 작업을 종료하고 독약 객체를 만나 종료되도록 할 수 있다. FIFO 큐에서는 객체의 순서가 유지되기 때문에 독약 객체보다 먼저 큐에 쌓인 객체는 항상 독약 객체보다 먼저 처리된다. 그리고 물론 프로듀서 측에서는 독약 객체를 한 번 큐에 넣고 나면 더 이상 다른 작업을 추가해서는 안 된다.  

독약 객체는 프로듀서의 개수와 컨슈머의 개수를 정확히 알고 있을 때에만 사용할 수 있다.  

##### 7.2.5. shutdownNow 메소드의 약점
<br/>
shutdownNow 메소드를 사용해 ExecutorService를 강제로 종료시키는 경우에는 현재 실행 중인 모든 스레드의 작업을 중단시키도록 시도하고, 등록됐지만 실행은 되지 않았던 모든 작업의 목록을 리턴해준다. 그러면 ExecutorService를 사용했던 클래스는 리턴받은 작업에 대한 로그 메시지를 출력하거나 나중에 다시 작업하도록 보관해 둘 수도 있다.  

shutdownNow에서 리턴받은 Runnable 객체는 ExecutorService에 등록했던 것과 '동일한' 객체가 아닐 수도 있고, 등록한 작업을 ExecutorService에서 내부적으로 다른 클래스로 덮어 씌워 사용했을 수도 있으며, 그럴 때는 덮어 씌운 객체를 넘겨 받을수도 있다.  

그런데 실행되기 시작은 했지만 아직 완료되지 않은 작업이 어떤 것인지를 알아볼 수 있는 방법은 없다. 따라서 개별 작업 스스로가 작업 진행 정도 등의 정보를 외부에 알려주기 전에는 서비스를 종료하라고 했을 때 실행 중이던 작업의 상태를 알아볼 수 없다. 종료 요청을 받았지만 아직 종료되지 않은 작업이 어떤 작업인지 확인하려면 실행이 시작되지 않은 작업도 알아야 할 뿐더러 Executor가 종료될 때 실행 중이던 작업이 어떤 것인지도 알아야 한다.  

공교롭게도 종료 메소드에는 실행이 시작되지 않은 작업을 리턴받을 것인지, 실행 중이던 작업은 계속 실행해도 좋은지에 대한 선택의 여지가 없다. 이런 세밀한 부분까지 선택 사항을 고를 수 있다면 어정쩡한 상태를 최대한 피할 수 있을 것이다.  

#### 7.3. 비정상적인 스레드 종료 상황 처리
<br/>
단일 스레드로 동작하는 콘솔 애플리케이션에서 예외 상황이 발생했는데 제대로 처리하지 못했다면 예외 상황의 결과는 상당히 단순한데, 프로그램 실행이 멈추면서 일반적인 프로그램 출력 내용과는 사뭇 다른 스택 트레이스를 출력하게 된다. 하지만 많은 수의 스레드를 사용하는 병렬 애플리케이션에서 예외가 발생했을 때에는 단일 스레드 애플리케이션처럼 단순한 상태로 넘어가지 않는 경우가 많다. 스택 트레이스를 콘솔에 출력하는 경우도 있겠지만, 아무도 콘솔을 쳐다보고 있지 않을 수도 있다. 더군다나 오류 때문에 스레드가 멈춘 경우에도 전체 애플리케이션은 마치 오류 없이 계속해서 동작하는 것처럼 보일 수도 있다. 다행스럽게도 애플리케이션의 스레드에서 오류가 발생해 멈추지 않도록 예방할 수도 있고, 멈춘 스레드를 찾아내는 방법도 있다.  

스레드를 예상치 못하게 종료시키는 가장 큰 원인은 바로 RuntimeException이다. RuntimeException은 대부분 프로그램이 잘못 짜여져서 발생하거나 기타 회복 불능의 문제점을 나타내는 경우가 많기 때문에 try-catch 구문으로 잡지 못하는 경우가 많다. RuntimeException은 호출 스택을 따라 상위로 전달되기보다는 현재 실행되는 시점에서 콘솔에 스택 호출 추적 내용을 출력하고 해당 스레드를 종료시키도록 되어 있다.  

스레드가 비정상적으로 종료됐을 때 나타나는 현상은 해당 스레드의 역할에 따라 다르지만 아주 사소한 것부터 시작해서 애플리케이션 입장에서 엄청나게 큰 문제가 되는 경우도 있다. 스레드 풀에서 스레드가 하나 죽어버리면 성능이 떨어지는 상황이 올 수 있지만, 50개의 스레드를 사용해서 동작하던 애플리케이션이 49개 스레드로 동작한다 해도 그다지 큰 문제가 되지는 않을 것으로 예상할 수 있다. 하지만 예를 들어 GUI가 중요한 부분을 차지하는 애플리케이션에서 이벤트 처리 스레드가 종료되거나 하면 GUI 화면이 멈추는 등의 상황이 나타나면서 심각한 오류 상황이 될 수 있다.  

RuntimeException은 어디에서건 발생할 수 있다. 프로그램에서 다른 메소드를 호출할 때는 정상적으로 결과 값을 받아오거나, 아니면 발생할 수 있다고 예정된 예외 상황이 발생하면서 메소드가 리턴될 것이라고 예상하고, 또 그렇게 믿고 호출한다. 만약 호출해야 할 메소드를 자주 사용하거나 잘 이해하고 있지 않다고 하면, 항상 그 메소드가 예상대로 동작하지 않을 수 있다고 생각하고 프로그램을 작성해야 한다.  

스레드 풀에서 사용하는 작업용 스레드나 스윙(Swing)의 이벤트 처리 스레드와 같은 작업 처리용 스레드는 항상 Runnable 등의 인터페이스를 통해 남이 정의하고 그래서 그 내용을 알 수 없는 작업을 실행하느라 온 시간을 보낸다. 따라서 이런 작업 처리 스레드는 자신이 실행하는 남의 작업이 제대로 동작하지 않을 수 있다고 가정하고 조심스럽게 실행해야 한다. 예를 들어 허술하게 만들어진 이벤트 처리 메소드에서 NullPointerException을 자꾸 띄워 이벤트 처리 스레드가 죽는 일이 발생한다면 큰 문제가 된다. 따라서 이와 같은 작업 처리 스레드는 실행할 작업을 try-catch 구문 내부에서 실행해 예상치 못한 예외 상황에 대응할 수 있도록 준비하거나, try-finally 구문을 사용해 스레드가 피치 못할 사정으로 종료되는 경우에도 외부에 종류된다는 사실을 알려 프로그램의 다른 부분에서라도 대응할 수 있도록 해야 한다.  

RuntimeException을 catch 구문에서 잡아 처리해야 할 상황은 그다지 않지 않은데, 몇 안 되는 상황 가운데 하나가 바로 남이 Runnable 등으로 정의해 둔 작업을 실행하는 프로그램을 작성하는 것이다.  

이런 기법으로 프로그램을 작성할 때의 안전성에 대해서는 여러 가지 비판적인 의견도 많다. 특정 스레드에서 정의되지 않은 예외 상황이 발생한다면 전체 애플리케이션이 전부 꼬여버리는 경우도 생길 수 있다. 오류가 발생했을 때 전체 애플리케이션을 종료시켜 버리는 등의 다른 방법도 생각해 볼 수 있겠지만, 그다지 일반적으로 사용하기에 좋은 방법은 아니다.  

##### 7.3.1. 정의되지 않은 예외 처리
<br/>
스레드 API를 보면 UncaughtExceptionHandler라는 기능을 제공하는데, 그런데 스레드 API를 보면 UncaughtExceptionHandler라는 기능을 제공하는데, 이 기능을 사용하면 처리하지 못한 예외 상황으로 인해 특정 스레드가 종료되는 시점을 정확히 알 수 있다. 이 두 가지 방법은 서로 상호 보완적인 측면이 있으므로, 두 가지 방법을 모두 사용하면 스레드를 잃을 수 있는 경우에 대해 좀더 효과적으로 대응할 수 있다.  

처리하지 못한 예외 상황 때문에 스레드가 종료되는 경우에 JVM이 애플리케이션에서 정의한 UncaughtExceptionHandler를 호출하도록 할 수 있다. 만약 핸들러가 하나도 정의되어 있지 않다면 기본 동작으로 스택 트레이스를 콘솔을 System.err 스트림에 출력한다.  

자바 5.0 버전 이전까지는 UncaughtExceptionHandler를 사용하려면 ThreadGroup를 상속받는 방법밖에 없었다. 하지만 자바 5.0 버전 이후부터는 Thread의 setUncaughtExceptionHandler 메소드를 사용해 스레드별로 UncaughtExceptionHandler를 지정할 수 있고, 이와 함께 setDefaultUncaughtExceptionHandler 메소드를 사용해 기본적으로 사용할 UncaughtExceptionHandler를 지정할 수도 있게 됐다. 이렇게 여러 단계로 UncaughtExceptionHandler를 지정할 수 있지만 실제 상황에서는 이 가운데 하나만이 실행된다. 예상치 못한 예외 상황이 발생했을 때 JVM은 먼저 스레드별로 지정된 핸들러가 있는지를 확인하고, 그 다음에야 ThreadGroup에 설정된 내용이 있는지 살펴본다. ThreadGroup에 정의되어 있는 기본적인 처리 방법은 먼저 상위 ThreadGroup에게 처리 기회를 넘기는 일이고, 가장 최상위 ThreadGroup까지 올라가는 과정에서 핸들러가 지정된 경우가 있는지를 확인하게 된다. 최상위 ThreadGroup에서는 기본 시스템 핸들러에 처리를 넘기거나, 지정된 기본 시스템 핸들러가 없다면 그냥 콘솔에 스택 트레이스를 출력해버린다.  

UncaughtExceptionHandler에서 어떤 일을 해야 하는지는 작성 중인 프로그램의 요구 사항에 따라 다르다. 대부분의 대응 방법은 화면에 오류 메시지를 출력하고, 애플리케이션에서 작성하는 로그 파일에 스택 트레이스를 출력하는 등의 작업이 일반적이다. 아니면 이보다 훨씬 직접적인 작업을 할 수도 있는데, 예를 들어 종료된 스레드가 작업을 다시 할 수 있도록 시도해보거나, 애플리케이션을 종료시키거나, 관리자에게 문자 메시지를 발송하거나, 기타 문제를 해결할 수 있는 여러 가지 방법을 시도할 수 있다.  

잠깐 실행하고 마는 애플리케이션이 아닌 이상, 예외가 발생했을 때 로그 파일에 오류를 출력하는 간단한 기능만이라도 확보할 수 있도록 모든 스레드를 대상으로 UncaughtExceptionHandler를 활용해야 한다.  

스레드 풀의 작업 스레드를 대상으로 UncaughtExceptionHandler를 설정하려면 ThreadPoolExecutor를 생성할 때 작업용 스레드 생성을 담당하는 ThreadFactory 클래스를 별도로 넘겨주면 된다(스레드를 처리할 때 항상 염두에 둬야 하는 부분이지만, 스레드의 UncaughtExceptionHandler를 지정하는 일도 해당 스레드의 소유자만이 하도록 해야 한다). 자바에서 기본적으로 제공하는 스레드 풀에서는 작업에서 예상치 못한 예외가 발행했을 때 해당 스레드가 종료되도록 하면서, try-finally 구문을 사용해 스레드가 종료되기 전에 스레드 풀에 종료된다는 사실을 알려 다른 스레드를 대체해 실행할 수 있도록 하고 있다. 이런 곳에 UncaughtExceptionHandler를 지정하지 않거나 기타 다른 오류 확인 방법을 전혀 사용하지 않는다면, 오류가 생긴 작업이 아무 소리 없이 조용히 종료되어 개발자나 운영자를 혼란스럽게 할 수도 있다. 작업을 실행하는 도중에 예외가 발생해 작업이 중단되는 경우가 생길 때 오류가 발생했다는 사실을 즉시 알고자 한다면, Runnable이나 Callable 인터페이스를 구현하면서 run 메소드에서 try-catch 구문으로 오류를 처리하도록 되어 있는 클래스를 거쳐 실제 작업을 실행하도록 하거나, ThreadPoolExcutor 클래스에 마련되어 있는 afterExecute 메소드를 오버라이드하는 방법으로 오류 상황을 알리도록 하자.  

상당히 혼동된다고 느낄만한 부분이 있는데, 예외 상황이 발생했을 때 UncaughtExceptionHandler가 호출되도록 하려면 execute를 통해서 작업을 실행해야 한다. 만약 submit 메소드로 작업을 등록했다면, 그 작업에서 발생하는 모든 예외 상황은 모두 해당 작업의 리턴 상태로 처리해야 한다. 다시 말하자면 submit 메소드로 등록된 작업에서 예외가 발생하면 Future.get 메소드에서 해당 예외가 ExecutionException에 감싸진 상태로 넘어온다.  

#### 7.4. JVM 종료
<br/>
JVM이 종료되는 두 가지 경우를 생각할 수 있는데, 하나는 예정된 절차대로 종료되는 경우이고, 또 하나는 예기치 못하게 임의로 종료되는 경우이고, 또 하나는 예기치 못하게 임의로 종료되는 경우이다. 절차에 맞춰 종료되는 경우에는 '일반'(데몬이 아닌) 스레드가 모두 종료되는 시점, 또는 어디에선가 System.exit 메소드를 호출하거나 기타 여러 가지 상황(예를 들면 SIGINT 시그널을 받거나 CTRL+C 키를 입력한 경우)에 JVM 종료 절차가 시작된다. 이런 방법이 JVM을 종료하는 가장 적절한 방법이며, 그 외에 Runtime.halt 메소드를 호출하거나 운영체제 수준에서 JVM 프로세스를 강제로 종료하는 방법(예를 들어 SIGKILL 시그널을 보내는 경우) 등으로 종료시킬 수도 있다.  

##### 7.4.1. 종료 훅
<br/>
예정된 절차대로 종료되는 경우에 JVM은 가장 먼저 등록되어 있는 모든 종료 훅(shutdown hook)을 실행시킨다. 종료 훅은 Runtime.addShutdownHook 메소드를 사용해 등록된 아직 시작되지 않은 스레드를 의미한다. 하나의 JVM에 여러 개의 종료 훅을 등록할 수도 있으며, 두 개 이상의 종료 훅이 등록되어 있는 경우에 어떤 순서로 훅을 실행하는지에 대해서는 아무런 규칙이 없다. JVM 종료 절차가 시작됐는데 (데몬이건 데몬이 아니건 간에) 애플리케이션에서 사용하던 스레드가 계속해서 동작 중이라면 종료 훅이 모두 작업을 마치고 나면 JVM은 runFinalizersOnExit 값을 확인해 true라고 설정되어 있으면 클래스의 finalize 메소드를 모두 호출하고 종료한다. JVM은 종료 과정에서 계속해서 실행되고 있는 애플리케이션 내부의 스레드에 대해 중단 절차를 진행하거나 인터럽트를 걸지 않는다. 계속해서 실행되던 스레드는 결국 종료 절차가 끝나는 시점에 강제로 종료된다. 만약 종료 훅이나 finalize 메소드가 작업을 마치지 못하고 계속해 실행된다면 종료 절차가 멈추는 셈이며, JVM은 계속해서 대기 상태로 머무르기 때문에 결국 JVM을 강제로 종료하는 수밖에 없다. JVM을 강제로 종료시킬 때는 JVM이 스스로 종료되는 것 이외에 종료 훅을 실행하는 등의 어떤 작업도 하지 않는다.  

따라서 종료 훅은 스레드 안전하게 만들어야만 한다. 공유된 자료를 사용해야 하는 경우에는 반드시 적절한 동기화 기법을 적용해야 한다. 이에 더해 애플리케이션의 상태에 대해 어떤 가정(예를 들어 애플리케이션에서 사용한 서비스는 이미 종료됐을 것이고, 일반 스레드는 모두 종료됐을 것이라는 가정)도 해서는 안 되며, JVM이 종료되는 원인에 대해서도 생각해서는 안 되는 등 어떤 상황에서도 아무런 가정 없이 올바로 동작할 수 있도록 굉장히 방어적인 형태로 만들어야 한다. 마지막으로 JVM이 종료될 때 종료 훅의 작업이 끝나기를 기다리기 때문에 마무리 작업을 최대한 빨리 끝내고 바로 종료돼야 한다. 종료 훅이 실행되는 시간이 오래 걸린다면, 사용자는 애플리케이션이 종료될 때까지 한참을 기다려야 하기 때문에 역시 프로그램의 응답 속도를 늦추는 결과가 된다.  

종료 훅은 어떤 서비스나 애플리케이션 자체의 여러 부분을 정리하는 목적으로 사용하기 좋다. 예를 들어 임시로 만들어 사용했던 파일을 삭제하거나, 운영체제에서 알아서 정리해주지 않는 모든 자원을 종료 훅에서 정리해야 한다.  

이런 경우를 예방하려면 종료 훅에서는 애플리케이션이 종료되거나 다른 종료 훅이 종료시킬 수 있는 서비스는 사용하지 말아야 한다. 이런 문제를 쉽게 해결하려면 서비스별로 각자 종료 훅을 만들어 등록하기보다는 모든 서비스를 정리할 수 있는 하나의 종료 훅을 사용해 각 서비스를 의존성에 맞춰 순서대로 정리하는 것도 방법이다. 이런 방법으로 각 서비스를 차례대로 정리하도록 하면 종료 훅의 작업이 단일 스레드에서 순차적으로 일어나기 때문에 종료 훅 간에 혹시나 발생할 수 있는 경쟁 조건나 데드락 등의 상황을 미연에 방지할 수 있다. 이와 같은 기법은 종료 훅을 사용하건 사용하지 않건 언제든지 적용할 수 있으며, 어떤 방법을 사용하건 종료할 때 마무리 절차를 여러 개의 스레드를 사용해 동시에 처리하는 것보다는 순차적인 방법으로 차례대로 처리하면 문제점이 발생하는 경우를 줄일 수 있다. 실제로 서비스 간의 종속성이 명확히 눈에 보이는 애플리케이션의 경우, 종료 시점의 마무리 절차를 순차적으로 처리하도록 하면 올바른 순서대로 서비스를 종료하고 마무리할 수 있다.  

##### 7.4.2. 데몬 스레드
<br/>
애플리케이션을 작성하다 보면 스레드를 하나 만들어 부수적인 기능을 처리하도록 하고는 싶지만, 그렇다고 해서 해당 스레드가 떠 있다는 이유로 JVM이 종료되지 않게 하고 싶지는 않을 경우가 있다. 이럴 때 사용할 수  있는 것이 바로 데몬(daemon) 스레드이다.  

스레드는 두 가지 종류로 나눠볼 수 있는데, 하나는 일반 스레드이고 다른 하나는 데몬 스레드이다. JVM이 처음 시작할 때 main 스레드를 제외하고 JVM 내부적으로 사용하기 위해 실행하는 스레드(가비지 컬렉터 스레드나 기타 여러 가지 부수적인 스레드)는 모두 데몬 스레드이다. 새로운 스레드가 생성되면 자신을 생성해 준 부모 스레드의 데몬 설정 상태를 확인해 그 값을 그대로 사용하며, 따라서 main 스레드에서 생성한 모든 스레드는 기본적으로 데몬 스레드가 아닌 일반 스레드이다.  

일반 스레드와 데몬 스레드는 종료될 때 처리 방법이 약간 다를 뿐 그 외에는 모든 것이 완전히 동일하다. 스레드 하나가 종료되면 JVM은 남아있는 모든 스레드 가운데 일반 스레드가 있는지를 확인하고, 일반 스레드는 모두 종료되고 남아있는 스레드가 모두 데몬 스레드라면 즉시 JVM 종료 절차를 진행한다. JVM이 중단(halt)될 때는 모든 데몬 스레드가 버려지는 셈이다. finally 블록의 코드도 실행되지 않으며, 호출 스택도 원상 복구되지 않는다.  

이런 특성을 갖고 있기 때문에 데몬 스레드는 보통 부수적인 용도로 사용하는 경우가 많다. 데몬 스레드에 사용했던 자원을 꼭 정리해야 하는 일을 시킨다면, JVM이 종료될 때 자원을 정리하지 못할 수 있기 때문에 적절하지 않다. 예를 들어 I/O와 관련된 기능을 데몬 스레드에 맡기는 것은 그다지 좋은 방법이 아니다. 다시 말하지만 데몬 스레드는 예를 들어 메모리 내부에 관리하고 있는 캐시에서 기한이 만료된 항목을 주기적으로 제거하는 등의 부수적인 단순 작업을 맡기기에 적절한 스레드이다.  

데몬 스레드는 예고 없이 종료될 수 있기 때문에 애플리케이션 내부에서 시작시키고 종료시키며 사용하기에는 그다지 좋은 방법이 아니다.  

##### 7.4.3. finalize 메소드
<br/>
애플리케이션 내부에서 더 이상 사용하지 않는 객체가 있다면 대부분 가비지 컬렉터가 알아서 수집해 제거하고 메모리를 호가보하는 일을 잘 수행해준다. 하지만 파일이나 소켓과 같은 일부 자원은 더 이상 사용하지 않을 때 운영체제에게 되돌려 주려면 반드시 자원을 명시적으로 정리해야 한다. 가비지 컬렉터는 finalize 메소드에 기능을 추가되어 있는 객체를 좀더 특별한 방법으로 처리해 이런 과정이 효과적으로 움직이도록 하고 있다. finalize 메소드가 정의되어 있는 객체는 명시적으로 풀어줘야 하는 자원을 정리할 수 있도록 가비지 컬렉터에 수집될 때 finalize 메소드를 호출해 실행시킨다.  

finalize 메소드는 JVM이 관리하는 스레드에서 직접 호출하기 때문에 finalize 메소드에서 사용하는 모든 애플리케이션 상태 변수를 다른 스레드에서도 얼마든지 동시에 사용할 수 있으며, 따라서 동기화 작업이 필수적으로 필요하다. 하지만 finalize 메소드는 과연 실행이 될 것인지 그리고 언제 실행될지에 대해서 아무런 보장이 없고, finalize 메소드를 정의한 클래스를 처리하는 데 상당한 성능상의 문제점이 생길 수 있다. 게다가 finalize 메소드를 올바른 방법으로 구현하기도 쉬운 일이 아니다. 대부분의 경우에는 finalize 메소드를 사용하는 대신 try-finally 구문에서 각종 close 메소드를 적절하게 호출하는 것만으로도 finalize 메소드에서 해야할 일을 훨씬 잘 처리할 수 있다. finalize 메소드가 더 나을 수 있는 유일한 예는 바로 네이티브 메소드에서 확보했던 자원을 사용하는 객체 정도밖에 없다. 여기에서 언급한 이런저런 이유를 생각하고 보면 웬만해서는 finalize 메소드를 사용하지 말고 다른 방법으로 처리하며, finalize 메소드를 사용하도록 되어 있는 클래스도 멀리하는 편이 좋겠다(자바 플랫폼 라이브러리에 포함된 클래스는 예외이다).

### 요약
<br/>
작업, 스레드, 서비스, 애플리케이션 등이 할 일을 모두 마치고 종료됴ㅚ는 시점을 적절하게 관리하려면 프로그램이 훨씬 복잡해질 수 있다. 자바에서는 선점적으로 작업을 중단하거나 스레드를 종료시킬 수 있는 방법을 제공하지 않는다. 그 대신 인터럽트라는 방법을 사용해 스레드 간의 협력 과정을 거쳐 작업 중단 기능을 구현하도록 하고 있으며, 작업 중단 기능을 구현하고 전체 프로그램에 일관적으로 적용하는 일은 모두 개발자의 몫이다. FutureTask나 Executor 등의 프레임웍을 사용하면 작업이나 서비스를 실행 도중에 중단할 수 있는 기능을 쉽게 구현할 수 있다는 점을 알아두자.  

### 8. 스레드 풀 활용
<br/>
#### 8.1. 작업과 실행 정책 간의 보이지  않는 연결 관계
<br/>
Executor 프레임웍이 작어브이 정의 부분과 실행 부분을 서로 분리시켜 준다는 사실은 이미 여러 번 언급했다. 복잡한 처리 과정을 분리시키려는 여러 가지 시도에서 볼 수 있는 것처럼 작업의 정의 부분과 실행 부분을 분리하는 일도 약간 과장된 면이 없지 않다. 이를테면 Executor 프레임웍이 나름대로 실행 정책을 정하거나 변경하는 데 있어서 어느 정도의 유연성을 갖고 있긴 하지만 특정 형태의 실행 정책에서는 실행할 수 없는 작업이 있기도 하다. 일정한 조건을 갖춘 실행 정책이 필요한 작업에는 다음과 같은 것들이 있다.  

+ 의존성이 있는 작업  
독립적인 작업은 대부분 문제 없이 잘 동작한다. 독립적인 작업은 타이밍이나 작업 결과, 다른 작업이 실행하는 데서 발생하는 부수적인 요건에 관계없이 동작하는 작업을 말한다. 이와 같이 독립적인 작업을 스레드 풀에서 실행시키면 아무런 문제 없이 풀의 크기와 설정을 마음대로 변경할 수 있으며, 설정을 아무리 바꿔도 성능 외에 다른 변화가 생기거나 문제가 발생하지 않는다. 반면에 다른 작업에 의존성을 갖는 작업을 스레드 풀에 올려 실행하려는 경우에는 실행 정책에 보이지 않는 조건을 거는 셈이다. 스레드 풀이 동작하는 동안활동성 문제(liveness problem)가 발생하지 않도록 하려면 실행 적책에 대한 이와 같은 보이지 않는 조건을 면밀하게 조사하고 관리해야 한다.  

+ 스레드 한정 기겁을 사용하는 작업  
단일 스레드로 동작하는 스레드 풀은 여러 스레드가 동작하는 경우보다 병렬 프로그램 입장에서 훨씬 안전하게 동작한다. 단일 스레드로 동작하기 때문에 등록된 작업이 동시에 동작하지 않는다는 점을 보장할 수 있고, 따라서 작업 정의 내용을 훨씬 쉽게 구현할 수 있다. 작업에서 사용하는 객체를 스레드 수준에 맞춰 한정할 수 있으므로, 같은 스레드에 한정되어 있는 객체라면 해당 객체가 스레드 안전성을 갖추고 있지 않다해도 얼마든지 마음대로 사용할 수 있다. 따라서 해당 작업을 실행하려면 Executor 프레임웍이 단일 스레드로 동작해야 한다는 조건이 생기기 때문에 작업과 실행 정책 간에 보이지 않는 연결 고리가 걸려 있는 상황이다. 이런 경우에 단일 스레드를 사용하는 풀 대신 여러 개의 스레드를 사용하는 풀로 변경하면, 스레드 안전성을 쉽게 잃을 수 있다.  

+ 응답 시간이 만감한 작업  
GUI 애플리케이션은 응답 시간이 중요하다. 버튼을 클릭하고 나서 그에 대응하는 응답이 눈에 빨리 들어오지 않으면 사용자는 금방 짜증을 느낀다. 단일 스레드로 동작하는 Executor에 오랫동안 실행될 작업을 등록하거나, 서너개의 스레드로 동작하는 풀에 실행 시간이 긴 작업을 몇 개만 등록하더라도 해당 Executor를 중심으로 움직이는 화면 관련 부분은 응답 성능이 크게 떨어질 수밖에 없다.  

+ ThreadLocal을 사용하는 작업  
ThreadLocal을 사용하면 각 스레드에서 같은 이름의 값을 각자의 버전으로 유지할 수 있다. 그런데 Executor는 상황이 되는대로 기존 스레드를 최대한 재사용한다. 기본으로 포함된 Executor는 처리해야 할 작업의 수가 적을 때는 쉬고 있는 스레드를 제거하기도 하고, 작업량이 많을 때는 새로운 스레드를 만들어 사용하기도 한다. 더군다나 작업을 실행하는 도중에 예외가 발생해 스레드를 더 이상 사용할 수 없는 상황에서는 새로운 스레드로 대치시키기도 한다. 스레드 풀에 속한 스레드에서 ThreadLocal을 사용할 때에는 현재 실행 중인 작업이 끝나면 더 이상 사용하지 않을 값만 보관해야 한다. ThreadLocal을 편법으로 활용해 작업 간에 값을 전달하는 용도로 사용해서는 안 된다.  

스레드 풀은 동일하고 서로 독립적인 다수의 작업을 실행할 때 가장 효과적이다. 실행 시간이 오래 걸리는 작업과 금방 끝나는 작업을 섞어서 실행하도록 하면 풀의 크기가 굉장히 크지 않은 한 작업 실행을 방해하는 것과 비슷한 상황이 발생한다. 또한 크기가 제한되어 있는 스레드 풀에 다른 작업의 내용에 의존성을 갖고 있는 작업을 등록하면 데드락이 발생할 가능성이 높다. 다행스럽게도 일반적인 네트웍 기반의 서버 애플리케이션(웹 서버, 메일 서버, 파일 서버 등)은 작업이 서로 동일하면서 독립적이어야 한다는 조건을 대부분 만족한다.  

특정 작업 을 실행하고자 할 때 그에 맞는 실행 정책을 요구하는 경우도 있고, 특정 실행 정책 아래에서는 실행되징 안흔 경우도 있다. 다른 작업에 의존성이 있는 작업을 실행해야할 때는 스레드 풀의 크기를 충분히 크게 잡아서 작업이 큐에서 대기하거나 등록되지 못하는 상황이 없도록 해야 한다. 스레드 한정 기법을 사용하는 작업은 반드시 순차적으로 실행돼야 한다. 작업을 구현할 때는 나중에 유지보수를 진행할 때 해당 작업과 호환되지 않는 실행 정책 아래에서 실행하도록 변경해 애플리케이션의 안전성을 해치거나 실행되지 않는 경우를 막을 수 있도록 실행 정책과 관련된 내용을 문서로 남겨야 한다.  

##### 8.1.1. 스레드 부족 데드락
<br/>
스레드 풀에서 다른 작업에 의존성을 갖고 있는 작업을 실행시킨다면 데드락에 걸릴 가능성이 높다. 단일 스레드로 동작하는 Executor에서 다른 작업을 큐에 등록하고 해당 작업이 실행된 결과를 가져다 사용하는 작업을 실행하면, 데드락이 제대로 걸린다. 이전 작업이 추가한 두 번째 작업은 큐에 쌓인 상태로 이전 작업이 끝나기를 기다릴 것이고, 이전 작업은 추가된 작업이 실행되어 그 결과를 알려주기를 기다릴 것이기 때문이다. 스레드 풀의 크기가 크더라도 실행되는 모든 스레드가 큐에 쌓여 아직 실행되지 않은 작업의 결과를 받으려고 대기 중이라면 이와 동일한 상황이 발생할 수 있다. 이런 현상을 바로 스레드 부족 데드락(thread starvation deadlock)이라고 하며, 특정 자원을 확보하고자 계속해서 대기하거나 풀 내부의 다른 작업이 실행돼야 알 수 있는 조건이 만족하기를 기다리는 것처럼 끝없이 계속 대기할 가능성이 있는 기능을 사용하는 작업이 풀에 등록된 경우에는 언제든지 발생할 수 있다. 필요한 작업을 데드락 없이 실행시킬 수 있을 만큼 풀의 크기가 충분히 크다면 물론 문제가 없을 수도 있다.  

완저히 독립적이지 않은 작업을 Executor에 등록할 때는 항상 스레드 부족 데드락이 발생할 수 있다는 사실을 염두에 둬야 하며, 작업을 구현한 코드나 Executor를 설정하는 설정 파일 등에 항상 스레드 풀의 크기나 설정에 대한 내용을 설명해야 한다.  

스레드 풀의 크기는 직접적으로 지정하는 것 이외에도 스레드 풀에서 필요로 하는 자원이 제한되어 원하는 크기보다 작은 수준에서 동작하는 경우도 있다.  

##### 8.1.2. 오래 실행되는 작업
<br/>
데드락이 발생하지 않는다 하더라도, 특정 작업이 예상보다 긴 시간동안 종료되지 않고 실행된다면 스레드 풀의 응답 속도에 문제점이 생긴다. 오래 실행되는 작업이 있다면 스레드 풀은 전체적인 작업 실행 과정에 어려움을 겪게 되며 금방 끝나는 작업이 실행되는 속도에도 영향을 미친다. 오래 실행될 것이라고 예상되는 작업이 대략 몇 개인지를 알고 있을 때 그 개수에 비해 스레드 가운데 상당수가 오래 실행되는 작업에 잡혀있을 가능성이 크다. 이런 상황에 다다르면 스레드 풀의 응답 속도가 크게 느려진다.  

제한 없이 계속해서 대기하는 기능 대신 일정 시간 동안만 대기하는 메소드를 사용할 수 있다면, 오래 실행되는 작업이 주는 악영향을 줄일 수 있는 하나의 방법으로 볼 수 있다. 자바 플랫폼 라이브러리에서 제공하는 대부분의 블로킹 메소드는 시간이 제한되지 않은 것과 시간이 제한된 것이 함께 만들어져 있다. 예를 들어 Thread.join 메소드, BlockingQueue.put 메소드, CountDownLatch.await 메소드, Selector.select 메소드 등이 그렇다. 대기하는 도중에 지정한 시간이 지나면 해당 작업이 제대로 실행되지 못했다고 기록해두고 일단 종료시킨 다음 큐의 맨 뒤에 다시 추가하는 등의 대책을 세울 수 있다. 이렇게 해두면 성공하건 성공하지 못하건 간에 작업은 뭔가 계속해서 움직이는 모습을 보여줄 것이며, 큐에 쌓여 있던 금방 끝나는 작업을 실행할 수 있도록 스레드를 비워주는 효과가 있다. 스레드 풀을 사용하는 도중에 모든 스레드에서 실행 중인 작업이 대기 상태에 빠지는 경우가 자주 발생한다면, 스레드 풀의 크기가 작다는 것으로 이해할 수도 있겠다.  

#### 8.2. 스레드 풀 크기 조절
<br/>
스레드 풀의 가장 이상적인 크기는 스레드 풀에서 실행할 작업의 종류와 스레드 풀을 활용할 애플리케이션의 특성에 따라 결정된다. 스레드 풀의 크기를 하드코딩해 고정시키는 것은 그다지 좋은 방법이 아니며, 스레드 풀의 크기는 설정 파일이나 Runtime.availableProcessors 등의 메소드 결과 값에 따라 동적으로 지정되도록 해야 한다.  

스레드 풀의 크기를 결정하는 데 특별한 공식이 있지는 않다. 다만 "너무 크다"거나 "너무 작다"는 등의 극단적인 크기만 아니면 된다. 스레드 풀의 크기가 너무 크게 설정되어 있다면 스레드는 CPU나 메모리 등의 자원을 조금이라도 더 확보하기 위해 경쟁하게 되고, 그러다 보면 CPU에는 부하가 걸리고 메모리는 모자라 금방 자원 부족에 시달릴 것이다. 반대로 스레드 풀의 크기가 너무 작다면 작업량은 계속해서 쌓이는데 CPU나 메모리는 남아돌면서 작업 처리 속도가 떨어질 수 있다.  

스레드 풀의 크기를 적절하게 산정하려면 현재 컴퓨터 환경이 어느 정도인지 확인해야 하고, 확보하고 있는 자원의 양도 알아야 하며, 해야 할 작업이 어떻게 동작하는지도 정확하게 알아야 한다. 애플리케이션을 실제로 탑재해 동작할 하드웨어에 CPU가 몇 개나 꽂혀 있는지? 메모리는 얼마나 꽂혀 있는지? 실행하는 작업이 CPU 연산을 많이 하는지 아니면 I/O 작업을 많이 하는지? 아니면 CPU와 I/O 작업을 비슷하게 많이 사용하는지? 그다지 많이 확보할 수 없는 JDBC 연결과 같은 자원을 얼머나 사용하는지? 게다가 처리할 작업의 종류가 다양하다면 각자의 작업 부하에 따라 섬세하게 성능을 조절할 수 있도록 여러 개의 스레드 풀을 만들어 활용하는 방법도 사용해볼 수 있겠다.  

CPU를 많이 사용하는 작업의 경우 N개의 CPU를 탑재하고 있는 하드웨어에서 스레드 풀을 사용할 때는 스레드의 개수를 N+1개로 맞추면 최적의 성능을 발휘한다고 알려져 있다(CPU를 많이 사용하는 스레드에서도 페이징 오류가 발생하거나 기타 여러 가지 원인으로 인해 스레드가 멈추는 경우가 있기 대문에 1개의 추가 스레드를 마련해 두면 스레드 가운데 하나에 문제가 발생했을 때 CPU가 쉬지 않고 계속해서 일을 할 수 있다). I/O 작업이 많거나 기타 다른 블로킹 작업을 해야 하는 경우라면 어느 순간에는 모든 스레드가 대기 상태에 들어가 전체적인 진행이 멈출 수 있기 대문에 스레드 풀의 크기를 훨씬 크게 잡아야 할 필요가 있다. 어쨌거나 스레드 풀의 크기를 정하려면 처리해야 할 작업이 시작해서 끝날 때까지 실제 작업하는 시간 대비 대기 시간의 비율을 구해봐야 한다. 그 비율이 아주 정확해야 할 필요는 없으며, 몇 가지 성능 측정 툴을 사용하거나 기타 단순한 방법으로 비율을 구해볼 수도 있다. 아니면 스레드 풀의 크기를 바꿔가면서 애플리케이션을 자꾸 실행시켜 보면서 스데르 풀의 크기가 어느 수준일 때 CPU가 가장 열심히 일을 하는지 알아볼 수도 있다.   

다음과 같은 수치를 정의해보자.  

Ncpu = CPU의 개수  
Ucpu = 목표로 하는 CPU 활용도, UCPU 값은 0보다 크거나 같고, 1보다 작거나 같다.  
W/C = 작업 시간 대비 대기 시간의 비율  

위의 수치를 갖고 있을 때 CPU가 원하는 활용도를 유지할 수 있는 스레드 풀의 크기는 다음 수식으로 구할 수 있다.  

Nthreads = Ncpu * Ucpu * (1+W/C)  

CPU의 개수는 Runtime 클래스의 availableProcessors 메소드로 다음과 같이 알아낼 수 있다.  

```java
int N_CPU = Runtime.getRuntime().availableProcessors();
```

물론 스레드 풀을 사용해서 CPU의 사용량만을 조절할 수 있는 것은 아니다. 스레드 풀을 적용하면 메모리, 파일 핸들, 소켓 핸들, 데이너베이스 연결과 같은 자원의 사용량도 적절하게 조절할 수 있다. CPU가 아닌 이런 자원을 대상으로 하는 스레드 풀의 크기를 정하는 일은 CPU 때보다 훨씬 쉬운데, 각 작업에서 실제로 필요한 자원의 양을 모두 더한 값을 자원의 전체 개수로 나눠주면 된다. 이 값이 바로 스레드 풀의 최대 크기에 해당된다.  

스레드 풀에서 동작하는 작업 내부에서 데이터베이스 연결과 같은 자원을 사용해야 한다면 스레드 풀의 크기와 자원 풀의 크기가 서로에게 영향을 미친다. 각 작업 하나가 데이터베이스 연결 하나를 사용한다고 가정하면 스레드 풀의 실제 크기는 데이터베이스 연결 풀의 크기로 제한되는 셈이다. 이와 반대로 데이터베이스 연결 풀을 특정 스레드 풀에서만 사용한다고 하면 데이터베이스 연결 풀에 확보된 연결 가운데 실제로 스레드 풀의 크기에 해당하는 연결만 사용될 것이다.  

#### 8.3. ThreadPoolExecutor 설정
<br/>
ThreadPoolExcutor는 Executors 클래스에 들어 있는 newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool과 같은 팩토리 메소드에서 생성해주는 Executor에 대한 기본적인 내용이 구현되어 있는 클래스이다. ThreadPoolExcutor 클래스는 유연하면서도 안정적이고 여러 가지 설정을 통해 입맛에 맞게 바꿔 사용할 수 있도록 되어 있다.  

팩토리 메소드를 사용해 만들어진 스레드 풀의 기본 실행 정책이 요구 사항에 잘 맞지 않는다면 ThreadPoolExcutor 클래스의 생성 메소드를 직접 호출해 스레드 풀을 생성할 수 있으며 생성 메소드에 넘겨주는 값을 통해 스레드 풀의 설정을 마음대로 조절할 수 있다. 자바 플랫폼에 들어 있는 Executors 클래스의 소스코드를 들여다 보면 각종 기본 팩토리 메소드에서 ThreadPoolExcutor 클래스에 어떤 설정을 적용하는지 쉽게 알아볼 수 있으니 참조하자.  

##### 8.3.1. 스레드 생성과 제거
<br/>
풀의 코어(core) 크기나 최대(maximum) 크기, 스레드 유지(keep-alive) 시간 등의 값을 통해 스레드가 생성되고 제거되는 과정을 조절할 수 있다. 코어 크기는 스레드 풀을 사용할 때 원하는 스레드의 개수라고 볼 수 있다. 스레드 풀 클래스는 실행할 작업이 없다 하더라도 스레드이 개수를 최대한 코어 크기에 맞추도록 되어 있다. 최초에 ThreadPoolExcutor를 생성한 이후에도 prestartAllCoreThreads 메소드를 호출하지 않는 한 코어 크기만큼의 스레드가 미리 만들어지지는 않는다. 작업이 실행되면서 코어 크기까지의 스레드가 차례로 생성된다. 또한 쿠에 작업이 가득 차지 않는 이상 스레드의 수가 코어 크기를 넘지 않는다. 풀의 최대 크기는 동시에 얼마나 많은 개수의 스레드가 동작할 수 있는지를 제한하는 최대 값이다. 지정한 스레드 유지 시간 이상 아무런 작업 없이 대기하고 있던 스레드는 제거 대상 목록에 올라가며, 풀의 스레드 개수가 코어 크기를 넘어설 때 제거될 수 있다.  

따라서 코어 크기와 스레드 유지 시간을 적절하게 조절하면 작업 없이 쉬고 있는 스레드가 차지하고 있는 자원을 프로그램의 다른 부분에서 활용하게 반납하도록 할 수 있다(언제나 그렇지만 이 경우에도 장단점이 있다. 스레드를 한 번 종료하고 나면 나중에 스레드가 필요해서 생성해야 하는 시점에 스레드를 생성하는 만큼의 시간이 더 필요한 단점이 있다).  

newFixedThreadPool 팩토리 메소드는 결과로 생성할 스레드 풀의 코어 크기와 최대 크기를 newFixedThreadPool 메소드에 지정한 값으로 동일하게 지정하며, 시간 제한은 무제한으로 설정되는 것과 같다. newCachedThreadPool 팩토리 메소드는 스레드 풀의 최대 크기를 Integer.MAX&#95;VALUE 값으로 지정하고 코어 크기를 0으로, 스레드 유지 시간을 1분으로 지정한다. 따라서 newCachedThreadPool에서 만들어 낸 스레드 풀은 끝없이 크기가 늘어날 수 있으며, 사용량이 줄어들면 스레드 개수가 적당히 줄어드는 효과가 있다. 물론 앞에서 언급한 것처럼 ThreadPoolExcutor 클래스의 생성 메소드를 직접 호출해 코어 크기, 최대 크기, 스레드 유지 시간을 원하는 대로 지정하면 얼마든지 다양한 조합을 만들어 낼 수 있다.  

##### 8.3.2. 큐에 쌓인 작업 관리
<br/>
크기가 제한된 스레드 풀에서는 동시에 실행될 수 있는 스레드이 개수가 제한되어 있다(단일 스레드로 동작하는 풀은 일종의 특별 케이스라고 볼 수 있겠는데, 이런 스레드 풀은 스레드가 하나 뿐이기 대문에 병렬로 실행되는 경우가 없으며, 스레드 한정 기법을 사용하는 경우 스레드 안전성을 보장할 수 있다).  

앞서 제한 없이 스레드를 계속 생성했을 때 안정적이지 못한 상황이 발생할 수 있다는 점을 확인했으며, 이렇게 불안정한 문제를 해결하려면 요청이 들어올 때마다 배번 스레드를 생성하기보다는 고정된 크기의 스레드 풀을 사용하는 방법도 완벽한 해법은 아니었다. 스레드 풀을 사용하더라도 애플리케이션에 부하가 많이 걸리는 경우에는 자원을 모두 잡아먹는 상태에 이를 수 있으며, 단지 스레드 풀을 사용하지 않는 경우보다 문제가 훨씬 적게 발생할 뿐이다. 작업을 처리할 수 있는 능력보다 많은 양의 요청이 들어오면 처리하지 못한 요청이 큐에 계속해서 쌓인다. 스레드 풀을 사용하는 경우에는 Executor 클래스에서 관리하는 큐에 Runnable로 정의된 작업이 계속해서 쌓일 뿐이며, 스레드 풀 없이 스레드가 계속해서 생성됐을 때 각 스레드가 CPU를 확보하기 위해 대기하는 것과 다를 바 없는 상황이 발생한다. 대기 중인 작업을 Runnable로 표현하고 Runnable의 묶음을 List 형태로 관리하면 스레드를 생성하는 것보다 자원을 덜 소모하기는 하지만, 애플리케이션이 처리할 수 있는 것보다 많은 양의 작업이 들어올 때 시스템 자원이 모자라는 것은 같다는 말이다.  

일반적인 경우네는 작업이 추가되는 속도가 굉장히 일정한 편이지만, 간혹 어느 수간에 한꺼번에 대량의 작업이 추가되기도 한다. 큐를 사용하면 대량의 작업이 갑자기 들어오는 경우에 좀더 유연하게 대응할 수 있기는 하지만, 계속해서 처리하는 속도보다 빠른 속도로 작업이 추가되면 속도 조절 기능을 사용해 메모리가 가득 차는 현상을 막아야 할 것이다. 일반적인 컴퓨터 통신에서 말하는 호름 제어(flow constrol)과는 약간 다른 개념이다. 일정량의 작업은 버퍼에 쌓아둘 수 있겠지만, 결국은 클라이언트 측에서 더 이상 요청을 보내지 않도록 하는 방법이 필요할 수도 있고, 아니면 양에 넘치게 들어온 요청은 일단 무시하고 버린 다음 클라이언트에게 나중에 다시 보내달라고 응답을 보내는 방법도 있다. 아직 메모리에 공간이 남아 가득 찬 상태가 아니라 하더라도, 큐에 작업이 쌓이면 쌓일수록 작업을 처리해 응답해주는 시간은 점점 길어질 것이다.  

ThreadPoolExcuto를 생성할 때 작업을 쌓아둘 큐로 BlockingQueue를 지정할 수 있다. 스레드 풀에서 작업을 쌓아둘 큐에 적용할 수 있는 전략에는 세 가지가 있다. 첫 번째는 큐에 크기 제한을 두지 않는 방법이고, 두 번째는 큐의 크기를 제한하는 방법, 세 번째는 작업을 스레드에게 직접 넘겨주는 방법이다. 작업을 쌓는 방법 역시 풀의 크기를 지정하는 것과 같은 여러 가지 설정과 연관되어 있다.  

newFixedThreadPool 메소드와 newSingleThreadExecutor 메소드에서 생성하는 풀은 기본 설정으로 크기가 제한되지 않은 LinkedBlockingQueue를 사용한다. 스레드 풀의 모든 작업 스레드가 실행 중일 때 작업이 등록되면 해당 작업은 큐에 쌓이게 되며, 작업이 처리되는 속도보다 작업이 추가되는 속도가 빠르면 큐에 끝없이 계속해서 작업이 쌓일 수 있다.  

자원 관리 측면에서 ArrayBlockingQueue 또는 크기가 제한된 LinkedBlockingQueue나 PriorityBlockingQueue와 같이 큐의 크기를 제한시켜 사용하는 방법이 훨씬 안정적이다. 크기가 제한된 큐를 사용하면 자원 사용량을 한정시킬 수 있다는 장점이 있지만, 큐가 가득 찼을 때 새로운 작업을 등록하려는 상황을 어떻게 처리해야 하는지에 대한 문제가 생긴다. 작업 큐의 크기를 제한한 상태에서는 큐의 크기와 스레드의 개수를 동시에 튜닝해야 한다. 스레드의 개수는 줄이면서 큐의 크기를 늘려주면 메모리와 CPU 사용량을 줄이면서 컨텍스트 스위칭 횟수를 줄일 수 있지만, 전체적인 성능에는 제한이 생길 수 있다.  

스레드의 개수가 굉장히 많거나 제한이 거의 없는 상태인 경우에는 작업을 큐에 쌓는 절차를 생략할 수도 있을텐데, 이럴때는 SynchrounousQueue를 사용해 프로듀서에서 생성한 작업을 컨슈머인 스레드에게 직접 전달할 수 있다. SynchrounousQueue는 따지고 보면 큐가 아니며 단지 스레드 간에 작업을 넘겨주는 기능을 담당한다고 볼 수도 있다. SynchrounousQueue에 작업을 추가하려면 컨슈머인 스레드가이미 작업을 받기 위해 대기하고 있어야만 한다. 대기 중인 스레드가 없는 상태에서 스레드의 개수가 최대 크기보다 작다면 ThreadPoolExcutor는 새로운 스레드를 생성해 동작시킨다. 반면 스레드의 개수가 최대 크기에 다다른 상태라면 집중 대응 정책(saturation policy)에 따라 작업을 거부하도록 되어 있다. 처리할 작업을 큐에 일단 쌓고 쌓인 작업을 쉬는 스레드가 가져가도록 하는 것보다는 쉬고 있는 작업을 직접 넘겨누는 방법이 있다면 훨신 효율적일 수 있다. SynchrounousQueue는 스레드의 개수가 제한이 없는 상태이거나 넘치는 작업을 마음대로 거부할 수 있는 상황이어야 적용할만한 방법이다. newCachedThreadPool 팩토리 메소드에서는 스레드 풀에 SynchrounousQueue를 적용한다.  

LinkedBlockingQueue나 ArrayBlockingQueue와 같은 FIFO 큐를 사용하면 작업이 등록된 순서에 맞춰 실행된다. 작업이 실행되는 순서를 좀더 조절하고자 한다면 PriorityBlockingQueue를 사용해 작업에 지정된 우선 순위에 따라 실행되도록 할 수 있다. 작업의 우선 순위는 기본 순서(natural order, 작업 클래스에서 Comparable을 구현하는 경우)를 따르거나 Comparator를 지정해 원하는 순서로 배치할 수 있다.  

크기가 고정된 풀보다는 newCachedThreadPool 팩토리 메소드가 생성해주는 Executor가 나은 선택일 수 있다. 여기에서 언급한 성능의 차이는 LinkedBlockingQueue 대신 SynchrounousQueue를 사용하는 점에서 나타난다. 자바 6 버전에서는 블로킹 되지 않는 방법으로 동작하도록 SynchrounousQueue를 개선했으며, 따라서 Executor에 SynchrounousQueue를 적용했을 때 자바 5 버전에 비해 세 배 이상의 성능을 발휘한다. 크기가 고정된 스레드 풀은 자원 관리 측면에서 동시에 실행되는 스레드의 수를 제한해야 하는 경우에 현명한 선택이 될 수 있다. 예를 들어 네트웍으로 클라이언트의 요청을 받아 처리하는 애플리케이션과 같은 경우, 크기가 고정되어 있지 않다면 요청이 많아져 부하가 걸릴 때 문제가 커진다.  

스레드 풀에서 실행할 작업이 서로 독립적인 경우에만 스레드의 개수나 작업 큐의 크기를 제한할 수 있다. 다른 작업에 의존성을 갖는 작업을 실행해야 할 때 스레드나 큐의 크기가 제한되어 있다면 스레드 부족 데드락에 걸릴 가능성이 높다. 이럴 때는 newCachedThreadPool 메소드에서 생성하는 것과 같이 크기가 제한됮 않은 풀을 사용해야 한다. 또 다른 작업을 큐에 쌓고 그 작업의 결과를 기다리도록 만들어져 있는 작업을 실행하려는 경우에 적용할 수 있는 방법이 또 있긴하다. 스레드이 개수를 제한하고, 작업 큐로는 SynchrounousQueue를 사용하고, 집중 대응 정책으로 호출자 실행 전략을 사용하면 된다.  

##### 8.3.3. 집중 대응 정책
<br/>
크기가 제한된 큐에 작업이 가득 차면 집중 대응 정책(saturation policy)이 동작한다. ThreadPoolExcutor의 집중 대응 정책은 setRejectedExecutionHandler 메소드를 사용해 원하는 정책으로 변경할 수 있다(집중 대응 정책은 이미 종료된 스레드 풀에 작업을 등록하려는 경우에도 동작한다). 여러 가지 종류의 setRejectedExecutionHandler 메소드를 사용해 원하는 정책으로 변경할 수 있다(집중 대응 정책은 이미 종료된 스레드 풀에 작업을 등록하려는 경우에도 동작한다). 여러 가지 종류의 RejectedExecutionHandler에는 AbortPolicy, CallerRunsPolicy, DiscardPolicy, DiscardOldestPolicy 등이 있다.  

기본적으로 사용하는 집중 대응 정책은 중단(abort) 정책이며, execute 메소드에서 RuntimeException을 상속받은 RejectedExecutionException을 던진다. execute 메소드를 호출하는 스레드는 RejectedExecutionHandler을 잡아서 작업을 더 이상 추가할 수 없는 상황에 직접 대응해야 한다. 제거(discard) 정책은 큐에 작업을 더 이상 쌓을 수 없다면 방금 추가시키려고 했던 정책을 아무 반응 없이 제거해버린다. 이와 비슷한 오래된 항목 제거(discard oldest) 정책은 큐에 쌓은 항목 중 가장 오래되어 다음 번에 실행될 예정이던 작업을 제거하고, 추가하고자 했던 작업을 큐에 다시 추가해본다(작업 큐가 우선 순위에 따라 동작한다면 오래된 항목 제거 정책을 사용하는 경우에 큐에 들어 있는 항목 가운데 우선 순위가 가장 높은 항목을 제거한다. 따라서 오래된 항목을 제거하는 정책과 함께 작업 큐로 우선 순위 큐를 사용하는 것은 보기 좋은 조합이 아니다).  

호출자 실행(caller runs) 정책은 작업을 제거해 버리거나 예외를 던지지 않으면서 큐의 크기를 초과하는 작업을 프로듀서에게 거꾸로 넘겨 작업 추가 속도를 늦출 수 있도록 일종의 속도 조절 방법으로 사용된다. 다시 말해 새로 등록하려고 했던 작업을 스레드 풀의 작업 스레드로 실행하지 않고, execute 메소드를 호출해 작업을 등록하려 했던 스레드에서 실행시킨다. 작업 큐의 크기를 제한하고 호출자 실행 정책을 사용하도록 변경했다고 가정하고, 풀의 작업 스레드가 모두 동작 중이고 작업 큐가 가득 찬 상태라고 생각해보자. 이런 상황에서 메인 스레드가 스레드 풀의 execute를 호출해 새로운 작업을 실행하려 하면 execute 메소드 내부에서 메인 스레드가 직접 해당 작업을 실행하게 된다. 프로듀서인 메인 스레드가 추가하려던 작업을 직접 처리하게 되면, 해당 작업 하나를 실행하는 동안에는 또 다른 새 작업을 추가할 수 없으므로 자연스럽게 스레드 풀이 큐에 쌓인 작업을 처리할 시간을 약간 벌 수 있다. 웹 서버의 메인 스레드가 직접 작업을 처리하기 때문에 소켓의 accept 메소드도 호출할 수 없으므로 원격 클라이언트가 접속했을 때 네트웍으로 누군가 접속했다는 사실을 웹 서버 프로그램이 알기 전에 웹 서버보다 훨씬 낮은 TCP 계층으로 해당 접속 요청을 자체 큐에 쌓아 대기시킨다. TCP 계층의 큐에도 네트웍 접속 요청이 계속해서 쌓이다 보면 TCP 계층 역시 더 이상의 연결을 큐에 쌓지 못하고 연결 요청을 거부하기 시작한다. 이처럼 웹 서버에 부하가 걸리기 시작하면 부하가 웹 서버 내부에서 점점 밖으로 드러나기 시작한다. 가장 먼저 웹 서버 내부의 스레드 풀에서 부하가 나타나고, 서버가 동작하는 시스템의 TCP 계층에서 부하가 나타나며, 결국 클라이언트가 부하를 직접 느끼게 된다. 이렇게 여러 단계를 거쳐 부하가 전달되기 때문에 부하가 걸린 상태에서도 애플리케이션의 전체적인 성능이 점진적으로 떨어지도록 조절할 수 있다.  

스레드 풀에 적용할 집중 대응 정책을 선택하거나 실행 정책의 다른 여러 가지 설정을 변경하는 일은 모두 Executor를 생성할 때 지정할 수 있다.  

작업 큐가 가득 찼을 때 execute 메소드가 그저 대기하도록 하는 집중 대응 정책은 따로 만들어진 것이 없다. 하지만 Semaphore를 사용하면 작업 추가 속도를 적절한 범위 내에서 제한할 수 있다. 이런 방법을 사용하려면 큐의 크기에 제한을 두지 않아야 하고(큐의 크기를 제한하면서 동시에 작업 추가 속도를 제한해야 할 필요는 없다고 본다) 스레드 풀의 스레드 개수와 큐에서 대기하도록 허용하고자 하는 최대 작업 개수를 더한 값을 세마포어의 크기로 지정하면 된다. 여기에서는 세모포어가 현재 실행 중이거나 실행되기를 기다리는 작업의 개수를 더해 한꺼번에 제한할 수 있다는 점을 활용하고 있다.  

##### 8.3.4. 스레드 팩토리
<br/>
스레드 풀에서 새로운 스레드를 생성해야 할 시점이 되면, 새로운 스레드는 항상 스레드 팩토리를 통해 생성한다. 기본 값으로 설정된 스레드 팩토리에서는 데몬이 아니면서 아무런 설정도 변경하지 않은 새로운 스레드를 생성하도록 되어 있다. 스레드 팩토리를 직접 작성해 적용하면 스레드 풀에서 사용할 스레드이 설정을 원하는 대로 지정할 수 있다. ThreadFactory 클래스에는 newThread라는 메소드 하나만 정의되어 있으며, 스레드 풀에서 새로운 스레드를 생성할 때에는 항상 newThread 메소드를 호춯한다.  

스레드 팩토리를 직접 작성해 사용해야 하는 경우로 여러 가지 상황을 생각해 볼 수 있다. 스레드 풀에서 사용하는 스레드에 UncaughtExceptionHandler를 직접 지정하고자 할 경우도 있을 것이고, Thread 클래스를 상속받은 또 다른 스레드를 생성해 사용하고자 하는 경우(예를 들어 디버깅을 위한 메시지를 출력하는 기능을 추가하는 등의 경우)도 있을 수 있다. 새로 생성한 스레드의 실행 우선 순위를 조절(그다지 권장할 만한 기능은 아니다)하고자 할 수도 있고, 데몬 상태를 직접 지정(이 역시 그다지 권장할 만한 기능이 아니다)할 수도 있다. 아니면 스레드 풀에서 사용하는 스레드마다 의미가 있는 이름을 지정해 오류가 발생했을 때 나타나는 덤프 파일이나 직접 작성한 로그 파일에서 스레드 이름이 표시되독 할 수도 있다.  

애플리케이션에서 보안 정책(security policy)를 사용해 각 부분마다 권한을 따로 지정하고 있다면, Executors에 포함되어 있는 privilegedThreadFactory 팩토리 메소드를 사용해 스레드 팩토리를 만들어 사용할 수 있겠다. privilegedThreadFactory에서 만들어 낸 스레드 팩토리는 privilegedThreadFactory 메소드를 호출한 스레드와 동일한 권한, 동일한 AccessControlContext, 동일한 contextClassLoader 결과를 갖는 스레드를 생성한다. 그렇지 않다면 스레드 풀의 executor나 submit 메소드를 호출할 때 스레드를 그 즉시 생성하는 경우도 많은데, 이럴 때 execute나 submit을 호출한 클라이언트 스레드의 권한을 사용한다면 여러 클라이언트가 다양한 보안 정책을 갖고 있을 수 있기 때문에 혼동이 생길 수 있다. 보안의 측면에서 볼 대 이런 상황은 바람직하다고 볼 수 없다.  

##### 8.3.5. ThreadPoolExcutor 생성 이후 설정 변경
<br/>
ThreadPoolExcutor를 생성할 때 생성 메소드에 넘겨줬던 설정 값은 대부분 여러 가지 set 메소드를 사용해 생성된 이후에도 얼마든지 변경할 수 있다(예를 들어 코어 스레드 개수, 최대 스레드 개수, 스레드 유지 시간, 스레드 팩토리, 작업 거부 처리 정책 등), Executors 클래스에서 기본적으로 제공하는 여러 가지 메소드(newSingleThreadExecutor 메소드는 제외)를 사용해 Executor를 생성한 경우에는 스레드 풀을 Executor를 ThreadPoolExcutor로 형변환해 여러 가지 set 메소드를 사용할 수 있다.  

Executors에는 unconfigurableExecutorService 메소드가 있는데, 현재 만들어져 있는 ExecutorService를 넘겨 받은 다음 ExecutorService의 메소드만을 외부에 노출하고 나머지는 가리도록 한꺼풀 덮어 씌워 더 이상은 설정을 변경하지 못하도록 할 수 있다. 스레드 풀을 사용하지 않는 newSingleThreadExecutor 메소드는 ThreadPoolExcutor 인스턴스를 만들어 주는 대신 단일 스레드라는 기능에 맞춰 한꺼풀 덮어 씌운 ExecutorService를 생성한다. 단일 스레드로 실행하는 Executor가 ExecutorService 대신 하나의 스레드를 사용하는 스레드 풀을 사용한다 해도, 두 개 이상의 작업이 병렬로 동시에 처리되어서는 안 된다는 규칙은 그대로 보장한다. 그런데 단일 스레드로 실행하는 Executor의 풀 크기를 마음대로 변경했다고 하면, 원래 의도했던 실행 정책에 악영향을 미치게 된다.  

#### 8.4. ThreadPoolExecutor 상속
<br/>
ThreadPoolExecutor는 애초부터 상속받아 기능을 추가할 수 있도록 만들어졌다. 특히 상속받은 하위 클래스가 오버라이드해 사용할 수 있도록 beforeExecute, afterExecute, terminated와 같은 여러 가지 훅(hook)도 제공하고 있으며, 이런 훅을 사용하면 훨씬 다양한 기능을 구사할 수 있다.  

beforeExecute 메소드와 afterExecute 메소드는 작업을 실행할 스레드의 내부에서 호출하도록 되어 있으며, 로그 메시지를 남기거나 작업 실행 시점이 언제인지 기록해두거나 실행 상태를 모니터링하거나 기타 다양한 통계 값을 뽑는 등의 작업을 하기에 적당하다. 특히 afterExecute 훅 메소드는 run 메소드가 정상적으로 종료되거나 아니면 예외가 발생해 Exception을 던지고 종료되는 등의 어떤 상황에서도 항상 호출된다(만약 Exception보다 심각한 오류인 Error 때문에 작업이 중단되면 afterExecute 메소드가 실행되지 않는다는 점을 알아두자). 만약 beforeExecute 메소드에서 RuntimeException이 발생하면 해당 작업도 실행되지 않을 뿐더러 afterExecute 메소드 역시 실행되지 않으니 주의하자.  

스레드 풀이 종료 절차를 마무리한 이후, 즉 모든 작업과 모든 스레드가 종료되고 나면 terminated 훅 메소드를 호출한다. terminated 메소드에서는 Executor가 동작하는 과정에서 사용했던 각종 자원을 반납하는 등의 일을 처리하거나 여러 가지 알람이나 로그 출력, 다양한 통계 값을 확보하는 등의 작업을 진행하기에 적당한 메소드이다.  

#### 8.5. 재귀 함수 병렬화
<br/>
반복문 내부에서 복잡한 연산을 수행하거나 블로킹 I/O 메소드를 호출하는 등의 작업을 진행하는 부분이 있고, 각 반복 작업이 이전 회차와 독립적이라면 병렬화할 수 있는 좋은 대상으로 생각할 수 있다.  

반복문의 각 차수에 해당하는 작업이 서로 독립적이라고 한다면 반복문 내부의 작업이 순차적으로 실행되어 끝나기를 기다릴 필요가 없으며, Executor를 활용하면 순차적으로 실행되던 반복문을 병렬 프로그램으로 쉽게 변경할 수 있다.  

특정 작업을 여러 번 실행하는 반복문이 있을 때, 반복되는 각 작업이 서로 독립적이라면 병렬화해서 성능의 이점을 얻을 수 있다. 특히 반복문 내부의 작업을 개별적인 작업으로 구분해 실행하느라 추가되는 약간의 부하가 부담되지 않을 만큼 적지 않은 시간이 걸리는 작업이라야 더 효과를 볼 수 있다.  

반복문을 병렬화하는 작업은 일부 재귀(recursive) 함수 처리 부분에도 적용할 수 있다. 반복문의 각 단계에서 실행되는 작업이 그 내부에서 재귀적으로 호출했던 작업의 실행 결과를 사용할 필요가 없는 경우가 가장 간단하다.  

### 요약
<br/>
Executor 프레임웍은 작업을 병렬로 동작시킬 수 있는 강력함과 유연성을 고루 갖추고 있다. 스레드를 생성하거나 제거하는 정책이나 큐에 쌓인 작업을 처리하는 방법, 작업이 밀려 있을 때 밀린 작업을 처리하는 방법 등의 조건을 설정해 입맞에 맞게 튜닝할 수 있는 옵션도 제공하고 있으며, 여러 가지의 훅 메소드를 사용해 필요한 기능을 확장해 사용할 수 있다. 강력하면서 유연성이 높은 프레임웍에서 자주 발생하는 일이지만, 여러 가지 설정 가운데 서로 잘 맞지 않는 설정이 있을 수 있다. 예를 들어 특정 종류의 작업은 일정한 실행 정책 아래에서만 제대로 동작하기도 하고, 특이한 조합을 사용하면 예측할 수 없는 이상한 형태로 작업이 실행되기도 한다는 점을 주의하자.  

### 9. GUI 애플리케이션
<br/>
스윙을 사용해 GUI 애플리케이션을 작성해 본 경험이 있다면 GUI 애플리케이션만의 특이한 스레드 관련 문제를 겪어 봤을 것이다. 프로그램이 안정적으로 동작하도록 하려면 특정 작업은 반드시 스윙의 이벤트 스레드에서 동작시킬 수도 없는 것이 애플리케이션의 화면 응답이 멈출 수 있기 때문이다. 더군다나 스윙에서 사용하는 자료 구조가 스레드 안전성을 확보하지 못하고 있기 때문에 작업을 구현할 때 해당 작업이 이벤트 스레드에 제한돼 작동하도록 주의 깊게 만들어야 한다.  

스윙이나 SWT 등을 포함한 거의 모든 GUI 툴킷은 GUI 관련 작업이 모두 단일 스레드에서 일어나는 단일 스레드 서브시스템(single thread subsystem)으로 구현돼 있다. 만들고자 하는 프로그램이 완벽하게 단일 스레드상에서 동작할 것이 아닌 이상에야 프로그램에서 필요한 작업 가운데 일부는 이벤트 스레드에서 실행될 것이고, 또 나머지는 일반 애플리케이션 스레드를 잘못 구분하고 혼동해 사용한다면 단순히 애플리케이션이 다운되는 문제뿐만 아니라 어떨 때는 동작하고 어느 경우에는 동작하지 않아 그 원인을 찾기 어려운 상태가 발생하기 쉽다. 물론 GUI 부분만을 떼어놓고 보자면 단일 스레드로 동작하겠지만, 전체 애플리케이션을 놓고 보면 단일 스레드로 동작하지 않는 경우가 거의 전부이기 때문에 GUI 프로그램을 작성할 때는 항상 스레드 관련 문제가 발생하지 않도록 세심하게 신경을 써야 한다.  

#### 9.1. GUI는 왜 단일 스레드로 동작하는가?
<br/>
예전에는 GUI 애플리케이션이 단일 스레드로 동작했으며, GUI 이벤트는 애플리케이션의 메인 이벤트 반복문(main event loop)에서 처리했었다. 하지만 최근에 등장한 GUI 프레임웍은 약간 다른 구조로 만들어져 있는데, 이를테면 이벤트 처리 스레드(EDT, Event Dispatch thread)에서 GUI 이벤트를 전달해서 처리하도록 돼 있다.  

자바에서만 GUI 프레임웍을 단일 스레드로 구성한 것은 아니다. Qt, 넥스트스텝(NextStep), Mac OS의 코코아(Cocoa), X 윈도우 등을 포함한 대부분의 GUI 프레임웍이 단일 스레드로 동작하도록 돼 있다. 그렇다고 해서 아무도 단일 스레드를 벗어나려는 시도를 하지 않았던 것은 아니다. GUI 프레임웍에서 여러 개의 스레드를 사용하고자 하는 시도는 많았지만, 대부분 경쟁 조건(race condition)과 데드락(deadlock) 등의 문제가 계속해서 발생했다. 결국 대부분의 프레임웍이 이벤트 처리용 전담 스레드를 만들고, 전담 스레드는 큐에 쌓여 있는 이벤트를 가져와 애플리케이션에 준비돼 있는 이벤트 처리 메소드를 호출해 기능을 동작시키는 단일 스레드 이벤트 큐 모델에 정착한 셈이다(AWT는 멀티스레드에서 훨씬 자유롭게 활용할 수 있도록 구성돼 있었지만, 스윙을 설계할 때에는 AWT에서의 경험을 살려 여러 단점을 없앨 수 있도록 단일 스레드로 만들었다).  

멀티스레드로 구현된 GUI 프레임웍은 특히나 데드락 상황에 빠지기 쉬울 수밖에 없는데, 입력된 이벤트를 처리하는 과정과 GUI 컴포넌트를 구성한 객체 지향적인 구조가 어긋나는 경우가 많기 때문이다. 사용자가 취한 행동은 항상 운영체제에서 해당 애플리케이션으로 한 단계씩 넘어오게 돼 있다. 예를 들어 사용자가 마우스를 클릭하면 먼저 운영체제의 GUI 프레임웍에서 클릭 이벤트를 생성하고, 해당 애플리케이션의 이벤트 리스너에게 "버튼을 눌렀다"는 등의 이벤트를 넘겨준다. 반대로 애플리케이션의 작업은 대부분 이와 같이 하나의 GUI 컴퓨넌트를 놓고 양방향으로 움직이는 과정을 거치게 돼 있는데 이 과정에 속한 객체가 스레드 안전하도록 동기화시키다 보니 락이 배치되는 순서가 적절하지 않은 경우가 많아진다. 이처럼 락이 잘못된 순서와 구조로 배치되면 데드락에 걸릴 수밖에 없다. 이런 증상과 그 원인은 대부분의 GUI 프레임웍을 개발하는 과정에서 경험적으로 깨닫게 됐다.  

멀티스레드를 사용하는 GUI 프레임웍에서 데드락이 발생하곤 하는 또 다른 이유 가운데 하나는 바로 최근 널리 사용하는 MVC(Model-View-Controller) 패턴이다. 사용자 인터페이스를 모델, 뷰, 컨트롤러 객체가 협업하면서 움직이는 구조로 나누면 GUI 애플리케이션을 구현하는 단계는 굉장히 간편하게 작업할 수 있지만, 락의 순서가 올바르지 않게 배치될 가능성이 높다. 컨트롤러는 모델 내부의 값을 불러다 사용하고, 변경된 내용은 뷰를 통해 화면에 표시한다. 반대로 컨트롤러에서 뷰의 기능을 호출하면서 모델 내부의 상태를 확인하기 위해 모델의 기능을 호출하기도 한다. 그러다보니 객체마다 락이 걸리는 순서가 잘못 맞물려 데드락에 걸릴 가능성이 높다.  

썬마이크로시스템즈의 부사장인 그레이엄 해밀터(Graham Hamilton)은 자신의 블로그에 멀티스레드 GUI 프레임웍이 컴퓨터 과학 역사상 여러 가지 "이룰 수 없는 꿈" 가운데 하나라고 설명하고 있다.  

> 멀티스레드 GUI 프로임웍을 사용하더라도 다음과 같은 조건이 만족한다면 프로그램을 제대로 작성할 수 있다. 일단 GUI 프레임웍이 굉장히 세심하게 설계돼 있어야 하고, 내부적인 락과 동기화 방법을 아주 사소한 부분까지 공개해야 하고, 개발자가 굉장히 똑똑하면서 주의 깊은 사람이어야 하고, 그 개발자가 GUI 프레임웍의 내부 구조에 대해서 처음부터 끝까지 꿰뚫고 있어야 한다. 웨이서 언급한 여러 가지 조건 가운데 하나라도 약간 틀어진다면 프로그램이 대충 동작하는 것처럼 보이겠지만, 대드락 때문에 프로그램이 종종 멈추거나 경쟁 상황 때문에 여러 문제가 생길 것이다. 멀티스레드를 사용하는 방법은 GUI 프레임웍을 설계하는 일에 직접 참여했던 개발자만이 제대로 활용할 수 있을 것이다.<br/><br/>불행한 일이지만 멀티스레드 GUI 프레임웍의 이런 특성을 보면 상용 애플리케이션에 널리 사용되지 못할 것이 분명하다. 똑똑한 개발자를 데려다 애플리케이션을 만들고 나면 결국에는 원인도 제대로 찾을 수 없는 이상한 오류가 발생하면서 불안정하게 동작하는 결과를 얻을 가능성이 높다. 그러면 개발자 기분만 상하고 오류가 발생하지 않을까 겁을 내게 되는 데다 괜한 GUI 프레임웍에 대고 욕이나 하게 될 것이다.  

단일 스레드 GUI 프레임웍은 스레드 제한 기법으로 스레드 안정성을 보장한다. 화면 컴포넌트나 데이터 모델과 같은 모든 GUI 객체는 항상 이벤트 스레드에서 독점적으로 사용한다. 물론 이런 구조로 동작하다보니 애플리케이션을 작성하는 개발자는 각종 객체가 이벤트 스레드에 적절하게 제한돼 동작하도록 만들어야 하는 부담을 가질 수밖에 없다.  

##### 9.1.1. 순차적 이벤트 처리
<br/>
GUI 애플리케이션은 마우스 클릭, 키보드 입력, 타임아웃 등의 세밀한 이벤트를 처리하는 기능 위주로 만들게 된다. 이벤트는 이를테면 일종의 작업이라고 볼 수 있겠다. 특히 스윙이나 AWT에서 이벤트를 처리하도록 만들어진 구조를 살펴보면 Executor에서 작업을 실행하는 것과 많이 닮아 있다는 사실을 알 수 있다.  

GUI 이벤트를 처리하는 스레드는 단 하나밖에 없기 때문에 이벤트는 항상 순차적으로 실행된다. 이벤트 하나를 처리해야 다음 이벤트를 처리하며, 두 개 이상의 이벤트를 동시에 처리하는 일은 없다. 이런 기본적인 정보를 머릿속에서 놓치지 않는다면 다른 작업에 맞물려 올바르게 동작하지 않을 가능성을 배제하고 이벤트 처리 코드를 훨씬 쉽게 작성할 수 있다.  

작업을 순차적으로 처리하는 방법의 단점이라면 특정 작업을 실행하는 데 시간이 오래 걸리는 경우 그 이후에 실행할 작업은 이전 작업이 끝날 때까지 오랜 시간을 기다려야 한다는 점이다. 더군다나 오랜 시간 실행될 작업 뒤에서 대기하는 작업이 사용자의 입력에 반응하는 작업이거나 화면에 뭔가를 표시하는 작업이라면, 해당 애플리케이션 전체적으로 동작을 멈추고 다운된 듯한 현상이 벌어진다. 따라서 이런 문제를 방지하려면 이벤트 스레드에서 실행되는 작업은 반드시 작업을 빨리 끝마치고 제어권을 이벤트 스레드에게 재빠르게 넘겨야 한다. 대량의 문서를 대상으로 맞춤법 검사를 한다거나, 파링 시스템의 내용을 검색한다거나, 내트웍상의 정보를 가져오는 드의 작업을 할 때는 해당 작업을 이벤트 스레드가 아닌 독립 스레드에서 동작시키고, 이벤트 스레드에 제어권을 바로 넘기도록 해야 한다. 오래 실행되는 작업이 얼마나 실행됐는지를 화면에 표시하거나, 작업이 완료됐을 때 완료됐다는 메시지를 화면에 표시하고자 한다면 해당 화면 표시 작업은 이벤트 스레드 내부에서 실행되도록 해야 한다. 오래 실행될 작업은 이런 방법으로 처리해야 하기 때문에 코드가 금방 복잡해지곤 한다.  

##### 9.1.2. 스윙의 스레드 한정
<br/>
JButton이나 JTable과 같은 모든 스윙 컴포넌트와 TableModel, TreeModel 등의 데이터 모델 객체는 이벤트 스레드에 한정되도록 만들어져 있다. 따라서 이와 같은 컴포넌트나 모델 객체는 항상 이벤트 스레드 내부에서만 사용해야 한다. GUI 객체는 동기화 기법 대신 스레드 한정 기법을 사용해 스레드 안전성을 확보한다. 이럴 경우 이벤트 스레드 내부에서 실행되는 작업이 자료를 사용할 때 더 이상 동기화에 대해 걱정할 필요가 없다는 장점이 있다. 반대로 GUI 관련 객체를 이벤트 스레드 외부에서는 절대 건드려서는 안 된다는 단점이 있다.  

+ 스윙의 단일 스레드 규칙  
스윙 컴포넌트와 모델 객체는 이벤트 스레드 내부에서만 생성하고, 변경하고, 사용할 수 있다.  

물론 모든 규칙이 그렇듯 몇 가지 예외가 있다. 스윙 내부의 메소드 가운데 몇 가지는 이벤트 스레드 외부에서도 얼마든지 호출할 수 있으며, 이런 메소드를 항상 스레드 안전하게 외부에서 호출할 수 있다는 점은 API 문서에도 잘 설명돼 있다. 이런 예외 메소드에는 다음과 같은 것들이 있다.  

+ SwingUtilities.isEventDispatcherThread 메소드는 현재 스레드가 이벤트 스레드인지를 알려주는 메소드이다.  
+ SwingUtilities.invokeLater 메소드는 Runnable을 등록해 이벤트 스레드에서 실행되도록 해준다(이벤트 스레드 외부에서도 얼마든지 호출할 수 있다).  
+ SwingUtilities.invokeAndWait 메소드는 Runnable을 등록해 이벤트 스레드에서 실행되도록 하며, 해당 작업이 끝날 때까지 대기한다(GUI 스레드가 아닌 스레드에서만 호출핧 수 있다).  
+ 화면을 다시 그리거나(repaint) 재정비(revalidation)하는 요청을 이벤트 큐에 쌓는 메소드는 이벤트 스레드 외부에서도 얼마든지 호출할 수 있다.  
+ 마지막으로 이벤트 리스너를 추가하거나 제거하는 메소드 역시 이벤트 스레드 외부에서도 얼마든지 호출할 수 있다. 단, 리스너의 메소드는 이벤트 스레드에서만 호출한다.  

invokeLater와 invokeAndWait 메소드는 Executor의 기능과 굉장히 유사한 모습으로 동작한다. 실제로 SwingUtilities 클래스의 스레드 관련 메소드를 단일 스레드 Executor로 쉽게 구현할 수 있다. 스윙이 Executor 프레임웍보다 훨씬 전에 만들어져 SwingUtilities 내부에서 단일 스레드 Executor를 사용하지는 않는 것으로 알려져 있지만, 스윙을 최근에 새로 구현했다고 하면 아마도 단일 스레드 Executor를 사용했을 것이다.  

스윙 이벤트 스레드는 이벤트 큐에 쌓여 있는 작업을 순차적으로 처리하는 단일 스레드 Executor라고 볼 수 있다. 스레드 풀에서 봤던 것처럼 간혹 작업 스레드가 비정상적으로 종료돼 새로운 스레드로 대치되기도 하지만, 이런 일은 작업의 관점에서 아무런 변화 없이 진행돼야 한다. 순차적인 단일 스레드 실행 방법은 각 작업이 짧게 실행되며, 스케줄된 상황을 예측할 필요가 없고, 작업을 동시에 실행시킬 필요성이 없는 경우에 쓸모있는 방법이다.  

SWT에는 스윙의 invokeLater와 비슷한 Diplay.asyncExec 메소드가 있다.  

#### 9.2. 짧게 실행되는 GUI 작업
<br/>
GUI 애플리케이션에서는 이벤트 스레드에서 이벤트가 시작돼 애플리케이션에 만들어져 있는 리스너에게 전파된다. 리스너가 이벤트를 받으면 화면에 뭔가를 표시하는 객체를 사용해 동작한다. 예를 들어 짧은 시간 동안만 실행되는 작업은 작업 전체가 이벤트 스레드 내부에서 실행돼도 큰 문제는 없다. 하지만 오랜 시간 동안 실행되는 작업은 이벤트 스레드가 아닌 외부의 다른 스레드에서 실행하도록 해야 맞다.  

스위에서는 대부분의 화면 표시 객체가 두 개의 부분으로 나뉘어 있는데, 바로 모델(Model)과 뷰(view)이다. 화면에 표시돼야 할 데이터는 모델에 보관돼 있으며, 모델에 들어 있는 데이터를 화면에 어떻게 표시해야 할지는 뷰에서 결정한다. 모델에서 갖고 있는 데이터가 변경되면 데이터가 변경됐다는 이벤트를 발생시키게 되고, 뷰에서는 모델에서 발생하는 이벤트에 대한 리스너가 대기 중이다. 대기 중이던 뷰의 리스너가 모델의 데이터가 변경됐다는 이벤트를 받으면 모델에서 변경된 내역을 받아온 다음 변경된 해당 내용을 화면에 표시한다. 따라서 표 내부의 데이터를 변경하는 기능을 맡은 버튼의 리스너 가운데 동작 리스너는 먼저 모델의 데이터를 새 값으로 바꿔 놓고 fireXxx 메소드 몇 가지를 호출한다. fireXxx 메소드를 호출하면 뷰에서 대기하고 있는 리스너를 호출하는 셈이며, 결국 뷰의 화면에 새로운 값이 표시된다. 다시 말하지만 제어권은 이벤트 스레드를 떠난 적이 없다(스윙 프레임웍의 fireXxx 메소드는 해당하는 이벤트를 이벤트 큐에 쌓는 대신 리스너를 직접 호출하도록 돼 있다. 따라서 fireXxx 메소드를 이벤트 스레드 외부에서 호출하게 해서는 안 된다).  

#### 9.3. 장시간 실행되는 GUI 작업
<br/>
애플리케이션에서 실행하는 모든 작업이 금방 끝나는 작업이면서 GUI와 관련 없는 작업이 많지 않다면 애플리케이션의 모든 작업을 이벤트 스레드에서 실행해도 별 무리가 없으며 아무런 신경을 쓰지 않아도 큰 문제가 발생하지는 않는다. 하지만 GUI를 잘 구성해 둔 애플리케이션은 맞춤법 검사 기능이나 백그라운드 컴파일 작업이나 원격 서버에서 자료를 가져오는 것과 같이 사용자가 기다리는 시간이 길어질 수 있는 작업을 사용하는 경우도 많아진다. 이처럼 시간이 오래 걸리는 작업을 이벤트 스레드와 달리 독립된 스레드에서 실행하도록 하면 작업 도중에 GUI 화면이 얼어버리지 않게 할 수 있다.  

스윙에서는 원하는 작업을 이벤트 스레드 내부에서는 쉽게 실행하도록 돼 있었지만, (자바 6 이젠에는) GUI에서 작업을 실행할 때 이벤트 스레드 외부에 독립 스레드에서 다른 작업을 실행할 수 있는 방법이 없었다. 그렇다고 해서 스윙에서 이런 기능을 제공할 때까지 기다려야 할 필요는 없다. Executor를 직접 생성해 두고, 시간이 많이 걸리는 작업을 실행시키면 된다. 이처럼 GUI 애플리케이션에서 시간이 오래 걸리는 작업을 처리하는 데는 newCachedThreadPool 메소드로 생성한 Executor가 제격이다. GUI 애플리케이션에서 시간이 오래 걸릴 작업을 기계적으로 대량 생성하는 일은 거의 없기 대문에 스레드 풀의 크기가 무한정 늘어날 가능성은 거의 없기 때문이다.  

##### 9.3.1. 작업 중단
<br/>
독립적인 스레드를 사용해서 실행시켜야 할 만틈 오래 실행되는 작업은 사용자가 취소하고 싶은 생각이 들 때까지의 시간도 오래 걸리는 경우가 많다. 스레드 인터럽트 기능을 사용해 작업 중단 기능을 구현할 수도 있겠지만, 중단 가능한 작업을 만들 수 있도록 설계돼 있는 Future를 활용하면 훨씬 간편하게 구현할 수 있다.  

Future 인터페이스의 cancel 메소드를 호출할 때 mayInterruptIfRunning 값을 true로 설정했다면 Future를 구현한 클래스는 작업이 특정 스레드에서 시작됐을 경우 해당 스레드에 인터럽트를 걸게 돼 있다. 만약 등록한 작업이 인터럽트에 적절하게 대응하도록 만들어져 있다면 작업을 중단하고 얼마 지나지 않아 금방 멈출 것이다.  

##### 9.3.2. 진행 상태 및 완료 알림
<br/>
Future 인터페이스를 활용하면 장시간 실행되는 작업을 중단하는 일도 굉장히 간단하게 구현할 수 있었다. FutureTask 클래스에 포함돼 있는 done이라는 훅 메소드를 사용하면 작업이 끝났음을 알려주는 기능도 중단 기능처럼 간단하게 구현할 수도 있다. 백그라운드로 실행되던 Callable 작업이 완료되면 항상 done 메소드가 호출된다.  

##### 9.3.3. SwingWorker
<br/>
스윙에서는 작업 중단, 작업 완료 알림, 작업 진행 상태 알림과 같은 기능의 대부분을 SwingWorker를 통해 제공하고 있다.  

#### 9.4. 데이터 공유 모델
<br/>
TableModel이나 TreeModel과 같은 데이터 모델 객체를 포함해 스윙의 화면 표시 객체는 이벤트 스레드에 제한돼 있다. 일반적인 간단한 GUI 애플리케이션에서는 변경 가능한 상태 변수가 모두 화면 표시 객체에 담겨 있고 이벤트 스레드를 제외하고는 프로그램이 실행된 메인 스레드만이 동작하는 경우가 많다. 이와 같은 프로그램에서는 단일 스레드 규칙을 쉽게 적용할 수 있다. 바로 '메인 스레드에서는 데이터 모델이나 화면 표시 객체를 건드리지 말라'는 간단한 규칙으로 충분하다. 하지만 이보다 복잡한 구조로 여러 개의 스레드를 사용해 파일 시스템이나 데이터베이스와 같은 데이터 저장소에서 값을 가져오거나 저장해야 하지만, 그 동안에도 화면 응답 속도에는 영향을 주지 않아야 하는 애플리케이션도 있다.  

가장 간단한 경우를 생각해보면, 데이터 모델에 들어 있는 값을 이벤트 스레드가 아닌 다른 스레드에서 전혀 건드리지 않았다고 가정하자. 그러면 그 데이터는 사용자가 직접 입력했거나 애플리케이션이 시작될 때 파일이나 기타 다른 저장소에서 가져온 값일 수밖에 없다. 하지만 일부 화면 표시 객체의 데이터 모델에 들어 있는 값은 데이터베이스, 파일 시스템, 아니면 원격지의 서비스에서 가져온 값을 단순히 보여주기만 하는 경우도 있다. 이럴 때는 데이터가 애플리케이션으로 들어오고 나가는 과정에 두 개 이상의 스레드가 관여하기도 한다.  

예를 들어 트리 컨트롤을 사용해 원격 컴퓨터의 파일 시스템에 어떤 내용이 들어 있는지를 표시한다고 해보자. 아마도 트리 컨트롤을 표시하기 전에 원격 컴퓨터의 모든 디렉토리 구조를 전부 받아와서 트리에 한꺼번에 집어 넣으려고 하지는 않을 것이다. 만약 한꺼번에 표시하도록 한다면 감당하기 어려울 만큼 오랜 시간이 걸리고 상당량의 메모리도 필요하기 때문이다. 이런 방법 대신 트리의 각 항목을 확장하는 순간 해당 디렉토리 바로 아래의 정보만을 가져와 트리에 추가할 수 있겠다. 물론 디렉토리 하나의 파일 목록을 가져오는 것이라 해도 시간이 오래 걸릴 수 있기 때문에 디렉토리를 가져오는 작업은 백그라운드에서 실행하도록 해야 한다. 디렉토리를 가져오는 백그라운드 작업이 완료되면 가져온 데이터를 트리 모델에 적절하게 추가해 화면에 표시되도록 할 수 있다. 데이터를 트리 모델에 추가흐는 작업은 백그라운드 작업에서 얻은 결과를 이벤트 스레드에서 트리 모델에 추가하는 작업은 백그라운드 작업에서 얻은 결과를 이벤트 스레드에서 트리 모델에 추가하도록 invokeLater 메소드를 사용하도록 한다. 아니면 이벤트 스레드에서 주기적으로 추가된 데이터가 있는지를 폴링하도록 하는 방법도 있겠다.  

##### 9.4.1. 스레드 안전한 데이터 모델
<br/>
동기화된 부분에서 스레드가 대기하는 상황 때문에 GUI의 응답 속도가 형편없이 떨어지는 수준이 아니라면, 특정 데이터를 놓고 여러 스레드가 동시에 동작하는 상황은 스레드에 안전한 데이터 모델을 사용해 쉽게 해결할 수 있다. 사용하고자 하는 데이터 모델에서 동시 사용성을 높은 수준으로 지원한다면 응답 속도 문제 없이 이벤트 스레드와 작업용 백그라운드 스레드에서 데이터를 충분히 공유할 수 있다.  

일부 상황에서는 CopyWriteArrayList와 같은 버전 데이터 모델(versioned data model)을 사용해 스레드 안전성과 데이터 안전성과 높은 응답 속도를 한꺼번에 얻을 수도 있다. 예를 들어 CopyOnWriteXXX 컬렉션에서는 Iterator 반복문도 해당 Iterator가 생성되던 시점에 내용을 그래도 보존하고 반복한다. 하지만 CopyOnWriteXXX 컬렉션은 데이터를 추가하거나 제거하는 기능보다 반복문을 훨씬 많이 사용하는 경우에만 정상적인 성능을 얻을 수 있다. 이런 조건 때문에 필요한 곳마다 매번 적용하지 못하는 경우가 많은데, 아마도 차량 추적 시스템과 같은 경우에는 적절하지 않은 방법이라고 본다. 고도의 동기화 기법을 사용한 컬렉션 클래스를 활용한다면 이와 같은 제약 사항을 뛰어 넘을 수도 있겠지만, 병렬 환경에서 원할하게 동작하고 오래된 버전의 데이터를 적절한 시점에 자동으로 제거하는 등의 효율적인 기능을 갖추도록 하는 것은 그다지 쉬운 일이 아니다. 이런 부분은 다른 모든 방법을 동원해도 원하는 결과를 얻을 수 없을 때 생각해 봐도 늦지 않다.  

##### 9.4.2. 분할 데이터 모델
<br/>
GUI 입장에서 보면 TableModel이나 TreeModel과 같은 스윙 내부의 데이터 모델 클래스는 화면에 표시할 데이터를 저장하는 공식 저정소와 같은 역할을 하고 있다. 그런데 따지고 보면 TableModel이나 TreeModel 역시 애플리케이션이 관리하는 다른 데이터 저장소에 대한 '뷰'에 불과할 수도 있다. 이처럼 화면 표시 부분(presentation-domain)과 애플리케이션 부분(application-domain)의 데이터 모델을 구분해 사용하는 모양을 분할 데이터 모델이라고 한다.  

분할 데이터 모델 환경에서 화면 표시 부분의 데이터 모델은 항상 이벤트 스레드 내부의 제한돼 있고, 흔히 공유 모델(shared model)이라고 하는 애플리케이션 부분의 모델은 이벤트 스레드와 애플리케이션 스레드에서 동시에 사용할 수 있기 때문에 스레드 안전성을 고려한 구조를 갖고 있다. 화면 표시 모델은 공유 모델에 이벤트 리스너를 등록해 변경 사항이 발생했을 때 변경된 내용을 알 수 있다. 화면 표시 모델은 이벤트 공유 모델에 변경 사항이 있을 때 변경된 내용을 알 수 있다. 화면 표시 모델은 이벤트 공유 모델에 변경 사항이 있을 때 이벤트 리스너를 통해 공유 모델의 스냅샷을 받아와 화면에 반영할 수도 있겠고, 아니면 뭔가 바뀌었다는 이벤트만을 받은 이후 직접 공유 모델에 접근해 필요한 데이터를 뽑아 갈 수도 있다.  

위에서 소개했던 스냅샷 방법은 간편하긴 하지만 단점이 있다. 공유 모델이 갖고 있는 데이터의 규모가 작고 공유 모델의 변경 빈도가 높지 않아야 하며 공유 모델과 화면 표시 모델의 데이터 구조가 비슷해야 하는 등의 제약 사항이 바로 단점이라고 볼 수 있다. 만약 공유 모델이 갖고 있는 데이터의 규모가 크고 업데이트가 빈번하게 이뤄진다거나, 한쪽 또는 양쪽 모두의 모델에서 서로 사용할 수 없도록 제한된 데이터를 갖고 있다면 전체 스냅샷을 보내는 대신 변경된 부분만을 추려서 보내는 방법이 훨씬 효율적이다. 이렇게 변경된 부분만을 전송하는 증분 업데이트(incremental update) 방법은 공유 모델의 변경된 부분을 직렬화(serialize)해서 화면 표시 모델에 보내고, 화면 표시 모델의 이벤트 스레드에서 직렬화된 데이터를 풀어내는 형태로 동작하게 된다. 증분 업데이트를 하면 어떤 부분이 변경됐는지를 정확하게 알 수 있기 때문에 화면에 정보를 보여줄 때 사용자 인터페이스의 품질을 높일 수 있다. 예를 들어 차량 추적 시스템에서 차량 한 대가 이동했을 뿐인데 전체 화면을 모두 새로 그릴 필요 없이 위치가 변경된 차량과 관련된 부분만 새로 그리도록 하면 성능을 크게 향상시킬 수 있다.  

데이터 모델을 여러 개의 스레드에서 공유해야 하는 경우라면 분할 데이터 모델을 사용하는 방법을 고려해보자. 스레드 안전하게 공유할 수 있는 데이터 모델을 만들어 사용하고자 할 대 댁 상태에 들어가는 블로킹 문제, 일관성 문제, 구현하기에 복잡하다는 이유 등이 있다면 스레드 안전한 모델 대신 분할 데이터 모델을 추천한다.  

#### 9.5. 다른 형태의 단일 스레드 서브시스템
<br/>
스레드 제한 기법은 GUI에서만 사용하는 것은 아니고, 어떤 기능이건 간에 단일 스레드의 형태로 구현된 경우에는 언제든지 적용할 수 있다. 간혹 보면 동기화 작업이나 데드락 등에 신경 쓸 필요가 없다는 이유만으로 개발자가 단일 스레드를 고집하는 경우도 있다. 예를 들어 일부 네이티브 라이브러리는 System.loadLibrary 메소드로 불러온다 해도 항상 동일한 스레드에서만 사용해야 한다고 제한하기도 한다.  

네이티브 라이브러리의 기능을 활용하는 부분에 GUI 프레임웍에서 활용했던 기법을 적용해보자. 먼저 네이티브 라이브러리를 사용하려면 프록시(proxy) 객체의 메소드를 호출하고, 프록시 객체는 메소드에 해당하는 이벤트를 전용 스레드에 등록해 실행되도록 할 수 있다. 특정 기능에 대한 프록시 클래스의 메소드에서는 원하는 기능에 맞는 이벤트(작업)를 생성해 submit하고, 그 즉시 Future.get을 호출해 결과를 얻을 때까지 대기한다(만약 스레드 한정될 객체가 특정 인터페이스를 구현하도록 설계한다면, 동적인 프록시를 활용해 각 메소드에서 Callable 작업을 생성하고 백그라운드 Executor에 등록해 그 결과가 나오기를 기다리는 과정을 자동화할 수 있다).  

### 요약
<br/>
GUI 프레임웍은 거의 대부분 단일 스레드 서브시스템으로 구현돼 있으며, 화면 표시 부분과 관련된 기능이 모두 이벤트 스레드에서 작업의 형태로 실행되도록 만들어져 있다. 장시간 실행돼야 할 작업이 있는 경우 이벤트 스레드가 하나밖에 없기 때문에 전체적인 사용자 인터페이스의 응답 속도가 떨어질 수밖에 없다. 따라서 장시간 실행될 작업은 이벤트 스레드가 아닌 백그라운드 스레드에서 실행시켜야 한다.
