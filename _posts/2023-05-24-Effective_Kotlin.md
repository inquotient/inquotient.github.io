---
title:  Effective Kotlin
categories:
- Effective Kotlin
feature_text: |
  ## Effective Kotlin
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---
<style>
	thead td { text-align: center; }
	td { border: 1px solid #444444; }
</style>

### Item 1. 가변성을 제한하라
<br/>

시간의 변화에 따라서 변하는 요소를 표현할 수 있다는 것은 유용하지만, 상태를 적절하게 관리하는 것이 생각보다 꽤 어렵습니다.  

(1) 프로그램을 이해하고 디버그하기 힘들어집니다. 이러한 상태를 갖는 부분들의 관계를 이해해야 하며, 상태 변경이 많아지면 이를 추적하는 것이 힘들어집니다. 이러한 클래스는 이해하기도 어렵고, 이후에 코드를 수정하기도 힘듭니다. 클래스가 예상하지 못한 상황 또는 오류를 발생시키는 경우에 큰 문제가 됩니다.

(2) 가변성(mutability)이 있으면, 코드의 실행을 추론하기 어려워집니다. 시점에 따라서 값이 달라질 수 있으므로, 현재 어떤 값을 갖고 있는지 알아야 코드의 실행을 예측할 수 있습니다. 또한 한 시점에 확인한 값이 계속 동일하게 유지된다고 확신할 수 없습니다.  

(3) 멀티스레드 프로그램일 때는 적절한 동기화가 필요합니다. 변경이 일어나는 모든 부분에서 충돌이 발생할 수 있습니다.  

(4) 테스트하기 어렵습니다. 모든 상태를 테스트해야 하므로, 변경이 많으면 많을 수록 더 많은 조합을 테스트해야 합니다.  

(5) 상태 변경이 일어날 때, 이러한 변경을 다른 부분에 알려야 하는 경우가 있습니다. 예를 들어 정렬되어 있는 리스트에 가변 요소를 추가한다면, 요소에 변경이 일어날 때마다 리스트 전체를 다시 정렬해야 합니다.  

(6) 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽습니다.  

(7) immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있습니다.  

(8) immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있습니다.  

(9) immutable 객체는 방어적 복사본(defensive copy)을 만들 필요가 없습니다. 또한 객체를 복사할 때 깊은 복사를 따로 하지 않아도 됩니다.  

(10) immutable 객체는 다른 객체(mutable 또는 immutable 객체)를 만들 때 활용하기 좋습니다. 또한 immutable 객체는 실행을 더 쉽게 예측할 수 있습니다.  

(11) immutable 객체는 '세트(set)' 또는 '맵(map)의 키'로 사용할 수 있습니다. 참고로 mutable 객체는 이러한 것으로 사용할 수 없습니다. 이는 세트와 맵이 내부적으로 해시 테이블을 사용하고, 해시 테이블은 처음 요소를 넣을 때 요소의 값을 기반으로 버킷을 결정하기 때문입니다. 따라서 요소에 수정이 일어나면 해시 테이블 내부에서 요소를 찾을 수 없게 되어 버립니다.  

#### Item 1.1. 코틀린에서 가변성 제한하기  
<br/>

코틀린은 가변성을 제한할 수 있게 설계되어 있습니다.  

immutable 객체는 자신이 일부를 수정한 새로운 객체를 만들어 내는 메서드를 가져야 합니다. 예를 들어 Int는 immutable입니다. 그래도 Int는 내부적으로 plus와 minus 메서드로 자신을 수정한 새로운 Int를 리턴할 수 있습니다. Iterable도 읽기 전용입니다. 그래도 map과 filter 메서드로 자신을 수정한 새로운 Iterable 객체를 만들어 리턴합니다.  

다만 모든 프로퍼티를 대상으로 이런 함수를 하나하나 만드는 것은 굉장히 귀찮은 일입니다. 그럴 때는 data 한정자를 사용하면 됩니다. data 한정자는 copy라는 이름의 메서드를 만들어 줍니다. copy 메서드를 활용하면, 모든 기본 생성자 프로퍼티가 같은 새로운 객체를 만들어 낼 수 있습니다.  

+ 읽기 전용 프로퍼티(val)  
값은 변경될 수 있기는 하지만, 프로퍼티 레퍼런스 자체를 변경할 수는 없으므로 동기화 문제 등을 줄일 수 있습니다. 또한 이는 게터 또는 델리게이트(delegate)로 정의할 수 있습니다. 만약 완전히 변경할 필요가 없다면, final 프로퍼티를 사용하는 것이 좋습니다. 또한 스마트 캐스트(smart-cast) 등의 추가적인 기능을 활용할 수 있습니다.  

+ 가변 컬렉션과 읽기 전용 컬렉션 구분하기  
+ 데이터 클래스의 copy  

#### Item 1.2. 정리  

+ var보다는 val을 사용하는 것이 좋습니다.
+ mutable 프로퍼티보다는 immutable 프로퍼티를 사용하는 것이 좋습니다.
+ mutable 객체와 클래스보다는 immutable 객체와 클래스를 사용하는 것이 좋습니다.
+ 변경이 필요한 대상을 만들어야 한다면, immutable 데이터 클래스로 만들고 copy를 활용하는 것이 좋습니다.
+ 컬렉션에 상태를 저장해야 한다면, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용하는 것이 좋습니다.
+ 변이 지점을 적절하게 설계하고, 불필요한 변이 지점은 만들지 않는 것이 좋습니다.
+ mutable 객체를 외부에 노출하지 않는 것이 좋습니다.

### Item 2. 변수의 스코프를 최소화하라  
<br/>

상태를 정의할 때는 변수와 프로퍼티의 스코프를 최소화하는 것이 좋습니다.  

+ 프로퍼티보다는 지역 변수를 사용하는 것이 좋습니다.
+ 최대한 좁은 스코프를 갖게 변수를 사용합니다.  

스코프를 좁게 만드는 것이 좋은 이유는 굉장히 많지만, 가장 중요한 이유는 프로그램을 추적하고 관리하기 쉽기 때문입니다.  

여러 프로퍼티를 한꺼번에 설정해야 하는 경우에는 구조분해 선언(destructuring declaration)을 활용하는 것이 좋습니다.  

#### Item 2.1. 정리  
<br/>

여러 가지 이유로 변수의 스코프는 좁게 만들어서 활용하는 것이 좋습니다. 또한 var보다는 val을 사용하는 것이 좋습니다. 람다에서 변수를 캡처합니다.  

### Item 3. 최대한 플랫폼 타입을 사용하지 말라  
<br/>

+ 플랫폼 타입  
자바 등의 다른 프로그래밍 언어에서 넘어온 타입들  

플랫폼 타입은 타입 이름 뒤에 ! 기호를 붙여서 표기합니다. 물론 이러한 노테이션이 직접적으로 코드에 나타나지는 않습니다.  

문제는 null이 아니라고 생각되는 것이 null일 가능성이 있으므로, 여전히 위험하다는 것입니다. 그래서 플랫폼 타입을 사용할 대는 항상 주의를 기울여야 합니다. 설계자가 명시적으로 어노테이션으로 표시하거나, 주석으로 달아두지 않으면, 언제든지 동작이 변경될 가능성이 있습니다. 따라서 함수가 지금 당장 null을 리턴하지 않아도, 미래에는 변경될 수도 있다는 것을 염두해 둬야 합니다.  

자바를 코틀린과 함께 사용할 때, 자바 코드를 직접 조작할 수 있다면, 가능한 &#64;Nullable과 &#64;NotNull 어노테이션을 붙여서 사용하기 바랍니다.  

현재 다음과 같은 여러 어노테이션이 지원되고 있습니다.  

+ JetBrains(org.jetbrains.annotations의 &#64;Nullable, &#64;NotNull)
+ Android(android.annotation, com.android.annotations, android.support.annotations의 &#64;Nullable, &#64;NonNull)
+ JSR-305(javax.annotation의 &#64;Nullable, &#64;CheckForNull, &#64;Nonnull)
+ JavaX(javax.annotation의 &#64;Nullable, &#64;CheckForNull, &#64;Nonnull)
+ FindBugs(edu.umd.cs.findbugs.annotation의 &#64;Nullable, &#64;CheckForNull, &#64;PossiblyNull, &#64;NonNull)
+ ReactiveX(io.reactivex.annotations의 &#64;Nullable, &#64;NonNull)
+ Eclipse(org.eclipse.jdt.annotation의 &#64;Nullable, &#64;NonNull)
+ Lombok(lombok의 &#64;NonNull)  

대체적으로 JSR 305의 &#64;ParametersAreNonnullByDefault 어노테이션 등을 활용하면, 자바에서도 디폴트로 파라미터가 널이 아니라는 것을 보장할 수 있습니다.  

### Item 4. inferred 타입으로 리턴하지 말라  
<br/>

코틀린의 타입 추론(type inference)은 JVM 세계에서 가장 널리 알려진 코틀린의 특징입니다. 자바도 자바10부터는 코틑린을 따라 타입 추론을 도입했습니다(물론 코틑린과 비교하면 몇 가지 제약이 있습니다).  

다만 타입 추론을 사용할 때는 몇 가지 위험한 부분들이 있습니다. 이러한 위험한 부분을 피하려면, 우선 할당 때 inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설정된다는 것을 기억해야 합니다. 절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않습니다.  

일반적인 경우에는 이러한 것이 문제가 되지 않습니다. 그냥 원하는 타입보다 제한된 타입이 설정되었다면, 타입을 명시적으로 지정해서 이러한 문제를 해결할 수 있습니다.  

하지만 직접 라이브러리(또는 모듈)를 조작할 수 없는 경우에는 이러한 문제를 간단하게 해결할 수 없습니다. 그리고 이러한 경우에서 inferred 타입을 노출하면, 위험한 일이 발생할 수 있습니다.  

리턴 타입은 API를 잘 모르는 사람에게 전달해 줄 수 있는 중요한 정보입니다. 따라서 리턴 타입은 외부에서 확인할 수 있게 명시적으로 지정해 주는 것이 좋습니다.  

#### Item 4.1. 정리  
<br/>

타입을 확실하게 지정해야 하는 경우에는 명시적으로 타입을 지정해야 한다는 원칙만 갖고 있으면 됩니다. 이는 굉장히 중요한 정보이므로, 숨기지 않는 것이 좋습니다. 또한 안전을 위해서 외부 API를 만들 때는 반드시 타입을 지정하고, 이렇게 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말기 바랍니다. inferred 타입은 프로젝트가 진전될 때, 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수 있다는 것을 기억하세요.  


### Item 5. 예외를 활용해 코드에 제한을 걸어라  
<br/>

확실하게 어떤 형태로 동작해야 하는 코드가 있다면, 예외를 활용해 제한을 걸어주는 것이 좋습니다. 코틀린에서는 코드의 동작에 제한을 걸 때 다음과 같은 방법을 사용할 수 있습니다.  

+ require 블록: 아규먼트를 제한할 수 있습니다.
+ check 블록: 상태와 관련된 동작을 제한할 수 있습니다.
+ assert 블록: 어떤 것이 true인지 확인할 수 있습니다. assert 블록은 테스트 모드에서만 작동합니다.
+ return 또는 throw와 함께 활용하는 Elvis 연산자  

이렇게 제한을 걸어 주면 다양한 장점이 발생합니다.  

+ 제한을 걸면 문서를 읽지 않은 개발자도 문제를 확인할 수 있습니다.
+ 문제가 있을 경우에 함수가 예상하지 못한 동작을 하지 않고 예외를 throw합니다. 예상하지 못한 동작을 하는 것은 예외를 throw하는 것보다 굉장히 위험하며, 상태를 관리하는 것이 굉장히 힘듭니다. 이러한 제한으로 인해서 문제를 놓치지 않을 수 있고, 코드가 더 안정적으로 작동하게 됩니다.
+ 코드가 어느 정도 자체적으로 검사됩니다. 따라서 이와 관련된 단위 테스트를 줄일 수 있습니다.
+ 스마트 캐스트 기능을 활용할 수 있게 되므로, 캐스트(타입 변환)를 적게 할 수 있습니다.  

#### Item 5.1. 아규먼트  
<br/>

함수를 정의할 때 타입 시스템을 활용해서 아규먼트(argument)에 제한을 거는 코드를 많이 사용합니다.  

일반적으로 이러한 제한을 걸 때는 require 함수를 사용합니다. require 함수는 제한을 확인하고, 제한을 만족하지 못할 경우 예외를 throw합니다.  

```kolin
fun factorial(n: Int): Long {
    require(n >= 0)
    return if (n <= 1) 1 else factorial(n - 1) * n
}

fun findClusters(points: List<Point>): List<Cluster> {
    require(points.isNotEmpty())
    //...
}

fun sendEmail(user: User, message: String) {
    requireNotNull(user,email)
    require(isValidEmail(user.email))
    //...
}
```

이와 같은 형태의 입력 유효성 검사 코드는 함수의 가장 앞부분에 배치되므로, 읽는 사람도 쉽게 확인할 수 있습니다(물론 코드를 사용하는 모든 사람이 실제 코드 본문을 읽는 것은 아니므로, 문서에 관련된 내용은 반드시 명시해 두어야 합니다).  

require 함수는 조건을 만족하지 못할 때 무조건적으로 IllegalArgumentException을 발생시키므로 제한을 무시할 수 없습니다. 일반적으로 이러한 처리는 함수의 가장 앞부분에 하게 되므로, 코드를 읽을 때 쉽게 확인할 수 있습니다. 참고로 코드를 읽지 않는 사람이 있을 수도 있으므로 반드시 문서에 이러한 제한이 있다고 별도로 표시해 놓아야 합니다.  

#### Item 5.2. 상태  
<br/>

어떤 구체적인 조건을 만족할 때만 함수를 사용할 수 있게 해야 할 때가 있습니다.  

+ 어떤 객체가 미리 초기화되어 있어야만 처리를 하게 하고 싶은 함수
+ 사용자가 로그인했을 때만 처리를 하게 하고 싶은 함수
+ 객체를 사용할 수 있는 시점에 사용하고 싶은 함수  

상태와 관련된 제한을 걸 때는 일반적으로 check 함수를 사용합니다.  

```kotlin
fun speak(text: String) {
    check(isInitialized)
    //...
}

fun getUserInfo(): UserInfo {
    checkNotNull(token)
    //...
}

fun next(): T {
    check(isOpen)
    //...
}
```

check 함수는 require와 비슷하지만, 지정된 예측을 만족하지 못할 때, IllegalStateException을 throw합니다. 상태가 올바른지 확인할 때 사용합니다. 예외 메시지는 require와 마찬가지로 지연 메시지를 사용해서 변경할 수 있습니다. 함수 전체에 대한 어떤 예측이 있을 때는 일반적으로 require 블록 뒤에 배치합니다. check를 나중에 하는 것입니다.  

이러한 확인은 사용자가 규약을 어기고, 사용하면 안 되는 곳에서 함수를 호출하고 있다고 의심될 때 합니다. 사용자가 코드를 제대로 사용할 거라고 믿고 있는 것보다는 항상 문제 상황을 예측하고, 문제 상황에 예외를 throw하는 것이 좋습니다. 이러한 확인은 사용자뿐만 아니라 이를 구현하는 사람에게도 좋습니다. 참고로 스스로 구현한 내용을 확인할 때는 일반적으로 assert라는 도 다른 함수를 사용합니다.  

#### Item 5.3. Assert 계열 함수 사용  
<br/>

함수가 올바르게 구현되었다면, 확실하게 참을 낼 수 있는 코드들이 있습니다. 그런데 함수가 올바르게 구현되어 있지 않을 수도 있습니다. 처음부터 구현을 잘못했을 수도 있고, 해당 코드를 이후에 다른 누군가가 변경(또는 리팩터링)해서 제대로 작동하지 않게 된 것일 수도 있습니다. 이러한 구현 문제로 발생할 수 있는 추가적인 문제를 예방하려면, 단위 테스트를 사용하는 것이 좋습니다.  

단위 테스트는 구현의 정확성을 확인하는 가장 기본적인 방법입니다.  

이러한 조건은 현재 코틀린/JVM에서만 활성화되며, -ea JVM 옵션을 활성화해야 확인할 수 있습니다. 이러한 코드도 코드가 예상대로 동작하는지 확인하므로 테스트라고 할 수 있습니다. 다만 프로덕션 환경에서는 오류가 발생하지 않습니다. 테스트를 할 때만 활성화되므로, 오류가 발생해도 사용자가 알아차릴 수는 없습니다. 만약 이 코드가 정말 심각한 오류고, 심각한 결과를 초래할 수 있는 경우에는 check를 사용하는 것이 좋습니다. 단위 테스트 대신 함수에서 assert를 사용하면, 다음과 같은 장점이 있습니다.  

+ Assert 계열의 함수는 코드를 자체 점검하며, 더 효율적으로 테스트할 수 있게 해 줍니다.
+ 특정 상황이 아닌 모든 상황에 대한 테스트를 할 수 있습니다.
+ 실행 시점에 정확하게 어떻게 되는지 확인할 수 있습니다.
+ 실제 코드가 더 빠른 시점에 실패하게 만듭니다. 따라서 예상하지 못한 동작일 언제 어디서 실행되었는지 쉽게 찾을 수 있습니다.  

참고로 이를 활용해도 여전히 단위 테스는 따로 작성해야 합니다. 표준 애플리케이션 실해에서는 assert가 예외를 throw하지 않는다는 것도 기억하세요.  

사실 이런 assert는 파이썬에서 굉장히 많이 사용되고, 자바에서는 딱히 사용되지 않습니다. 코틀린에서는 코드를 안정적으로 만들고 싶을 때 양념처럼 사용할 수 있다는 것을 기억하세요.  

#### Item 5.4. nullability와 스마트 캐스팅  
<br/>

코틀린에서 require와 check 블록으로 어떤 조건을 확인해서 true가 나왔다면, 해당 조건은 이후로도 true일 거라고 가정합니다.  

따라서 이를 활용해서 타입 비교를 했다면, 스마트 캐스트가 작동합니다. 다음 예에서는 어떤 사람(person)의 복장(person.outfit)이 드레스(Dress)여야 코드가 정상적으로 진행됩니다. 따라서 만약 이러한 outfit 프로퍼티가 final이라면, outfit 프로퍼티가 Dress로 스마트 캐스트됩니다.  

```kotlin
fun changeDress(person: Person) {
    require(person.outfit is Dress)
    val dress: Dress = person.outfit
}
```

이러한 특징은 어떤 대상이 null인지 확인할 때 굉장히 유용합니다.  

```kotlin
class Person(val email: String?)

fun sendEmail(person: Person, message: String) {
    require(person.email != null)
    val email: String = person.email
}
```

이러한 경우 requireNotNull, checkNotNull이라는 특수한 함수를 사용해도 괜찮습니다. 둘 다 스마트 캐스트를 지원하므로, 변수를 '언팩(unpack)'하는 용도로 활용할 수 있습니다.  

```kotlin
class Person(val email: String?)
fun validateEmail(email: String) { /*...*/ }

fun sendEmail(person: Person, text: String) {
    val email = requireNotNull(person.email)
    validateEmail(email)
    //...
}

fun sendEmail(person: Person, text: String) {
    requireNotNull(person.email)
    validateEmail(person.email)
    //...
}
```

nullability를 목적으로, 오른쪽에 throw 또는 return을 두고 Elvis 연산자를 활용하는 경우가 많습니다. 이러한 코드는 굉장히 읽기 쉽고, 유연하게 사용할 수 있습니다. 첫 번째로 오른쪽에 return을 넣으면, 오류를 발생시키지 않고 단순하게 함수를 중지할 수도 있습니다.  

```kotlin
fun sendEmail(person: Person, text: String) {
    val email: String = person.email ?: return
    //...
}
```

프로퍼티에 문제가 있어서 null일 때 여러 처리를 해야 할 때도, return/throw와 run 함수를 조합해서 활용하면 됩니다. 이는 함수가 중지된 이유를 로그에 출력해야 할 때 사용할 수 있습니다.  

```kotlin
fun sendEmail(person: Person, text: String) {
    val email: String = person.email ?: run {
        log("Email not sent, no email address")
        return
    }
}
```

이처럼 return과 throw를 활용한 Elvis 연산자는 nullable을 확인할 때 굉장히 많이 사용되는 관용적은 방법입니다. 따라서 적극적으로 활용하는 것이 좋습니다. 또한 이러한 코드는 함수의 앞부분에 넣어서 잘 보이게 만드는 것이 좋습니다.  

#### Item 5.5. 정리  
<br/>

다음과 같은 이득을 얻을 수 있습니다.  

+ 제한을 훨씬 더 쉽게 확인할 수 있다.
+ 애플리케이션을 더 안정적으로 지킬 수 있다.
+ 코드를 잘못 쓰는 상황을 막을 수 있다.
+ 스마트 캐스팅을 활용할 수 있다.  

이를 위해 활용했던 메커니즘을 정리하면 다음과 같습니다.  

+ require 블록: 아규먼트와 관련된 예측을 정의할 때 사용하는 범용적인 방법
+ check 블록: 상태와 관련된 예측을 정의할 때 사용하는 범용적인 방법
+ assert 블록: 테스트 모드에서 테스트를 할 때 사용하는 범용적인 방법
+ return과 throw와 함께 Elvis 연산자 사용하기  

이외에도 다른 오류들을 발생시킬 때 throw를 활용할 수도 있습니다.  

### Item 6. 사용자 정의 오류보다는 표준 오류를 사용하라  
<br/>

require, check, assert 함수를 사용하면, 대부분의 코틀린 오류를 처리할 수 있습니다. 하지만, 이외에도 예측하지 못한 상황을 나타내야 하는 경우가 있습니다. 예를 들어 JSON 형식을 파싱하는 라이브러리를 구현한다고 해 봅시다. 기본적으로 입력된 JSON 파일의 형식에 문제가 있다면, JSONParsingException 등을 발생시키는 것이 좋을 것입니다.  

```kotlin
inline fun <reified T> String.readObject(): T {
    //...
    if (incorrectSign) {
        throw JsonParsingException()
    }
    //...
    return result
}
```

표준 라이브러리에는 이를 나타내는 적절한 오류가 없으므로, 사용자 정의 오류를 사용했습니다. 하지만 가능하다면, 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋습니다. 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로, 이를 재사용하는 것이 좋습니다. 잘 만들어진 규약을 가진 널리 알려진 요소를 재사용하면, 다른 사람들이 API를 더 쉽게 배우고 이해할 수 있습니다. 일반적으로 사용되는 예외를 몇 가지 정리해보면 다음과 같습니다.  

+ IllegalArgumentException과 IllegalStateException: require와 check를 사용해 throw할 수 있는 예외입니다.
+ IndexOutOfBoundsException: 인덱스 파라미터의 값이 범위를 벗어났다는 것을 나타냅니다. 일반적으로 컬렉션 또는 배열과 함께 사용합니다. 예를 들어 ArrayList.get(Int)를 사용할 때 throw됩니다.
+ ConcurrentModificationException: 동시 수정(concurrent modification)을 금지했는데, 발생해 버렸다는 것을 나타냅니다.
+ UnsupportedOperationException: 사용자가 사용하려고 했던 메서드가 현재 객체에서는 사용할 수 없다는 것을 나타냅니다. 기본적으로는 사용할 수 없는 메서드는 클래스에 없는 것이 좋습니다.
+ NoSuchElementException: 사용자가 사용하려고 했던 요소가 존재하지 않음을 나타냅니다. 예를 들어 내부에 요소가 없는 Iterable에 대해 next를 호출할 때 발생합니다.  

### Item 7. 결과 부족이 발생할 경우 null과 Failure를 사용하라  
<br/>

함수가 원하는 결과를 만들어 낼 수 없을 때가 있습니다. 몇 가지 예를 들어보면, 다음과 같습니다.  

+ 서버로부터 데이터를 읽어 들어려고 했는데, 인터넷 연결 문제로 읽어 들이지 못한 경우
+ 조건에 맞는 첫 번째 요소를 찾으려 했는데, 조건에 맞는 요소가 없는 경우
+ 텍스트를 파싱해서 객체를 만들려고 했는데, 텍스트의 형식이 맞지 않는 경우  

이러한 상황을 처리하는 메커니즘은 다음과 같이 두 가지가 있습니다.  

+ null 또는 '실패를 나타내는 sealed 클래스(일반적으로 Failure라는 이름을 붙입니다)'를 리턴한다.
+ 예외를 throw한다.  

이러한 두 가지는 중요한 차이점이 있습니다. 일단 예외는 정보를 전달하는 방법으로 사용해서는 안 됩니다. 예외는 잘못된 특별한 상황을 나타내야 하며, 처리되어야 합니다. 예외는 예외적인 상황이 발생했을 때 사용하는 것이 좋습니다. 이러한 이유를 정리하면 다음과 같습니다.  

+ 많은 개발자가 예외가 전파되는 과장을 제대로 추적하지 못합니다.  
+ 코틀린의 모든 예외는 unchecked 예외입니다. 따라서 사용자가 예외를 처리하지 않을 수도 있으며, 이와 관련된 내용은 문서에도 제대로 드러나지 않습니다. 실제로 API를 사용할 때 예외와 관련된 사항을 단순하게 메서드 등을 사용하면서 파악하기 힘듭니다.
+ 예외를 예외적인 상황을 처리하기 위해서 만들어졌으므로 명시적인 테스트(explicit test)만큼 빠르게 동작하지 않습니다.
+ try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한됩니다.  

반면, 첫 번째로 설명했던 null과 Failure는 예상되는 오류를 표현할 때 굉장히 좋습니다. 이는 명시적이고, 효율적이며, 간단한 방법으로 처리할 수 있습니다. 따라서 충분히 예측할 수 있는 범위의 오류는 null과 Failure를 사용하고, 예측하기 어려운 예외적인 범위의 오류는 예외를 throw해서 처리하는 것이 좋습니다. 간단한 예를 살펴봅시다.  

```kotlin
inline fun <reified T> String.readObjectOrNull(): T? {
    //...
    if(incorrectSign) {
        return null
    }
    //...
    return result
}

inline fun <reified T> String.readObject(): Result<T> {
    //...
    if(incorrectSign) {
        return Failure(JsonParsingException)
    }
    //...
    return Success(result)
}

sealed class Result<out T>
class Success<out T>(val result: T): Result<T>()
class Failure(val throwable: Throwable): Result<Nothing>()

class JsonParsingException: Exception()
```

이렇게 표시되는 오류는 다루기 쉬우며 놓치기 어렵습니다. null을 처리해야 한다면, 사용자는 안전 호출(safe call) 또는 Elvis 연산자 같은 다양한 널 안정성(null-safety) 기능을 활용합니다.  

Result와 같은 공용체(union type)를 리턴하기로 했다면, when 표현식을 사용해서 이를 처리할 수 있습니다.  

이러한 요류 처리 방식은 try-catch 블록보다 효율적이며, 사용하기 쉽고 더 명확합니다. 예외는 놓칠 수도 있으며, 전체 애플리케이션을 중지시킬 수도 있습니다. null 값과 sealed result 클래스는 명시적으로 처리해야 하며, 애플리케이션의 흐름을 중지하지도 않습니다. null 값과 sealed result 클래스는 명시적으로 처리해야 하며, 애플리케이션의 흐름을 중지하지도 않습니다.  

null 값과 sealed result 클래스의 차이점이 궁금할 수도 있는데요. 추가적인 정보를 전달해야 한다면 sealed result를 사용하고, 그렇지 않으면 null을 사용하는 것이 일반적입니다. Failure는 처리할 때 필요한 정보를 가질 수 있다는 것을 기억하세요.  

일반적으로 두 가지 형태의 함수를 사용합니다. 하나는 예상할 수 있을 때, 다른 하나는 예상할 수 없을 때 사용합니다. List는 두 가지를 모두 갖고 있으므로 이를 기반으로 살펴봅시다.  

+ get: 특정 위치에 있는 요소를 추출할 때 사용합니다. 만약 요소가 해당 위치에 없다면 IndexOutOfBoundsException을 발생시킵니다.
+ getOrNull: out of range 오류가 발생할 수 있는 경우에 사용하며, 발생한 경우에는 null을 리턴할 수 있습니다.  

이외에도 일부 상황에 유용한 getOrDefault와 같은 다른 선택지도 있습니다. 하지만 일반적으로 getOrNull 또는 Elvis 연산자(?:)를 사용하는 것이 쉽습니다.  

개발자는 항상 자신이 요소를 안전하게 추출할 거라 생각합니다. 따라서 nullable을 리턴하면 안 됩니다. 개발자에게 null이 발생할 수 있다는 경고를 주려면, getOrNull 등을 사용해서 무엇이 리턴되는지 예측할 수 있게 하는 것이 좋습니다.  

### Item 8. 적절하게 null을 처리하라  
<br/>

null '값이 부족하다(lack of value)'는 것을 나타냅니다. 프로퍼티가 null이라는 것을 값이 설정되지 않았거나, 제거되었다는 것을 나타냅니다. 함수가 null을 리턴한다는 것은 함수에 따라서 여러 의미를 가질 수 있습니다. 예를 들어,  

+ String.toIntOrNull()은 String을 Int로 적절하게 변환할 수 없을 경우 null을 리턴합니다.  
+ Iterable<T>.firstOrNull(() -> Boolean)은 주어진 조건에 맞는 요소가 없을 경우 null을 리턴합니다.  

이처럼 null은 최대한 명확한 의미를 갖는 것이 좋습니다. 이는 nullable 값을 처리해야 하기 때문에, 이를 처리하는 사람은 API 사용자(API 요소를 사용하는 개발자)입니다.  

기본적으로 nullable 타입은 세 가지 방법으로 처리합니다.  

+ ?., 스마트 캐스팅, Elvis 연산자 등을 활용해서 안전하게 처리한다.
+ 오류를 throw한다.
+ 함수 또는 프로퍼티를 리팩터링해서 nullable 타입이 나오지 않게 바꾼다.  

#### Item 8.1. null을 안전하게 처리하기  
<br/>

+ 방어적 프로그래밍(defensive programming)  
모든 가능성을 올바른 방식으로 처리하는 것으로 코드가 프로덕션 환경으로 들어갔을 때 발생할 수 있는 수많은 것들로부터 프로그램을 방어해서 안정성을 높이는 방법을 나타내는 굉장히 포괄적인 용어  

+ 공격적 프로그래밍(offensive programming)  
예상하지 못한 상황이 발생했을 때, 이러한 문제를 개발자에게 알려서 수정하게 만드는 것  

#### Item 8.2. not-null assertion(!!)과 관련된 문제  
<br/>

nullable을 처리하는 가장 간단한 방법은 not-null assertion(!!)을 사용하는 것입니다. 그런데 !!를 사용하면 자바에서 nullable을 처리할 때 발생할 수 있는 문제가 똑같이 발생합니다. 어떤 대상이 null이 아니라고 생각하고 다루면 NPE 예외가 발생합니다. !!은 사용하기 쉽지만, 좋은 해결 방법은 아닙니다. 예외가 발생할 때, 어떤 설명도 없는 제네릭 예외(generic exception)가 발생합니다. 또한 코드가 짧고 너무 사용하기 쉽다 보니 남용하게 되는 문제도 있습니다. !!은 타입은 nullable이지만, null이 나오지 않는다는 것이 거의 확실한 상황에서 많이 사용됩니다. 하지만 현재 확실하다고, 미래에 확실한 것은 아닙니다. 문제는 미래의 어느 순간에 일어납니다.  

nullability(널일 수 있는지)와 관련된 정보는 숨겨져 있으므로, 굉장히 쉽게 놓칠 수 있습니다. 변수와 비슷합니다. 변수를 일단 선언하고, 이후에 사용하기 전에 값을 할당해서 사용하기로 하고, 다음과 같은 코드를 작성했다고 해 봅시다. 이처럼 변수를 null로 설정하고, 이후에 !! 연산자를 사용하는 방법은 좋은 방법이 아닙니다.  

```kotlin
class UserControllerTest {

    private var doc: UserDao? = null
    private var controller: UserController? = null

    @BeforeEach
    fun init() {
        dao = mockk()
        controller = UserController(dao!!)
    }

    @Test
    fun test() {
        controller!!.doSomething()
    }
}
```

이렇게 코드를 작성하면, 이후에 프로퍼티를 계속해서 언팩(unpack)해야 하므로 사용하기 귀찮습니다. 또한 해당 프로퍼티가 실제로 이후에 의미 있는 null값을 가질 가능성 자체를 차단해 버립니다. 이후에 살펴보겠지만, 이러한 코드를 작성하는 올바른 방법은 lateinit 또는 Delegates.notNull을 사용하는 것입니다.  

미래에 코드가 어떻게 변화할지는 아무도 알 수 없습니다. !! 연산자를 사용하거나 명시적으로 예외를 발생시키는 형태로 설계하면, 미래의 어느 시점에서 해당 코드가 오류를 발생시킬 수 있다는 것을 염두에 둬야 합니다. 예외는 예상하지 못한 잘못된 부분을 알려 주기 위해서 발생하는 것입니다. 하지만 명시적 오류는 제네릭 NPE보다는 훨씬 더 많은 정보를 제공해 줄 수 있으므로 !! 연산자를 사용하는 것보다는 훨씬 좋습니다.  

!! 연산자는 의미 있는 경우는 굉장히 드뭅니다. 일반적으로 nullability가 제대로 표현되지 않는 라이브러리를 사용할 때 정도에만 사용해야 합니다. 코틀린을 대상으로 설계된 API를 활용한다면, !! 연산자를 사용하는 것을 이상하게 생각해야 합니다.  

일반적으로 !! 연산자 사용을 피해야 합니다. 이러한 제한은 코틀린 커뮤니티 전체에서 널리 승인되고 있는 제안입니다. 대부분의 팀이 !! 연산자를 아예 사용하지 못하게 하는 정책을 갖고 있습니다. 오류까지 발생시키는 것은 조금 극단적이라고 생각하기는 하지만, 문제가 발생할 수 있는 코드를 짚어 줄 수 있다는 것에는 동의합니다. !! 연산자를 보면 반드시 조심하고, 무언가가 잘못되어 있을 가능성을 생각합시다.  

#### Item 8.3. 의미 없는 nullability 피하기  
<br/>

nullability는 어떻게든 적절하게 처리해야 하므로, 추가 비용이 발생합니다. 따라서 필요한 경우가 아니라면, nullability 자체를 피하는 것이 좋습니다. null은 중요한 메시지를 전달하는 데 사용될 수 있습니다. 따라서 다른 개발자가 보기에 의미가 없을 때는 null을 사용하지 않는 것이 좋습니다. 만약 이유 없이 null을 사용했다면, 다른 개발자들이 코드를 작성할 때, 위험한 !! 연산자를 사용하게 되고, 의미 없이 코드를 더럽히는 예외 처리를 해야 할 것입니다. nullability를 피할 때 사용할 수 있는 몇 가지 방법을 소개하겠습니다.  

+ 클래스에서 nullability에 따라 여러 함수를 만들어서 제공할 수도 있습니다. 대표적인 예로 List<T>의 get과 getOrNull 함수가 있습니다.
+ 어떤 값이 클래스 생성 이후에 확실하게 설정된다는 보장이 있다면, lateinit 프로퍼티와 notNull 델리게이트를 사용하세요.
+ 빈 컬렉션 대신 null을 리턴하지 마세요. List<Int>?와 Set<String?>과 같은 컬렉션을 빈 컬렉션으로 둘 때와 null로 둘 때는 의미가 완전히 다릅니다. null은 컬렉션 자체가 없다는 것을 나타냅니다. 요소가 부족하다는 것을 나타내려면, 빈 컬렉션을 사용하세요.  
+ nullable enum과 None enum 값은 완전히 다른 의미입니다. null enum은 별도로 처리해야 하지만, None enum 정의에 없으므로 필요한 경우에 사용하는 쪽에서 추가해서 활용할 수 있다는 의미입니다.  

#### Item 8.4. lateinit 프로퍼티와 notNull 델리게이트  
<br/>

클래스가 클래스 생성 중에 초기화할 수 없는 프로퍼티를 가지는 것은 드문 일은 아니지만 분명 존재하는 일입니다. 이러한 프로퍼티는 사용 전에 반드시 초기화해서 사용해야 합니다. 예로 JUnit &#64;BeforeEach처럼 다른 함수들보다도 먼저 호출되는 함수에서 프로퍼티가 설정되는 경우가 있습니다.  

프로퍼티를 사용할 때마다 nullable에서 null이 아닌 것으로 타입 변환하는 것은 바람직하지 않습니다. 이러한 값은 테스트 전에 설정될 거라는 명확하므로, 의미 없는 코드가 사용된다고 할 수 있습니다. 이러한 코드에 대한 바람직한 해결책은 나중에 속성을 초기화할 수 있는, lateinit 한정자를 사용하는 것입니다. lateinit 한정자는 프로퍼티가 이후에 설정될 것임을 명시하는 한정자입니다.  

물론 lateinit를 사용할 경우에도 비용이 발생합니다. 만약 초기화 전에 값을 사용하려고 하면 예외가 발생합니다. 무섭게 들릴 수도 있겠지만, 무서워할 필요가 없습니다. 처음 사용하기 전에 반드시 초기화가 되어 있을 경우에만 lateinit를 붙이는 것입니다. 만약 그런 값이 사용되어 예외가 발생한다면, 그 사실을 알아야 하므로 예외가 발생하는 것은 오히려 좋은 일입니다. lateinit는 nullable과 비교해서 다음과 같은 차이가 있습니다.  

+ !! 연산자로 언팩(unpack)하지 않아도 됩니다.
+ 이후에 어떤 의미로 나타내기 위해서 null을 사용하고 싶을 때, nullable로 만들 수도 있습니다.
+ 프로퍼티가 초기화된 이후에는 초기화되지 않은 상태로 돌아갈 수 없습니다.  

lateinit은 프로퍼티를 처음 사용하기 전에 반드시 초기화될 거라고 예상되는 상황에 활용합니다. 이러한 상황으로는 라이프 사이클(lifecycle)을 갖는 클래스처럼 메서드 호출에 명확한 순서가 있을 경우가 있습니다. 안드로이드 Activity의 onCreate, iOS UIViewController의 viewDidAppear, 리액트 React.Component의 componentdidMount 등이 대표적인 예입니다.  

반대로 lateinit를 사용할 수 없는 경우도 있습니다. JVM에서 Int, Long, Double, Boolean과 같은 기본 타입과 연결된 타입으로 프로퍼티를 초기화해야 하는 경우입니다. 이런 경우에는 lateinit보다는 약간 느리지만, Delegates.notNull을 사용합니다.  

프로퍼티 위임을 사용하면, nullability로 발생하는 여러 가지 문제를 안전하게 처리할 수 있습니다.  

### Item 9. use를 사용하여 리소스를 닫아라  
<br/>

더 이상 필요하지 않을 때, close 메서더를 사용해서 명시적으로 닫아야 하는 리소스가 있습니다. 코틀린/JVM에서 사용하는 자바 표준 라이브러리에는 이런 리소스들이 굉장히 많습니다. 예를 들어  

+ InputStream와 OutputStream
+ java.sql.Connection
+ java.io.Reader(FileReader, BufferedReader, CSSParser)
+ java.new.Socket과 java.util.Scanner  

등이 있습니다. 이러한 리소스들은 AutoCloseable을 상속받는 Closeable 인터페이스를 구현(implement)하고 있습니다.  

이러한 모든 리소스는 최종적으로 리소스에 대한 레퍼런스가 없어질 때는, 가비지 컬렉터가 처리합니다. 하지만 굉장히 느리며(쉽게 처리되지 않습니다). 그동안 리소스를 유지하는 비용이 많이 들어갑니다. 따라서 더 이상 필요하지 않다면, 명시적으로 close 메서드를 호출해 주는 것이 좋습니다. 전통적으로 이러한 리소스는 try-finally 블록을 사용해서 처리했습니다.  

```kotlin
fun countCharacterInFile(path: String): Int {
    val reader = BufferedReader(FileReader(path))
    try {
        return reader.lineSequence().sumBy { it.length }
    } finally {
        reader.close()
    }
}
```

하지만 이런 코드는 굉장히 복잡하고 좋지 않습니다. 리소스를 닫을 때 예외가 발생할 수도 있는데, 이러한 예외를 따로 처리하지 않기 때문입니다. 또한 try 블록과 finally 블록 내부에서 오류가 발생하면, 둘 중 하나만 전파됩니다. 둘 다 전파될 수 있다면 좋을 것입니다. 하지만 이를 직접 구현하려면 코드가 굉장히 길고 복잡해집니다. 그래도 굉장히 많이 사용되는 일반적인 구현이므로, 표준 라이브러리에 use라는 이름의 함수로 포함되어 있습니다. use 함수를 사용해서 앞의 코드를 적절하게 변경하면, 다음과 같습니다. 이러한 코드는 모든 Closeable 객체에 사용할 수 있습니다.  

```kotlin
fun countCharactersInFile(path: String): Int {
    val reader = BufferedReader(FileReader(path))
    reader.use {
        return reader.lineSequence().sumBy { it.length }
    }
}
```

람다 매개변수로 리시버(현재 코드에서는 reader)가 전달되는 형태도 있으므로, 줄여서 다음과 같이 작성할 수도 있습니다.  

```kotlin
fun countCharactersInFile(path: String): Int {
    BufferedReader(FileReader(path)).use { reader =>
        return reader.lineSequence().sumBy { it.length }
    }
}
```

파일을 리소스로 사용하는 경우가 많고, 파일을 한 줄씩 읽어 들이는 경우도 많으므로, 코틀린 표준 라이브러리는 파일을 한 줄씩 처리할 때 활용할 수 있는 useLines 함수도 제공합니다.  

```kotlin
fun countCharactersInFile(path: String): Int {
    File(path).useLines { lines ->
        return lines.sumBy { it.length }
    }
}
```

이렇게 처리하면 메모리에 파일의 내용을 한 줄씩만 유지하므로, 대용량 파일도 적절하게 처리할 수 있습니다. 다만 파일의 줄을 한 번만 사용할 수 있는 단점이 있습니다. 파일의 특정 줄을 두 번 이상 반복 처리하려면, 파일을 두 번 이상을 열어야 합니다. 앞의 코드는 다음과 같이 간단하게 작성할 수 있습니다.  

```kotlin
fun countCharactersInFile(path: String): Int =
    File(path).useLines { lines ->
        lines.sumBy { it.length }
    }
```

### Item 10. 단위 테스트를 만들어라  
<br/>

코드를 안전하게 만드는 가장 궁극적인 방법은 다양한 종류의 테스트를 하는 것입니다. 이러한 종류의 테스트는 개발자의 관점에서 애플리케이션 내부적으로 올바르게 작동하는지 확인하는 것입니다. 이러한 종류의 테스트는 개발자의 관점에서 애플리케이션 내부적으로 올바르게 작동하는지 확인하는 것이 아니라, 사용자의 관점에서 애플리케이션 외부적으로 제대로 작동하는지 확인하는 것이 목표입니다. 일반적으로 대부분의 관리자는 이러한 테스트만 인지하고 있습니다.  

이러한 테스트는 개발자에게 유용하지만 충분하지는 않습니다. 이것만으로는 해당 요소가 올바르게 작동한다는 것을 완전하게 보증할 수는 없습니다. 또한 개발 시점에서 빠른 피드백을 받을 수 없습니다. 이러한 문제를 해결하려면, 단위 테스트(unit test)가 필요합니다. 단위 테스트는 개발자가 작성하며, 개발자에게 유용합니다.  

단위 테스트는 일반적으로 다음과 같은 내용을 확인합니다.  

+ 일반적인 유스 케이스(이를 happy path라고 표현합니다): 요소가 사용될 거라고 예상되는 일반적인 방법을 테스트합니다.  
+ 일반적인 오류 케이스와 잠재적인 문제: 제대로 동작하지 않을 거라고 예상되는 일반적인 부분, 과거에 문제가 발생했던 부분 등을 테스트합니다.
+ 에지 케이스와 잘못된 아규먼트: Int의 경우 Int.MAX&#95;VALUE를 사용하는 경우, nullable의 경우 'null' 또는 'null 값으로 채워진 객체'를 사용하는 경우를 의미합니다.  

단위 테스트는 개발자가 만들고 있는 요소가 제대로 동작하는지를 빠르게 피드백해 주므로 개발하는 동안에 큰 도움이 됩니다. 테스트는 계속해서 축적되므로, 회귀 테스트도 쉽습니다. 또한 수동으로 테스트하기 어려운 것들도 확인할 수 있습니다. TDD(Test Driven Development)라는 접근 방식도 있습니다. TDD는 개발 전에 테스트를 먼저 작성하고, 테스트를 통과시키는 것을 목적으로 하나하나 구현해 나가는 방식입니다.  

단위 테스트의 장점을 정리해 보면 다음과 같습니다.  

+ 테스트가 잘 된 요소는 신뢰할 수 있습니다. 요소를 신뢰할 수 있으므로 요소를 활용한 작업에 자신감이 생깁니다.
+ 테스트가 잘 만들어져 있다면, 리팩터링하는 것이 두렵지 않습니다. 테스트가 있으므로, 리팩터링했을 때 버그가 생기는지 쉽게 확인할 수 있습니다. 따라서 테스트를 잘 만든 프로그램은 코드가 점점 발전합니다. 반면 테스트가 없으면 실수로 오류를 일으킬 수도 있다는 생각에 레거시 코드(기존의 코드)를 수정하려고 만지는 것을 두려워하게 됩니다.
+ 수동으로 테스트하는 것보다 단위 테스트로 확인하는 것이 빠릅니다. 빠른 속도의 피드백 루프(코드를 작성하고 테스트하고를 반복하는 것)가 만들어지므로, 개발의 전체적인 속도가 빨라지고 재미있습니다. 또한 버그를 빨리 찾을 수 있으므로 버그를 수정하는 비용도 줄어듭니다.  

하지만 다음과 같은 단점도 있습니다.  

+ 단위 테스트를 만드는 데 시간이 걸립니다. 다만 장기적으로 좋은 단위 테스트는 '디버깅 시간'과 '버그를 찾는 데 소모되는 시간'을 줄여 줍니다. 또한 단위 테스트가 수동 테스트(또는 다른 종류의 테스트)보다 훨씬 빠르므로 시간이 절약됩니다.
+ 테스트를 활용할 수 있게 코드를 조정해야 합니다. 변경하기 어렵기는 하지만, 이러한 변경을 통해서 훌륭하고 잘 정립된 아키텍처를 사용하는 것이 강제됩니다.
+ 좋은 단위 테스트를 만드는 작업이 꽤 어렵습니다. 남은 개발 과정에 대한 확실한 이해가 필요합니다. 잘못 만들어진 단위 테스트는 득보다 실이 큽니다. 단위 테스트를 제대로 하려면, 올바르게 단위 테스트를 하는 방법을 배워야 합니다. 소프트웨어 테스팅 또는 테스트 주도 개발과 관련된 내용을 이해해야 합니다.  

효과적인 단위 테스트를 하는 방법을 습득하고, 단위 테스트를 위한 코드를 작성하는 것이 생각보다 어렵습니다. 숙련된 코틀린 개발자가 되려면, 단위 테스트와 관련된 기술을 습득하고, 중요한 코드라고 할 수 있는 다음과 같은 부분에 대해 단위 테스트하는 방법을 알고 있어야 합니다.  

+ 복잡한 부분
+ 계속해서 수정이 일어나고 리팩터링이 일어날 수 있는 부분
+ 비즈니스 로직 부분
+ 공용 API 부분
+ 문제가 자주 발생하는 부분
+ 수정해야 하는 프로덕션 버그  

### Item 11. 가독성을 목표로 설계하라  
<br/>

### Item 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라  
<br/>

### Item 13. Unit?을 리턴하지 말라  
<br/>

### Item 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라  
<br/>

### Item 15. 리시버를 명시적으로 참조하라  
<br/>

### Item 16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다  
<br/>

+ 파생 프로퍼티(derived property)  
var를 사용해서 만들고, 게터와 세터를 정의할 수 있고, 읽고 쓸 수 있는 프로퍼티  

원칙적으로 프로퍼티는 상태를 나타내거나 설정하기 위한 목적으로만 사용하는 것이 좋고, 다른 로직 등을 포함하지 않아야 합니다. 어떤 것을 프로퍼티로 해야 하는지 판단할 수 있는 간단한 질문이 있습니다. "이 프로퍼티를 함수로 정의할 경우, 접두사로 get 또는 set을 붙일 것인가?" 만약 아니라면, 이를 프로퍼티로 만드는 것은 좋지 않습니다. 조금 더 구체적으로 프로퍼티 대신 함수를 사용하는 것이 좋은 경우를 정리해 보면, 다음과 같습니다.  

+ 연산 비용이 높거나, 복잡도가 O(1)보다 큰 경우: 관습적으로 프로퍼티를 사용할 때 연산 비용이 많이 필요하다고 생각하지 않습니다. 연산 비용이 많이 들어간다면, 함수를 사용하는 것이 좋습니다. 그래야 사용자가 연산 비용을 예측하기 쉽고, 이를 기반으로 캐싱 등을 고려할 수 있기 때문입니다.  
+ 비즈니스 로직(애플리케이션의 동작)을 포함하는 경우: 관습적으로 코드를 읽을 때 프로퍼티가 로깅, 리소너 통지, 바인드된 요소 변경과 같은 단순한 동작 이상을 할 거라고 기대하지 않습니다.
+ 결정적잊 않은 경우: 같은 동작을 연속적으로 두 번 했는데 다른 값이 나올 수 있다면, 함수를 사용하는 것이 좋습니다.
+ 변환의 경우: 변환은 관습적으로 Int.toDouble()과 같은 변환 함수로 이루어집니다. 따라서 이러한 변환을 프로퍼티로 만들면, 오해를 불러 일으킬 수 있습니다.
+ 게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우: 관습적으로 게터에서 프로퍼티의 상태 변화를 일으킨다고 생각하지는 않습니다. 따라서 게터에서 프로퍼티의 상태 변화를 일으킨다면, 함수를 사용하는 것이 좋습니다.  

### Item 17. 이름 있는 아규먼트를 사용하라  
<br/>

파라미터가 명확하지 않은 경우에는 이를 직접 지정해서 명확하게 만들어 줄 수 있습니다.  

```kotlin
val text = (1..10).joinToString(separator = "|")
```

또는 다음과 같이 변수를 사용해서도 의미를 명확하게 할 수 있습니다.  

```kotlin
val separator = "|"
val text = (1..10).joinToString(separator)
```

물론 이름 있는 파라미터를 사용하면 더 신뢰할 수 있습니다. 변수 이름을 사용하는 방법도 개발자의 의도를 쉽게 알 수 있지만, 실제로 코드에서 사용되고 있는지는 알 수 없습니다. 변수를 잘못 만들 수도 있고, 함수 호출 때 잘못된 위치에 배치할 수도 있습니다. 이름 있는 아규먼트는 이러한 문제가 발생하지 않습니다. 그래서 변수를 사용할 때도 이름 있는 아규먼트를 함께 활용하면 좋습니다.  

#### Item 17.1. 이름 있는 아규먼트는 언제 사용해야 할까?  
<br/>

이름 있는 아규먼트를 사용하면 코드가 길어지지만, 다음과 같은 두 가지 장점이 생깁니다.  

+ 이름을 기반으로 값이 무엇을 나타내는지 알 수 있습니다.
+ 파라미터 입력 순서와 상관 없으므로 안전합니다.  

타입은 이러한 정보를 전달하는 굉장히 좋읍 방법이라고 할 수 있습니다. 만약 성능에 영향을 줄 것 같아서 걱정된다면, 인라인 클래스를 사용하기 바랍니다. 하지만 여전히 이전에 설명했던 것처럼 파라미터의 순서를 잘못 입력하는 등의 문제가 발생할 수 있습니다. 그래서 이름 있는 아규먼트를 추천합니다. 특히 다음과 같은 경우에는 더 추천합니다.  

+ 디폴트 아규먼트의 경우
+ 같은 타입의 파라미터가 많은 경우
+ 함수 타입의 파라미터가 있는 경우(마지막 경우 제외)  

#### Item 17.2. 디폴트 아규먼트의 경우  
<br/>

프로퍼티가 디폴트 아규먼트를 가질 경우, 항상 이름을 붙여서 사용하는 것이 좋습니다. 일반적으로 함수 이름은 필수 파라미터들과 관련되어 있기 때문에 디폴트 값을 갖는 옵션 파라미터(optional parameter)의 설명이 명확하지 않습니다. 따라서 이러한 것들은 이름을 붙여서 사용하는 것이 좋습니다.  

#### Item 17.3. 같은 타입의 파라미터가 많은 경우  
<br/>

파라미터가 모두 다른 타입이라면, 위치를 잘못 입력하면 오류가 발생할 것이므로 쉽게 문제를 발견할 수 있습니다. 하지만 파라미터에 같은 타입이 있다면, 잘못 입력했을 때 문제를 찾아내기 어려울 수 있습니다.  

#### Item 17.4. 함수 타입 파라미터  
<br/>

마지막으로, 함수 타입 파라미터는 조금 특별하게 다루어야 합니다. 일반적으로 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋습니다. 함수 이름이 함수 타입 아규먼트를 설명해 주기도 합니다.  

그 밖의 모든 함수 타입 아규먼트는 이름 있는 아규먼트를 사용하는 것이 좋습니다.  

### Item 18. 코딩 컨벤션을 지켜라  
<br/>

### Item 19. knowledge를 반복하여 사용하지 말라  
<br/>

+ DRY(Don't Repeat Yourself) 규칙  
knowledge를 반복하여 사용하지 말라  

+ WET(We Enjoy Typing, Waste Everyone's Time or Write Everything Twice) 안티패턴  
개발자는 타이핑하는 것을 좋아하므로, 많은 사람의 기간을 낭비하게 만들거나 같은 코드를 두 번씩 작성한다라고 비꼬는 것  

#### Item 18.1. knowledge  
<br/>

프로그래밍에서 knowledge는 넓은 의미로 '의도적인 정보'를 뜻합니다. 이와 같은 knowledge는 코드 또는 데이터로 표현할 수 있습니다. 또한 기본 동작을 하게 아예 코드와 데이터를 부족하게 만들어서도 표현할 수 있습니다. 상속을 하는데도 불구하고 특정 메서드를 오버라이드하지 않게 강제한다는 것은, '해당 메서드가 슈퍼클래스와 동일하게 동작하기 원한다'는 의미입니다.  

이처럼 프로젝트를 진행할 때 정의한 모든 것이 knowledge입니다. knowledge의 종류는 굉장히 다양합니다. 알고리즘의 작동 방식, UI의 형태, 우리가 원하는 결과 등이 모두 '의도적인 표현'이며, knowledge입니다. knowledge는 코드, 설정, 템플릿 등으로 표현할 수 있습니다. 이러한 knowledge는 어떤 도구, 가상머신, 다른 프로그램들에서 직접 또는 간접적으로 이해할 수 있는 정보라고 할 수 있습니다.  

우리 프로그램에서 중요한 knowledge를 크게 두 가지 뽑는다면, 다음과 같습니다.  

(1) 로직(logic): 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지  
(2) 공통 알고리즘(common algorithm): 원하는 동작을 하기 위한 알고리즘  

둘의 가장 큰 차이점은 시간에 따른 변화입니다. 비즈니스 로직은 시간이 지나면서 계속해서 변하지만, 공통 알고리즘은 한 번 정의된 이후에는 크게 변화지 않습니다. 물론 공통 알고리즘을 최적화를 하거나, 같은 카테고리의 더 빠른 알고리즘으로 바꿀 수도 있지만, 동작은 크게 변하지 않습니다.  

### Item 20. 일반적인 알고리즘을 반복해서 구현하지 말라  
<br/>

많이 사용되는 알고리즘을 추출하는 방법으로는 톱레벨 함수, 프로퍼티 위임, 클래스 등이 있습니다. 확장 함수는 이러한 방법들과 비교해서, 다음과 같은 장점을 갖고 있습니다.  

+ 함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋습니다. 특히 부가작용(side-effect)이 없는 경우에만 더 좋습니다.
+ 톱레벨 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있으므로 좋습니다.
+ 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측면에서 좋습니다.
+ 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 쉽게 찾을 수 있습니다.  

### Item 21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라  
<br/>

코틀린은 코드 재사용과 관련해서 프로퍼티 위임이라는 새로운 기능을 제공합니다. 프로퍼티 위임을 사용하면 일반적인 프로퍼티의 행위를 추출해서 재사용할 수 있습니다. 대표적인 예로 지연 프로퍼티가 있습니다. lazy 프로퍼티는 이후에 처음 사용하는 요청이 들어올 때 초기화되는 프로퍼티를 의미합니다. 이러한 패턴은 굉장히 많이 사용됩니다. 일반적으로 대부분의 언어(자바스크립트 등)에서느느 필요할 때마다 이를 복잡하게 구현해야 하지만, 코틀린에서는 프로퍼티 위임을 활용해 간단하게 구현할 수 있습니다. 코틀린의 stdlib는 lazy 프로퍼티 패턴을 쉽게 구현할 수 있게 lazy 함수를 제공합니다.  

```kotlin
val value by lazy { createValue() }
```

프로퍼티 위임을 사용하면, 이외에도 변화가 있을 때 이를 감지하는 observable 패턴을 쉽게 만들 수 있습니다. 예를 들어 목록을 출력하는 리스트 어댑터가 있다면, 내부 데이터가 변경될 때마다 변경된 내용을 다시 출력해야 할 것입니다. 또한 프로퍼티의 변경 사항을 로그로 출력하고 싶은 경우도 있을 것입니다. 이러한 것들은 다음과 같이 stdlib의 observable 델리게이트를 기반으로 간단하게 구현할 수 있습니다.  

```kotlin
var items: List<Item> by
    Delegates.observable(listOf()) { _, _, _ ->
        notifyDataSetChanged()
}

var key: String? by
    Delegates.observable(null) { _, old, new ->
        Log.e("key changed from $old to $new")
    }
```

lazy와 observable 델리게이터는 언어적인 관점에서 보았을 때, 그렇게 특별한 것은 아닙니다. 일반적으로 프로퍼티 위임 메커니즘을 활용하면, 다양한 패턴들을 만들 수 있습니다. 좋은 예로 뷰, 리소스 바인딩, 의존성 주입, 데이터 바인딩 등이 있습니다. 일반적으로 이런 패턴들을 사용할 때 자바 등에서는 어노테이션을 많이 활용해야 합니다. 하지만 코틀린은 프로퍼티 위임을 사용해서 간단하고 type-safe하게 구현할 수 있습니다.  

```kotlin
// 안드로이드에서의 뷰와 리소스 바인딩
private val button: Button by bindView(R.id.button)
private val textSize by bindDimension(R.dimen.font_size)
private val doctor: Doctor by argExtra(DOCTOR_ARG)

// Kotlin에서의 종속성 주입
private val presenter: MainPresenter by inject()
private val repository: NetworkRepository by inject()
private val vm: MainViewModel by viewModel()

// 데이터 바인딩
private val port by bindConfiguration("port")
private val token: String by preferences.bind(TOKEN_KEY)
```

어떻게 이런 코드가 가능하고, 프로퍼티 위임을 어떻게 활용할 수 있는지 살펴볼 수 있게, 간단한 프로퍼티 델리게이트를 만들어 보겠습니다. 예를 들어 일부 프로퍼티가 사용될 때, 간단한 로그를 출력하고 싶다고 해 봅시다. 가장 기본적인 구현 방법은 다음과 같이 게터와 세터에서 로그를 출력하는 방법입니다.  

```kotlin
var token: String? = null
    get() {
        print("token returned value $field")
        return field
    }
    set(value) {
        print("token changed from $field to $value")
        field = value
    }

var attempts: Int = 0
    get() {
        print("attempts returned value $field")
        return field
    }
    set(value) {
        print("attempts changed from $field to $value")
        field = value
    }
```

두 프로퍼티는 타입이 다르지만, 내부적으로 거의 같은 처리를 합니다. 또한 프로젝트에서 자주 반복될 것 같은 패턴처럼 보입니다. 따라서 프로퍼티 위임을 활용해서 추출하기 좋은 부분입니다. 프로퍼티 위임은 다른 객체의 메서드를 활용해서 프로퍼티의 접근자(게터와 세터)를 만드는 방식입니다. 이때 다른 객체의 메서드 이름이 중요한데요. 게터는 getValue, 세터는 setValue 함수를 사용해서 만들어야 합니다. 객체를 만든 뒤에는 by 키워드를 사용해서, getValue와 setValue를 정의한 클래스와 연결해 주면 됩니다. 다음 코드는 이전에 살펴본 코드를 프로퍼티 위임을 활용해 변경한 예입니다.  

```kotlin
var token: String? by LoggingProperty(null)
var attempts: Int by LoggingProperty(0)

private class LoggingProperty<T>(var value: T) {
    operator fun getValue(
        thisRef: Any?,
        prop: KProperty<*>
    ): T {
        print("${prop.name} returned value $value")
        return value
    }

    operator fun setValue(
        thisRef: Any?,
        prop: KProperty<*>,
        newValue: T
    ) {
        val name = prop.name
        print("$name changed from $value to $newValue")
        value = newValue
    }
}
```

프로퍼티 위임이 어떻게 동작하는지 이해하려면, by가 어떻게 컴파일되는지 보는 것이 좋습니다. 위의 코드에서 token 프로퍼티는 다음과 비슷한 형태로 컴파일됩니다.  

```kotlin
@JvmField
private val 'token$delegate' = LoggingProperty<String?>(null)
var token: String?
    get() = 'token$delegate'.getValue(this, ::token)
    set(value) {
        'token$delegate'.setValue(this, ::token, value)
    }
```

코드를 보면 알 수 있는 것처럼 getValue와 setValue는 단순하게 값만 처리하게 바뀌는 것이 아니라, 컨텍스트(this)와 프로퍼티 레퍼런스의 경계도 함께 사용하는 형태로 바뀝니다. 프로퍼티에 대한 레퍼런스는 이름, 어노테이션과 관련된 정보 등을 얻을 때 사용됩니다. 그리고 컨텍스트는 함수가 어떤 위치에서 사용되는지와 관련된 정보를 제공해 줍니다.  

이러한 정보로 인해서 getValue와 setValue 메서드가 여러 개 있어도 문제 없습니다. getValue와 setValue 메서드가 여러 개 있어도 컨텍스트를 활용하므로, 상황에 따라서 적절한 메서드가 선택됩니다. 이는 굉장히 다양하게 활용됩니다. 예를 들어 여러 종류의 뷰와 함께 사용할 수 있는 델리게이트가 필요한 경우를 생각해 봅시다. 이는 다음과 같이 구현해서, 컨텍스트의 종류에 따라서 적절한 메서드가 선택되게 만들 수 있습니다.  

```kotlin
class SwipeRefreshBinderDelegate(val id: Int) {
    private var cache: SwipeRefreshLayout? = null

    operator fun getValue(
        activity: Activity,
        prop: KProperty<*>
    ): SwipeRefreshLayout {
        return cache ?: activity
            .findViewById<SwipeRefreshLayout>(id)
            .also { cache = it }
    }

    operator fun getValue(
        fragment: Fragment,
        prop: KProperty<*>
    ): SwipeRefreshLayout {
        return cache ?: fragment.view
            .findViewById<SwipeRefreshLayout>(id)
            .also { cache = it }
    }
}
```

객체를 프로퍼티 위임하려면 val의 경우 getValue 연산, var의 경우 getValue와 setValue 연산이 필요합니다. 이러한 연산은 지금까지 살펴본 것처럼 멤버 함수로도 만들 수 있지만, 확장 함수로도 만들 수 있습니다. 예를 들어 다음 코드는 Map<String, &#42;>를 사용하는 예입니다.  

```kotlin
val map: Map<String, Any> = mapOf(
    "name" to "Marcin"
    "kotlinProgrammer" to true
)
val name by map
print(name) // Marcin
```

이는 코틀린 stdlib에 다음과 같은 확장 함수가 정의되어 있어서 사용할 수 있는 것입니다.  

```kotlin
inline operator fun <V, V1: V> Map<in String, V>
    .getValue(thisRef: Any?, property: KProperty<*>): V1 = getOrImplicitDefault(property.name) as V1
```

코틀린 stdlib에서 다음과 같은 프로퍼티 델리게이터를 알아 두면 좋습니다.  

+ lazy
+ Delegates.observable
+ Delegates.vetoable
+ Delegates.notNull  

굉장히 범용적으로 사용되는 패턴들에 대한 프로퍼티 델리게이터이므로 알아두면 좋습니다. 또한 프로퍼티 델리게이터를 직접 만들어서 사용할 수도 있다는 것을 기억하세요.  

### Item 22. 일반적인 알고리즘을 구현할 때 제네릭을 사용하라  
<br/>

+ 제네릭 함수  
타입 아규먼트를 사용하는 함수(즉, 타입 파라미터를 갖는 함수)  

타입 파라미터는 컴파일러에 타입과 관련된 정보를 제공하여 컴파일러가 타입을 조금이라도 더 정확하게 추측할 수 있게 해 줍니다. 따라서 프로그램이 조금 더 안전해지고, 개발자는 프로그래밍이 편해집니다.  

#### Item 22.1 제네릭 제한  
<br/>

타입 파라미터의 중요한 기능 중 하나는 구체적인 타입의 서브타입만 사용하게 타입을 제한하는 것입니다.  

### Item 23. 타입 파라미터의 섀도잉을 피하라  
<br/>

+ 섀도잉(shadowing)  
프로퍼티와 파라미터가 같은 이름을 가지는 것과 비슷한 경우처럼 지역 파라미터가 외부 스코프에 있는 프로퍼티를 가리는 현상  

### Item 24. 제네릭 타입과 variance 한정자를 활용하라  
<br/>

#### Item 24.1. variance 한정자의 안전성  
<br/>

자바의 배열은 covariant입니다. 이렇게 만들어진 이유는 다양합니다. 많은 출처에 따르면, 이는 배열을 기반으로 제네릭 연산자는 정렬 함수 등을 만들기 위해서라고 이야기합니다. 그런데 자바의 covariant라는 속성을 갖기 때문에 큰 문제가 발생합니다.  

covariant 타입 파라미터(out 한정자)가 in 한정자 위치(예를 들어 타입 파라미터)에 있다면, covariant와 업캐스팅을 연결해서, 우리가 원하는 타입을 아무것이나 전달할 수 있습니다. 즉, value가 매우 구체적인 타입이라 안전하지 않습니다.  

코틀린은 public in 한정자 위치에 covariant 타입 파라미터(out 한정자)가 오는 것을 금지하여 이러한 상황을 막습니다.  

가시성을 private로 제한하면, 오류가 발생하지 않습니다. 객체 내부에서는 업캐스트 객쳉 covariant(out 한정자)를 사용할 수 없기 때문입니다.  

covariant(out 한정자)는 public out 한정자 위치에서도 안전하므로 따로 제한되지 않습니다. 이러한 안전성의 이유로 생성되거나 노출되는 타입에만 covariant(out 한정자)를 사용하는 것입니다. 이러한 프로퍼티는 일반적으로 producer 또는 immutable 데이터 홀더에 많이 사용됩니다.  

좋은 예로 T는 covariant인 List<T>가 있습니다. 지금까지 설명한 이유로 함수의 파라미터가 List<Any?>로 예측된다면, 별도의 변환 없이 모든 종류의 파라미터로 전달할 수 있습니다. 다만 MutableList<T>에서 T는 in 한정자 위치에서 사용되며, 안전하지 않으므로 invariant입니다.  

또 다른 좋은 예로는 Response가 있습니다. Response를 사용하면 다양한 이득을 얻을 수 있습니다. 다음 코드 스니펫(snippet)에서 어떻게 사용하는지 확인해 보겠습니다. 일단 다음 내용을 살펴봅시다. variance 한정자 덕분에 이 내용은 모두 참이 됩니다.  

+ Response<T>라면 T의 모든 서브타입이 허용됩니다. 예를 들어 Response<Any>가 예상된다면, Response<Int>와 Response<String>이 허용됩니다.
+ Response<T1, T2>라면 T1과 T2의 모든 서브타입이 허용됩니다.
+ Failure<T>라면, T의 모든 서브타입 Failure가 허용됩니다. 예를 들어 Failure<Number>라면, Failure<Int>와 Failure<Double>이 모두 허용됩니다. Failure<Any>라면, Failure<Int>와 Failure<String>이 모두 허용됩니다.
+ 다음 코드를 살펴봅시다. covariant와 Nothing 타입으로 인해서 Failure는 오류 타입을 지정하지 않아도 되고, Success는 잠재적인 값을 지정하지 않아도 됩니다.  

```kotlin
sealed class Response<out R, out E>
class Failure<out E>(val error: E): Response<Nothing, E>()
class Success<out R>(val value: R): Response<R, Nothing>()
```

covariant와 public in 위치와 같은 문제는 contravariant 타입 파라미터(in 한정자)와 public out 위치(함수 리턴 타입 또는 프로퍼티 타입)에서도 발생합니다. out 위치는 암묵적인 업캐스팅을 허용합니다.  

사실 이는 contravariant(in 한정자)에 맞는 동작이 아닙니다. 다음 코드를 살펴봅시다. 어떤 상자(Box 인스턴스)에 어떤 타입이 들어 있는지 확실하게 알 수가 없습니다.  

```kotlin
class Box<in T>(
    // 코틀린에서는 사용할 수 없는 코드입니다.
    val value: T
)

val garage: Box<Car> = Box(Car())
val amphibiousSpot: Box<Amphibious> = garage
val boat: Boat = garage.value // 하지만 Car를 위한 공간입니다.

val noSpot: Box<Nothing> = Box<Car>(Car())
val boat: Nothing = noSpot.value
// 아무것도 만들 수 없습니다.
```

이러한 상황을 막기 위해, 코틀린은 contravariant 타입 파라미터(in 한정자)를 public out 한정자 위치에 사용하는 것을 금지하고 있습니다.  

#### Item 24.2. variance 한정자의 위치  
<br/>

variance 한정자는 크게 두 위치에 사용할 수 있습니다. 첫 번째는 선언 부분입니다. 일반적으로 이 위치에 사용합니다. 이 위치에서 사용하면 클래스와 인터페이스 선언에 한정자가 적용됩니다. 따라서 클래스와 인터페이스가 사용되는 모든 곳에 영향을 줍니다.  

```kotlin
// 선언 쪽의 variance 한정자
class Box<out T>(val value: T)
val boxStr: Box<String> = Box("Str)
val boxAny: Box<Any> = boxStr
```

두 번째는 클래스와 인터페이스를 활용하는 위치입니다. 이 위치에 variance 한정자를 사용하면 특정한 변수에만 variance 한정자가 적용됩니다.  

```kotlin
class Box<T>(val value: T)
val boxStr: Box<String> = Box("Str")
// 사용하는 쪽의 variance 한정자
val boxAny: Box<out Any> = boxStr
```

모든 인스턴스에 variance 한정자를 적용하면 안 되고, 특정 인스턴스에만 적용해야 할 때 이런 코드를 사용합니다. 하지만 단일 파라미터 타입에 in 한정자를 붙여서 contravariant를 가지게 하는 것은 가능합니다. 이렇게 하면 여러 가지 타입을 받아들이게 할 수 있습니다.  

참고로 variance 한정자를 사용하면, 위치가 제한될 수 있습니다. 예를 들어 MutableList<out T>가 있다면, get으로 요소를 추출했을 때 T 타입이 나올 것입니다. 하지만 set은 Nothing 타입의 아규먼트가 전달될 거라 예상되므로 사용할 수 없습니다. 이는 모든 타입의 서브타입을 가진 리스트(Nothing 리스트)가 존재할 가능성이 있기 때문입니다. MutableList<in T>를 사용할 경우, get과 set을 모두 사용할 수 있습니다. 하지만 get을 사용할 경우, 전달되는 자료형은 Any?가 됩니다. 이는 모든 타입의 슈퍼타입을 가진 리스트(Any 리스트)가 존재할 가능성이 있기 때문입니다.  

#### Item 24.3. 정리  
<br/>

코틀린은 타입 아규먼트의 관계에 제약을 걸 수 있는 굉장히 강력한 제네릭 기능을 제공합니다. 이러한 기능으로 제네릭 객체를 연산할 때 굉장히 다양한 지원을 받을 수 있습니다. 코틀린에는 다음과 같은 타입 한정자가 있습니다.  

+ 타입 파라미터의 기본적인 variance의 동작은 invariant입니다.  
+ out 한정자는 타입 파라미터를 covariant하게 만듭니다.  
+ in 한정자는 타입 파라미터를 contravariant하게 만듭니다.  

코틀린에서는 

+ List와 Set의 타입 파라미터는 convariant(out 한정자)입니다. 또한 Map에서 값의 타입을 나타내는 타입 파라미터는 covariant(out 한정자)입니다. Array, MutableList, MutableSet, MutableMap의 타입 파라미터는 invariant(한정자 지정 없음)입니다.
+ 함수 타입의 파라미터 타입은 contravariant(in 한정자)입니다. 그리고 어떤 타입은 contravariant(out 한정자)입니다.
+ 리턴만 되는 타입에는 covariant(out 한정자)를 사용합니다.
+ 허용만 되는 타입에는 contravariant(in 한정자)를 사용합니다.  

### Item 25. 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라  
<br/>

### Item 26. 함수 내부의 추상화 레벨을 통일하라  
<br/>

#### Item 26.1. 추상화 레벨 통일  
<br/>

+ 추상화 레벨 통일(Single Level of Abstraction, SLA)  
함수를 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다는 원칙  

함수는 작아야 하며, 최소한의 책임만을 가져야 한다.  

어떤 함수가 다른 함수보다 좀 복잡하다면, 일부 부분을 추출해서 추상화하는 것이 좋습니다. 모든 추상화 레벨에서 '추상 요소(abstract term)'(메서드 또는 클래스)를 조작합니다. 각각의 추상 요소가 어떤 내용을 담고 잇는지 확인하고 싶다면, 정의로 이동해서 확인하면 됩니다(IntelliJ와 안드로이드 스튜디오(Android Studio)에서는 함수 이름을 Ctrl(맥에서는 Command) 키를 누르면서 클릭하면 곧바도 해당 위치로 이동합니다).  

추가적으로 이런 형태로 함수를 추출하면, 재사용과 테스트가 쉬워집니다.  

#### Item 26.2. 정리  
<br/>

별도의 추상화 계층을 만드는 것은 프로그래밍에서 일반적으로 사용되는 개념입니다. 이는 knowledge를 체계화하고, 서브시스템의 세부 사항을 숨김으로써 상호 운영성(interoperability)과 플랫폼 독립성을 얻게 합니다. 함수, 클래스, 모듈 등의 다양한 방식을 통해서 추상화를 분리합니다. 이때 각각의 레이어가 너무 커지는 것은 좋지 않습니다. 작고 최소한의 책임만 갖는 함수가 이해아기 쉽습니다. 추상화 레벨은 구첵적인 동작, 프로세서, 입출력과 가까울 수록 낮은 레벨이라고 표현합니다. 낮은 추상화 계층에서는 높은 계층에서 사용하는 요소(API)를 만듭니다.  

### Item 27. 변화로부터 코드를 보호하려면 추상화를 사용하라  
<br/>

#### Item 27.1. 상수  
<br/>

리터럴은 아무것도 설명하지 않습니다. 따라서 코드에서 반복적으로 등장할 때 문제가 됩니다. 이러한 리터럴을 상수 프로퍼티로 변경하면 해당 값에 의미 잇는 이름을 붙일 수 있으며, 상수의 값을 변경해야 할 대 훨씬 쉽게 변경할 수 있습니다.  

상수로 추출하면 이름을 붙일 수 있고, 나중에 해당 값을 쉽게 변경할 수 있습니다.  

#### Item 27.2. 함수  
<br/>

함수는 매우 단순한 추상화지만, 제한이 많습니다. 예를 들어 함수는 상태를 유지하지 않습니다. 또한 함수 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있습니다.  

#### Item 27.3. 클래스  
<br/>

클래스가 함수보다 더 강력한 이유는 상태를 가질 수 있으며, 많은 함수를 가질 수 있다는 점 때문입니다(클래스 멤버 함수를 메서드라고 부릅니다).  

하지만 여전히 한계가 있습니다. 예를 들어 클래스가 final이라면, 해당 클래스 타입 아래에 어떤 구현이 있는지 알 수 있습니다. open 클래스를 활용하면 조금은 더 자유를 얻을 수 있습니다. open 클래스는 서브클래스를 대신 제공할 수 있기 때문입니다. 더 많은 자유를 얻으려면, 더 추상적이게 만들면 됩니다.  

#### Item 27.4. 인터페이스  
<br/>

라이브러리를 만드는 사람은 내부 클래스의 가시성을 제한하고, 인터페이스를 통해 이를 노출하는 코드를 많이 사용합니다. 이렇게 하면 사용자가 클래스를 직접 사용하지 못하므로, 라이브러리를 만드는 사람은 인터페이스만 유지한다면, 별도의 걱정 없이 자신이 원하는 형태로 그 구현을 변경할 수 있습니다. 즉, 인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있는 것입니다.  

또 다른 장점은 테스트할 때 인터페이스 페이킹(faking)이 클래스 모킹(mocking)보다 간단하므로, 별도의 모킹 라이브러리(mocking library)를 사용하지 않아도 된다는 것입니다.  

마지막으로 선언과 사용이 분리되어 있으므로, 실제 클래스를 자유롭게 변경할 수 있습니다. 다만 사용 방법을 변경하려면, 인터페이스를 변경하고, 이를 구현하는 모든 클래스를 변경해야 합니다.  

#### Item 27.5 추상화가 주는 자유  
<br/>

+ 상수로 추출한다.
+ 동작을 함수로 래핑한다.
+ 함수를 클래스로 래핑한다.
+ 인터페이스 뒤에 클래스를 숨긴다.
+ 보편적인 객체(universal object)를 특수한 객체(specialistic object)로 래핑한다.  

이를 구현할 때는 여러 도구를 활용할 수 있습니다.  

+ 제네릭 타입 파라미터를 사용한다.
+ 내부 클래스를 추출한다.
+ 생성을 제한한다(예를 들어 팩토리 함수로만 객체를 생성할 수 있게 만드는 등).

#### Item 27.6. 어떻게 균형을 맞춰야 할까?  
<br/>

경험에 의하면, 모든 추상화는 자유를 주지만, 코드가 어떻게 돌아가는 것인지 이해하기 어렵게 만듭니다. 극단적인 것은 언제나 좋지 않습니다. 최상의 답은 언제나 그 사이 어딘가에 있습니다. 정확한 위치는 다음과 같은 요소들에 따라서 달라질 수 있습니다.  

+ 팀의 크기
+ 팀의 경험
+ 프로젝트의 크기
+ 특징 세트(feature set)
+ 도메인 지식  

따라서 프로젝트에 따라서 균형이 다를 수 있습니다. 적절한 균형을 찾는 것은 거의 감각에 의존해야 하는 예술에 가깝습니다. 수천 시간까지는 아니더라도, 수백 시간 이상의 경험이 있어야 할 수 있는 일입니다. 그래도 사용할 수 있는 몇 가지 규칙을 정리해 보면 다음과 같습니다.  

+ 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 변경하기 어렵습니다. 따라서 추상화 방법을 사용하는 것이 좋습니다. 최대한 모듈과 부분(part)을 분리하는 것이 좋습니다.
+ 의존성 주입 프레임워크를 사용하면, 생성이 얼마나 복잡한지는 신경 쓰지 않아도 됩니다. 클래스 등은 한 번만 정의하면 되기 때문입니다.
+ 테스트를 하거나, 다른 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면 추상화를 사용하는 것이 좋습니다.
+ 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮습니다. 문제가 발생했다면, 최대한 빨리 직접 변경하면 됩니다.  

항상 무언가 변화할 수 있다고 생각하는 것이 좋습니다. 이후에 더 일반적인 메커니즘이 필요할 가능성이 있는지, 플랫폼 독립적인 메커니즘이 필요할 수 있는지, 이러한 확률이 얼마나 되는지 등은 여러 가지 경험을 해 보면 어느 정도 알 수 있게 됩니다.  

#### Item 27.7. 정리  
<br/>

추상화는 단순하게 중복성을 제거해서 코드를 구성하기 위한 것이 아닙니다. 추상화는 코드를 변경해야 할 때 도움이 됩니다. 따라서 추상화를 사용하는 것은 굉장히 어렵지만, 이를 배우고 이해해야 합니다. 다만 추상적인 구조를 사용하면, 결과를 이해하기 어렵습니다. 추상화를 사용할 때의 장점과 단점을 모두 이해하고, 프로젝트 내에서 그 균형을 찾아야 합니다. 추상화가 너무 많거나 너무 적은 상황 모두 좋은 상황이 아닙니다.  

### Item 28. API 안정성을 확인하라  
<br/>

프로그래밍에서는 안정적이고 최대한 표준적인 API(Application Programming Interface)를 선호합니다. 주요 이유는 다음과 같습니다.  

(1) API가 변경되고, 개발자가 이를 업데이트했다면, 여러 코드를 수동으로 업데이트해야 합니다. 많은 요소가 이 API에 의존하고 있다면 이는 큰 문제가 됩니다. 변경에 대응하거나, 다른 대안을 찾는 것은 매우 어려운 일입니다. 특히 다른 개발자가 API를 사용한 경우에는 익숙하지도 않아 더욱 어려울 것입니다. 라이브러리의 작은 변경은 이를 활용하는 다른 코드들의 많은 부분을 변경하게 만들 수 있습니다. 그래서 라이브러리가 변경되어도 이전 라이브러리를 유지하는 경우가 많습니다. 하지만 그럴수록 점점 업데이트가 어려워지고, 버그와 취약성 등이 발생할 수 있습니다. 오래된 라이브러리는 더 이상 지원되지 않을 수도 있습니다. 따라서 개발자가 안정적인 라이브러리로 업데이트하는 것을 두려워한다는 것은 매우 좋지 않은 상황입니다.  

(2) 사용자가 새로운 API를 배워야 합니다. 새로 배운다는 것은 꽤 힘들고 고통스러운 일이므로, 많은 사람이 이를 피합니다. 하지만 새로 배우지 않으면, 오래된 지식 때문에 보안 문제가 발생할 수 있습니다. 따라서 처음부터 안정적이지 않은 모듈을 많이 공부하는 것보다는 안정적인 모듈부터 공부해 두는 것이 좋습니다.  

하지만 좋은 API를 한번에 설계할 수는 없습니다. API 제작자는 이를 계속해서 개선하기 위해서 변경을 원합니다. 따라서 우리(프로그래밍 커뮤니티)는 계속해서 API를 안정적으로 유지하기 위한 의견을 제시해서 균형을 맞춰야 합니다.  

일단 간단한 방법은 작성자가 'API' 또는 'API의 일부'가 불안정하다면, 이를 명확하게 알려 줘야 합니다. 일반적으로 버전을 활용해서 라이브러리와 모듈의 안정성을 나타냅니다. 많은 버저닝 시스템(versioning system)이 있지만, 일반적으로는 시멘틱 버저닝(Semantic Versioning, SemVer)을 사용합니다. 이 시스템은 버전 번호를 세 번호, 즉 MAJOR, MINOR, PATCH로 나누어서 구성합니다. 각각의 부분은 0 이상의 정수로 구성되며, 0부터 시작해서 API에 다음과 같은 변경 사항이 있을 때 1씩 증가시킵니다.  

+ MAJOR 버전: 호환되지 않는 수준의 API 변경
+ MINOR 버전: 이전 변경과 호환되는 기능을 추가
+ PATCH 버전: 간단한 버그 수정  

버전은 MAJOR.MINOR.PATCH 형태로 붙입니다. MAJOR를 증가시킬 때는 MINOR와 PATCH를 0으로 돌려 둡니다. MINOR를 증가시킬 때는 PATCH를 0으로 돌려 둡니다. 사전 배포(pre-release)와 빌드 메타데이터 등은 추가적인 레이블을 활용합니다. 메이저 버전이 0인 경우(0.y.z)는 초기 개발 전용 버전을 의미합니다. 따라서 언제든지 변경될 수 있으며, 안정적이지 않다는 의미입니다. 따라서 라이브러리와 모듈이 SemVer에 따라 버전이 붙는다면, MAJOR 버전이 0일 때는 안정적일 거라고 생각하면 안 됩니다.  

베타 버전이 오래 유지되는 것을 싫어하는 사람들이 있지만, 코틀린도 1.0버전까지 도달하는 데 5년 이상의 시간이 걸렸습니다. 이 시기에 많은 것이 바뀌었습니다. 이 시기는 코틀린에게 굉장히 중요한 시기였다고 할 수 있습니다.  

안정적인 API에 새로운 요소를 추가할 때, 아직 해당 요소가 안정적이지 않다면, 먼저 다른 브랜치에 해당 요소를 추가할 때, 아직 해당 요소가 안정적이지 않다면, 먼저 다른 브랜치에 해당 요소를 두는 것이 좋습니다. 일부 사용자가 이를 사용하도록 허용하려면(코드를 메인 브랜치에 머지(merge)하고 배포했다면), 일단 Expertimental 메타 어노테이션을 사용해서 사용자들에게 아직 해당 요소가 안정적이지 않다는 것을 알려 주는 것이 좋습니다. 이렇게 Experimental 메타 어노테이션을 붙이면, 요소를 보고 사용할 수 있지만, 사용할 때 경고 또는 오류(설정된 레벨에 따라서 다릅니다)가 출력됩니다.  

이러한 요소는 언제든지 변경될 수 있습니다. 다시 말하지만, 요소를 오랜 시간 동안 실험적 기능으로 유지하는 것을 두려워하지 말기 바랍니다. 채택 속도는 느려지지만, 더 오래 동안 좋은 API를 설계하는 데 도움이 됩니다.  

안정적인 API의 일부를 변경해야 한다면, 전환하는 데 시간을 두고 Deprecated 어노테이션을 활용해서 사용자에게 미리 알려 줘야 합니다.  

또한 직접적인 대안(direct alternative)이 있다면, IDE가 자동 전환을 할 수 있게 ReplaceWith를 붙여 주는 것도 좋습니다.  

이렇게 Deprecated와 ReplaceWith를 사용했다면, 사용자가 이러한 변경에 적응할 시간을 제공해야 합니다. 사용자는 라이브러리를 최신 버전으로 적용하는 일 이외에도 수많은 일을 갖고 있으므로, 적용하는 데에도 시간이 꽤 걸립니다. 심지어 널리 사용되는 API는 이러한 적응 시간을 몇 년으로 잡기도 합니다. 이러한 시간이 지난 뒤에는 주요 배포판(major release)에서 이 요소를 제거하면 됩니다.  

#### Item 28.1. 정리  
<br/>

사용자는 API의 안정성에 대해 알아야 합니다. 안정적인 API를 사용하는 것이 좋습니다. 다만 안정적이라고 생각했던 API에 예상하지 못한 변경이 일어났다면, 가장 나쁜 상황입니다. 이러한 변경은 수많은 사람들에게 고통을 줄 수 있습니다. 따라서 모듈과 라이브러리를 만드는 사람과 이를 사용하는 사람들 사이에 커뮤니케이션이 중요합니다. 커뮤니케이션은 버전 이름, 문서, 어노테이션 등을 통해 할 수 있습니다. 또한 안전적인 API에 변경을 가할 때는 사용자가 적응할 충분할 시간을 줘야 합니다.  

### Item 29. 외부 API를 랩(wrap)해서 사용하라  
<br/>

API 설계자가 안전하지 않다고 하거나 API 설계자가 안전하다고 해도 우리가 그것을 제대로 신뢰할 수 없다면, 해당 API는 불안정한 것입니다. 이러한 불안정한 API를 과도하게 사용하는 것은 굉장히 위험합니다. 어쩔 수 없이 이런 API를 활용해야 한다면, 최대한 이러한 API를 로직과 직접 결합시키지 않는 것이 좋습니다. 그래서 많은 프로젝트가 잠재적으로 불안정하다고 판단되는 외부 라이브러리 API를 랩(wrap)해서 사용합니다. 랩해서 사용하면, 다음과 같은 자유와 안정성을 얻을 수 있습니다.  

+ 문제가 있다면 래퍼(wrapper)만 변경하면 되므로, API 변경에 쉽게 대응할 수 있습니다.  
+ 프로젝트의 스타일에 맞춰서 API의 형태를 조정할 수 있습니다.
+ 특정 라이브러리에서 문제가 발생하면, 래퍼를 수정해서 다른 라이브러리를 사용하도록 코드를 쉽게 변경할 수 있습니다.
+ 필요한 경우 쉽게 동작을 추가하거나 수정할 수 있습니다.  

단점으로는 다음과 같은 것들이 있습니다.  

+ 래퍼를 따로 정의해야 합니다.
+ 다른 개발자가 프로젝트를 다룰 때, 어떤 래퍼들이 있는지 따로 확인해야 합니다.
+ 래퍼들은 프로젝트 내부에서만 유효하므로, 문제가 생겨도 질문할 수 없습니다.  

장점과 단점을 모두 이해하고 랩할 API를 결정해야 합니다. 라이브러리가 얼마나 안정적인지 확인할 수 있는 가장 기본적인 휴리스틱은 버전 번호와 사용자 수입니다. 일반적으로 라이브러리 사용자가 많을수록 안정적입니다. 사용자가 많으면, 제작자가 프로젝트에 작은 변화를 가할 때도 굉장히 신중하게 할 것입니다. 제작자가 프로젝트에 작은 변화를 가할 때도 굉장히 신중하게 할 것입니다. 반대로 인기가 없고 새로 만들어진 라이브러리는 위험할 수 있습니다. 이런 경우에는 신중하게 사용을 결정하고, 사용하기로 했다면 클래스와 함수로 랩하는 것을 고려하기 바랍니다.  

### Item 30. 요소의 가시성을 최소화하라  
<br/>

API를 설계할 때 가능한 한 간결한 API를 선호하는 데는 여러 가지 이유가 있습니다.  

작은 인터페이스는 배우기 쉽고 유지하기 쉽습니다. 기능이 많은 클래스보다는 적은 클래스를 이해하는 것이 쉽습니다. 또한 유지보수하기도 쉽습니다. 일반적으로 어떤 수정을 가하기 위해서는 클래스 전체를 이해하고 있어야 합니다. 보이는 요소 자체가 적다면, 유지보수하고 테스트할 것이 적습니다.  

변경을 가할 때는 기존의 것을 숨기는 것보다 새로운 것을 노출하는 것이 쉽습니다. 일반적으로 공개적으로 노출되어 있는 요소들은 이미 외부에서 사용되고 있을 것입니다. 그래서 이런 요소들을 변경하면, 이 코드를 사용하는 모든 부분이 영향을 받습니다. 가시성과 관련된 제한을 변경하는 것은 더 어렵습니다. 이러한 변경은 신중하게 고려해야 하며, 변경할 경우에는 대체재를 제공해야 합니다. 다만 다른 개발자가 구현한 코드에 대한 대체재를 제공하는 것은 굉장히 어려울 수 있습니다. 비즈니스 요구 사항이 무엇인지 빠르게 파악하기 어려울 수 있기 때문입니다. 널리 사용되는 공개 라이브러리라면, 일부 요소의 가시성을 제한한 경우 여러 사용자가 분노할 수 있습니다. 따라서 처음에는 작은 API로서 개발을 하도록 강제하는 것이 더 좋을 수 있습니다.  

클래스의 상태를 나타내는 프로퍼티를 외부에서 변경할 수 있다면, 클래스는 자신의 상태를 보장할 수 없습니다. 클래스가 만족해야 하는 클래스의 상태에 대한 규약 등이 있을 수 있습니다. 이러한 규약을 모르는 사람은 클래스의 상태를 마음대로 변경할 수 있으므로, 클래스의 불변성(invariant)이 무너질 가능성이 있습니다.  

일반적으로 코틀린에서는 구체 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화하는 것이 좋습니다.  

서로서로 의존하는 프로퍼티가 있을 때는 객체 상태를 보호하는 것이 더 중요해집니다.  

가시성이 제한될수록 클래스의 변경을 쉽게 추적할 수 있으며, 프로퍼티의 상태를 더 쉽게 이해할 수 있습니다. 이는 동시성(concurrency)을 처리할 때 중요합니다. 상태 변경은 병렬 프로그래밍에서 문제가 됩니다. 따라서 많은 것을 제한할수록 병렬 프로그래밍은 할 때 안전해집니다.  

#### Item 30.1. 가시성 한정자 사용하기  
<br/>

내부적인 변경 없이 작은 인터페이스를 유지하고 싶다면, 가시성(visibility)을 제한하면 됩니다. 기본적으로 클래스와 요소를 외부에 노출할 필요가 없다면, 가시성을 제한해서 외부에서 접근할 수 없게 만드는 것이 좋습니다. 가시성 제한은 가시성을 한정자(visibility modifier)를 활용해서 구현합니다.  

클래스 멤버의 경우 다음과 같은 4개의 가시성 한정자를 사용할 수 있습니다.  

+ public(디폴트): 어디에서나 볼 수 있습니다.
+ private: 클래스 내부에서만 볼 수 있습니다.
+ protected: 클래스와 서브클래스 내부에서만 볼 수 있습니다.
+ internal: 모듈 내부에서만 볼 수 있습니다.  

톱레벨 요소에는 세 가지 가시성 한정자를 사용할 수 있습니다.  

+ public(디폴트): 어디에서나 볼 수 있습니다.
+ private: 같은 파일 내부에서만 볼 수 있습니다.
+ internal: 모듈 내부에서만 볼 수 있습니다.  

참고로 모듈과 패키지는 의미가 전혀 다릅니다. 코틀린에서 모듈이란 함께 컴파일되는 코틀린 소스를 의미합니다. 따라서 다음을 의미합니다.  

+ 그레이들(Gradle) 소스 세트  
+ 메이븐(Maven) 프로젝트
+ 인텔리제이(IntelliJ) IDEA 모듈
+ 엔트(Ant) 태스트 한 번으로 컴파일되는 파일 세트  

만약 모듈이 다른 모듈에 의해서 사용될 가능성이 있다면, internal을 사용해서 공개하고 싶지 않은 요소를 숨깁니다. 요소가 상속을 위해 설계되어 있고, 클래스와 서브클래스에서만 사용되게 만들고 싶다면 protected를 사용합니다. 동일한 파일 또는 클래스에서만 요소를 사용하게 만들고 싶다면 private을 사용합니다. 참고로, 코틀린은 지역적으로만 사용되고 있는 요소는 private으로 만드는 것이 좋다는 컨벤션을 제공해 줍니다.  

이러한 규칙은 데이터를 저장하도록 설계된 클래스(데이터 모델 클래스, DTO)에는 적용하지 않는 것이 좋습니다. 데이터를 저장하도록 설계된 클래스는 숨길 이유가 없기 때문입니다. 따라서 프로퍼티를 사용할 수 있게 눈에 띄게 만드는 것이 좋으며, 필요하지 않은 경우 그냥 프로퍼티를 제거하는 것이 좋습니다.  

한 가지 큰 제한은, API를 상속할 때 오버라이드해서 가시성을 제한할 수는 없다는 것입니다. 이는 서브클래스가 슈퍼클래스로도 사용될 수 있기 때문입니다. 이것이 상속보다 컴포지션을 선호하는 대표적인 이유입니다.  

#### Item 30.2. 정리  
<br/>

보이는 요소들은 모두 public API로서 사용되며, 다음과 같은 이유로 최대한 단순한 것이 좋습니다.  

+ 인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉽습니다.
+ 최대한 제한이 되어 있어야 변경하기 쉽습니다.
+ 클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없습니다.
+ 가시성이 제한되면 API의 변경을 쉽게 추적할 수 있습니다.  

### Iten 31. 문서로 규약을 정의하라  
<br/>

일반적이 문제는 행위가 문서화되지 않고, 요소의 이름이 명확하지 않다면 이를 사용하는 사용자는 우리가 만들려고 했던 추상화 목표가 아닌, 현재 구현에만 의존하게 된다는 것입니다. 이러한 문제는 예상되는 행위를 문서로 설명함으로써 해결합니다.  

#### Item 31.1. 규약  
<br/>

어떤 행위를 설명하면 사용자는 이를 일종의 약속으로 취급하며, 이를 기반으로 스스로 자유롭게 생각하던 예측을 조정합니다.  

+ 요소의 규약(contract of an element): 예측되는 행위  

#### Item 31.2. 규약 정의하기  
<br/>

그럼 규약은 어떻게 정의할까요? 다양한 방법이 있습니다. 간단하게 대표적인 몇 가지를 정리해 보겠습니다.  

+ 이름: 일반적인 개념과 관련된 메서드는 이름만으로 동작을 예측할 수 있습니다.
+ 주석과 문서: 필요한 모든 규약을 적을 수 있는 강력한 방법입니다.
+ 타입: 타입은 객체에 대한 많은 것을 알려 줍니다. 어떤 함수의 선언에 있는, 리턴 타입과 아규먼트 타입은 굉장히 큰 의미가 있습니다. 자주 사용되는 타입의 경우에는 타입만 보아도 어떻게 사용하는 지 알 수 있지만, 일부 타입은 문서에 추가로 설명해야 할 의무가 있습니다.  

#### Item 31.3. KDoc 형식  
<br/>

+ KDoc: 주석으로 함수를 문서화할 때 사용되는 공식적인 형식으로 /&#42;&#42;로 시작해서 &#42;/로 끝나고 이 사이의 모든 줄은 일반적으로 &#42;로 시작하며 설명은 KDoc 마크다운이라는 형식으로 작성  

KDoc 주석의 구조는 다음과 같습니다.  

+ 첫 번째 부분은 요소에 대한 요약 설명(summary description)입니다.
+ 두 번째 부분은 상세 설명입니다.
+ 이어지는 줄은 모두 태그로 시작합니다. 이러한 태그는 추가적인 설명을 위해 사용됩니다.  

사용할 수 있는 태그는 다음과 같습니다.  

+ &#64;param <name>: '함수 파라미터' 또는 '클래스, 프로퍼티, 함수 타입 파라미터'를 문서화합니다.
+ &#64;return: 함수의 리턴 값을 문서화합니다.
+ &#64;constructor: 클래스의 기본 생성자를 문서화합니다.
+ &#64;receiver: 확장 함수의 리시버를 문서화합니다.
+ &#64;property <name>: 명확한 이름을 갖고 있는 클래스의 프로퍼티를 문서화합니다. 기본 생성자에 정의된 프로퍼티에 사용합니다.
+ &#64;throw <class>, &#64;exception <class>: 메서드 내우베엇 발생할 수 있는 예외를 문서화합니다.
+ &#64;sample <identifier>: 정규화된 형식 이름(specified qualified name)을 사용해서 함수의 사용 예를 문서화합니다.
+ &#64;see <identifier>: 특정한 클래스 또는 메서드에 대한 링크를 추가합니다.
+ &#64;author: 요소의 작성자를 지정합니다.
+ &#64;since: 요소에 대한 버전을 지정합니다.
+ &#64;supress: 이를 지정하면, 만들어지는 문서에서 해당 요소가 제외됩니다. 외부에서 사용할 수는 있지만, 공식 API에 포함할 필요는 없는 요소에 지정합니다.  

'설명'과 '태그를 설명하는 텍스트' 모두 요소, 구체 클래스, 메서드, 프로퍼티, 파라미터를 연결할 수 있습니다. 관련된 요소 등에 링크를 걸 때는 대괄호를 사용합니다. 만약 링크 대상에 대한 추가 설명을 입력하고 싶을 때는 대괄호를 두 번 연속해서 사용합니다.  

이러한 태그는 모든 코틀린 문서 생성 도구에서 사용됩니다. 공식적인 코틀린 문서 생성 도구의 이름은 Dokka입니다. Dokka는 온라인에 게시하고, 외부 사용자에게 제공할 수 있는 문서 파일을 만들어 줍니다.  

#### Item 31.4. 타입 시스템과 예측  
<br/>

+ 리스코브 치환 원칙(Liskov substitution principle)  
S가 T의 서브타입이라면, 별도의 변경이 없어도 T 타입 객체를 S 타입 객체로 대체할 수 있어야 한다. 클래스가 어떤 동작을 할 것이라 예측되면, 그 서브클래스도 이를 보장해야 한다.  

### Item 32. 추상화 규약을 지켜라  
<br/>

#### Item 32.1. 상속된 규약  
<br/>

클래스를 상속하거나, 다른 라이브러리의 인터페이스를 구현할 때는 규약을 반드시 지켜야 합니다. 만약 지키지 않는다면, 객체가 제대로 동작하지 않을 수 있습니다.  

### Item 33. 생성자 대신 팩토리 함수를 사용하라  
<br/>

+ 팩토리 함수  
생성자의 역할을 대신해 주는 함수  

+ 생성자와 다르게, 함수에 이름을 붙일 수 있습니다. 이름은 객체가 생성되는 방법과 아규먼트로 무엇이 필요한지 설명할 수 있습니다. 이름은 굉장히 유용합니다. 또한 동일한 파라미터 타입을 갖는 생성자의 충돌을 줄일 수 있다는 장점도 있습니다.
+ 생성자와 다르게, 함수가 원하는 형태의 타입을 리턴할 수 있습니다. 따라서 다른 객체를 생성할 때 사용할 수 있습니다. 인터페이스 뒤에 실제 객체의 구현을 숨길 때 유용하게 사용할 수 있습니다. 그렇다면 실제로 어떤 객체를 리턴할까요? 이는 플랫폼에 따라서 다릅니다. 코틀린/JVM, 코틀린/JS, 코틀린/네이티브에 따라서 각 플랫폼의 빌트인 컬렉션으로 만들어집니다. 코틀린 팀이 만든 핵심적인 최적화 중 하나입니다. 또한 인터페이스를 리턴한 것이므로, 인터페이스만 지켜서 만들어진다면 어떤 클래스라도 잘 동작할 것입니다. 따라서 코틀린 제작자가 더 많은 자유를 가질 수 있습니다.
+ 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없습니다. 함수를 사용해서 객체를 생성하면 싱글턴 패턴처럼 객체를 하나만 생성하게 강제하거나, 최적화를 위해 캐싱 메커니즘을 사용할 수도 있습니다. 또한 객체를 만들 수 없을 경우, null을 리턴하게 만들 수도 있습니다.
+ 팩토리 함수는 아직 존재하지 않는 객체를 리턴할 수도 있습니다. 이러한 특징 때문에 어노테이션 처리를 기반으로 하는 라이브러리에는 팩토리 함수를 많이 사용합니다. 이를 활용하면 프로젝트를 빌드하지 않고도 앞으로 만들어질 객체를 사용하거나, 프록시를 통해 만들어지는 객체를 사용할 수 있습니다.  
+ 객체 외부에 팩토리 함수를 만들면, 그 가시성을 원하는 대로 제어할 수 있습니다.  
+ 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 reified로 만들 수 있습니다.
+ 생성자는 즉시 슈퍼클래스 또는 기본 생성자를 호출해야 합니다. 하지만 팩토리 함수를 사용하면, 원하는 때에 생성자를 호출할 수 있습니다.  

다만 팩토리 함수로 클래스를 생성할 때는 약간의 제한이 발생합니다. 서브클래스 생성에는 슈퍼클래스의 생성자가 필요하기 때문에, 서브클래스를 만들어 낼 수 없습니다.  

팩토리 함수는 굉장히 강력한 객체 생성 방법입니다. 참고로 이 말을 들으면, 기본 생성자 또는 팩토리 함수 중에 하나를 사용해야 한다고 이해할 수 있는데, 기본 생성자를 사용하지 말라는 말이 아닙니다. 팩토리 함수 내부에서는 생성자를 사용해야 합니다. 일반적인 자바로 팩토리 패턴을 구현할 때는 생성자를 private으로 만들지만, 코틀린에서는 그렇게 하는 경우가 거의 없습니다. 팩토리 함수는 기본 생성자가 아닌 추가적인 생성자(secondary constructor)와 경쟁 관계입니다. 여러 코틀린 프로젝트를 살펴보면 알겠지만, 추가적인 생성자보다는 팩토리 함수를 많이 사용합니다. 또한 팩토리 함수는 다른 종류의 팩토리 함수와 경쟁 관계에 있다고 할 수 있습니다. 팩토리 함수에는 어떤 것들이 있는지 살펴봅시다.  

(1) companion 객체 팩토리 함수
(2) 확장 팩토리 함수  
(3) 톱레벨 팩토리 함수  
(4) 가짜 생성자  
(5) 팩토리 클래스의 메서드  

#### Item 33.1. Companion 객체 팩토리 함수  
<br/>

팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 것입니다.  

함수의 이름만 보면 무엇을 하는 함수인지 잘 모를 수도 있겠지만, 대부분의 개발자는 자바에서 온 규칙 덕분에 이미 이 이름에 익숙할 것이므로 큰 문제없이 이해할 수 있을 것입니다. 이외에도 다음과 같은 이름들이 많이 사용됩니다.  

+ from: 파라미터를 하나 받고, 같은 타입의 인스턴스 하나를 리턴하는 타입 변환 함수를 나타냅니다.
+ of: 파라미터를 여러 개 받고, 이를 통합해서 인스턴스를 만들어 주는 함수를 나타냅니다.
+ valueOf: from 또는 of와 비슷한 기능을 하면서도, 의미를 조금 더 쉽게 읽을 수 있게 이름을 붙인 함수입니다.
+ instance 또는 getInstance: 싱글턴으로 인스턴스 하나를 리턴하는 함수입니다. 파라미터가 있을 경우, 아규먼트를 기반으로 하는 인스턴스를 리턴합니다. 일반적으로 같은 아규먼트를 넣으면, 같은 인스턴스를 리턴하는 형태로 작동합니다.
+ createInstance 또는 newInstance: getInstance처럼 동작하지만, 싱글턴이 적용되지 않아서, 함수를 호출할 때마다 새로운 인스턴스를 만들어서 리턴합니다.
+ getType: getInstance처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 때 사용하는 이름입니다. 타입은 팩토리 함수에서 리턴하는 타입입니다.
+ newType: newInstance처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 때 사용하는 이름입니다. 타입은 팩토리 함수에서 리턴하는 타입입니다.  

companion 객체는 인터페이스를 구현할 수 있으며, 클래스를 상속받을 수도 있습니다. 일반적으로 다음과 같은 형태로 companion 객체를 만드는 팩토리 함수를 만듭니다.  

참고로, 추상 companion 객체 팩토리는 값을 가질 수 있습니다. 따라서 캐싱을 구현하거나, 테스트를 위한 가짜 객체 생성(fake creation)을 할 수 있습니다.  

#### Item 33.2. 확장 팩토리 함수  
<br/>

이미 companion 객체가 존재할 때, 이 객체의 함수처럼 사용할 수 있는 팩토리 함수를 만들어야 할 때가 있습니다. 그런데 이때 companion 객체를 직접 수정할 수는 없고, 다른 파일에 함수를 만들어야 한다면 어떻게 할까요? 이러한 경우에는 확장 함수를 활용하면 됩니다.  

이를 활용하면 팩토리 메서드를 만들어서, 외부 라이브러리를 확장할 수 있습니다. 다만 companion 객체를 확장하려면, (적어도 비어 있는) 컴패니언 객체가 필요하다는 것입니다.  

#### Item 33.3. 톱레벨 팩토리 함수  
<br/>

객체를 만드는 흔한 방법 중 하나로 톱레벨 팩토리 함수를 이용하는 방법이 있습니다. 대표적인 예로는 listOf, setOf, mapOf가 있습니다. 톱레벨 팩토리 함수는 굉장히 광범위하게 사용됩니다. 예를 들어 안드로이드에서는 액티비티(Activity)를 시작하기 위해서, 인텐트(Intent)를 만드는 함수를 정의해서 사용합니다. 이를 코틀린으로 옮긴다면, getIntent()를 companion 객체로 다음과 같이 만들 수 있습니다.  

하지만 코틀린 Anko 라이브러리를 사용하면 reified 타입을 활용해서 intentFor라는 톱레벨 함수를 사용하는 코드를 작성할 수 있습니다.  

```kotlin
intentFor<MainActivity>()
```

하지만 톱레벨 함수는 신중하게 사용해야 합니다. public 톱레벨 함수는 모든 곳에서 사용할 수 있으므로, IDE가 제공하는 팁을 복잡하게 만드는 단점이 있습니다. 톱레벨 함수의 이름을 클래스 메서드 이름처럼 만들면, 다양한 혼란을 일으킬 수 있습니다. 따라서 톱레벨 함수를 만들 때는 꼭 이름을 신중하게 생각해서 잘 지정해야 합니다.  

#### Item 33.4. 가짜 생성자  
<br/>

코틀린의 생성자는 톱레벨 함수와 같은 형태로 사용됩니다.  

```kotlin
class A
val a = A()
```

따라서 다음과 같이 톱레벨 함수처럼 참조될 수 있습니다(생성자 레퍼런스는 함수 인터페이스로 구현합니다).  

```kotlin
val reference: ()->A = ::A
```

일반적인 사용의 관점에서 대문자로 시작하는지 아닌지는 생성자와 함수를 구분하는 기준입니다. 물론 함수도 대문자로 시작할 수 있지만, 이는 특수한 다른 용도로서 사용됩니다. 예를 들어 List와 MutableList는 인터페이스입니다. 따라서 생성자를 가질 수 없습니다. 하지만 List를 생성자처럼 사용하는 코드를 보았을 것입니다.  

```kotlin
List(4) { "User$it" } // [User0, User1, User2, User3]
```

이는 다음과 같은 함수가 코틀린 1.1부터 stdlib에 포함되었기 때문입니다.  

```kotlin
public inline fun <T> List(
    size: Int,
    init: (index: Int) -> T
): List<T> = MutableList(size, init)

public inline fun <T> MutableList(
    size: Int,
    init: (index: Int) -> T
): MutableList<T> {
    val list = ArrayList<T>(size)
    repeat(size) { index -> list.add(init(index)) }
    return list
}
```

이러한 톱레벨 함수는 생성자처럼 보이고, 생성자처럼 작동합니다. 하지만 팩토리 함수와 같은 모든 장점을 갖습니다. 많은 개발자가 이 함수가 톱레벨 함수인지 잘 모릅니다. 그래서 이것을 가짜 생성자(fake constructor)라고 부르는 것입니다.  

개발자가 진짜 생성자 대신에 가짜 생성자를 만드는 이유는 다음과 같습니다.  

+ 인터페이스를 위한 생성자를 만들고 싶을 때
+ reified 타입 아규먼트를 갖게 하고 싶을 때  

이를 제외하면, 가짜 생성자는 진짜 생성자처럼 동작해야 합니다. 생성자처럼 보여야 하며, 생성자와 같은 동작을 해야 합니다. 캐싱, nullable 타입 리턴, 서브클래스 리턴 등의 기능까지 포함해서 객체를 만들고 싶다면, companion 객체 팩토리 메서드처럼 다른 이름을 가진 팩토리 함수를 사용하는 것이 좋습니다.  

가짜 생성자를 선언한은 또 다른 방법이 있습니다. invoke 연산자를 갖는 companion 객체를 사용하면, 비슷한 결과를 얻을 수 있습니다.  

다만 이와 같은 방식은 거의 사용되지 않으며, 추천하지 않는 방법입니다. 이는 연산자 오버로드를 할 때는 의미에 맞게 하라는 것에 위배되기 때문입니다.  

invoke는 호출한다는 의미입니다. 따라서 객체 생성과 의미가 다릅니다. 이런 식으로 연산자를 오버로드하면, 원래 의미와 차이가 발생합니다. 또한 이런 방식은 톱레벨 함수로 만드는 코드보다 훨씬 복잡합니다. 리플렉션을 보면 지금까지 살펴보았던 생성자, 가짜 생성자, invoke 함수의 복잡성을 확인할 수 있습니다.  

따라서 가짜 생성자는 톱레벨 함수를 사용하는 것이 좋습니다. 기본 생성자를 만들 수 없는 상황 또는 생성자가 제공하지 않는 기능(예: reified 타입 파라미터 등)으로 생성자를 만들어야 하는 상황에만 가짜 생성자를 사용하는 것이 좋습니다.  

#### Item 33.5. 팩토리 클래스의 메서드  
<br/>

팩토리 클래스와 관련된 추상 팩토리, 프로토타입 등의 수많은 생성 패턴이 있습니다. 이러한 패턴들은 각각 다양한 장점이 있습니다.  

이러한 패턴 중 일부는 코틀린에서는 적합하지 않습니다. 예를 들어 점층적으로 생성자 패턴과 빌더 패턴은 코틀린에서는 의미가 없습니다.  

팩토리 클래스는 클래스의 상태를 가질 수 있다는 특징 때문에 팩토리 함수보다 다양한 기능을 갖습니다.  

팩토리 클래스는 프로퍼티를 가질 수 있습니다. 이를 활용하면 다양한 종류로 최적화하고, 다양한 기능을 도입할 수 있습니다. 예를 들어 캐싱을 활용하거나, 이전에 만든 객체를 복제해서 객체를 생성하는 방법으로 객체 생성 속도를 높일 수 있습니다.  

### Item 34. 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라  
<br/>

#### Item 34.1. 점층적 생성자 패턴  
<br/>

+ 점층적 생성자 패턴  
여러 가지 종류의 생성자를 사용하는 패턴  

디폴트 아규먼트는 코드를 단순하고 깔끔하게 만들어 줄 뿐만 아니라, 점층적 생성자보다 훨씬 다양한 기능을 제공합니다.  

디폴트 아규먼트가 점층적 생성자보다 좋은 이유는 다음과 같습니다.  

+ 파라미터들의 값을 원하는 대로 지정할 수 있습니다.
+ 아규먼트를 원하는 순서로 지정할 수 있습니다.
+ 명시적으로 이름을 붙여서 아규먼트를 지정하므로 의미가 훨씬 명확합니다.  

#### Item 34.2. 빌더 패턴  
<br/>

빌더 패턴을 사용하면, 다음과 같은 장점이 있습니다.  

+ 파라미터에 이름을 붙일 수 있습니다.
+ 파리미터를 원하는 순서로 지정할 수 있습니다.
+ 디플로트 값을 지정할 수 있습니다.  

빌더 패턴을 사용하는 것보다 이름 있는 파라미터를 사용하는 것이 좋은 이유를 간단하게 정리해 보면, 다음과 같습니다.  

+ 더 짧습니다: 디폴트 아규먼트가 있는 생성자 또는 팩토리 메서드가 빌더 패턴보다 구현하기 훨씬 쉽습니다. 단순하게 구현만 쉬운 것이 아니라, 이를 읽는 사람의 입장에서 읽는 것도 쉽습니다. 빌더 패턴은 많은 코드를 입력해야 하므로, 구현하는 데 시간이 많이 걸립니다. 또한 코드를 수정하는 것도 어렵습니다.  
+ 더 명확합니다: 객체가 어떻게 생성되는지 확인하고 싶을 때, 빌더 패턴은 여러 메서드들을 확인해야 합니다. 하지만 디폴트 아규먼트가 있는 코드는 생성자 주변 부분만 확인하면 됩니다. 거대하게 빌더 패턴을 만들어진 객체는 디폴트로 어떤 값을 가지는지, 그리고 내부적으로 어던 추가적인 처리가 일어나는지 이해하기 어렵습니다.  
+ 더 사용하기 쉽습니다: 기본 생성자는 언어에 내장된 개념입니다. 하지만 빌더 패턴은 언어 위에 추가로 구현한 개념이므로, 추가적인 knowledge가 필요합니다.  
+ 동시성과 관련된 문제가 없습니다: 코틀린의 함수 파라미터는 항상 immutable입니다. 반면 대부분의 빌더 패턴에서 프로퍼티는 mutable입니다. 따라서 빌더 패턴의 빌더 함수를 쓰레드 안전(thread-safe)하게 구현하는 것은 어렵습니다.  

물론 무조건 빌더 패턴 대신 기본 생성자를 사용해야 한다는 것은 아닙니다. 빌더 패턴이 좋은 경우를 간단하게 살펴봅시다.  

다음 코드를 살펴봅시다. 빌더 패턴은 값의 의미를 묶어서 지정할 수 있습니다(setPositiveButton, setNegativeButton, addRoute). 또한 특정 값을 누적하는 형태로 사용할 수 있습니다(addRoute).  

```kotlin
val dialog = AlertDialog.Builder(context)
    .setMessage(R.string.fire_missiles)
    .setPositiveButton(R.string.fire, { d, id ->
        // 미사일 발사!
    })
    .setNegativeButton(R.string.cancel, { d, id ->
        // 사용자가 대화상자에서 취소를 누른 경우
    })
    .create()

val router = Router.Builder()
    .addRoute(path = "/home", ::showHome)
    .addRoute(apth = "/users", ::showUsers)
    .build()
```

빌더 패턴을 사용하지 않고 이를 구현하려면, 추가적인 타입들을 만들고 활용해야 합니다. 코드가 오히려 복잡해집니다.  

```kotlin
val dialog = AlertDialog(context,
    message = R.string.fire_missiles,
    positiveButtonDescription = ButtonDescription(R.string.fire, { d, id ->
        // 미사일 발사
    }),
    negativeButtonDescription(R.string.cancel, { d, id ->
        // 사용자가 대화상자에서 취소를 누른 경우
    })
)

val router = Router(
    routes = listOf(
        Router("/home", ::showHome),
        Router("/users", ::showUsers)
    )
)
```

이러한 코드는 코틀린 커뮤니티에서 좋게 받아 들여지지 않습니다. 일반적으로 이런 코드는 다음과 같이 DSL(Domain Specific Language) 빌더를 사용합니다.  

```kotlin
val dialog = context.alert(R.string.fire_missiles) {
    positiveButton(R.string.fire) {
        // 미사일 발사
    }
    negativeButton {
        // 사용자가 대화상자에서 취소를 누른 경우
    }
}

val route = router {
    "/home" directsTo ::showHome
    "/users" directsTo ::showUsers
}
```

이렇게 DSL 빌더를 활용하는 패턴이 전통적인 빌더 패턴(이전에 살펴본 코드)보다 훨씬 유연하고 명확해서, 코틀린은 이와 같은 형태의 코드를 많이 사용합니다. 물론 DSL을 만드는 것이 조금 어렵습니다. 그런데 빌더를 만드는 것도 그렇게 쉬운 일은 아닙니다. 시간을 조금 더 투자해서 더 유연하고 가독성이 더 좋은 코드를 만들어 낼 수 있다면, 그 방법을 사용하는 게 더 좋을 것입니다. 그래서 DSL을 많이 사용합니다.  

고전적인 빌더 패턴의 또 다른 장점으로는 팩토리로 사용할 수 있다는 것입니다.  

```kotlin
fun Context.makeDefaultDialogBuilder() = 
    AlertDialog.Builder(this)
            .setIcon(R.drawable.ic_dialog)
            .setTitle(R.string.dialog_title)
            .setOnCancelListener { it.cancel() }

```

팩토리 메서드를 기본 생성자처럼 사용하게 만들려면, 커링(currying)을 활용해야 합니다. 하지만 코틀린은 커링을 지원하지 않습니다. 대신 객체 설정을 데이터 클래스로 만들고, 데이터 클래스로 객체를 만들어 두고, 이를 copy로 복제한 뒤, 필요한 설정들을 일부 수정해서 사용하는 형태로 만듭니다.  

```kotlin
data class DialogConfig(
    val icon: Int = -1,
    val title: Int = -1,
    val onCancelListener: (() -> Unit)? = null
)

fun makeDefaultDialogConfig() = DialogConfig(
    icon = R.drawable.ic_dialog,
    title = R.string.dialog_title,
    onCancelListener = { it.cancel() }
)
```

사실 두 가지 모두 실무에서 보기 어려운 형태의 코드입니다. 예를 들어 애플리케이션에서 사용되는 기본적인 대화상자를 정의하려는 경우, 함수를 사용해서 만들고, 모든 사용자 정의 요소를 옵션 아규먼트로 전달하는 방법을 사용하는 것이 좋습니다. 그래서 빌더 패턴의 장점도 빌더 패턴을 사용할 이유가 되지는 못합니다.  

결론적으로 코틀린에서는 빌더 패턴을 거의 사용하지 않습니다. 빌더 패턴은 다음과 같은 경우에만 사용합니다.  

+ 빌더 패턴을 사용하는 다른 언어로 작성된 라이브러리를 그대로 옮길 때
+ 디폴트 아규먼트와 DSL을 지원하지 않는 다른 언어에서 쉽게 사용할 수 있게 API를 설계할 때  

이를 제외하면, 빌더 패턴 대신에 디폴트 아규먼트를 갖는 기본 생성자 또는 DSL을 사용하는 것이 좋습니다.  

#### Item 34.2. 정리  
<br/>

코틀린에서는 점층적 생성자 패턴을 사용하지 않습니다. 대신 디폴트 아규먼틀 활용하는 것이 좋습니다. 빌더 패턴도 마찬가지로 거의 사용하지 않습니다. 기본 생성자를 사용하는 코드로 바꾸거나, DSL을 활용하는 것이 좋습니다.  


### Item 35. 복잡한 객체를 생성하기 위한 DSL을 정의하라  
<br/>

코틀린을 활용하면 DSL(Domain Specific Language)을 직접 만들 수 있습니다. DSL은 복잡한 객체, 계층 구조를 갖고 있는 객체들을 정의할 때 굉장히 유용합니다. DSL을 만드는 것은 약간 힘든 일이지만, 한 번 만들고 나면 보일러플레이트(boilerplate)와 복잡성을 숨기면서 개발자의 의도를 명확하게 표현할 수 있습니다.  

DSL은 자료 또는 설정을 표현할 대도 활용될 수 있습니다.  

DSL을 활용하면 복잡하고 계층적인 자료 구조를 쉽게 만들 수 있습니다. 참고로 DSL 내부에서도 코틀린이 제공하는 모든 것을 활용할 수 있습니다. 코틀린의 DSL은 type-safe이므로, (그루비 등와 다르게) 여러 가지 유용한 힌트를 활용할 수 있습니다. 이미 존재하는 코틀린 DSL을 활용하는 것도 좋지만, 사용자정의 DSL을 만드는 방법도 알아 두면 좋습니다.  

#### Item 35.1. 사용자 정의 DSL 만들기  
<br/>

사용자 정의 DSL을 만드는 방법을 이해하려면, 리시버를 사용하는 함수 타입에 대한 개념을 이해해야 합니다.  

+ 함수 타입  
함수로 사용할 수 있는 객체를 나타내는 타입  

함수 타입의 몇 가지 예를 살펴봅시다.  

+ ()->Unit: 아규먼트를 갖지 않고, Unit을 리턴하는 함수입니다.
+ (Int)->Unit: Int를 아규먼트로 받고, Unit을 리턴하는 함수입니다.
+ (Int)-Int: Int를 아규먼트로 받고, Int를 리턴하는 함수입니다.
+ (Int, Int)->Int: Int 2개를 아규먼트로 받고, Int를 리턴하는 함수입니다.
+ (Int)->()->Unit: Int를 아규먼트로 받고, 다른 함수를 리턴하는 함수입니다. 이때 다른 함수는 아규먼트로 아무것도 받지 않고, Unit을 리턴합니다.
+ (()->Unit)->Unit: 다른 함수를 아규먼트로 받고, Unit을 리턴하는 함수입니다. 이때 다른 함수는 아규먼트로 아무것도 받지 않고, Unit을 리턴합니다.  

함수 타입을 만드는 기본적인 방법은 다음과 같습니다.  

+ 익명 함수: 이름을 갖고 있지 않는 함수
+ 람다 표현식: 익명 함수를 짧게 작성할 수 있는 표기 방법
+ 함수 레퍼런스  

+ 리시버를 가진 함수 타입  
확장 함수를 나타내는 특별한 타입  

리시버를 가진 익명 확장 함수와 람다 표현식은 다음과 같은 방법으로 호출할 수 있습니다.  

+ 일반적인 객체처럼 invoke 메서드를 사용
+ 확장 함수가 아닌 함수처럼 사용
+ 일반적인 확장 함수처럼 사용  

이처럼 리시버를 가진 함수 타입의 가장 중요한 특징은 this의 참조 대상을 변경할 수 있다는 것입니다. this는 apply 함수에서 리시버 객체의 메서드와 프로퍼티를 간단하게 참조할 수 있게 해 주기도 합니다.  

리시버를 가진 함수 타입은 코틀린 DSL을 구성하는 가장 기본적인 블록입니다.  

#### Item 35.2. 언제 사용해야 할까?  
<br/>

DSL은 다음과 같은 것을 표현하는 경우에 유용합니다.  

+ 복잡한 자료 구조
+ 계층적인 구조
+ 거대한 양의 데이터  

DSL 업싱 빌더 또는 단순하게 생성자만 활용해도 원하는 모든 것을 표현할 수 있습니다. DSL은 많이 사용되는 구조의 반복을 제거할 수 있게 해 줍니다. 많이 사용되는 반복되는 코드가 있고, 이를 간단하게 만들 수 있는 별도의 코틀린 기능이 없다면, DSL 사용을 고려해 보는 것이 좋습니다.  

### Item 36. 상속보다는 컴포지션을 사용하라  
<br/>

#### Item 36.1. 간단한 행위 재사용  
<br/>

+ 상속은 몇 가지 단점이 있습니다. 상속을 사용해서 행위를 추출하다 보면, 많은 함수를 갖는 거대한 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어집니다.  
+ 상속은 클래스의 모든 것을 가져오게 됩니다. 따라서 불필요한 함수를 갖는 클래스가 만들어질 수 있습니다(인터페이스 분리 원칙(Interface Segregation Principle)을 위반하게 됩니다).
+ 상속은 이해하기 어렵습니다. 일반적으로 개발자가 메서드를 읽고, 메서드의 작동 방식을 이해하기 위해 슈퍼클래스를 여러 번 확인해야 한다면, 문제가 있는 것입니다.  

이러한 이유 때문에 다른 대안을 사용하는 것이 좋습니다. 대표적인 대안은 바로 컴포지션(composition)입니다. 컴포지션을 사용한다는 것은 객체를 프로퍼티로 갖고, 함수를 호출하는 형태로 재사용한다는 것을 의미합니다.  

또한 컴포지션을 활용하면, 하나의 클래스 내부에서 여러 기능을 재사용할 수 있게 됩니다.  

하나 이상의 클래스를 상속할 수는 없습니다. 따라서 상속으로 이를 구현하려면, 두 기능을 하나의 슈퍼클래스에 배치해야 합니다. 이 때문에 클래스들에 복잡한 계층 구조가 만들어질 수 있습니다. 이러한 계층 구조는 이해하기도 어렵고, 수정하기도 어렵습니다.  

상속은 슈퍼클래스의 모든 것을 가져옵니다. 필요한 것만 가져올 수는 없습니다. 따라서 이런 형태로 활용하는 것은 좋지 않습니다.  

#### Item 36.2. 모든 것을 가져올 수밖에 없는 상속  
<br/>

상속은 슈퍼클래스의 메서드, 제약, 행위 등 모든 것을 가져옵니다. 따라서 상속은 객체의 계층 구조를 나타낼 때 굉장히 좋은 도구입니다. 하지만 일부분을 재사용하기 위한 목적으로는 적합하지 않습니다. 일부분만 재사용하고 싶다면, 컴포지션을 사용하는 것이 좋습니다. 컴포지션은 우리가 원하는 행위만 가져올 수 있기 때문입니다.  

참고로 무조건 좋다는 것은 아닙니다. 만약 타입 계층 구조를 표현해야 한다면, 인터페이스를 활용해서 다중 상속을 하는 것이 좋을 수도 있습니다.  

#### Item 36.3. 캡슐화를 깨는 상속  
<br/>

상속을 활용할 때는 외부에서 이를 어떻게 활용하는지도 중요하지만, 내부적으로 이를 어떻게 활용하는지도 중요합니다. 내부적인 구현 방법 변경에 의해서 클래스의 캡슐화가 깨질 수 있기 때문입니다.  

+ 위임 패턴  
클래스가 인터페이스를 상속받게 하고, 포함한 객체의 메서드들을 활용해서, 인터페이스에서 정의한 메서드를 구현한 패턴  

+ 포워딩 메서드(forwarding method)  
위임 패턴으로 구현된 메서드  

상속된 메서드를 직접 활용하는 것이 위험할 때는 위임 패턴을 사용하는 것이 좋습니다. 하지만 사실 일반적으로 다형성이 그렇게까지 필요한 경우는 없습니다. 그래서 단순하게 컴포지션을 활용하면 해결되는 경우가 굉장히 많습니다. 컴포지션을 사용한 코드는 이해하기 쉬우며, 유연하기까지 합니다. 이러한 경우에는 위임(delegation)을 사용하지 않는 컴포지션이 훨씬 더 이해하기 쉽고 유연하므로 더 적합합니다.  

상속으로 캡슐화를 깰 수 있다는 사실은 보안 문제입니다. 하지만 대부분의 경우에 이러한 행위는 규약으로 지정되어 있거나, 서브클래스에 의존할 필요가 없는 경우입니다(일반적으로 메서드가 상속을 위해서 설계된 경우입니다). 최종적으로 정리하면, 컴포지션을 사용하는 데는 여러 가지 이유가 있습니다. 컴포지션은 재사용하기 쉽고, 더 많은 유연성을 제겅하기 때문입니다.  

#### Item 36.4. 오바라이딩 제한하기  
<br/>

개발자가 상속용으로 설계되지 않은 클래스를 상속하지 못하게 하려면, final을 사용하면 됩니다. 그런데 만약 어떤 이유로 상속은 허용하지만, 메서드는 오버라이드하지 못하게 만들고 싶은 경우가 있을 수 있습니다. 이러한 경우에는 메서드에 open 키워드를 사용합니다. open 클래스는 open 메서드만 오버라이드할 수 있습니다.  

상속용으로 설계된 메서드에만 open을 붙이면 됩니다. 참고로 메서드를 오버라이드할 때, 서브클래스에서 해당 메서드에 final을 붙일 수도 있습니다.  

이를 활용하면 서브클래스에서 오버라이드할 수 있는 메서드를 제한할 수 있습니다.  

#### Item 36.5. 정리  
<br/>

컴포지션과 상속은 다음과 같은 차이가 있습니다.  

+ 컴포지션은 더 안전합니다. 다른 클래스의 내부적인 구현에 의존하지 않고, 외부에서 관찰되는 동작에만 의존하므로 안전합니다.
+ 컴포지션은 더 유연합니다. 상속은 한 클래스만을 대상으로 할 수 있지만, 컴포지션은 여러 클래스를 대상으로 할 수 있습니다. 상속은 모든 것을 받지만, 컴포지션은 필요한 것만 받을 수 있습니다. 슈퍼클래스의 동작을 변경하면, 서브클래스의 동작도 큰 영향을 받습니다. 하지만 컴포지션을 활용하면, 이러한 영향이 제한적입니다.
+ 컴포지션은 더 명시적입니다. 이것은 장점이자 단점이라고 할 수 있습니다. 슈퍼클래스의 메서드를 사용할 때는 리시버를 따로 지정하지 않아도 됩니다(this 키워드를 사용하지 않아도 됩니다). 덜 명시적입니다. 즉, 코드가 짧아질 수 있지만, 메서드가 어디에서 왔는지 혼동될 수 있으므로 위험할 수 있습니다. 컴포지션을 활용하면, 리시버를 명시적으로 활용할 수밖에 없으므로 메서드가 어디에 있는 것인지 확실하게 알 수 있습니다.
+ 컴포지션은 생각보다 번거롭습니다. 컴포지션은 객체를 명시적으로 사용해야 하므로, 대상 클래스에 일부 기능을 추가할 때 이를 포함하는 객체의 코드를 변경해야 합니다. 그래서 상속을 사용할 때보다 코드를 수정해야 하는 경우가 더 많습니다.
+ 상속은 다형성을 활용할 수 있습니다. 이것은 양날의 검입니다. 상속을 사용할 경우 슈퍼클래스와 서브클래스의 규약을 항상 잘 지켜서 코드를 작성해야 합니다.  

일반적으로 OOP에서는 상속보다 컴포지션을 사용하는 것이 좋습니다. 코틀린에서는 더욱 이런 규칙을 지켜 주는 것이 좋습니다.  

그렇다면 상속은 언제 사용하면 좋을까요? 명확한 'is-a 관계'일 때 상속을 사용하는 것이 좋습니다. 슈퍼클래스를 상속하는 모든 서브클래스는 슈퍼클래스로도 동작할 수 있어야 합니다. 슈퍼클래스의 모든 단위 테스트는 서브클래스로도 통과할 수 있어야 합니다. 슈퍼클래스의 모든 단위 테스트는 서브클래스로도 통과할 수 있어야 한다는 의미입니다(리스코브 치환 원칙). 또한 상속을 위해 설계되지 않은 메서드는 final로 만들어 두는 것이 좋습니다.  

### Item 37. 데이터 집합 표현에 data 한정자를 사용하라  
<br/>

때로는 데이터들을 한꺼번에 전달해야 할 때가 있습니다. 일반적으로 이러한 상황에 다음과 같은 클래스를 사용합니다.  

data 한정자를 붙이면, 다음과 같은 몇 가지 함수가 자동으로 생성됩니다.  

+ toString
+ equals와 hashCode
+ copy
+ componentN(component1, component2 등)  

equals는 기본 생성자의 프로퍼티가 같은지 확인해 줍니다. 그리고 hashCode는 equals와 같은 결과를 냅니다.  

copy는 immutable 데이터 클래스를 만들 때 편리합니다. copy는 기본 생성자 프로퍼티가 같은 새로운 객체를 복제합니다. 새로 만들어진 객체의 값은 이름있는 아규먼트를 활용해서 변경할 수 있습니다.  

이러한 copy 메서드는 data 한정자를 붙이기만 하면 자동으로 만들어지므로, 그 구현을 볼 수도 없고, 볼 필요도 없습니다.  

또한 copy 메서드는 객체를 얕은 복사하지만, 이것은 객체가 immutable이라면 아무런 상관이 없습니다. immutable 객체는 깊은 복사한 객체가 필요 없기 때문입니다.  

componentN 함수(component1, component2 등)는 위치를 기반으로 객체를 해제할 수 있게 해 줍니다. 다음 코드를 살펴봅시다.  

```kotlin
val (id, name, pts) = player
```

이렇게 객체를 해제하는 코드를 작성하면, 코틀린은 내부적으로 componentN 함수를 사용하는 다음과 같은 코드로 변환합니다.  

```kotlin
// 컴파일 후
val id: Int = player.component1()
val name: String = player.component2()
val pts: Int = player.component3()
```

이렇게 위치를 기반으로 객체를 해제하는 것은 장점도 있고, 단점도 있습니다. 가장 큰 장점은 변수의 이름을 원하는 대로 지정할 수 있다는 것입니다. 또한 componentN 함수만 있다면, List와 Map.Entry 등의 원하는 형태로도 객체를 해제할 수 있습니다.  

하지만 위치를 잘못 지정하면, 다양한 문제가 발생할 수 잇어서 위험합니다. 위치 순서를 혼동해서 객체를 잘못 해제하는 문제는 굉장히 자주 발생합니다.  

객체를 해제할 때는 주의해야 하므로 데이터 클래스의 기본 생성자에 붙어 있는 프로퍼티 이름과 같은 이름을 사용하는 것이 좋습니다. 그렇게 하면 순서 등을 잘못 지정했을 때, 인텔리제이와 안드로이드 스튜디오가 관련된 경고를 줍니다. 이런 경고는 굉장히 유용하므로, 경고 대신 오류로 업그레이드해도 좋습니다.  

참고로 값을 하나만 갖는 데이터 클래스는 해제하지 않는 것이 좋습니다.  

읽는 사람에게 혼동을 줄 수 있습니다. 특히 람다 표현식과 함께 활용될 때 문제가 됩니다.  

일부 프로그래밍 언어에서는 람다 표현식이 아규먼트 주변에 감싸는 괄호를 입력해도 되고, 입력하지 않아도 되므로 문제가 됩니다.  

#### Item 37.1. 튜플 대신 데이터 클래스 사용하기  
<br/>

데이터 클래스는 튜플보다 많은 것을 제공합니다. 구체적으로 코틀린의 튜플은 Serializable을 기반으로 만들어지며, toString을 사용할 수 있는 제네렉 데이터 클래스입니다.  

Pair, Triple은 코틀린에 남아 있는 마지막 튜플입니다. 과거에는 (Int, String, String, Long)처럼 괄호와 타입 지정을 통해 원하는 형태의 튜플을 정의할 수 있었습니다. 튜플은 데이터 클래스와 같은 역할을 하지만, 훨씬 가독성이 나빴습니다. 튜플만 보고는 어떤 타입을 나타내는지 예측할 수 없습니다. 튜플은 굉장히 좋아 보였지만, 언제나 데이터 클래스를 사용하는 것이 더 좋았기 때문에 점차 없어진 것입니다. Pair와 Triple은 몇 가지 지역적인 목적으로 남아 있을 뿐입니다.  

+ 값에 간단하게 이름을 붙일 때
+ 표준 라이브러리에서 볼 수 있는 것처럼 미리 알 수 없는 aggregate(집합)를 표현할 때  

이 경우들을 제외하면 무조건 데이터 클래스를 사용하는 것이 좋습니다.  

### Item 38. 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라  
<br/>

+ SAM(Single-Abstract Method)  
연산 또는 액션을 전달할 때 메서드가 하나만 있는 인터페이스  

참고로, SAM의 장점은 '그 아규먼트에 이름이 붙어 있는 것'이라고 말하는 사람도 있습니다. 하지만 타입 별칭(type alias)을 사용하면, 함수 타입도 이름을 붙일 수 있습니다.  

```kotlin
typealias OnClick = (View) -> Unit
```

파라미터도 이름을 가질 수 있습니다. 이름을 붙이면, IDE의 지원을 받을 수 있다는 굉장히 큰 장점이 있습니다.  

람다 표현식을 사용할 때는 아규먼트 분해(destructure argument)도 사용할 수 있습니다. 이것도 SAM보다 함수 타입을 사용하는 것이 훨씬 더 좋은 이유입니다.  

여러 옵저버를 설정할 때, 이 장점을 확인할 수 있습니다.  

API를 소비하는 사용자의 관점에서는 함수 타입을 따로따로 갖는 것이 훨씬 사용하기 쉽습니다.  

인터페이스를 사용해야 하는 특별한 이유가 없다면, 함수 타입을 활용하는게 좋습니다. 함수 타입은 다양한 지원을 받을 수 있으며, 코틀린 개발자들 사이에서 이미 널리 사용되고 있습니다.  

#### Item 38.1. 언제 SAM을 사용해야 할까?  
<br/>

딱 한 가지 경우에는 SAM을 사용하는 것이 좋습니다. 코틀린이 아닌 다른 언어에서 사용할 클래스를 설계할 때입니다. 자바에서는 인터페이스가 더 명확합니다. 함수 타입으로 만들어진 클래스는 자바에서 타입 별칭과 IDE의 지원 등을 제대로 받을 수 없습니다. 마지막으로 다른 언어(자바 등)에서 코틀린의 함수 타입을 사용하려면, Unit을 명시적으로 리턴하는 함수가 필요합니다.  

자바에서 사용하기 위한 API를 설계할 때는 함수 타입보다 SAM을 사용하는 것이 합리적입니다. 하지만 이외의 경우에는 함수 타입을 사용하는 것이 좋습니다.  

### Item 39. 태그 클래스보다 클래스 계층을 사용하라  
<br/>

큰 규모의 프로젝트에서는 상수(constant) '모드'를 가진 클래스를 꽤 많이 볼 수 있습니다. 이러한 상수 모드를 태그(tag)라고 부르며, 태그를 포함한 클래스를 태그 클래스(tagged class)라고 부릅니다. 그런데 태그 클래스는 다양한 문제를 내포하고 있습니다. 이러한 문제는 서로 다른 책임을 한 클래스에 태그로 구분해서 넣는다는 것에서 시작합니다.  

+ 한 클래스에 여러 모드를 처리하기 위한 상용구(boilerplate)가 추가됩니다.
+ 여러 목적으로 사용해야 하므로 프로퍼티가 일관적이지 않게 사용될 수 있으며, 더 많은 프로퍼티가 필요합니다.  
+ 요소가 여러 목적을 가지고, 요소를 여러 방법으로 설정할 수 있는 경우에는 상태의 일관성과 정확성을 지키기 어렵습니다.
+ 팩토리 메서드를 사용해야 하는 경우가 많습니다. 그렇지 않으면 객체가 제대로 생성되었는지 확인하는 것 자체가 굉장히 어렵습니다.  

코틀린은 그래서 일반적으로 태그 클래스보다 sealed 클래스를 많이 사용합니다. 한 클래스에 여러 모드를 만드는 방법 대신에, 각각의 모드를 여러 클래스로 만들고 타입 시스템과 다형성을 활용하는 것입니다. 그리고 이러한 클래스에는 sealed 한정자를 붙여서 서브클래스 정의를 제한합니다.  

이렇게 구현하면 책임이 분산되므로 훨씬 깔끔합니다. 각각의 객체들은 자신에게 필요한 데이터만 있으며, 적절한 파라미터만 갖습니다. 이와 같은 계층을 사용하면, 태그 클래스의 단점을 모두 해소할 수 있습니다.  

#### Item 39.1. sealed 한정자  
<br/>

반드시 sealed 한정자를 사용해야 하는 것은 아닙니다. 대신 abstract 한정자를 사용할 수도 있지만, sealed 한정자는 외부 파일에서 서브클래스를 만드는 행위 자체를 모두 제한합니다. 외부에서 추가적인 서브클래스를 만들 수 없으므로, 타입이 추가되지 않을 거라는 게 보장됩니다. 따라서 when을 사용할 때 else 브랜치를 따로 만들 필요가 없습니다. 이러한 장점을 이용해서 새로운 기능을 쉽게 추가할 수 있으며, when 구문에서 이를 처리하는 것을 잊어버리기 않을 수도 있습니다.  

when은 모드를 구분해서 다른 처리를 만들 때 굉장히 편리합니다.  

반면 abstract 키워드를 사용하면, 다른 개발자가 새로운 인스턴스를 만들엇 사용할 수도 있습니다. 이러한 경우에는 함수를 abstract로 선언하고, 서브클래스 내부에 구현해야 합니다. when을 사용하면, 프로젝트 외부에서 새로운 클래스가 추가될 때 함수가 제대로 동작하지 않을 수 있기 때문입니다.  

sealed 한정자를 사용하면, 확장 함수를 사용해서 클래스에 새로운 함수를 추가하거나, 클래스의 다양한 변경을 쉽게 처리할 수 있습니다. abstract 클래스는 계층에 새로운 클래스를 추가할 수 있는 여지를 남깁니다. 클래스의 서브클래스를 제어하려면, sealed 한정자를 사용해야 합니다. abstract는 상속과 관련된 설계를 할 때 사용합니다.  

#### Item 39.2. 태그 클래스와 상태 패턴의 차이  
<br/>

태그 클래스와 상태 패턴(state pattern)을 혼동하면 안 됩니다.  

+ 상태 패턴  
객체의 내부 상태가 변화할 때, 객체의 동작이 변하는 소프트웨어 디자인 패턴으로 프런트엔드 컨트롤러(controller), 프레젠터(presenter), 뷰(view) 모델을 설계할 때 많이 사용됩니다(각각 MVC, MVP, MVVM 아키텍처에서).  

상태 패턴을 사용한다면, 서로 다른 상태를 나타내는 클래스 계층 구조를 만들게 됩니다. 그리고 현재 상태를 나타내기 위한 읽고 쓸 수 있는 프로퍼티도 만들게 됩니다.  

여기에서 차이점은 다음과 같습니다.  

+ 상태는 더 많은 책임을 가진 큰 클래스입니다.
+ 상태는 변경할 수 있습니다.  

구체 상태(concrete state)는 객체를 활용해서 표현하는 것이 일반적이며, 태그 클래스보다는 sealed 클래스 계층으로 만듭니다. 또한 이를 immutable 객체로 만들고, 변경해야 할 때마다 state 프로퍼티를 변경하게 만듭니다. 그리고 뷰에서 이러한 state의 변화를 관찰(observe)합니다.  

#### Item 39.3. 정리  
<br/>

코틀린에서는 태그 클래스보다 타입 계층을 사용하는 것이 좋습니다. 그리고 일반적으로 이러한 타입 계층을 만들 때는 sealed 클래스를 사용합니다. 이는 상태 패턴과는 다릅니다. 타입 계층과 상태 패턴은 실질적으로 함께 사용하는 협력 관계라고 할 수 있습니다. 하나의 뷰를 가지는 경우보다는 여러 개의 상태로 구분할 수 있는 뷰를 가질 때 많이 활용됩니다.  

### Item 40. equals의 규약을 지켜라  
<br/>

#### Item 40.1. 동등성  
<br/>

코틀린에는 두 가지 종류의 동등성(equality)이 있습니다.  

+ 구조적 동등성(structural equality): equals 메서드와 이를 기반으로 만들어진 == 연산자(!= 포함)로 확인하는 동등성입니다. a가 nullable이 아니라면 a == b는 a.equals(b)로 변환되고, a가 nullable이라면 a?.equals(b) ?: (b === null)로 변환됩니다.
+ 레퍼런스적 동등성(referential equality): === 연산자(!== 포함)로 확인하는 동등성입니다. 두 피연산자가 같은 객체를 가리키면, true를 리턴합니다.  

equals는 모든 클래스의 슈퍼클래스인 Any에 구현되어 있으므로, 모든 객체에서 사용할 수 있습니다. 다만 연산자를 사용해서 다른 타입의 두 객체를 비교하는 것은 허용되지 않습니다.  

물론 다음과 같이 같은 타입을 비교하거나, 둘이 상속 관계를 갖는 경우에는 비교할 수 있습니다.  

다른 타입의 두 객체를 비교하는 것은 큰 의미가 없으므로, 이렇게 구현되어 있는 것입니다.  

#### Item 40.2. equals가 필요한 이유  
<br/>

Any 클래스에 구현되어 있는 equals 메서드는 디폴트로 ===처럼 두 인스턴스가 완전히 같은 객체인지를 비교합니다. 이는 모든 객체는 디폴트로 유일한 객체라는 것을 의미합니다.  

이러한 동작은 데이터베이스 연결, 리포지토리, 스레드 등의 활동 요소(active element)를 활용할 때 굉장히 유용합니다. 하지만 동등성을 약간 다른 형태로 표현해야 하는 객체가 있습니다.  

데이터 클래스는 내부에 어떤 값을 갖고 있는지가 중요하므로, 이와 같이 동작하는 것이 좋습니다. 그래서 일반적으로 데이터 모델을 표현할 때 data 한정자를 붙입니다.  

데이터 클래스의 동등성은 모든 프로퍼티가 아니라 일부 프로퍼티만 비교해야 할 때도 유용합니다. 일반적으로 캐시를 위한 객체는 캐시에 영향을 주지 않는 프로퍼티가 복사되지 않는 것이 좋습니다.  

참고로, 기본 생성자에 선언되지 않은 프로퍼티는 copy로 복사되지 않습니다. 기본 생성자에 선언되지 않은 프로퍼티까지 복사하는 것은 굉장히 의미 없는 일이므로, 기본 생성자에 선언되지 않은 것을 복사하지 않는 동작은 올바른 동작이라고 할 수 있습니다.  

이렇게 data 한정자를 기반으로 동등성의 동작을 조작할 수 있으므로, 일반적으로 코틀린에서는 equals를 직접 구현할 필요가 없습니다. 다만 상황에 따라서 equals를 직접 구현해야 하는 경우가 있을 수도 있습니다.  

equals를 직접 구현해야 하는 경우를 정리해 보면, 다음과 같습니다.  

+ 기본적으로 제공되는 동작과 다른 동작을 해야 하는 경우
+ 일부 프로퍼티만으로 비교해야 하는 경우
+ data 한정자를 붙이는 것을 원하지 않거나, 비교해야 하는 프로퍼티가 기본 생성자에 없는 경우  

#### Item 40.3. equals의 규약  
<br/>

구현은 반드시 다음과 같은 요구 사항을 충족해야 한다.

+ 반사적(reflective) 동작: x가 널(null)이 아닌 값이라면, x.equals(x)는 true를 리턴해야 한다.
+ 대칭적(symmetric) 동작: x와 y가 널이 아닌 값이라면, x.equals(y)는 y.equals(x)와 같은 결과를 출력해야 한다.
+ 연속적(transitive) 동작: x, y, z가 널이 아닌 값이고 x.equals(y)와 y.equals(z)가 true라면, x.equals(z)도 true여야 한다.
+ 일관적(consistent) 동작: x와 y가 널이 아닌 값이라면, x.equals(y)는 (비교에 사용되는 프로퍼티를 변경한 것이 아니라면) 여러 번 실행하더라도 항상 같은 결과를 리턴해야 한다.
+ 널과 관련된 동작: x가 널이 아닌 값이라면, x.equals(null)은 항상 false를 리턴해야 한다.  

추가로, equals, toString, hashCode의 동작은 매우 빠를 거라 예측되므로, 빠르게 동작해야 합니다. 이는 공식 문서에는 없는 규약이지만, 두 요소가 같은지 확인하는 동작에 몇 초가 걸리는 것은 일반적으로 예측하지 못하는 동작입니다.  

요구 사항은 모두 중요합니다. 이 요구 사항들은 자바 때부터 정의되었으며, 코틀린에서도 처음부터 정의된 내용입니다. 따라서 수많은 객체가 이러한 동작에 의존해서 만들어졌습니다.  

#### Item 40.4. URL과 관련된 equals 문제  
<br/>

equals를 굉장히 잘못 설계한 예로는 java.net.URL이 있습니다. java.net.URL 객체 2개를 비교하면 동일한 IP 주소로 해석될 때는 true, 아닐 때는 false가 나옵니다. 문제는 이 결과가 네트워크 상태에 따라서 달라진다는 것입니다.  

이 설계의 문제점을 정리해 보면, 다음과 같습니다.  

+ 동작이 일관되지 않습니다. 네트워크가 정상이라면 두 URL이 같고, 문제가 있다면 다릅니다. 네트워크 설정에 따라서도 결과가 달라질 수 있습니다. 주어진 호스트의 IP 주소는 시간과 네트워크 상황에 따라서 다릅니다. 어떤 네트워크에서는 두 URL이 같을 수 있지만, 다른 네트워크에서는 또 다를 수 있습니다.
+ 일반적으로 equals와 hashCode 처리는 빠를 거라 예상하지만, 네트워크 처리는 굉장히 느립니다. URL이 어떤 리스트 내부에 있는지 확인하는 경우를 생각해 봅시다. 이러한 작업을 할 때, 각가의 요소(URL)에 대해 네트워크 호출이 필요할 것입니다. 따라서 일반적으로 예상되는 속도보다 느리게 동작합니다. 또한 안드로이드 등과 같은 일부 플랫폼에서는 기본 쓰레드에서 네트워크 작업이 금지됩니다. 이런 환경에서는 URL을 세트(set)에 추가하는 기본적인 조작도 쓰레드를 나누어서 해야 합니다.
+ 동작 자체에 문제가 있습니다. 동일한 IP 주소를 갖는다고, 동일한 콘텐츠를 나타내는 것은 아닙니다. 가상 호스팅(virtual hosting)을 한다면, 관련 없는 사이트가 같은 IP 주소를 공유할 수도 있습니다. 현재 java.net.URL은 이런 경우에도 비교하면, 무조건 true를 리턴합니다.  

안드로이드는 Android 4.0(Ice Create Sandwich) 버전부터 이러한 내용이 수정되었습니다. 이 배포 버전부터는 호스트 이름이 동일할 때만 true를 리턴합니다. 코틀린/JVM 또는 다른 플랫폼을 사용할 때는 java.net.URL이 아니라 java.net.URI를 사용해서 이런 문제를 해결합니다.  

#### Item 40.5. equals 구현하기  
<br/>

특별한 이유가 없는 이상, 직접 equals를 구현하는 것은 좋지 않습니다. 기본적으로 제공되는 것을 그래도 쓰거나, 데이터 클래스로 만들어서 사용하는 것이 좋습니다. 기본적으로 제공되는 것을 그래도 쓰거나, 데이터 클래스로 만들어서 사용하는 것이 좋습니다. 그래도 직접 구현해야 한다면, 반사적, 대칭적, 연속적, 일관적 동작을 하는 곡 확인하세요. 그리고 이러한 클래스는 final로 만드는 것이 좋습니다. 만약 상속을 한다면, 서브클래스에서 equals가 작동하는 방식을 변경하면 안 된다는 것을 기억하세요. 상속을 지원하면서도 완벽한 사용자 정의 equals 함수를 만드는 것은 거의 불가능에 가깝습니다. 참고로 데이터 클래스는 언제나 final입니다.  

### Item 41. hashCode의 규약을 지켜라  
<br/>

#### Item 41.1. 해시 테이블  
<br/>

컬렉션에 요소를 빠르게 추가하고, 컬렉션에서 요소를 빠르게 추출해야 한다고 해 봅시다. 이럴 때 사용할 수 있는 컬렉션으로는 세트와 맵이 있습니다. 이 둘은 중복을 허용하지 않습니다. 따라서 요소를 추가할 때, 일단 동일한 요소가 이미 들어 있는지 확인해야 합니다.  

배열 또는 링크드 리스트를 기반으로 만들어진 컬렉션은 요소가 포함되어 있는지 확인하는 성능이 좋지 않습니다. 요소가 포함되어 있는지 확인할 때 하나하나 모든 요소와 비교해야 하기 때문입니다. 수백 만 개의 텍스트가 포함된 배열에 특정 테스트가 포함되어 있는지 확인해야 한다고 합시다. 수백 만 개의 텍스트를 선형으로 비교한다면, 꽤 오랜 시간이 걸릴 것입니다.  

성능을 좋게 만드는 해결 방법이 바로 해시 테이블입니다. 해시 테이블은 각 요소에 숫자를 할당하는 함수가 필요합니다. 이 함수를 해시 함수라고 부르며, 같은 요소라면 항상 같은 숫자를 리턴합니다. 추가로, 해시 함수가 다음과 같은 특성을 갖고 있으면 좋습니다.  

+ 빠르다.
+ 충돌이 적다(다른 값이라면 최대한 다른 숫자를 리턴한다는 의미입니다).  

해시 함수는 각각의 요소에 특정한 숫자를 할당하고, 이를 기반으로 요소를 다른 버킷(bucket, 통)에 넣습니다. 또한 해시 함수의 기본적인 조건(같은 요소라면 항상 같은 숫자를 리턴한다)에 의해서, 같은 요소는 항상 동일한 버킷에 넣게 됩니다. 버킷은 버킷 수와 같은 크기의 배열인 해시 테입르에 보관됩니다. 요소를 추가하는 경우에는 해시 함수로 배치할 버킷을 계산하고, 이 버킷 안에 요소를 추가합니다(버킷은 배열처럼 구현됩니다). 해시 함수의 속도는 빨라야 하므로 이 처리는 굉장히 빠르게 이루어집니다. 요소를 찾는 경우에도 해시 함수로 만들어지는 숫자를 활용해 버킷을 찾은 뒤, 버킷 내부에서 원하는 요소를 찾습니다. 해시 함수는 같은 요소라면 같은 값을 리턴하므로, 다른 버킷을 확인할 필요 없이 바로 원하는 것이 들어 있는 버킷을 찾을 수 있습니다. 예를 들어 1,000,000개의 요소와 1,000개의 버킷이 있는 경우, 버킷을 특정한 후에 해당 버킷 내부에 원하는 요소가 있는지 찾으면 됩니다. 버킷 하나에 평균 1,000개의 요소가 들어 있을 것이므로 1,000번만 비교하면 됩니다.  

#### Item 41.2. 가변성과 관련된 문제  
<br/>

요소가 추가될 때만 해시 코드를 계산합니다. 요소가 변경되어도 해시 코드는 계산되지 않으며, 버킷 재배치도 이루어지지 않습니다. 그래서 기본적인 LinkedHashSet과 'LinkedHashMap의 키'는 한 번 추가한 요소를 변경할 수 없습니다.  

그래서 해시 등이 'mutable 프로퍼티로 요소를 조합하는 자료 구조'에서는 mutable 객체가 사용되지 않습니다. 따라서 세트와 맵의 키로 mutable 요소를 사용하면 안 되며, 사용하더라도 요소를 변경해서는 안 됩니다. 이러한 이유로 immutable 객체를 많이 사용합니다.  

#### Item 41.3. hashCode의 규약  
<br/>

hashCode는 명확한 규약이 있습니다. 코틀린 1.3.11을 기준으로 공식적인 규약을 정리해 보면, 다음과 같습니다.  

+ 어떤 객체를 변경하지 않았다면(equals에서 비교에 사용된 정보가 수정되지 않는 이상), hashCode는 여러 번 호출해도 그 결과가 항상 같아야 합니다.
+ equals 메서드의 실행 결과로 두 객체가 같다고 나온다면, hashCode 메서드의 호출 결과도 같다고 나와야 합니다.  

첫 번재 요구 사항은 일관성 유지를 위해서 hashCode가 필요하다는 것입니다. 두 번재 요구 사항은 많은 개발자가 자주 잊어버리는 것들 중 하나이므로 강조되어야 합니다. hashCode는 equals와 같이 일관성 있는 동작을 해야 합니다. 즉, 같은 요소는 반드시 같은 해시 코드를 가져야 한다는 의미입니다. 그렇지 않으면 컬렉션 내부에 요소가 들어 있는지 제대로 확인하지 못하는 문제가 발생할 수 있습니다.  

그래서 코틀린은 equals 구현을 오버라이드할 때, hashCode도 함께 오버라이드하는 것을 추천합니다.  

필수 요구 사항은 아니지만 제대로 사용하려면 지켜야 하는 요구 사항이 있습니다. 바로 hashCode는 최대한 요소를 넓게 퍼뜨려야 한다는 것입니다. 다른 요소라면 최대한 다른 해시 값을 갖는 것이 좋습니다.  

많은 요소가 같은 버킷에 배치되는 경우를 생각해 봅시다. 해시 테이블을 쓴 이유 자체가 없어질 것입니다.  

#### Item 41.4. hashCode 구현하기  
<br/>

일반적으로 data 한정자를 붙이면, 코틀린이 알아서 적당한 equals와 hashCode를 정의해 주므로 이를 직접 정의할 일은 거의 없습니다. 다만 equals를 따로 정의했다면, 반드시 hashCode도 함께 정의해 줘야 합니다. equals를 따로 정의하지 않았다면, 정당한 이유가 없는 이상 hashCode를 따로 정의하지 않는 것이 좋습니다. equals로 같은 요소라고 판정되는 요소는 hashCode가 반드시 같은 값을 리턴해야 합니다.  

hashCode는 기본적으로는 equals에서 비교에 사용되는 프로퍼티를 기반으로 해시 코드를 만들어야 합니다. 해시 코드를 어떻게 만들어 낼까요? 일반적으로 모든 해시 코드의 값을 더합니다. 더하는 과정마다 이전까지의 결과에 31을 곱한 뒤 더해 줍니다. 물론 31일 필요는 없지만, 관례적으로 31을 많이 사용합니다. data 한정자를 붙일 때도 이렇게 구현됩니다.  

이때 유용한 함수로는 코틀린/JVM의 Objects.hashCode가 있습니다. 이 함수는 해시를 계산해 줍니다.  

코틀린 stdlib에는 이러한 함수가 따로 없습니다. 따라서 다른 플랫폼에서는 다음과 같은 함수를 구현해서 사용해야 합니다.  

```kotlin
override fun hashCode(): Int = hashCodeOf(timezone, millis)

inline fun hashCodeOf(vararg values: Any?) =
    values.fold(0) { acc, value ->
        (acc * 31) + value.hashCode()
    }
```

코틀린 stdlib이 이러한 함수를 기본적으로 제공하지 않는 이유는 사실 hashCode를 우리가 직접 구현할 일이 거의 없기 때문입니다.  

hashCode를 구현할 때 가장 중요한 규칙은 '언제나 equals와 일관된 결과가 나와야 한다'입니다. 같은 객체라면 언제나 같은 값을 리턴하게 만들어 주세요.  

### Item 42. compareTo의 규약을 지켜라  
<br/>

compareTo 메서드는 Any 클래스에 있는 메서드가 아닙니다. 이는 수학적인 부등식으로 변환되는 연산자입니다.  

참고로 compareTo 메서드는 Comparable<T> 인터페이스에도 들어 있습니다. 어떤 객체가 이 인터페이스를 구현하고 있거나 compareTo라는 연산자 메서드를 갖고 있다는 의미는 해당 객체가 어떤 순서를 갖고 있으므로, 비교할 수 있다는 것입니다. compareTo는 다음과 같이 동작해야 합니다.  

+ 비대칭적 동작: a >= b이고 b >= a라면, a == b여야 합니다. 즉, 비교와 동등성 비교에 어떠한 관계가 있어야 하며, 서로 일관성이 있어야 합니다.
+ 연속적 동작: a >= b이고 b >= c라면, a >= c여야 합니다. 마찬가지로 a > b이고 b > c라면, a > c여야 합니다. 이러한 동작을 하지 못하면, 요소 정렬이 무한 반복에 빠질 수 있습니다.
+ 코넥스적 동작: 두 요소는 어떤 확실한 관계를 갖고 있어야 합니다. 즉, a >= b 또는 b >= a 중에 적어도 하나는 항상 true여야 합니다. 두 요소 사이에 관계가 없으면, 퀵 정렬과 삽입 정렬 등의 고전적인 정렬 알고리즘을 사용할 수 없습니다. 대신 위상 정렬(topological sort)과 같은 정렬 알고리즘만 사용할 수 있습니다.  

#### Item 42.1. compareTo를 따로 정의해야 할까?  
<br/>

코틀린에서 compareTo를 따로 정의해야 하는 상황은 거의 없습니다. 일반적으로 어떤 프로퍼티 하나를 기반으로 순서를 지정하는 것으로 충분하기 때문입니다. 예를 들어 sortedBy를 사용하면, 원하는 키로 컬렉션을 정렬할 수 있습니다.  

여러 프로퍼티를 기반으로 정렬해야 한다면 어떻게 해야 할까요? 그럴 때는 sortedWith 함수를 사용하면 됩니다. 이 함수는 다음과 같이 사용합니다. compareBy를 활용해서 비교기(comparator)를 만들엇 사용합니다.  

#### Item 42.2. compareTo 구현하기  
<br/>

compareTo를 구현할 때 유용하게 활용할 수 있는 톱레벨 함수가 있습니다. 두 값을 단순하게 비교하기만 한다면, compareValues 함수를 다음과 같이 활용할 수 있습니다.  

더 많은 값을 비교하거나, 선택기(selector)를 활용해서 비교하고 싶다면, 다음과 같이 compareValuesBy를 사용합니다.  

이 함수는 비교기를 만들 때 도움이 됩니다. 특별한 논리를 구현해야 하는 경우에는 이 함수가 다음 값을 리턴해야 한다는 것을 기억하세요.  

+ (): 리시버와 other가 같은 경우
+ 양수: 리시비가 other보다 큰 경우
+ 음수: 리시버가 other보다 작은 경우  

이를 구현한 뒤에는 이 함수가 비대칭적 동작, 연속적 동작, 코넥스적 동작을 하는지 확인하세요.  

### Item 43. API의 필수적이지 않는 부분을 확장 함수로 추출하라  
<br/>

클래스의 메서드를 정의할 때는 메서드를 멤버로 정의할 것인지 아니면 확장 함수로 정의할 것인지 결정해야 합니다.  

두 가지 방법은 거의 비슷합니다. 호출하는 방법도 비슷하고, 리플렉션으로 레퍼런싱하는 방법도 비슷합니다.  

둘의 차이점을 설명하기 전에 알아 두었으면 하는 것이 있다면, 두 방식 중에 어떤 방식이 우월하다고 할 수 없다는 것입니다. 장단점을 도무 갖고 있으므로 상황에 맞게 사용해야 합니다. 따라서 지금부터 설명하는 내용을 무조건 적용하지 말고, 반드시 검토한 후, 필요한 경우에만 사용하기 바랍니다.  

일단 멤버와 확장의 가장 큰 차이점은 확장은 따로 가져와서 사용해야 한다는 것입니다. 그래서 일반적으로 확장은 다른 패키지에 위치합니다. 확장은 우리가 직접 멤버를 추가할 수 없는 경우, 데이터와 행위(behavior)를 분리하도록 설계된 프로젝트에서 사용됩니다. 필드가 있는 프로퍼티는 클래스에 있어야 하지만, 메서드는 클래스의 public API만 활용한다면 어디에 위치해도 상관없습니다.  

임포트해서 사용한다는 특징 덕분에 확장은 같은 타입에 같은 이름으로 여러 개 만들 수도 있습니다. 따라서 여러 라이브러리에서 여러 메서드를 받을 수도 있고, 충돌이 발생하지도 않는다는 장점이 생깁니다. 하지만 같은 이름으로 다른 동작을 하는 확장이 있다는 것은 위험할 수 있습니다. 위험 가능성이 있다면, 그냥 멤버 함수로 만들어서 사용하는 것이 좋습니다. 그렇게 하면 컴파일러가 항상 확장 대신 멤버 함수를 호출할 것입니다. 다만 stdlib의 확장 함수가 kotlin.internal.HidesMembers 어노테이션을 갖고 있는 경우에느 예외입니다.  

또 다른 차이점은 확장은 가상(virtual)이 아니라는 것입니다. 즉, 파생 클래스에서 오버라이드할 수 없습니다. 확장 함수는 컴파일 시점에 정적으로 선택됩니다. 따라서 확장 함수는 가상 멤버 함수와 다르게 동작합니다. 상속을 목적으로 설계된 요소는 확장 함수로 만들면 안 됩니다.  

이러한 차이는 확장 함수가 '첫 번째 아규먼트로 리시버가 들어가는 일반 함수'로 컴파일되기 때문에 발생되는 결과입니다.  

추가로 확장 함수는 클래스가 아닌 타입에 정의하는 것입니다. 그래서 nullable 또는 구체적인 제네릭 타입에도 확장 함수를 정의할 수 있습니다.  

마지막으로 중요한 차이점은 확장은 클래스 레퍼런스에서 멤버로 표시되지 않는다는 것입니다. 그래서 확장 함수는 어노테이션 프로세서(annotation processor)가 따로 처리하지 않습니다. 따라서 필수적이지 않은 요소를 확장 함수로 추출하면, 어노테이션 프로세스로부터 숨겨집니다. 이는 확장 함수가 클래스 내부에 있는 것은 아니기 때문입니다.  

#### Item 43.1. 정리  
<br/>

멤버와 확장 함수의 차이를 비교하면, 다음과 같습니다.  

+ 확장 함수는 읽어 들여야 합니다.
+ 확장 함수는 virtual이 아닙니다.
+ 멤버는 높은 우선 순위를 갖습니다.
+ 확장 함수는 클래스 위가 아니라 타입 위에 만들어집니다.
+ 확장 함수는 클래스 레퍼런스에 나오지 않습니다.  

정리해 보면, 확장 함수는 우리에게 더 많은 자유와 유연성을 줍니다. 확장 함수는 상속, 어노테이션 처리 등을 지원하지 않고, 클래스 내부에 없으므로 약간 혼동을 줄 수도 있습니다. API의 필수적인 부분은 멤버로 두는 것이 좋지만, 필수적이지 않은 부분은 확장 함수로 만드는 것이 여러모로 좋습니다.  

### Item 44. 멤버 확장 함수의 사용을 피하라  
<br/>

어떤 클래스에 대한 확장 함수를 정의할 대, 이를 멤버로 추가하는 것은 좋지 않습니다. 확장 함수는 첫 번째 아규먼트로 리시버를 받는 단순한 일반 함수로 컴파일됩니다. 예를 들어 다음과 같은 함수는  

```kotlin
fun String.isPhoneNumber(): Boolean = 
    length == 7 && all { it.isDigit() }
```

컴파일되면, 다음과 같이 변합니다.  

```kotlin
fun isPhoneNumber('$this': String): Boolean =
    '$this'.length == 7 && '$this'.all { it.isDigit() }
```

이렇게 단순하게 변환되는 것이므로, 확장 함수를 클래스 멤버로 정의할 수도 있고, 인터페이스 내부에 정의할 수도 있습니다.  

```kotlin
interface PhoneBook {
    fun String.isPhoneNumber(): Boolean
}

class Fizz: PhoneBook {
    override fun String.isPhoneNumber(): Boolean =
        length == 7 && all { it.isDigit() }
}
```

이런 코드가 가능하지만, DSL을 만들 때를 제외하면 이를 사용하지 않는 것이 좋습니다. 특히 가시성 제한을 위해 확장 함수를 멤버로 정의하는 것은 굉장히 좋지 않습니다.  

```kotlin
// 나쁜 습관입니다. 이렇게 하지 마세요.
class PhoneBookIncorrect {
    // ...

    fun String.isPhoneNumber() = length == 7 && all { it.isDigit() }
}
```
한 가지 큰 이유는 가시성을 제한하지 못한다는 것입니다. 이는 단순하게 확장 함수를 사용하는 형태를 어렵게 만들 뿐입니다. 이러한 확장 함수를 사용하려면, 다음과 같이 사용해야 합니다.  

```kotlin
PhoneBookIncorrect().apply { "1234567890".test() }
```

확장 함수의 가시성을 제한하고 싶다면, 멤버로 만들지 말고, 가시성 한정자를 붙여 주면 됩니다.  

```kotlin
// 이런 형태로 확장 함수의 가시성을 제한합니다.
class PhoneBookCorrect {
    // ...
}

private fun String.isPhoneNumber() =
    length == 7 && all { it.isDigit() }
```

멤버 확장을 피해야 하는 몇 가지 타당한 이유를 정리해 보면, 다음과 같습니다.  

+ 레퍼런스를 지원하지 않습니다.  
+ 암묵적 접근을 할 때, 두 리시버 중에 어떤 리시버가 선택될지 혼동됩니다.  
+ 확장 함수가 외부에 있는 다른 클래스를 리시버로 받을 때, 해당 함수가 어떤 동작을 하는지 명확하지 않습니다.
+ 경험이 적은 개발자의 경우 확장 함수를 보면, 직관적이지 않거나, 심지어 보기만 해도 겁먹을 수도 있습니다.  

정리해 보겠습니다. 멤버 확장 함수를 사용하는 것이 의미가 있는 경우에는 사용해도 괜찮습니다. 하지만 일반적으로는 그 단점을 인지하고, 사용하지 않는 것이 좋습니다. 가시성을 제한하려면, 가시성과 관련된 한정자를 사용하세요. 클래스 내부에 확장 함수를 배치한다고, 외부에서 해당 함수를 사용하지 못하게 제한되는 것이 아닙니다.  

### Item 45. 불필요한 객체 생성을 피하라  
<br/>

객체 생성은 언제나 비용이 들어갑니다. 상황에 따라서는 굉장히 큰 비용이 들어갈 수도 있습니다. 따라서 불필요한 객체 생성을 피하는 것이 최적화의 관점에서 좋습니다. 다양한 레벨에서 객체 생성을 피할 수 있습니다. 예를 들어 JVM에서는 하나의 가상 머신에서 동일한 문자열을 처리하는 코드가 여러 개 있다면, 기존의 문자열을 재사용합니다.  

Integer와 Long처럼 박스화한 기본 자료형도 작은 경우에는 재사용됩니다(기본적으로 Int는 -127~127 범위를 캐시해 둡니다).  

참고로, nullable 타입은 int 자료형 대신 Integer 자료형을 사용하게 강제됩니다. Int를 사용하면, 일반적으로 기본 자료형 int로 컴파일됩니다. 하지만 nullable로 만들거나, 타입 아규먼트로 사용할 경우에는 Integer로 컴파일됩니다. 기본 자료형은 null일 수 없고, 타입 아규먼트로 사용할 수 없기 때문입니다. 이러한 메커니즘은 객체 생성 비용에 큰 영향을 줍니다.  

#### Item 45.1. 객체 생성 비용은 항상 클까?  
<br/>

어떤 객체를 랩(wrap)하면, 크게 세 가지 비용이 발생합니다.  

+ 객체는 더 많은 용량을 차지합니다. 현대 64비트 JDK에서 객체는 8바이트의 배수만큼 공간을 차지합니다. 앞부분 12바이트는 헤더라서 반드시 있어야 하므로, 최소 크기는 16바이트입니다. 참고로, 32비트 JVM에서는 8바이트입니다. 추가로 객체에 대한 레퍼런스도 공간을 차지합니다. 일반적으로 레퍼런스는 -Xmx32G까지는 32비트 플랫폼과 64비트 플랫폼 모두 4바이트입니다. 또한 64비트 플랫폼에서 32G(-Xmx32G)부터는 8바이트입니다. 큰 공간은 아니지만, 분명히 비용으로서 추가됩니다. 정수처럼 작은 것들을 많이 사용하면, 그 비용의 차이가 더 커집니다. 기본 자료형 int는 4바이트지만, 오늘날 널리 사용되고 있는 64비트 JDK에 랩(wrap)되어 있는 Integer는 16바이트입니다. 추가로 이에 대한 레퍼런스로 인해 8바이트가 더 필요합니다. 따라서 5배 이상의 공간을 차지한다고 할 수 있습니다.
+ 요소가 캡슐화되어 있다면, 접근에 추가적인 함수 호출이 필요합니다. 함수를 사용하는 처리는 굉장히 빠르므로 마찬가지로 큰 비용이 발생하지는 않습니다. 하지만 티끌 모아 태산이 되는 것처럼 수많은 객체를 처리한다면, 이 비용도 굉장히 커집니다.
+ 객체는 생성되어야 합니다. 객체는 생성되고, 메모리 영역에 할당되고, 이에 대한 레퍼런스를 만드는 등의 작업이 필요합니다. 마찬가지로 적은 비용이지만, 모이면 굉장히 큰 비용이 됩니다.  

객체를 제거함으로써 이런 세 가지 비용을 모두 피할 수 있습니다. 특히 객체를 재사용하면 첫 번째와 세 번째에 대한 설명한 비용을 제거할 수 있습니다. 이를 알면 코드에서 불필요한 객체를 어떤 식으로 제거해야 하는지 알 수 있습니다.  

#### Item 45.2. 객체 선언  
<br/>

매 순간 객체를 생성하지 않고, 객체를 재사용하는 간단한 방법은 객체 선언을 사용하는 것입니다(싱글톤).  

#### Item 45.3. 캐시를 활용하는 팩토리 함수  
<br/>

일반적으로 객체는 생성자를 사용해서 만듭니다. 하지만 팩토리 메서드를 사용해서 만드는 경우도 있습니다. 팩토리 함수는 캐시(cache)를 가질 수 있습니다. 그래서 팩토리 함수는 항상 같은 객체를 리턴하게 만들 수도 있습니다.  

객체 세트가 있고, 그중에서 하나를 리턴하는 경우를 생각해 봅시다. 예를 들어 코틀린 코루틴 라이브러리에 있는 디폴트 디스패처인 Dispatchers.Default는 쓰레드 풀을 갖고 있으며, 어떤 처리를 시작하라고 명령하면, 사용하고 있지 않은 쓰레드 하나를 사용해 명령을 수행합니다. 참고로 데이터베이스도 비슷한 형태로 커넥션 풀을 사용합니다. 객체 생성이 무겁거나, 동시에 여러 mutable 객체를 사용해야 하는 경우에는 이처럼 객체 풀을 사용하는 것이 좋습니다.  

parameterized 팩토리 메서드도 캐싱을 활용할 수 있습니다. 예를 들어 객체를 다음과 같이 map에 저장해 둘 수 있을 것입니다.  

```kotlin
private val connections = mutableMapOf<String, Connection>()

fun getConnection(host: String) = connections.getOrPut(host) { createConnection(host) }
```

모든 순수 함수는 캐싱을 활용할 수 있습니다. 이를 메모이제이션(memoization)이라고 부릅니다.  

참고로 메모리가 필요할 때 가비지 컬렉터(Garbage Collector, GC)가 자동으로 메모리를 해제해 주는 SoftReference를 사용하면 더 좋습니다. WeakReference와 혼동하지 마세요. WeakReference와 SoftReference의 차이를 간단하게 정리하면, 다음과 같습니다.  

+ WeakReference는 가비지 컬렉터가 값을 정리(clean)하는 것을 막지 않습니다. 따라서 다른 레퍼런스(변수)가 이를 사용하지 않으면 곧바로 제거됩니다.
+ SoftReference는 가비지 컬렉터가 값을 정리할 수도 있고, 정리하지 않을 수도 있습니다. 일반적인 JVM 구현의 경우, 메모리가 부족해서 추가로 필요한 경우에만 정리합니다. 따라서 캐시를 만들 때는 SoftReference를 사용하는 것이 좋습니다.  

캐시는 언제나 메모리와 성능의 트레이드 오프가 발생하므로, 캐시를 잘 설계하는 것은 쉽지 않습니다. 성능 문제를 메모리 부족 문제를 돌리고 싶은 사람은 아무도 없을 것입니다. 여러 가지 상황을 잘 고려해서 현명하게 사용하기 바랍니다.  

#### Item 45.4. 무거운 객체를 외부 스코프로 보내기  
<br/>

성능을 위한 굉장히 유용한 트릭으로, 무거운 객체를 외부 스코프로 보내는 방법이 있습니다. 컬렉션 처리에서 이루어지는 무거운 연산은 컬렉션 처리 함수 내부에서 외부로 빼는 것이 좋습니다. 간단한 예로 Iterable 내부에 '최댓값의 수를 세는 확장 함수'를 만드는 경우를 생각해 봅시다.  

```kotlin
fun <T: Comparable<T>> Iterable<T>.countMax(): Int = 
    count { it == this.max() }
```

앞 코드를 조금 더 수정하면, 다음과 같이 만들 수 있습니다. 최댓값을 나타내는 max를 countMax 함수의 레벨로 옮겼습니다.  

```kotlin
fun <T: Comparable<T>> Iterable<T>.countMax(): Int {
    val max = this.max()
    return count { it == max }
}
```

이렇게 코드를 작성하면 처음에 max 값을 찾아 두고, 이를 활용해서 수를 셉니다. 일단 확장 리시버로 max를 호출하는 형태가 확실하게 보이므로 가독성이 향상됩니다. 또한 반복 처리 중에 max 값을 한 번만 확인하므로 코드의 성능이 좋아집니다.  

연산을 외부로 추출해서 값 계산을 추가로 하지 않게 만든다는 것이 당연하게 들릴 수도 있겠지만, 사실 많은 사람이 자주 실수하는 부분입니다. 추가적인 예로 문자열이 IP 주소 형식을 갖는지 확인하는 다음 함수를 살펴봅시다.  

```kotlin
fun String.isValidIpAddress(): Boolean {
    return this.matches("\\A(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\z".toRegex())
}

// 사용
print("5.173.80.254".isValidIpAddress()) // true
```

이 함수의 문제는 함수를 사용할 때마다 Regex 객체를 계속해서 새로 만든다는 것입니다. 정규 표현식 패턴을 컴파일하는 과정은 꽤 복잡한 연산이라, 이처럼 함수를 호출할 때마다 계속해서 새로 만든다는 것은 성능적으로 문제를 일으킵니다. 정규 표현식을 톱레벨로 보내면, 이런 문제가 사라집니다.  

```kotlin
private val IS_VALID_EMAIL_REGEX = "\\A(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\z".toRegex()

fun String.isValidIpAddress(): Boolean = matches(IS_VALID_EMAIL_REGEX)
```

이 함수가 한 파일에 다른 함수와 함께 있을 때, 함수를 사용하지 않는다면 정규 표현식이 만들어지는 것 자체가 낭비입니다. 이러한 경우에는 지연 초기화(lazy initialization)하면 됩니다.  

```kotlin
private val IS_VALID_EMAIL_REGEX by lazy {
    "\\A(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\z".toRegex()
}
```

이처럼 프로퍼티를 지연되게 만드는 것은 무거운 클래스를 사용할 때 유용합니다.  

#### Item 45.5. 지연 초기화  
<br/>

무거운 클래스를 만들 때는 지연되게 만드는 것이 좋을 때가 있습니다. 예를 들어 A 클래스에 B, C, D라는 무거운 인스턴스가 필요하다고 가정해 봅시다. 클래스를 생성할 때 이를 모두 생성한다면, A 객체를 생성하는 과정이 굉장히 무거워질 것입니다.  

```kotlin
class A {
    val b = B()
    val c = D()
    val d = D()

    //...
}
```

내부에 있는 인스턴스들을 지연 초기화하면, A라는 객체를 생성하는 과정을 가볍게 만들 수 있습니다.  

```kotlin
class A {
    val b by lazy { B() }
    val c by lazy { D() }
    val d by lazy { D() }

    //...
}
```

다만 이러한 지연 초기화는 장점도 있지만 단점도 갖고 있습니다. 클래스가 무거운 객체를 가졌지만, 메서드의 호출은 빨라야 하는 경우가 있을 수 있습니다. A가 HTTP 호출에 응답하는 백엔드 애플리케이션의 컨트롤러라고 생각해봅시다. 지연되게 만들었다면, 처음 호출될 때 무거운 객레들의 초기화가 필요할 것입니다. 일반적으로 백엔드 애플리케이션은 전체적인 실행 시간은 중요하지 않은데, 이처럼 지연되게 만들면, 첫 번째 호출 때 응답 시간이 굉장히 길 것입니다. 그래서 백엔드 애플리케이션에서 좋지 않을 수 있습니다. 또한 지연되게 만들면, 성능 테스트가 복잡해지는 문제가 있습니다. 따라서 지연 초기화는 상황에 맞게 사용해야 합니다.  

#### Item 45.6. 기본 자료형 사용하기  
<br/>

JVM은 숫자와 문자 등의 기본적인 요소를 나타내기 위한 특별한 기본 내장 자료형을 갖고 있습니다. 이를 기본 자료형(primitives)이라고 부릅니다. 코틀린/JVM 컴파일러는 내부적으로 최대한 이러한 기본 자료형을 사용합니다. 다만 다음과 같은 두 가지 상황에서는 기본 자료형을 랩(wrap)한 자료형이 사용됩니다.  

(1) nullable 타입을 연산할 때(기본 자료형은 null일 수 없으므로)
(2) 타입을 제네릭으로 사용할 때  

이를 알면 랩한 자료형 대신 기본 자료형을 사용하게 코드를 최적화할 수 있습니다. 참고로 이러한 최적화는 코틀린/JVM, 일부 코틀린/Native 버전에서만 의미가 있으며, 코틀린/JS에서는 아무런 의미가 없습니다. 또한 숫자에 대한 작업이 여러 번 반복될 때만 의미가 있습니다. 숫자와 관련된 연산은 정도는 어떤 형태의 자료형을 사용하나 성능적으로 큰 차이가 없습니다. 따라서 굉장히 큰 컬렉션을 처리할 때 차이를 확인할 수 있습니다. 또한 기존의 코드에서 사용되던 자료형을 일괄 변경하면, 코드를 읽기 힘들어질 수 있습니다. 결과적으로 코드와 라이브러리의 성능이 굉장히 중요한 부분에서만 이를 적용하기 바랍니다. 프로파일러를 활용하면, 어떤 부분이 성능에 중요한 역할을 하는지 쉽게 찾을 수 있습니다.  

### Item 46. 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라  
<br/>

코틀린 표준 라이브러리의 고차 함수(higher-order function)를 살펴보면, 대부분 inline 한정자가 붙어 있는 것을 확인할 수 있습니다.  

inline 한정자의 역할은 컴파일 시점에 '함수를 호출하는 부분'을 '함수의 본문'으로 대체하는 것입니다.  

이처럼 inline 한정자를 붙여 함수를 만들면, 굉장히 큰 변화가 일어납니다. 일반적인 함수를 호출하면 함수 본문으로 점프하고, 본문의 모든 문장을 호출한 뒤에 호출했던 위치로 다시 점프하는 과정을 거칩니다. 하지만 '함수를 호출하는 부분'을 '함수의 본문'으로 대체하면, 이러한 점프가 일어나지 않습니다.  

inline 한정자를 사용하면, 다음과 같은 장점이 있습니다.  

(1) 타입 아규먼트에 reified 한정자를 붙여서 사용할 수 있습니다.  
(2) 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작합니다.
(3) 비지역(non-local) 리턴을 사용할 수 있습니다.  

하지만 단점도 분명 존재합니다. inline 한정자를 붙였을 때 발생하는 비용도 당연히 있습니다. 그럼 inline 한정자와 관련된 장점과 단점을 살펴봅시다.  

#### Item 46.1. 타입 아규먼트를 reified로 사용할 수 있다  
<br/>

구버전의 자바에는 제네릭이 없었습니다. 2004년 J2SE 5.0 버전부터 자바에서 제네릭을 사용할 수 있게 되었습니다. 하지만 JVM 바이트 코드에는 제네릭이 존재하지 않습니다. 따라서 컴파일을 하면, 제네릭 타입과 관련된 내용이 제거됩니다. 예를 들어 List<Int>를 컴파일하면 List로 바뀝니다. 그래서 객체가 List인지 확인하는 코드는 사용할 수 있지만, List<Int>인지 확인하는 코드는 사용할 수 없습니다.  

```kotlin
any is List<Int> // 오류
any is List<*> // OK
```

같은 이유로 다음과 같은 타입 파라미터에 대한 연산도 오류가 발생합니다.  

```kotlin
fun <T> printTypeName() {
    print(T::class.simpleName) // 오류
}
```

함수를 인라인으로 만들면, 이러한 제한을 무시할 수 있습니다. 함수 호출이 본문으로 대체되므로, reified 한정자를 지정하면, 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체됩니다.  

```kotlin
inline fun <reified T> printTypeName() {
    print(T::class.simpleName)
}

// 사용
printTypeName<Int>() // Int
printTypeName<Char>() // Char
printTypeName<String>() // String
```

컴파일하는 동안 printTypeName의 본문이 실제로 대체됩니다. 따라서 실제로는 다음과 같이 됩니다.  

```kotlin
printTypeName(Int::class.simpleName) // Int
printTypeName(Char::class.simpleName) // Char
printTypeName(String::class.simpleName) // String
```

reified는 굉장히 유용한 한정자입니다. 예를 들어 표준 라이브러리의 filterIsInstance도 특정 타입의 요소를 필터링할 때 사용됩니다.  

#### Item 46.2. 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다  
<br/>

조금 더 구체적으로 말하면, 모든 함수는 inline 한정자를 붙이면 조금 더 빠르게 동작합니다. 함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없기 때문입니다. 그래서 표준 라이브러리에 있는 간단한 함수들에는 대부분 inline 한정자가 붙어 있습니다.  

하지만 함수 파라미터를 가지지 않는 함수에서는 이러한 차이가 큰 성능 차이를 발생시키지 않습니다. 그래서 간단한 inline을 붙일 경우, 인텔리제이가 다음과 같은 경고를 표시해 주는 것입니다.  

그 이유를 이해하려면, 일단 함수를 객체로서 조작할 때 발생하는 문제를 이해해야 합니다. 함수 리터럴을 사용해 만들어진 이러한 종류의 객체는 어떤 방식으로든 저장되고 유지되어야 합니다. 코틀린/JS에서는 자바스크립트가 함수를 일급 객체(first-class citizen)로 처리하므로, 굉장히 간단하게 변환이 이루어집니다. 코틀린/JS에서 함수는 단순한 함수 또는 함수 레퍼런스입니다. 반면, 코틀린/JVM에서는 JVM 익명 클래스 또는 일반 클래스를 기반으로, 함수를 객체로 만들어 냅니다. 따라서 다음과 같은 람다 표현식은  

```kotlin
val lamba: ()->Unit = {
    // 코드
}
```

클래스로 컴파일됩니다. 익명 클래스로 컴파일하면 다음과 같으며,  

```kotlin
// 자바
Function0<Unit> lambda = new Function0<Unit>() {
    public Unit invoke() {
        // 코드
    }
}
```

별도의 파일에 정의되어 있는 일반 클래스로 컴파일하면, 다음과 같습니다.  

```kotlin
// 자바
// 다른 파일의 추가적인 클래스
public class Test$lambda implements Function0<Unit> {
    public Unit invoke() {
        // 코드
    }
}

// 사용
Function0 lambda = new Test$lambda()
```

두 결과 사이에 큰 차이는 없습니다.  

참고로, JVM에서 아규먼트가 없는 함수 타입은 Function0 타입으로 변환됩니다. 다른 타입의 함수는 다음과 같은 형태로 변환됩니다.  

+ ()->Unit는 Function0<Unit>로 컴파일
+ ()->Int는 Function0<Int>로 컴파일
+ (Int)->Int는 Function1<Int, Int>로 컴파일
+ (Int, Int)->Int는 Function2<Int, Int, Int>로 컴파일  

이러한 모든 인터페이스는 모두 코틀린 컴파일러에 의해서 생성됩니다. 요청이 있을 때 생성되므로, 이를 명시적으로 사용할 수는 없습니다. 대신 하수 타입을 사용할 수 있습니다. 함수 타입이 단순한 인터페이스라는 것을 알면, 추가적인 가능성들이 보이게 됩니다.  

```kotlin
class OnClickListener: ()->Unit {
    override fun invoke() {
        // ...
    }
}
```

함수 본문을 객체로 랩(wrap)하면, 코드의 속도가 느려집니다. 그래서 다음과 같으 두 함수가 있을 때, 첫 번째 함수가 더 빠른 것입니다.  

```kotlin
inline fun repeat(times: Int, action: (Int) -> Unit) {
    for (index in 0 until times) {
        action(index)
    }
}

fun repeatNoinline(times: Int, action: (Int) -> Unit) {
    for (index in 0 until times) {
        action(index)
    }
}
```

눈으로는 차이가 보이지만, 실제로는 큰 차이가 없다고 생각할 수도 있습니다. 하지만 테스트를 잘 설계하고 확인해 보면, 차이가 분명하게 드러납니다.  

```kotlin
@Benchmark
fun nothingInline(blackhole: Blackhole) {
    repeat(100_000_000) {
        blackhole.consume(it)
    }
}

@Benchmark
fun nothingInline(blackhole: Blackhole) {
    noinlineRepeat(100_000_000) {
        blackhole.consume(it)
    }
}
```

'인라인 함수'와 '인라인 함수가 아닌 함수'의 더 중요한 차이는 함수 리터럴 내부에서 지역 변수를 캡처할 때 확인할 수 있습니다. 캡처된 값은 객체로 래핑(wrapping)해야 하며, 사용할 때마다 객체를 통해 작업이 이루어져야 합니다.  

```kotlin
var l = 1L
noinlineRepeat(100_100_000) {
    l += it
}
```

인라인이 아닌 람다 표현식에서는 지역 변수 l을 직접 사용할 수 없습니다. l은 컴파일 과정 중에 다음과 같이 레퍼런스 객체로 래핑되고, 람다 표현식 내부에서는 이를 사용합니다.  

```kotlin
val a = Ref.LongRef()
a.element = 1L
noinlineRepeat(100_000_000) {
    a.element = a.element + it
}
```

일반적으로 함수 타입의 파라미터가 어떤 식으로 동작하는지 이해하기 어려우므로, 함수 타입 파라미터를 활용해서 유틸리티 함수를 만들 때(예: 컬렉션 처리)는 그냥 인라인을 붙여 준다 생각하는 것도 좋습니다. 이러한 이유로 표준 라이브러리가 제공하는 대부분의 함수 타입 파라미터를 가진 확장 함수는 인라인으로 정의됩니다.  

#### Item 46.2. 비지역적 리턴(non-local return)을 사용할 수 있다  
<br/>

이전에 살펴보았던 repeatNoninline은 제어문처럼 코드를 작성했습니다. 일반적인 if 조건문, for 반복문과 비교해서 살펴봅시다.  

```kotlin
if(value != null) {
    print(value)
}

for (i in 1..10) {
    print(i)
}

repeatNoninline(10) {
    print(it)
}
```

하지만 중요한 차이점이 있습니다. repeatNoninline은 내부에서 리턴을 사용할 수 없습니다.  

```kotlin
fun main() {
    repeatNoinline(10) {
        print(it)
        return // 오류: 허용되지 않습니다.
    }
}
```

이는 함수 리터럴이 컴파일될 때, 함수가 객체로 래핑되어서 발생하는 문제입니다. 함수가 다른 클래스에 위치하므로, return을 사용해서 main으로 돌아올 수 없는 것입니다. 인라인 함수라면 이런 제한이 없습니다. 함수가 main 함수 내부에 박히기 때문입니다.  

```kotlin
fun main() {
    repeat(10) {
        print(it)
        return // OK
    }
}
```

덕분에 제어문처럼 보이면서도 잘 동작합니다.  

```kotlin
fun getSomeMoney(): Money? {
    repeat(100) {
        val money = searchForMoney()
        if(money != null) return money
    }
    return null
}
```

#### Item 46.3. inline 한정자의 비용  
<br/>

inline 한정자는 굉장히 유용한 한정자지만, 모든 곳에 사용할 수는 없습니다. 대표적인 예로 인라인 함수는 재귀적으로 동작할 수 없습니다. 재귀적으로 사용하면, 무한하게 대체되는 문제가 발생합니다. 이러한 문제는 인텔리제이가 오류로 잡아 주지 못하므로 굉장히 위험합니다.  

또한 인라인 함수는 더 많은 가시성 제한을 가진 요소를 사용할 수 없습니다. public 인라인 함수 내부에서는 private과 internal 가시성을 가진 함수와 프로퍼티를 사용할 수 없습니다.  

이처럼 인라인 함수는 구현을 숨길 수 없으므로, 클래스에 거의 사용되지 않는 것입니다.  

inline 한정자를 남용하면, 코드의 크기가 쉽게 커집니다. 소로 호출하는 인라인 함수가 많아지면, 코드가 기하급수적으로 증가하므로 위험합니다.  

#### Item 46.4. crossline과 noinline  
<br/>

함수를 인라인으로 만들고 싶지만, 어떤 이유로 일부 함수 타입 파라미터는 inline으로 받고 싶지 않을 경우가 있을 수 있습니다. 이러한 경우에는 다음과 같은 한정자를 사용합니다.  

+ crossline: 아규먼트로 인라인 함수를 받지만, 비지역적 리턴을 하는 함수는 받을 수 없게 만듭니다. 인라인으로 만들지 않은 다른 람다 표현식과 조합해서 사용할 때 문제가 발생하는 경우 활용합니다.
+ noinline: 아규먼트로 인라인 함수를 받을 수 없게 만듭니다. 인라인 함수가 아닌 함수를 아규먼트로 사용하고 싶을 때 활용합니다.  

#### Item 46.4. 정리  
<br/>

인라인 함수가 사용되는 주요 사례를 정리해 보면 다음과 같습니다.  

+ print 함수처럼 매우 많이 사용되는 경우
+ filterIsInstance 함수처럼 타입 아규먼트로 reified 타입을 전달받는 경우
+ 함수 타입 파라미터를 갖는 톱레벨 함수를 정의해야 하는 경우, 특히 컬렉션 처리 함수와 같은 헬퍼 함수(map, filter, flatMap, joinToString 등), 스코프 함수(also, apply, let 등), 톱레벨 유틸리티 함수(repeatm, run, with)의 경우  

API를 정의할 때 인라인 함수를 사용하는 경우는 거의 없습니다. 또한 한 인라인 함수가 다른 인라인 함수를 호출하는 경우, 코드가 기하급수적으로 많아질 수 있으므로 주의하세요.  

### Item 47. 인라인 클래스의 사용을 고려하라  
<br/>

하나의 값을 보유하는 객체도 inline으로 만들 수 있습니다. 이는 코틀린 1.3부터 도입된 기능입니다. 기본 생성자 프로퍼티가 하나의 클래스 앞에 inline을 붙이면, 해당 객체를 사용하는 위치가 모두 해당 프로퍼티로 교체됩니다.  

이러한 inline 클래스는 타입만 맞다면, 다음과 같이 그냥 값을 곧바로 집어 넣는 것도 허용됩니다.  

```kotlin
// 코드
val name: Name = Name("Marcin")

// 컴파일 때 다음과 같은 형태로 바뀝니다.
val name: String = "Marcin"
```

inline 클래스의 메서드는 모두 정적 메서드로 만들어집니다.  

인라인 클래스는 다른 자료형의 래핑해서 새로운 자료형을 만들 대 많이 사용됩니다. 이때 어떠한 오버헤드도 발생하지 않습니다. inline 클래스는 다음과 같은 상황에서 많이 사용됩니다.  

+ 측정 단위를 표현할 때
+ 타입 오용으로 발생하는 문제를 막을 때  

#### Item 47.1. 측정 단위를 표현할 때  
<br/>

타이머 클래스를 만드는 경우를 가정해 봅시다. 이 클래스는 특정 시간 후에 파라미터로 받은 함수를 호출합니다.  

```kotlin
interface Timer {
    fun callAfter(tiem: Int, callback: ()->Unit)
}
```

그런데 여기에서 time은 정확하게 어떤 단위일까요? ms(밀리초), s(초), min(분) 중에서 어떤 단위인지 명확하지 않습니다. 따라서 심각한 실수로 여러 문제가 발생할 수 있는 지점입니다. 실제로 화성이 대기와 충돌한 화성 기후 궤도선(Mars Climate Orbiter)에서 이런 문제가 발생했습니다. 나사(NASA)는 궤도선 제어에 사용되는 소프트웨어 개발을 외부 회사에 맡겼습니다. 하지만 나사가 생각했던 측정 단위와 외주 회사가 만든 측정 단위에 차이가 발생했습니다. 나사는 뉴턴 초(newton-seconds, N·s) 단위를 생각했지만, 파운드 힘 초(pound-force seconds, lbs·s)로 만들어 버린 것입니다. 3억 2,360만 달러가 들어간 이 프로젝트는 이 단순한 문제로 완전히 실패했습니다. 이처럼 측정 단위 혼동은 굉장히 큰 문제를 초래할 수 있습니다.  

이러한 문제를 해결할 수 있는 가장 쉬운 방법은 파라미터 이름에 측정 단위를 붙여 주는 것입니다.  

```kotlin
interface Timer {
    fun callAfter(timeMillis: Int, callback: ()->Unit)
}
```

하지만 함수를 사용할 때 프로퍼티 이름이 표시되지 않을 수 있으므로, 여전이 실수를 할 수 있습니다. 또한 파라미터는 이름을 붙일 수 있지만, 리턴 값은 이름을 붙일 수 없습니다.  

물론 함수에 이름을 붙여서, 어떤 단위로 리턴하는지 알려 줄 수 있습니다. 예를 들어 함수 이름을 decideAboutTimeMillis로 만들면, ms 단위로 리턴한다는 것을 알 수 있습니다. 하지만 이러한 해결 방법은 함수를 더 길게 만들고, 필요 없는 정보까지도 전달해 줄 가능성이 있으므로, 실제로는 거의 사용되지 않습니다.  

더 좋은 해결 방법은 타입에 제한을 거는 것입니다. 제한을 걸면 제네릭 유형을 잘못 사용하는 문제를 줄일 수 있습니다. 그리고 이때 코드를 더 호율적으로 만들려면, 다음과 같이 인라인 클래스를 활용합니다.  

```kotlin
inline class Minutes(val minutes: Int) {
    fun toMillis(): Millis = Millis(minutes * 60 + 1000)
    // ...
}

inline class Millis(val milliseconds: Int) {
    // ...
}

interface User {
    fun decideAboutTime(): Minutes
    fun wakeup()
}

interface Timer {
    fun callAfter(timeMillis: Millis, callback: ()->Unit)
}

fun setUpUserWakeUpUser(user: User, timer: Timer) {
    val time: Minutes = user.decideAboutTime()
    timer.callAfter(time) { // 오류: Type mismatch
        user.wakeUp()
    }
}
```

이렇게 하면, 올바른 타입을 사용하는 것이 강제됩니다.  

```kotlin
fun setUpUserWakeUpUser(user: User, timer: Timer) {
    val time = user.decideAboutTime()
    timer.callAfter(time.toMillis()) {
        user.wakeUp()
    }
}
```

프런트엔드 개발에서는 px, mm, dp 등이 다양한 단위를 사용하는데, 이러한 단위를 제한할 때 활용하면 좋습니다, 또한 객체 생성을 위해서 DSL-like 확장 프로퍼티를 만들어 두어도 좋습니다.  

#### Item 47.2. 타입 오용으로 발생하는 문제를 막을 때  
<br/>

SQL 데이터베이스는 일반적으로 ID를 사용해서 요소를 식별합니다. ID는 일반적으로 단순한 숫자입니다. 간단한 예로 학생 성적 관리 시스템이 있다고 해 봅시다. 학생, 교사, 학교 등의 데이터들이 모두 ID를 갖고 있을 겁니다.  

```kotlin
@Entity(tableName = "grades")
class Grade(
    @ColumnInfo(name = "studentId")
    val studentId: Int,
    @ColumnInfo(name = "teacherId")
    val teacherId: Int,
    @ColumnInfo(name = "schoolId")
    val schoolId: Int,
    // ...
)
```

그런데 이런 코드는 모든 ID가 Int 자료형이므로, 실수로 잘못된 값을 넣을 수 있습니다. 또한 이러한 문제가 발생했을 때 어떠한 오류도 발생하지 않으므로, 문제를 찾는 게 힘들어집니다. 이런 문제를 미리 막으려면, 다음과 같이 Int 자료형의 값을 inline 클래스를 활용해 래핑합니다.  

```kotlin
inline class StudentId(val studentId: Int)
inline class TeacherIdId(val teacherId: Int)
inline class SchoolId(val schoolId: Int)

class Grade(
    @ColumnInfo(name = "studentId")
    val studentId: StudentId,
    @ColumnInfo(name = "teacherId")
    val teacherId: TeacherIdId,
    @ColumnInfo(name = "schoolId")
    val schoolId: SchoolId,
    // ...
)
```

이렇게 하면 ID를 사용하는 것이 굉장히 안전해지며, 컴파일할 때 타입이 Int로 대체되므로 코드를 바꾸어도 별도의 문제가 발생하지 않습니다. 이처럼 인라인 클래스를 사용하면, 안전을 위해 새로운 타입을 도입해도, 추가적인 오버헤드가 발생하지 않습니다.  

#### Item 47.3. 인라인 클래스와 인터페이스  
<br/>

인라인 클래스도 다른 클래스와 마찬가지로 인터페이스를 구현할 수 있습니다.  

#### Item 47.4. typealias  
<br/>

typealias를 사용하면, 타입에 새로운 이름을 붙여 줄 수 있습니다.  

이러한 typealias는 길고 반복적으로 사용해야 할 때 많이 유용합니다.  

히자만 typealias는 안전하지 않습니다. Seconds와 Millis 모두 단순하게 Int를 나타냅니다. 따라서 실수로 둘을 혼용해서 잘못 입력하더라도, 어떠한 오류도 발생하지 않습니다. 하지만 이름이 명확하게 Seconds와 Mills라고 붙어 있으므로, 안전할 거라는 착각을 하게 만듭니다. 이는 오히려 문제가 발생했을 때, 문제 찾는 것을 어렵게 만듭니다.  

```kotlin
typealias Seconds = Int
typealias Millis = Int

fun getTime(): Millis = 10
fun setUpTimer(time: Seconds) {}

fun main() {
    val seconds: Seconds = 10
    val millis: Millis = seconds // 컴파일 오류가 발생하지 않습니다.

    setUpTimer(getTime())
}
```

위의 코드는 typealias를 사용하지 않는 것이 오히려 오류를 쉽게 찾을 수 있을 것입니다. 따라서 이런 형태로 typealias를 사용하면 안 됩니다. 단위 등을 표현하려면, 파라미터 이름 또는 클래스를 사용하세요. 이름은 비용이 적게 들고, 클래스는 안전합니다. 인라인 클래스를 사용하면, 비용과 안전이라는 두 마리 토끼를 모두 잡을 수 있습니다.  

#### Item 47.5. 정리  
<br/>

인라인 클래스를 사용하면 성능적인 오버헤드 없이 타입을 래핑할 수 있습니다. 인라인 클래스는 타입 시스템을 통해 실수로 코드를 잘못 작성하는 것을 막아주므로, 코드의 안정성을 향상시켜 줍니다. 의미가 명확하지 않은 타입, 특히 여러 측정 단위들을 함께 사용하는 경우에는 인라인 클래스를 꼭 활용하세요.  

### Item 48. 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라  
<br/>

리소스를 정적으로 유지하지 않는 것이 가장 좋습니다. 의존 관계를 정적으로 저장하지 말고, 다른 방법을 활용해서 적절하게 관리하기 바랍니다. 또한 객체에 대한 레퍼런스를 다른 곳에 저장할 때는 메모리 누수가 발생할 가능성을 언제나 염두에 두기 바랍니다.  

일반적인 규칙은 상태를 유지할 때 메모리 관리를 염두에 두어야 한다는 것입니다. 코드를 작성할 때는 '메모리와 성능'뿐만 아니라 '가독성과 확장성'을 항상 고려해야 합니다. 일반적으로 가독성이 좋은 코드는 메모리와 성능적으로도 좋습니다. 가독성이 좋지 않은 코드는 메모리와 CPU 리소스의 낭비를 숨기고 있을 가능성이 높습니다. 물론 둘 사이에 트레이드 오프가 발생하는 경우도 있습니다. 이럴 때는 일반적으로 가독성과 확장성을 더 중시하는 것이 좋습니다. 예외적으로 라이브러리를 구현할 때는 메모리와 성능이 더 중요합니다.  

일반적으로 메모리 누수가 발생하는 부분을 몇 가지 정리해 보겠습니다. 첫 번째는 절대 사용되지 않는 객체를 캐시해서 저장해 두는 경우입니다. 물론 캐시를 해 두는 것이 나쁜 것은 아닙니다. 하지만 이것이 OutOfMemoryError를 일으킬 수 있다면, 아무런 도움도 되지 않습니다. 해결 방법은 소프트 레퍼런스(soft reference)를 사용하는 것입니다. 소프트 레퍼런스를 활용하면, 메모리가 필요한 경우에는 가비지 컬렉터가 이를 알아서 해제합니다. 하지만 메모리가 부족하지 않아서 해제되지 않았다면, 이를 활용할 수 있습니다.  

화면 위의 대화상자와 같은 일부 객체는 약한 레퍼런스(weak reference)를 사용하는 것이 좋을 수 있습니다. 대화상자가 출력되는 동안에는 가비지 컬렉터가 이를 수집하지 않을 것입니다. 그리고 대화상자를 닫은 이후에는 이에 대한 참조를 유지할 필요가 전혀 없습니다. 따라서 약한 레퍼런스를 사용하면 좋습니다.  

메모리 누수는 예측하기 어렵습니다. 애플리케이션이 크래시(crash)되기 전까지 있는지 확인하기 힘들 수도 있습니다. 메모리 누수는 안드로이드 애플리케이션에서 더 큰 문제가 됩니다. 안드로이드 애플리케이션은 일반적인 데스크톱 애플리케이션보다 메모리 사용량에 엄격한 제한이 있기 때문입니다. 그래서 별도의 도구들을 활용해서 메모리 누수를 찾는 것도 좋은 방법입니다. 가장 기본적인 도구로는 힙 프로파일러(heap profiler)가 있습니다. 또한 메모리 누수 탐색에 도움이 되는 라이브러리도 있습니다. 예를 들어 안드로이드에서 인기 있는 라이브러리로, 메모리 누수가 검출될 때마다 알려 주는 LeakCanary가 있습니다.  

사실 객체를 수동으로 해제해야 하는 경우는 굉장히 드웁니다. 일반적으로 스코프를 벗어나면서, 어떤 객체를 가리키는 레퍼런스가 제거될 때 객체가 자동으로 해제됩니다. 따라서 메모리와 관련된 문제를 피하는 가장 좋은 방법은 변수를 지역 스코프(local scope)에 정의하고, 톱레벨 프로퍼티 또는 객체 선언(companion 객체 포함)으로 큰 데이터를 저장하지 않는 것입니다.  

### Item 49. 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라  
<br/>

Sequence는 지연(lazy) 처리됩니다. 따라서 시퀀스 처리 함수들을 사용하면, 데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴됩니다. 최종적인 계산은 toList 또는 count 등의 최종 연산이 이루어질 때 수행됩니다. 반면, Iterable은 처리 함수를 사용할 때마다 연산이 이루어져 List가 만들어집니다.  

정리하면, 컬렉션 처리 연산은 호출할 때 연산이 이루어집니다. 반면, 시퀀스 처리 함수는 최종 연산이 이루어지기 전까지는 각 단계에서 연산이 일어나지 않습니다.  

시퀀스의 지연 처리는 다음과 같은 장점을 갖습니다.  

+ 자연스러운 처리 순서를 유지합니다.
+ 최소한만 연산합니다.
+ 무한 시퀀스 형태로 사용할 수 있습니다.
+ 각각의 단계에서 컬렉션을 만들어 내지 않습니다.  

각각의 장점을 하나씩 자세하게 살펴봅시다.  

#### Item 49.1. 순서의 중요성  
<br/>

이터러블 처리와 시퀀스 처리는 연산의 순서가 달라지면, 다른 결과가 나옵니다. 시퀀스 처리는 요소 하나하나에 지정한 연산을 한꺼번에 적용합니다. 이를 전문적으로 element-by-element order 또는 lazy order라고 부릅니다. 반면, 이터러블은 요소 전체를 대상으로 연산을 차근차근 적용해 나갑니다. 이를 전문적으로 step-by-step order 또는 eager order라고 부릅니다.  

#### Item 49.2. 최소 연산  
<br/>

이터러블 처리는 기본적으로 중간 연산이라는 개념이 없으므로, 원하는 처리를 컬렉션 전체에 적용한 뒤에 처리합니다. 하지만 시퀀스는 중간 연산이라는 개념을 갖고 있으므로, 원하는 요소만 처리를 적용할 수 있습니다.  

처리를 적용하고 싶은 요소를 선택하는 연산으로는 first, take, any, all, none, indexOf가 있습니다.  

#### Item 49.3. 무한 시퀀스  
<br/>

시퀀스는 실제로 최종 연산이 일어나기 전까지는 컬렉션에 어떠한 처리도 하지 않습니다. 따라서 무한 시퀀스(infinite sequence)를 만들고, 필요한 부분까지만 값을 추출하는 것도 가능합니다. 무한 시퀀스를 만드는 일반적인 방법은 generateSequence 또는 sequence를 사용하는 것입니다. 먼저 genertateSequence는 '첫 번째 요소'와 '그 다음 요소를 계산하는 방법'을 지정해야 합니다.  

두 번째로 sequence는 중단 함수(suspending function, 코루틴)로 요소들을 지정합니다. 시퀀스 빌더는 중단 함수 내부에서 yield로 값을 하나씩 만들어 냅니다.  

참고로 무한 시퀀스를 실제로 사용할 때는 몇 개 활용할지 지정해야 합니다. 그렇지 않으면 무한하게 반복합니다.  

따라서 take를 사용해서 활용할 값의 수를 지정하거나, first, find, any, all, none, indexOf와 같은 일부 요소만 선택하는 종결 연산을 활용해야 합니다. 이를 구할 때도 모든 요소를 처리하지 않으므로, 시퀀스가 이터러블보다 훨씬 더 효율적으로 동작합니다. 다만 실제로 사용해 보면, 무한 반복에 빠지는 경우가 생각보다 많습니다. any는 true를 리턴하지 못하면, 무한 반복에 빠집니다. 결과적으로 무한 시퀀스는 종결 연산으로 take와 first 정도만 사용하는 것이 좋습니다.  

#### Item 49.4. 각각의 단계에서 컬렉션을 만들어 내지 않음  
<br/>

표준 컬렉션 처리 함수는 각각의 단계에서 새로운 컬렉션을 만들어 냅니다. 일반적으로 대부분 List입니다. 각각의 단계에서 만들어진 결과를 활용하거나 저장할 수 있다는 것은 컬렉션의 장점이지만, 각각의 단계에서 결과가 만들어지면서 공간을 차지하는 비용이 든다는 것은 큰 단점입니다.  

크거나 무거운 컬렉션을 처리할 때는 굉장히 큰 비용이 들어갑니다.  

컬렉션 처리의 각각의 단계에서 새로운 컬렉션을 만드는 데는 비용이 들어갑니다. 크기가 큰 요소를 처리할수록 비용이 커집니다. 처리 단계가 하나 정도라면, 컬렉션 처리와 시쿠너스 처리의 차이가 크지 않습니다. 하지만 처리 단계가 많아질수록 이러한 차이가 커지므로, 큰 컬렉션으로 여러 처리 단계를 거쳐야 한다면, 컬렉션 처리보다는 시퀀스 처리를 사용하는 것이 좋습니다.  

#### Item 49.5. 시퀀스가 빠르지 않은 경우  
<br/>

컬렉션 전체를 기반으로 처리해야 하는 연산은 시퀀스를 사용해도 빨라지지 않습니다. 현재 유일한 예로 코틀린 stdlib의 sorted가 있습니다. sorted는 Sequence를 List로 변환한 뒤에, 자바 stdlib의 sort를 사용해 처리합니다. 문제는 이러한 변환 처리로 인해서, 시퀀스가 컬렉션(Collection) 처리보다 느려진다는 것입니다(물론 이터러블 Collection 또는 배열은 아니므로, 변호나 처리가 필요해서 차이가 크지는 않습니다).  

참고로 무한 시퀀스처럼 시퀀스의 다음 요소를 lazy하게 구하는 시퀀스에 sorted를 적용하면, 무한 반복에 빠지는 문제가 있습니다. 그래서 시퀀스에서 sorted를 빼야 한다는 의견도 있지만, 정렬 처리는 일반적으로 사용되는 처리이므로, 시퀀스에도 들어간 것입니다. 따라서 무한 시퀀스에 sorted를 사용할 수 없다는 결함은 따로 기억해야 합니다.  

sorted는 Sequence보다 Collection이 더 빠른 희귀한 예입니다. 다른 처리는 모두 Sequence가 빠지므로, 여러 처리가 결합된 경우에는 Collection을 사용하는 것보다 Sequence를 사용하는 것이 더 빠릅니다.  

#### Item 49.6. 자바 스트림의 경우  
<br/>

자바 8부터는 컬렉션 처리를 위해 스트림 기능이 추가되었습니다. 코틀린의 시퀀스와 비슷한 형태로 동작합니다.  

자바 8의 스트림도 lazy하게 작동하며, 마지막 처리 단계에서 연산이 일어납니다. 다만 자바의 스트림과 코틀린의 시퀀스는 다음과 같은 세 가지 큰 차이점이 있습니다.  

+ 코틀린의 시퀀스가 더 많은 처리 함수를 갖고 있습니다(확장 함수를 사용해서 정의되어 있으므로). 그리고 사용하기 더 쉽습니다(이는 자바 스트림이 나온 이후에 코틀린 시퀀스가 나와서 몇 가지 문제를 해결했기 때문입니다. 예를 들어 최종 연산을 collect(Collectors.toList())가 아닌 toList()처럼 간단하게 할 수 있습니다).
+ 자바 스트림은 병렬 함수를 사용해서 병렬 모드로 실행할 수 있습니다. 이는 (현재는 널리 사용되는) 멀티 코어 환경에서 굉장히 큰 성능 향상을 가져옵니다. 다만 몇 가지 결함이 있으므로 주의해서 사용해야 합니다.
+ 코틀린의 시퀀스는 코틀린/JVM, 코틀린/JS, 코틀린/네이티브 등의 일반적인 모듈에서 모두 사용할 수 있습니다. 하지만 자바 스트림은 코틀린/JVM에서만 동작하며, 그것도 JVM이 8 버전 이상일 때만 동작합니다.  

일반적으로 병렬 모드를 사용하지 않는다면, 자바 스트림과 코틀린 시퀀스 중에 어떤 것이 더 효율적이라고 단정지어서 이야기하기 어렵습니다. 병렬 모드로 성능적 이득을 얻을 수 있는 곳에서만 자바 스트림을 사용하고, 이외의 일반적인 경우에는 코틀린 시퀀스를 사용하는 것이 좋습니다. 코틀린 stdlib 함수를 사용하면, 모든 플랫폼에서 활용할 수 있는 공통 모듈의 코드가 더 깔끔해집니다.  

#### Item 49.7. 코틀린 시퀀스 디버깅  
<br/>

코틀린 시쿠너스와 자바 스트림은 모두 단계적으로 요소의 흐름을 추적할 수 있는 디버깅 기능이 지원됩니다. 자바 스트림은 'Java Stream Debugger'라는 이름의 플러그인, 코틀린은 'Kotlin Squence Debugger'라는 이름의 플러그인으로 이를 활용할 수 있습니다. 참고로, 현재 'Kotlin Squence Debugger' 플러그인에 통합되어 있습니다.  

#### Item 49.8. 정리  
<br/>

컬렉션과 시퀀스는 같은 처리 메서드를 지원하며, 사용하는 형태가 거의 비슷합니다. 일반적으로 데이터를 컬렉션에 저장하므로, 시퀀스 처리를 하려면 시퀀스로 변환하는 과정이 필요합니다. 또한 최종적으로 컬렉션 결과를 원하는 경우가 많으므로, 시퀀스를 다시 컬렉션으로 변환하는 과정도 필요합니다. 이것이 시퀀스 처리의 단점이라고 할 수 있습니다. 하지만 시퀀스는 lazy하게 처리됩니다. 이로 인해서 다음과 같은 장점이 발생합니다.  

+ 자연스러운 처리 순서를 유지합니다.
+ 최소한만 연산합니다.
+ 무한 시퀀스 형태로 사용할 수 있습니다.
+ 각각의 단계에서 컬렉션을 만들어 내지 않습니다.  

결과적으로 무거운 객체나 규모가 큰 컬렉션을 여러 단계에 걸쳐서 처리할 때는 시퀀스를 사용하는 것이 좋습니다. 또한 시퀀스 처리는 'Kotlin Squence Debugger' 플러그인을 활용해서, 처리 단계를 시각적으로 확인할 수 있습니다. 상황에 따라서 시퀀스 처리를 활용하면 큰 성능 향상이 있을 수 있습니다.  

### Item 50. 컬렉션 처리 단계 수를 제한하라  
<br/>

모든 컬렉션 처리 메서드는 비용이 많이 듭니다. 표준 컬렉션 처리는 내부적으로 요소들을 활용해 반복을 돌며, 내부적으로 계산을 위해 추가적인 컬렉션을 만들어 사용합니다. 시퀀스 처리도 시퀀스 전체를 랩하는 객체가 만들어지며, 조작을 위해서 또 다른 추가적인 객체를 만들어 냅니다. 두 처리 모두 요소의 수가 많다면, 꽤 큰 비용이 들어갑니다. 따라서 적절한 메서드를 활용해서, 컬렉션 처리 단계 수를 적절하게 제한하는 것이 좋습니다.  

### Item 51. 성능이 중요한 부분에는 기본 자료형 배열을 사용하라  
<br/>

코틀린은 기본 자료형(primitive)을 선언할 수 없지만, 최적화를 위해서 내부적으로는 사용할 수 있습니다. 기본 자료형은 다음과 같은 특징이 있습니다.  

+ 가볍습니다. 일반적인 객체와 다르게 추가적으로 포함되는 것들이 없기 때문입니다.
+ 빠릅니다. 값에 접근할 때 추가 비용이 들어가지 않습니다.  

따라서 대규모의 데이터를 처리할 때 기본 자료형을 사용하면, 상당히 큰 최적화가 이루어집니다. 그런데 코틀린에서 사용되는 List와 Set 등의 컬렉션은 제네릭 타입입니다. 제네릭 타입에는 기본 자료형을 사용할 수 없으므로, 랩핑된 타입을 사용해야 합니다. 일반적인 경우에는 이렇게 하는 것이 훨씬 더 처리가 쉬워지므로 적합합니다. 하지만 성능이 중요한 코드라면 IntArray와 LongArray 등의 기본 자료형을 활용하는 배열을 사용하는 것이 좋습니다.  

기본 자료형을 포함하는 배열은 코드 성능이 중요한 부분을 최적화할 때 활용하면 좋습니다. 배열은 더 적은 메모리를 차지하고, 더 빠르게 동작합니다. 다만 일반적인 경우에는 List를 사용하는 것이 좋습니다. List가 훨씬 더 기능이 다양하며, 더 많은 곳에 쉽게 사용될 수 있습니다. 성능이 중요한 경우에는 Array를 떠올려 주세요.  

### Item 52. mutable 컬렉션 사용을 고려하라  
<br/>

immutable 컬렉션보다 mutable 컬렉션이 좋은 점은 성능적인 측면에서 더 빠르다는 것입니다. immutable 컬렉션에 요소를 추가하려면, 새로운 컬렉션을 만들면서 여기에 요소를 추가해야 합니다. 

그래서 복제 처리를 하지 않는 mutable 컬렉션이 성능적 관점에서 좋습니다. 다만 immutable 컬렉션은 안전하다는 측면에서 좋습니다. 하지만 일반적인 지역 변수는 이때 언급했던 문제가 될 수 있는 경우(동기화와 캡슐화)에 해당되지 않습니다. 따라서 지역 변수로 사용할 때는 mutable 컬렉션을 사용하는 것이 더 합리적이라고 할 수 있습니다. 그래서 표준 라이브러리도 내부적으로 어떤 처리를 할 때는 mutable 컬렉션을 사용하도록 구현되어 있습니다.