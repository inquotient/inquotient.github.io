---
title:  기본 원리
categories:
- Java Concurrency In Practice
feature_text: |
  ## 기본 원리
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---

### 1. 개요
<br/>
#### 1.3. 스레드 사용의 위험성
<br/>
##### 1.3.2. 활동성 위험
<br/>

+ 안전성  
"잘못된 일이 생기지 않는다"  

+ 활동성
"원하는 일이 결국 일어난다", "뭔가 좋은 일이 반드시 일어난다"

#### 1.4. 스레드는 어디에나
<br/>
프레임웍은 프로그램 컴포넌트를 호출할 때 프레임웍 내부의 스레드에서 호출하기 때문에 자동으로 프로그램이 스레드를 활용하는 것과 동일한 효과를 준다. 컴포넌트는 언제나 프로그램 내부의 상태에 접근하기 때문에 해당 상태에 접근하는 모든 코드 경로에 해당하는 컴포넌트 역시 스레드 안전해야 한다.

### 2. 스레드 안전성
<br/>
만약 여러 스레드가 변경할 수 있는 하나의 상태 변수를 적절한 동기화 없이 접근하면 그 프로그램은 잘못된 것이다. 이렇게 잘못된 프로그램을 고치는 데는 세 가지 방법이 있다.  

+ 해당 상태 변수를 스레드 간에 공유하지 않거나
+ 해당 상태 변수를 변경할 수 없도록 만들거나
+ 해당 상태 변수에 접근할 땐 언제나 동기화를 사용한다.

스레드 안전한 클래스를 설계할 땐, 바람직한 객체 지향 기법이 왕도다. 캡슐화와 불변 객체를 잘 활용하고, 불변 조건을 명확하게 기술해야 한다.  

#### 2.1. 스레드 안전성이란?
<br/>
+ 정확성  
클래스가 해당 클래스의 명세에 부합하는 것으로 잘 작성된 클래스 명세는 객체 상태를 제약하는 불변조건(invariants)과 연산 수행 후 효과를 기술하는 후조건(postcondition)을 정의한다.  

여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어디에 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다.

스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.  

상태 없는 객체는 항상 스레드 안전하다.  

#### 2.2. 단일 연산
<br/>
##### 2.2.3. 복합 동작
<br/>
작업 A를 실행 중인 스레드 관점에서 다른 스레드가 작업 B를 실행할 때 작업 B가 모두 수행됐거나 또는 전혀 수행되지 않은 두가지 상태로만 파악된다면 작업 A의 눈으로 볼 때 작업 B는 단일 연산이다. 단일 연산 작업은 자신을 포함해 같은 상태를 다루는 모든 작업이 단일 연산인 작업을 지칭한다.  

가능하면 클래스 상태를 관리하기 위해 AtomicLong처럼 스레드에 안전하게 이미 만들어져 있는 객체를 사용하는 편이 좋다. 스레드 안전하지 않은 상태 변수를 선언해두고 사용하는 것보다 이미 스레드 안전하게 만들어진 클래스가 가질 수 있는 가능한 상태의 변화를 파악하는 편이 훨씬 쉽고, 스레드 안전성을 더 쉽게 유지하고 검증할 수 있다.  

#### 2.3. 락
<br/>
상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.  

##### 2.3.1. 암묵적인 락
<br/>
자바에는 단일 연산 특성을 보장하기 위해 synchronized라는 구문으로 사용할 수 있는 락을 제공한다(락뿐만 아니라 다른 동기화 수단 모두 가시성이라는 중요한 특성을 갖고 있다). synchronized 구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성된다.  

모든 자바 객체는 락으로 사용할 수 있다. 이와 같이 자바에 내장된 락을 암묵적인 락(intrinsic lock) 혹은 모니터 락(monitor lock)이라고 한다. 락은 스레드가 synchronized 블록에 들어가기 전에 자동으로 확보되며 정상적으로든 예외가 발생해서든 해당 블록을 벗어날 때 자동으로 해제된다. 해당 락으로 보호된 synchronized 블록이나 메소드에 들어가야만 암묵적인 락을 확보할 수 있다.  

자바에서 암묵적인 락은 뮤텍스(mutexes, 또는 mutual exclusion lock(즉 상호 배제 락))로 동작한다. 즉 한 번에 한 스레드만 특정 락을 소유할 수 있다.  

##### 2.3.2. 재진입성
<br/>
스레드가 다른 스레드가 가진 락을 요청하면 해당 스레드는 대기 상태에 들어간다. 하지만 암묵적인 락은 재진입 가능(reentrant)하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있다. 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미한다.  

재진입성을 구현하려면 각 락마다 확보 횟수와 확보한 스레드를 연결시켜 둔다. 확보 횟수가 0이면 락은 해제된 상태이다. 스레드가 해제된 락을 확보하면 JVM이 락에 대한 소유 스레드를 기록하고 확보 횟수를 1로 지정한다. 같은 스레드가 락을 다시 얻으면 횟수를 증가시키고, 소유한 스레드가 synchronized 블록 밖으로 나가면 횟수를 감소시킨다. 이렇게 횟수가 0이 되면 해당 락은 해제된다.  

#### 2.4. 락으로 상태 보호하기
<br/>
락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 때문에, 공유된 상태에 배타적으로 접근할 수 있도록 보장하는 규칙을 만들 때 유용하다. 이런 절차를 정확하게 따르면 항상 일관적인 상태를 유지할 수 있다.  

여러 스레드에서 접근할 수 있고 변경 가능한 모든 변수를 대상으로 해당 변수에 접근할 때는 항상 동일한 락을 먼저 확보한 상태여야 한다. 이 경우 해당 변수는 확보된 락에 의해 보호된다고 말한다.  

모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 한다. 유지 보수하는 사람이 알 수 있게 어느 락으로 보호하고 있는지를 명확하게 표시하라.  

여러 변수에 대한 불변조건이 있으면 해당 변수들은 모두 같은 락으로 보호해야 한다.  

#### 2.5. 활동성과 성능  
종종 단순성과 성능이 서로 상충할 때가 있다. 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성(잠재적으로 안정성을 훼손하면서)을 희생하고픈 유혹을 버려야 한다.  

복잡하고 오래 걸리는 계산 작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 한 락을 잡지 말아라.  

### 3. 객체 공유
<br/>
#### 3.1. 가시성
<br/>
+ 재배치(reordering) 현상  
특정 메소드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제  

얼핏 생각해보면 이런 현상이 나타난다는 것이 설계상의 문제점이라고 볼 수도 있지만, 실제로는 JVM이 최신 컴퓨터 하드웨어가 제공하는 기능을 100% 활용할 수 있게 의도적으로 설계한 부분이다. 예를 들어 자바 메모리 모델(Java Memory Model)에서는 별다른 동기화 구조가 잡혀 있지 않은 경우에 컴파일러가 직접 코드 실행 순서를 조절하면서 하드웨어 레지스터에 데이터를 캐시하거나 CPU가 명령 실행 순서를 재배치하고 프로세서 내부의 캐시에 데이터를 보관하는 등의 작업을 할 수 있도록 되어 있다.

동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM(자바 가상 머신) 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다. 다시 말하자면, 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 '반드시 이런 순서로 동작할 것이다'라고 단정지을 수 없다.  

##### 3.1.1. 스테일 데이터
<br/>
+ 스테일 현상  
읽으려는 데이터가 최신 데이터가 아닌 상황  

##### 3.1.2. 단일하지 않은 64비트 연산
<br/>
동기화되지 않은 상태에서 특정 스레드가 변수의 값을 읽으려 한다면 스테일 상태의 값을 읽어갈 가능성이 있긴 하지만, 그래도 전혀 엉뚱한 값을 가져가는 것이 아니라 바로 이전에 다른 스레드에서 설정한 값을 가져가게 된다. 말하자면 '전혀 난데 없는 값이 생기지는 않는다'는 정도로 생각할 수 있겠다.  

하지만 64비트를 사용하는 숫자형(double이나 long 등)에 volatile 키워드를 사용하지 않은 경우에는 난데없는 값마저 생길 가능성이 있다. 자바 메모리 모델은 메모리에서 값을 가져오고(fecth) 저장(store)하는 연산이 단일해야 한다고 정의하고 있지만, volatile로 지정되지 않은 long이나 double 형의 64비트 값에 대해서는 메모리에 쓰거나 읽을 때 두 번의 32비트 연산을 사용할 수 있도록 허용하고 있다. 따라서 volatile을 지정하지 않은 long 변수의 값을 쓰는 기능과 읽는 기능이 서로 다른 스레드에서 동작한다면, 이전 값과 최신 괎에서 각각 32비트를 읽어올 가능성이 생긴다. 따라서 스테일 문제를 신경 쓰지 않는다 해도, volatile로 지정하지도 않고 락을 사용해 동기화하지도 않은 상태로 long이나 double 값을 동시에 여러 스레드에서 사용할 수 있다면 항상 이상한 문제를 만날 가능성이 있다.  

##### 3.1.3. 락과 가시성
<br/>
락은 상호 배제(mutual exclusion)뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용한다. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야 한다.  

##### 3.1.4. volatile 변수
<br/>
자바 언어에서는 volatile 변수로 약간 다른 형태의 좀더 약한 동기화 기능을 제공하는데, 다시 말해 volatile로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다. 특정 변수를 선언할 때 volatile 키워드를 지정하면, 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안 된다'고 이해한다. volatile로 지정된 변수는 프로세서의 레지서터에 캐시되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있다.  

동기화하고자 하는 부분을 명확하게 볼 수 있고, 구현하기가 훨씬 간단한 경우에만 volatile 변수를 활용하자. 반대로 작은 부분이라도 가시성을 추론해봐야 하는 경우에는 volatile 변수를 사용하지 않는 것이 좋다. volatile 변수를 사용하는 적절한 경우는, 일반적으로 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트(초기화, 종료 등)가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우 등이 해당된다.  

디버깅 팁: 서버 애플리에키션을 작성하고 있다면 구현이나 테스트 작업을 진행하는 도중에도 JVM을 실행할 때 JVM 자체가 제공하는 -server 옵션을 사용해보기 바란다. JVM에 -server 옵션을 지정하면 일반적인 상태(client 상태)보다 더 많은 최적화 방법을 동원하는데, 예를 들어 반복문 내부에서 전혀 값이 바뀌지 않는 내용을 반복문 밖으로 빼내는 등의 최적화 작업이 일어난다. 따라서 -server 옵션을 지정하지 않은 상태로 개발이나 테스트 과정을 전행하고 실 서버에 적용할 때에만 -server 옵션을 지정하면, 프로그램이 예상했던 대로 작동하지 않을 가능성이 있다.  

락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있다. 하지만 volatile 변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.  

정리하자면, volatile 변수는 다음과 같은 상황에서만 사용하는 것이 좋다.  

+ 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재
+ 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다.
+ 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우  

#### 3.2. 공개와 유출
<br/>
특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개(published)되었다고 한다.

+ 에일리언 메소드  
클래스를 상속받으면서 오버라이드 할 수 있는 메소드  

+ 유출(escaped) 상태  
의도적으로 공개시키지 않았지만 외부에서 사용할 수 있게 공개된 경우  

##### 3.2.1. 성성 메소드 안전성
<br/>
일반적으로 생성 메소드가 완전히 종료하고 난 이후가 되어야 객체의 상태가 개발자가 예상한 상태로 초기화되기 때문에 생성 메소드가 실행되는 도중에 해당 객체를 외부에 공개한다면 정상적이지 않은 상태의 객체를 외부에서 불러 사용할 가능성이 있다. 이런 일은 공개하는 코드가 생성 메소드의 가운데 부분에 있을 뿐만 아니라, 생성 메소드의 가장 마지막 부분에 공개하는 코드가 있다 해도 충분히 가능한 일이다. 생성 메소드 실행 도중에 this 변수가 외부에 공개된다면, 이론적으로 해당 객체는 정상적으로 생성되지 않았다고 말할 수 있다.  

좀 더 정확하게 말하자면, 객체의 this 변수는 생성 메소드가 완전하게 종료되기 전까지는 외부에 절대 공개되면 안 된다. 이런 부분을 확실하게 할 수 있도록 생성 메소드를 실행하는 동안 this 변수를 한군데에 넣어두고, 생성 메소드가 종료될 때까지 다른 스레드에서 사용하지 못하도록 막을 수 있다.  

생성 메소드를 실행하는 도중에는 this 변수가 외부에 유출되지 않게 해야 한다.  

#### 3.3. 스레드 한정
<br/>
변경 가능한 객체를 공유해 사용하는 경우에는 항상 동기화시켜야 한다. 만약 동기화를 시키지 않아야 한다면, 기본적으로는 객체를 사용하지 않을 수밖에 없다. 특정 객체를 단일 스레드에서만 활요한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없다. 이처럼 객체를 사용하는 스레드를 한정(confine)하는 방법으로 스레드 안전성을 확보할 수 있다. 객체 인스턴스를 특정 스레드에 한정시켜두면, 해당하는 객체가 아니라 해도 자동으로 스레드 안전성을 확보하게 된다.  

##### 3.3.2. 스택 한정
<br/>
스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법이라고 할 수 있다. 변수를 클래스 내부에 숨겨두면 변경 상태를 관리하기가 쉬운데, 또한 클래스 내부에 숨겨둔 변수는 특정 스레드에 쉽게 한정시킬 수도 있다. 로컬 변수는 모두 암묵적으로 현재 실행 중인 스레드에 한정되어 있다고 볼 수 있다. 즉 로컬 변수는 현재 실행 중인 스레드 내부의 스택에만 존재하기 때문이며, 스레드 내부의 스택은 외부 스레드에서 볼 수 없다.  

##### 3.3.3. ThreadLocal
<br/>
스레드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀더 형식적인 방법으로 ThreadLocal이 있다. ThreadLocal 클래스에는 get과 set 메소드가 있는데 호출하는 스레드마다 다른 값을 사용할 수 있도록 관리해준다. 다시 말해 ThreadLocal 클래스의 get 메소드를 호출하면 현재 실행 중인 스레드에서 최근에 set 메소드를 호출해 저장했던 값을 가져올 수 있다.  

스레드 로컬 변수는 변경 가능한 싱글턴이나 전역 변수 등을 기반으로 설계되어 있는 구조에서 변수가 임의로 공유되는 상황을 막기 위해 사용하는 경우가 많다.  

이런 방법은 굉장히 자주 호출하는 메소드에서 임시 버퍼와 같은 객체를 만들어 사용해야 하는데, 임시로 사용할 객체를 매번 새로 생성하는 대신 이미 만들어진 객체를 재활용하고자 할 때 많이 사용한다.  

특정 스레드가 ThreadLocal.get 메소드를 처음 호출한다면 initialValue 메소드에서 값을 만들어 해당 스레드에게 초기 값으로 넘겨준다. 스레드별 값은 실제로 Thread 객체 자체에 저장되어 있으며, 스레드가 종료되면 스레드별 값으로 할당되어 있던 부분도 가비지 컬렉터가 처리한다.  

만약 원래 단일 스레드에서 동작하던 기능을 멀티스레드 환경으로 구성해야 할 때, 그 의미에 따라 다르지만 공유된 전역 변수를 ThreadLocal을 활용하도록 변경하면 스레드 안전성을 보장할 수 있다. 단일 스레드 애플리케이션에서 프로그램 전체를 대상으로 사용하던 캐시를 멀티스레드 애플리케이션에서는 여러 개의 스레드별 캐시로 나눠 사용하는 편이 더 효과적일 것이다.  

ThreadLocal 클래스는 애플리케이션 프로임웍을 구현할 때 상당히 많이 사용되는 편이다. 예를 들어 J2EE 컨테이너는 EJB를 사용하는 동안 해당 스레드와 트랜잭션 컨텍스트를 연결해 관리한다. 이처럼 스레드 단위로 트랜잭션 컨텍스트를 관리하고자 할 대는 static으로 선언된 ThreadLocal 변소에 트랜잭션 컨텍스트를 넣어두면 편리하다. 만약 프레임웍에서 현재 진행 중인 트랜잭션이 어느 것인지 확인하고 싶다면 트랜잭션이 보관되어 있는 ThreadLocal 클래스에서 쉽게 찾아낼 수 있다. 이런 방법을 활용하면 메소드를 호출할 때마다 현재 실행 중인 스레드의 정보를 넘겨줘야 할 필요하는 없지만, 이런 방법을 사용하는 코드는 해당 프레임웍에 대한 의존성을 갖게 된다.  

이렇게 편리하긴 하지만, 전역 변수가 아니면서도 전역 변수처럼 동작하기 때문에 프로그램 구조상 전역 변수를 남발하는 결과를 가져올 수도 있고, 따라서 메소드에 당연히 인자로 넘겨야 할 값을 ThreadLocal을 통해 뒤로 넘겨주는 방법을 사용하면서 프로그램의 구조가 허약해질 가능성도 높다. 일반적인 전역 변수가 갖는 단점처럼 ThreadLocal를 사용할 때에도 재사용성(reusability)을 크게 떨어뜨릴 수 있고, 객체 간에 눈에 보이지 않는 연결 관계를 만들어내기 쉽기 때문에 애플리케이션에 어떤 영향을 미치는지 정확하게 알고 신경 써서 사용해야 한다.  

#### 3.4. 불변성
<br/>
+ 불변 객체  
맨 처음 생성되는 시점을 제외하고는 그 값이 전혀 바뀌지 않는 객체  

불변 객체는 언제라도 스레드에 안전하다.  

다음 조건을 만족하면 해당 객체는 불변 객체다.  

+ 생성되고 난 이후에는 객체의 상태를 변경할 수 없다.
+ 내부의 모든 변수는 final로 설정돼야 한다.
+ 적절한 방법으로 생성돼야 한다(예를 들어 this 변수에 대한 참조가 외부에 유출되지 않아야 한다).  

##### 3.4.1. final 변수
<br/>
final 키워드를 적절하게 사용하면 초기화 안전성(initialization safety)을 보장하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있다.  

외부에서 반드시 사용할 일이 없는 변수는 private으로 선언하는 게 괜찮은 방법인 만큼, 나중에 변경할 일이 없다고 판단되는 변수는 final로 선언해두는 것도 좋은 방법이다.  

#### 3.5. 안전 공개
<br/>
##### 3.5.2. 불변 객체와 초기화 안전성
<br/>
불변 객체는 별다른 동기화 방법을 적용하지 않았다 해도 어느 스레드에서건 마음껏 안전하게 사용할 수 있다. 불변 객체를 공개하는 부분에 동기화 처리를 하지 않았다 해도 아무런 문제가 없다.  

##### 3.5.3. 안전한 공개 방법의 특성
<br/>
객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부의 스레드에게 동시에 볼 수 있어야 한다. 올바르게 생성 메소드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개할 수 있다.  

+ 객체에 대한 점조를 static 메소드에서 초기화시킨다.
+ 객체에 대한 참조를 volatile 변수 도는 AtomicReference 클래스에 보관한다.
+ 객체에 대한 참조를 올바르게 생성된 클래스 내부의 final 변수에 보관한다.
+ 락을 사용해 올바르게 막혀 있는 변수에 객체에 대한 참조를 보관한다.  

##### 3.5.4. 결과적으로 불변인 객체
<br/>
기술적으로만 본다면 특정 객체가 불변일 수 없다고 해도, 한 번 공개된 이후에는 그 내용이 변경되지 않는다고 하면 결과론적으로 봤을 때 해당 객체도 불변 객체라고 볼 수 있다. 이런 정도의 불변성이라고 하면 불변 객체를 정의하면서 살펴봤던 여러 가지 요구 조건을 반드시 만족시켜야 할 필요는 없다. 대신 프로그램 내부에서 해당 객체를 한 번 공개하는 이후에는 마치 불변 객체인 것처럼 사용하기만 하면 된다.  

안전하게 공개한 결과적인 불변 객체는 별다른 동기화 작업 없이도 여러 스레드에서 안전하게 호출해 사용할 수 있다.  

##### 3.5.5. 가변 객체
<br/>
가변성에 따라 객체를 공개할 때 필요한 점을 살펴보면 다음과 같다.  

+ 불변 객체는 어떤 방법으로 공개해도 아무 문제가 없다.
+ 결과적으로 불변인 객체는 안전하게 공개해야 한다.
+ 가변 객체는 안전하게 공개해야 하고, 스레드에 안전하게 만들거나 락으로 동기화시켜야 한다.  

##### 3.5.6. 객체를 안전하게 공유하기
<br/>
여러 스레드를 동시에 사용하는 병렬 프로그램에서 객체를 공유해 사용하고자 할 때 가장 많이 사용되는 몇 가지 원칙을 살펴보면 다음과 같다.  

+ 스레드 한정  
스레드에 한정된 객체는 완전하게 해당 스레드 내부에 존재하면서 그 스레드에서만 호출해 사용할 수 있다.  

+ 읽기 전용 객체를 공유  
읽기 전용 객체를 공유해 사용한다면 동괴화 작업을 하지 않더라도 여러 스레드에서 언제든지 마음껏 값을 읽어 사용할 수 있다. 물론 읽ㄱ기 전용이기 때문에 값이 변경될 수는 없다. 불변 객체와 결과적ㄱ으로 불변인 객체가 읽기 전용 객체에 해당한다고 볼 수 있다.  

+ 스레드에 안전한 객체를 공유  
스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경 쓸 필요가 없고, 여러 스레드에서 마음껏 호출해 사용할 수 있다.  

+ 동기화 방법 적용  
특정 객체에 동기화 방법을 적용해두면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없다. 스레드에 안전한 객체 내부에서 사용하는 객체나 공개된 객체 가운데 특정 락을 확보해야 사용할 수 있도록 막혀 있는 객체 등에 동기화 방법이 적용되어 있다고 볼 수 있다.  

### 4. 객체 구성
<br/>
#### 4.1. 스레드 안전한 클래스 설계
<br/>
클래스가 스레드 안전성을 확보하도록 설계하고자 할 때에는 다음과 같은 세 가지를 고려해야 한다.  

+ 객체의 상태를 보관하는 변수가 어떤 것인가?
+ 객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가?
+ 객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책  

+ 동기화 정책  
객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법  

동기화 정책에는 객체의 불변성, 스레드 한정, 락  등을 어떻게 적절하게 활용해 스레드 안전성을 확보할 수 있으며 어떤 변수를 어떤 락으로 막아야 하는지 등의 내용을 명시한다. 클래스를 유지보수하기 좋게 관리하려면 해당 객체에 대한 동기화 정책을 항상 문서로 작성해둬야 한다.  

##### 4.1.1. 동기화 요구사항 정리
<br/>
+ 상태 범위(state space)  
객체와 변수가 가질 수 있는 가능한 값의 범위  

클래스 내부의 상태나 상태 변화와 관련해 여러 가지 재약 조건이 있을 수 있는데, 이런 제약 조건에 따라 또 다른 동기화 기법이나 캡슐화 방법을 사용해야 할 수도 있다. 클래스가 특정 상태를 가질 수 없도록 구현해야 한다면, 해당 변수는 클래스 내부에 숨겨둬야만 한다. 변수를 숨겨두지 않으면 외부에서 클래스가 '올바르지 않다'고 정의한 값을 지정할 수 있기 때문이다. 그릭고 특정한 연산을 실행했을 때 올바르지 않은 상태 값을 가질 가능성이 있다면 해당 연산은 단일 연산으로 구현해야 한다. 반대로 클래스에서 변수의 값에 별다른 제약 조건을 두지 않는다면 클래스의 유연성과 실행 성능을 높인다는 측면에서 이와 같은 동기화 방법이나 캡슐화 기법을 사용하지 않아도 되겠다.  

객체가 가질 수 있는 값의 범위와 변동 폭을 정확하게 인식하지 못한다면, 스레드 안전성을 완벽하게 확보할 수 없다. 클래스의 상태가 정상적이라는 여러 가지 제약 조건이 있을 때 클래스의 상태를 정상적으로 유지하려면 여러 ㄱ가지 추가적인 동기화 기법을 적용하거나 상태 변수를 클래스 내부에 적절히 숨겨야 한다.  

##### 4.1.2. 상태 의존 연산
<br/>
+ 상태 의존 연산  
현재 조건에 따라 동작 여부가 결정되는 연산  
ex) 아무것도 들어 있지 않은 큐에서는 값을 뽑아낼 수가 없다.

##### 4.1.3. 상태 소유권
<br/>
변수를 통해 객ㄱ체의 상태를 정의하고자 할 때에는 해당 객체가 실제로 '소유하는' 데이터만을 기준으로 삼아야 한다.  

좋은 건지 나쁜 건지는 모르겠지만 가비지 컬렉션 기능을 고려한다면 객체의 소유권 개념을 생각하기가 어렵다. C++ 언어에서 특정 메소드에 객체 인스턴스를 넘겨주는 상황을 생각해보면, 호출하는 메소드에 객체와 함께 객체에 대한 소유권도 함께 넘겨주는 것인지, 잠시만 사용하도록 빌려주는 형식인지, 아니면 메소드 인자로 넘겨주지만 걔속해서 함께 사용하는 모양인지를 명확학게 정의할 수 있다. 물론 자바 언어로 프로그램을 작성할 때에도 이와 같은 객체 소유권의 문제를 대부분 조절할 수 있지만 ㄱ객체를 공유하는 데 있어 오류가 발생하기 쉬운 부분을 가비지 컬렉터가 대부분 알아서 조절해주기 때문에 소유권 개념이 훨씬 불명확한 경우가 많다.  

대부분의 경우 소유권과 캡슐화 정책은 함께 고려하는 경우가 많다. 캡슐화 정책은 내부에 객체와 함께 상태 정보를 숨기기 때문에 객ㄱ체의 상태에 대한 소유권이 있다. 특정 변수에 대한 소유권을 갖고 있기 때문에 특정 변수의 상태가 올바르게 유지되도록 조절하는 락 구조가 어떻게 움직이는지에 대해서도 소유권을 갖는다. 보다시피 소유권이란 말은 통제권이라는 말과 비슷한 의미를 갖지만, 특정 변수를 객체 외부로 공개하고 나면 해당 변수에 대한 통제권을 어느 정도 잃는다. 다시 말해 그저 '공동 소유권' 정도를 가질 뿐이다. 클래스는 일반 메소드나 생성 메소드로 넘겨받은 객체에 대한 소유권을 갖지 않는다는 게 일반적인 모양이지만, 넘겨받은 객체의 소유권을 확보하도록 메소드를 특별하게 작성하면 소유권을 확보할 수도 있다(동기화된 컬렉션 라이브러리에서 사용하는 팩토리 메소드가 전형적인 예이다).  

컬렉션 클래스에는 '소유권 분리'의 형태를 사용하는 경우도 많다. 소유권 부리는 컬렉션 클래스를 놓고 볼 때 컬렉션 내부의 구조에 대한 소유권은 컬렉션 클래스가 갖고, 컬렉션에 추가되어 있는 객체에 대한 소유권은 컬렉션을 호출해 사용하는 클라이언트 프로그램이 갖는 구조이다.  
ex) ServletContext  

#### 4.2. 인스턴스 한정
<br/>
데이터를 객체 내부에 캡슐화해 숨겨두면 숨겨진 내용은 해당 객체의 메소드에서만 사용할 수 있기 때문에 숨겨진 데이터를 사용하고자 할 때에는 항상 지정된 형태의 락이 적용되는지 쉽고 정확하게 파악할 수 있다.  

인스턴스 한정 기법을 사용하면 전체 프로그램을 다 뒤져보지 않고도 스레드 안전성을 확보하고 있는지 쉽게 분석해 볼 수 있기 때문에 스레드에 안전한 객체를 좀 더 쉽게 구현할 수 있다.  

#### 4.3. 스레드 안전성 위임
<br/>
##### 4.3.3. 위임할 때의 문제점
<br/>
클래스가 서로 의존성 없이 독립적이고 스레드 안전한 두 개 이상의 클래스를 조합해 만들어져 있고 두 개 이상의 클래스를 한번에 처리하는 복합 연산 메소드가 없는 상태라면, 스레드 안전성을 내부 변수에게 모두 위임할 수 있다.  

##### 4.3.4. 내부 상태 변수를 외부에 공개
<br/>
상태 변수가 스레드 안전하고, 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않고, 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다면, 해당 변수는 외부에 공개해도 안전하다.  

#### 4.4. 스레드 안전하게 구현된 클래스에 기능 추가
<br/>
기존 클래스를 상속받아 기능을 추가하는 방법은 기존 클래스에 직접 기능을 추가하는 방법보다 문제가 생길 위험이 훨씬 많다. 동기화를 맞춰야 할 대상이 두 개 이상의 클래스에 걸쳐 분산되기 때문이다. 만약 상위 클래스가 내부적으로 상태 변수의 스레드 안전성을 보장하는 동기화 기법을 약간이라도 수정한다면 그 하위 클래스는 본의 아니게 적절하나 락을 필요한 부분에 적용하지 못할 가능성이 높기 때문에 쥐도 새도 모르게 동기화가 깨질 수 있다.  

##### 4.4.1. 호출하는 측의 동기화
<br/>
+ 클라이언트 측 락(client-side lock)  
X라는 객체를 사용할 때 X 객체가 사용하는 것과 동일한 락을 사용해 스레드 안전성을 확보하는 방법  

특정 클래스를 상속받아 원하는 기능을 단일 연산으로 추가하는 방법은 락으로 동기화하는 기능을 여러 개의 클래스에 분산시키기 때문에 그다지 안정적이지 못한 방법이라고 한다면, 제3의 클래스를 만들어 클라이언트 측 락 방법으로 단일 연산을 구현하는 방법은 특정 클래스 내부에서 사용하는 락을 전혀 관계없는 제3의 클래스에서 갖다 쓰기 때문에 훨씬 위험해 보이는 방법이다. 락이나 동기화 전략에 대한 내용을 정확하게 구현하고 공지하지 않은 클래스를 대상으로 클라이언트 측 락을 적용하려면 충분히 주의를 기울여야 한다.  

클라이언트 측 락은 클래스 상속과 함께 봤을 때 여러 가지 공통점, 예를 들어 클라이언트나 하위 클래스에서 새로 구현한 내용과 원래 클래스에 구현되어 있던 내용이 밀접하게 연관되어 있다는 등의 공통점이 있다. 하위 클래스에서 상위 클래스가 캡슐화한 내용을 공개해버리는 것처럼 클라이언트 측 락을 구현할 때도 캡슐화되어 있는 동기화 정책을 무너뜨릴 가능성이 있다.  

#### 4.5. 동기화 정책 문서화하기
<br/>
구현한 클래스가 어느 수준까지 스레드 안전성을 보장하는지에 대해 충분히 문서를 작성해둬야 한다. 동기화 기법이나 정책을 잘 정리해두면 유지보수 팀이 원할하게 관리할 수 있다.  

### 5. 구성 단위
<br/>
#### 5.1. 동기화된 컬렉션 클래스
<br/>
##### 5.1.2. Iterator와 ConcurrentModificationException
<br/>
+ 즉시 멈춤(fail-fast)  
반복문을 실행하는 도중에 컬렉션 클래스 내부의 값을 변경하는 상황이 포착되면 그 즉시 ConcurrentModificationException 예외를 발생시키고 멈추는 처리 방법이다.  

컬렉션 클래스는 내부에 값 변경 횟수를 카운트하는 변수를 마련해두고, 반복문이 실행되는 동안 변경 횟수 값이 바뀌면 hasNext 메소드나 next 메소드에서 ConcurrentModificationException을 발생시킨다. 더군다나 변경 횟수를 확인하는 부분이 적절하게 동기화되어 있지 않기 때문에 반복문에서 변경 횟수를 세는 과정에서 스테일 값을 사용하게 될 가능성도 있고, 따라서 변경 작업이 있었다는 것을 모를 수도 있다는 말이다. 이렇게 구현한 모습이 문제가 있기는 하지만 전체적인 성능을 떨어뜨릴 수 있기 때문에 변경 작업이 있었다는 상황을 확인하는 기능에 정확한 동기화 기법을 적용하지 않았다고 볼 수 있다.  

단일 스레드 환경의 프로그램에서도 ConcurrentModificationException이 발생할 수 있다. 반복문 내부에서 Iterator.remove 등의 메소드를 사용하지 않고 해당하는 컬렉션의 값을 직접 제거하는 등의 작업을 하려 하면 예외 상황이 발생한다.  

반복문을 실행하는 코드 전체를 동기화시키는 방법이 그다지 훌륭한 방법이 아니라고 주장하는 여러 가지 이유를 생각해 볼 수 있다. 컬렉션에 엄청나게 많은 수의 값이 들어 있거나 값마다 반복하면서 실행해야 하는 작업이 시간이 많이 소모되는 작업일 수 있는데, 이런 경우에는 컬렉션 클래스 내부의 값을 사용하고자 하는 스레드가 상당히 오랜 시간을 대기 상태에서 기다려야 할 수 있다는 말이다. 또한 반복문에서 락을 잡고 있는 상황에서 또 다른 락을 확보해야 한다면, 데드락(deadlock)이 발생할 가능성도 높아진다. 소모상태(starvation)나 데드락의 위험이 있는 상태에서 컬렉션 클래스를 오랜 시간 동안 락으로 막아두고 있는 상태라면 전체 애플리케이션의 확장성을 해칠 수도 있다. 반복문에서 락을 오래 잡고 있으면 있을수록, 락을 확보하고자 하는 스레드가 대기 상태에 많이 쌓일 수 있고, 대기 상태에 스레드가 적체되면 될수록 CPU 사용량이 급격하게 증가할 가능성이 높다.  

반복문을 실행하는 동안 컬렉션 클래스에 들어 있는 내용에 락을 걸어둔 것과 비슷한 효과를 내려면 clone 메소드로 복사본을 만들어 복사본을 대상으로 반복문을 사용할 수 있다. 이렇게 clone 메소드로 복사본을 만들어 복사본을 대상으로 반복문을 사욯할 수 있다. 이렇게 clone 메소드로 복사한 사본은 특정 스레드에 한정되어 있으므로 반복문이 실행되는 동안 다른 스레드에서 컬렉션 사본을 건드리기 어렵기 때문에 ConcurrentModificationException이 발생하지 않는다(물론 최소한 clone 메소드를 실행하는 동안에는 컬렉션의 내용을 변경할 수 없도록 동기화시켜야 한다). 어찌됐건 clone 메소드로 복사본을 만드는 작업에도 시간은 필요하기 마련이다. 따라서 반복문에서 사용할 목적으로 복사본으로 만드는 방법도 컬렉션에 들어 있는 항목의 개수, 반복문에서 개별 항목마다 실행해야 할 작업이 시간이 얼마나 오래 걸리는지, 컬렉션의 여러 가지 기능에 비해 반복 기능을 얼마나 빈번하게 사용하는지, 그리고 응답성과 실행 속도 등의 여러 가지 요구 사항을 충분히 고려해서 적절하게 적용해야 한다.  

##### 5.1.3. 숨겨진 Iterator
<br/>
락을 걸어 동기화시키면 Iterator를 사용할 때 ConcurrentModificationException이 발생하지 않도록 제어할 수는 있다. 하지만 컬렉션을 공유해 사용하는 모든 부분에서 동기화를 맞춰야 한다는 점을 잊어서는 안 된다.  

클래스 내우베엇 필욯란 변수를 모두 캡슐화하면 그 상태를 보존하기가 훨신 편리한 것처럼, 동기화 기법을 클래스 내부에 캡슐화하면 동기화 정책을 적용하기가 쉽다.  

컬렉션 클래스의 toString 메소드뿐만 아니라 hashCode 메소드나 equals 메소드도 내부적으로 iterator를 사용한다(클래스의 hashCode나 equals 메소드는 해당 클래스를 컬렉션에 보관할 때 빈번하게 호출된다). 뿐만 아니라 containAll, removeAll, retainAll 등의 메소드, 컬렉션 클래스를 넘겨받는 생성 메소드 등도 모두 내부적으로 iterator를 사용한다. 이렇게 내부적으로 iterator를 사용하는 모드 메소드에서 ConcurrentModificationException이 발생할 가능성이 있다.  

#### 5.2. 병렬 컬렉션
<br/>
자바 5.0은 여러 가지 병렬 컬렉션 클래스르 제공하면서 컬렉션 동기화 측면에서 많은 발전이 있었다. 동기화된 컬렉션 클래스는 컬렉션의 내부 변수에 접근하는 통로를 일련화해서 스레드 안정성을 확보했다. 하지만 이렇게 만들다 보니 여러 스레드가 한꺼번에 동기화된 컬렉션을 사용하려고 하면 동시 사용성은 상당 부분 손해를 볼 수밖에 없다.  

하지만 병렬 컬렉션은 여러 스레드에서 동시에 사용할 수 있도록 설계되어 있다. 자바 5.0에는 해시 기반의 HashMap을 대치하면서 병렬성을 확보한 ConcurrentHashMap 클래스가 포함되어 있다. 그리고 CopyOnWriteArrayList는 추가되어 있는 객체 목록을 반복시키며 열람하는 연산의 성능을 최우선으로 구현한 List 클래스의 하위 클래스이다. 또한 새로 추가된 ConcurrentMap 인터페이스를 보면 추가하려는 항목이 기존에 없는 경우에만 새로 추가하는 put-if-absent 연산, 대치(replace) 연산, 조건부 제거(conditional remove) 연산 등을 정의하고 있다.  

기존에 사용하던 동기화 컬렉션 클래스를 병렬 컬렉션으로 교체하는 것만으로도 별다른 위험 요소 없이 전체적인 성능을 상당히 끌어 올릴 수 있다.  

자바 6에는 ConcurrentSkipListMap과 ConcurrentSkipListSet이라는 클래스가 있다. ConcurrentSkipListMap과 ConcurrentSkipListSet은 각각 SortedMap과 SortedSet 클래스의 병렬성을 높이도록 발전된 형태라고 볼 수 있다.  

##### 5.2.1. ConcurrentHashMap
<br/>
ConcurrentHashMap은 HashMap과 같이 해시를 기반으로 하는 Map이다. 하지만 내부적으로는 이전에 사용하던 것과 전혀 다른 동기화 기법을 채택해 병렬성과 확장성이 훨씬 나아졌다. 이전에는 모든 연산에서 하나의 락을 사용했기 때문에 특정 시점에 하나의 스레드만이 해당 컬렉션을 사용할 수 있었다. 하지만 ConcurrentHashMap은 락 스트라이핑(lock striping)이라 부르는 굉장히 세밀한 동기화 방법을 사용해 여러 스레드에서 공유하는 상태에 훨씬 잘 대응할 수 있다. 값을 읽어가는 연산은 많은 수의 스레드라도 얼마든지 동시에 처리할 수 있고, 읽기 연산과 쓰기 연산도 동시에 처리할 수 있으며, 쓰기 연산은 제한된 개수만큼 동시에 수행할 수 있다. 속도를 보자면 여러 스레드가 동시에 동작하는 환경에서 일반적으로 훨씬 높은 성능 결과를 볼 수 있으며, 이와 함께 단일 스레드 환경에서도 성능상의 단점을 찾아볼 수 없다.  

다른 병렬 컬렉션 클래스와 비슷하게 ConcurrentHashMap 클래스도 Iterator를 만들어 내는 부분에서 많이 발전했는데, ConcurrentHashMap이 만들어 낸 Iterator는 ConcurrentHashMap의 항목을 대상으로 반복문을 실행하는 경우에는 따로 락을 걸어 동기화해야 할 필요가 없다. ConcurrentHashMap에서 만들어 낸 Iterator는 즉시 멈춤(fail-fase) 대신 미약한 일관성 전략을 취한다.  

+ 미약한 일관성 전략  
반복문과 동시에 컬렉션의 내용을 변경한다 해도 Iterator를 만들었던 시점의 상황대로 반복을 계속할 수 있다. 게다가 Iteraotr를 만들 시점 이후에 변경된 내용을 반영해 동작할 수도 있다(이 부분은 반드시 보장되지는 않는다).  

이렇게 발전된 부분이 많지만 물론 신경을 더 써야 할 부분도 생겼다. 병렬성 문제때문에 Map의 모든 하위 클래스에서 공통적으로 사용하는 size 메소드나 isEmpty 메소드의 의미가 약간 약해졌다. 예를 들어 size 메소드는 그 결과를 리턴하는 시점에 이미 실제 객체의 수가 바뀌었을 수 있기 때문에 정확히 말하자면 size 메소드의 결과는 정확한 값일 수 없고, 단지 추정 값일 뿐이다. 정확한 값이 아니라면 사용하는 데 어려움이 있을까 걱정이 되기도 하겠지만, 실제로는 size나 isEmpty의 결과가 추정 값이라 해도 그다지 문제되는 부분은 없다. 당연한 얘기지만 get, put, containsKey, remove 등의 핵심 연산의 병렬성과 성능을 높이기 위해서라면 size나 isEmpty의 의미가 약간 변할 수밖에 없다.  

동기화된 Map에서는 지원하지만 ConcurrentHashMap에서는 지원하지 않는 기능이 있는데, 바로 맵을 독점적으로 사용할 수 있도록 막아버리는 기능이다. Hashtable과 synchronizeMap 메소드를 사용하면 Map에 대한 락을 잡아 다른 스레드에서 사용하지 못하도록 막을 수 있다. 이런 작업이 흔히 필요한 일은 아니지만, 단일 연산으로 여러 개의 값을 Map에 넣고자 한다거나 Map의 내용을 여러 번 반복시켜볼 때 반복되는 내용과 순서가 바뀌지 않아야 한다는 등의 특별한 상황이라면 필요할 수도 있다. 아무튼 이런 정도의 단점은 충분히 상식적으로 이해할 수 있다고 본다.  

지금까지 살펴본 것처럼 ConcurrentHashMap을 사용하면 Hashtable이나 synchronizeMap 메소드를 사용하는 것에 비해 단점이 있기는 하지만, 훨씬 많은 장점을 얻을 수 있기 때문에 대부분의 경우에는 Hashtable이나 synchronizeMap을 사용하던 부분에 ConcurrentHashMap을 대신 사용기만 해도 별 문제 없이 많은 장점을 얻을 수 있다. 만약 작업 중인 애플리케이션에서 특정 Map을 완전히 독점해서 사용하는 경우가 있다면, 그 부분에 ConcurrentHashMap을 적용할 때는 충분히 신경을 기울여야 한다.  

##### 5.2.2. Map 기반의 또 다른 단일 연산
<br/>
ConcurrentHashMap 클래스는 독점적으로 사용할 수 있는 락이 없기 때문에 '없을 경우에만 추가하는' 연산과 같이 여러 개의 단일 연산을 모아 새로운 단일 연산을 만들고자 할 때 클라이언트 측 락 기법을 활용할 수 없다. 히자만 ConcurrentHashMap 클래스에는 일반적으로 많이 사용하는 '없을 경우에만 추가하는 put-if=absent' 연산, '동일한 경우에만 제가하는 remove-if-equal' 연산, '동일한 경우에만 대치하는 replace-if-equal' 연산과 같이 자주 필요한 몇 가지의 연산이 이미 구현되어 있다. 만약 이미 구현되어 있지 않은 기능을 사용해야 한다면, ConcurrentHashMap 보다 ConcurrentMap을 사용해 보는 편이 낫겠다.  

##### 5.2.3. CopyOnWriteArrayList
<br/>
CopyOnWriteArrayList 클래스는 동기화된 List 클래스보다 병렬성을 훨씬 높이고자 만들어졌다. 예를 들어 대부분의 일반적인 용도에 쓰일 때 병렬성이 향상됐고, 특히 List에 들어 있는 값을 Iterator로 불러다 사용하려 할 때 List 전체에 락을 걸거나 List를 복제할 필요가 없다(CopyOnWriteArrayList와 비슷하게 Set 인터페이스를 구현하는 CopyOnWriteArraySet도 있다).  

'변경할 때마다 복사'하는 컬렉션 클래스는 불변 객체를 외부에 공개하면 여러 스레드가 동시에 사용하려는 환경에서도 별다른 동기화 작업이 필요 없다는 작업이 필요 없다는 개념을 바탕으로 스레드 안전성을 확보하고 있다. 하지만 컬렉션이라면 항상 내용이 바뀌어야 하기 때문에, 컬렉션의 내용이 변경될 대마다 복사본을 새로 만들어 내는 전략을 취한다. 만약 CopyOnWriteArrayList 컬렉션에서 Iterator를 뽑아내 사용한다면 Iterator를 뽑아내는 시점의 컬렉션 데이터를 기준으로 반복하며, 반복하는 동안 컬렉션에 추가되거나 삭제되는 내용은 반복문과 상관 없는 복사본을 대상으로 반영하기 때문에 동시 사용성에 문제가 없다. 물론 반복문에서 락을 걸어야 할 필요가 있기는 하지만, 반복할 대상 전체를 한번에 거는 대신 개별 항목마다 가시성을 확보하려는 목적으로 잠깐씩 락을 거는 정도면 충분하다. 변경할 때마다 복사하는 컬렉션에서 뽑아낸 Iterator를 사용할 때는 ConcurrentModificationException이 발생하지 않으며, 컬렉션에 어떤 변경 작업을 가한다 해도 Iterator를 뽑아내던 그 시점에 컬렉션에 들어 있던 데이터를 정확하게 활용할 수 있다.  

물론 컬렉션의 데이터가 변경될 때마다 복사본을 만들어내기 때문에 성능의 측면에서 손해를 볼 수 있고, 특히나 컬렉션에 많은 양의 자료가 들어 있다면 손실이 클 수 있다. 따라서 변경할 때마다 복사하는 컬렉션은 변경 작업보다 반복문으로 읽어내는 일이 훨씬 빈번한 경우에 효과적이다. 이런 조건은 이벤트 처리 시스템에서 이벤트 리스너를 관리하는 부분에 유용하게 사용할 수 있다. 리스너를 활용해 이벤트를 처리하는 시스템에서는 입네트가 발생하는 부분에 이벤트를 처리할 리스너를 등록하고, 특정 이벤트가 발생하면 등록된 리스너를 차례로 호출하도록 되어 있다. 이런 경우 리스너를 등록하거나 해제하는 기능을 사용하는 빈도가 리스너 목록의 내용을 반복문으로 호출하는 기능의 발생 빈도보다 훨씬 낮기 때문에 변경할 때마다 복사하는 컬렉션을 사용하기에 적당한 상황이라고 할 수 있다.  

#### 5.3. 블로킹 큐와 프로듀서-컨슈머 패턴
<br/>
블로킹 큐(blocking queue)는 put과 take라는 핵심 메소드를 갖고 있고, 더불어 offer와 poll이라는 메소드도 갖고 있다. 만약 큐가 가득 차 있다면 put 메소드는 값을 추가할 공간이 생길 때까지 대기한다. 반대로 큐가 비어 있는 상태라면 take 메소드는 뽑아낼 값이 들어올 때까지 대기한다. 큐는 그 크기를 제한할 수도 있고 제한하지 않을 수도 있는데, 말 그대로 큐의 크기에 제한을 두지 않으면 항상 여유 공간이 있는 셈이기 때문에 put 연산이 대기 상태에 들어가는 일이 발생하지 않는다.  

블로 킹 큐는 포로듀서-컨슈머(producer-consumer) 패턴을 구현할 때 사용하기에 좋다.  

+ 프로듀서-컨슈머 패턴  
'해야 할 일' 목록을 가운데에 두고 작업을 만들어 내는 주체와 작업을 처리하는 주체를 분리시키는 설계 방법으로 작업을 만들어 내는 부분과 작업을 처리하는 부분을 완전히 분리할 수 있기 때문에 개발 과정을 좀더 병확하게 단순화시킬 수 있고, 작업을 생성하는 부분과 처리하는 부분이 각각 감당할 수 있는 부하를 조절할 수 있다는 장점이 있다.  

프로듀서-컨슈머 패턴을 적용해 프로그램을 구현할 때 블로킹 큐를 사용하는 경우가 많은데, 예를 들어 프로듀서는 작업을 새로 만들어 큐에서 쌓아두고, 컨슈머는 큐에 쌓여 있는 작업을 가져다 처리하는 구조다. 프로듀서는 어떤 컨슈머가 몇 개나 동작하고 있는지에 대해 전혀 신경 쓰지 않을 수 있다. 단지 새로운 작업 내용을 만들어 큐에 쌓아두기만 하면 된다. 반대로 컨슈머 역시 프로듀서에 대해서 뭔가를 알고 있어야 할 필요가 없다. 프로듀서과 몇 개이건, 얼마나 많은 작업을 만들어 내고 있건 상관이 없다. 단지 큐에 쌓여 있는 작업을 가져다 처리하기만 하면 된다. 블로킹 큐를 사용하면 여러 개의 프로듀서와 여러 개의 컨슈머가 작동하는 프로듀서-컨슈머 패턴을 손쉽게 구현할 수 있다. 큐와 함께 스레드 풀을 사용하는 경우가 바로 프로듀서-컨슈머 패턴을 활용하는 가장 흔한 경우라고 볼 수 있다.  

블로킹 큐에는 그 외에도 offer 메소드가 있는데, offer 메소드는 큐에 값을 넣을 수 없을 때 대기하지 않고 바로 공간이 모자라 추가할 수 없다는 오류를 알려준다. offer 메소드를 잘 활용하면 프로듀서가 작업을 많이 만들어 과부하에 이르는 상태를 좀더 효과적으로 처리할 수 있다. 예를 들어 부하를 분배하거나, 작업할 내용을 직렬화(serialize)해서 디스크에 임시로 저장하거나, 아니면 프로듀서 스레드의 수를 동적으로 줄이거나, 기타 여러 가지 방법을 사용해 프로듀서가 작업을 생성하는 양을 조절할 수 있겠다.  

블로킹 큐는 애플리케이션이 안정적으로 동작하도록 만들고자 할 대 요긴하게 사용할 수 있는 도구이다. 블로킹 큐를 사용하면 처리할 수 있는 양보다 훨씬 많은 작업이 생겨 부하가 걸리는 상황에서 작업량을 조절해 애플리케이션이 안정적으로 동작하도록 유도할 수 있다.  

프로듀서-컨슈머 패턴을 사용하면 각각의 프로그램ㅇ 코드는 서로를 연결하는 큐를 기준으로 서로 분리되지만, 움직이는 동작 자체는 큐를 사이에 두고 서로 간접적으로 연결되어 있다. 생각하기에는 컨슈머가 항상 밀리지 않고 작업을 마쳐준다고 가정하고, 따라서 작업 큐에 제한을 둘 필요가 없을 것이라고 마음 편하게 넘어갈 수도 있다. 하지만 이런 가정을 하는 순간 나중에 프로그램 구조를 뒤집어 엎어야 하는 원인을 하나 남겨두는 것뿐이니 주의하자. 블로킹 큐를 사용해 설계 과정에서부터 프로그램에 자원 관리 기능을 추가하자. 대다수의 경우에는 블로킹 큐만 사용해도 원하는 기능을 쉽게 구현할 수 있다. 하지만 프로그램이 블로킹 큐를 쉽게 적용할 수 없는 모양새를 갖고 있다면 세마포어(Semaphore)를 사용해 사용하기 적합한 데이터 구조를 만들어야 한다.  

자바 클래스 라이브러리에는 BlockingQueue 인터페이스를 구현한 클래스 몇 가지가 들어 있다. LinkedBlockingQueue와 ArrayBlockingQueue는 FIFO 형태의 큐이며, 기존에 클래스 라이브러리에 포함되어 있던 LinkedList와 ArrayList에 각각 대응ㅇ된다. 대신 병렬 프고르매 환경에서는 LinkedList나 ArrayList에서 동기화된 List 인스턴스를 뽑아 사용하는 것보다 성능이 좋다. PriorityBlockingQueue 클래스는 우선 순위를 기준으로 동작하는 큐이고, FIFO가 아닌 다른 순서로 큐의 항목을 처리해야 하는 경우에 손쉽게 사용할 수 있다. PriorityBlockingQueue 역시 항목의 순서를 정렬시켜 사용할 수 있는 여타 컬렉션 클래스와 동일하게 기본 정렬 순서(항목으로 추가되는 클래스가 Comparable 인터페이스를 구현하는 경우)로 정렬시키거나, 아니면 Comparator 인터페이스를 사용해 정렬시킬 수 있다.  

마지막으로 SynchronousQueue 클래스도 BlockingQueue 인터페이스를 구현하는데, 큐에 항목이 쌓이지 않으며, 따라서 큐 내부에 값을 저장할 수 있도록 공간을 할당하지도 않는다. 대신 큐에 값을 추가하려는 스레드나 값을 읽어가려는 스레드의 큐를 관리한다. SynchronousQueue에는 큐에 추가된 데이터를 보관할 공간이 없기 때문에 put 메소드나 take 메소드를 호출하면 호출한 메소드의 상대편 측에 해당하는 메소드를 다른 스레드가 호출할 때까지 대기한다. 이처럼 SynchronousQueue는 데이터를 넘겨 받을 수 있는 충분한 개수의 컨슈머가 대기하고 잇는 경우에 사용하기 좋다.  

프로듀서-컨슈머 패턴을 사용하면 성능의 측면에서도 이득을 많이 볼 수 있다. 알다시피 프로듀서와 컨슈머는 서로 독립적으로 실행된다. 따라서 예를 들어 프로듀서의 작업은 디스크나 네트웍 I/O에 시간을 많이 소모하고, 컨슈머는 CPU를 많이 사용하는 특성이 있다면 프로듀서와 컨슈머의 기능을 단일 스레드에서 순차적으로 실행하는 것보다 성능이 크게 높아질 수 있다. 더군다나 프로듀서와 컨슈머가 멀티스레드로 동작하는 수준에서 차이가 있다면, 프로듀서와 컨슈머가 긴밀하게 연결되어 있을수록 병렬 처리 성능이 떨어질 수밖에 없다.  

##### 5.3.2. 직렬 스레드 한정
<br/>
java.util.concurrent 패키지에 들어 있는 블로킹 큐 관련 클래스는 모두 프로듀서 스레드에서 객체를 가져와 컨슈머 스레드에 넘겨주는 과정이 세심하게 동기화되어 있다.  

프로듀서-컨슈머 패턴과 블로킹 큐는 가변 객체(mutable object)를 사용할 때 객체의 소유권을 프로듀서에서 컨슈머로 넘기는 과정에서 직렬 스레드 한정(serial thread confinement) 기법을 사용한다. 스레드에 한정된 객체는 특정 스레드 하나만이 소유권을 가질 수 있는데, 객체를 안전한 방법으로 공개하면 객체에 대한 소유권을 이전(transfer)할 수 있다. 이렇게 소유권을 이전하고 나면 이전받은 컨슈머 스레드가 객체에 대한 유일한 소유권을 가지며, 프로듀서 스레드는 이전된 객체에 대한 소유권을 완전히 잃는다. 이렇게 안전한 공개 방법을 사용하면 새로운 소유자로 지정된 스레드는 객체의 상태를 완벽하게 볼 수 있지만 원래 소유권을 갖고 있던 스레드는 전혀 상태를 알 수 없게 되어, 새로운 스레드 내부에 객체가 완전히 한정된다. 물론 새로 소유권을 확보한 스레드가 객체를 마음껏 사용할 수 있다.  

객체 풀(object pool)은 직렬 스레드 한정 기법을 잘 활용하는 예인데, 풀에서 소유하고 있던 객체를 외부 스레드에게 '빌려주는' 일이 본업이기 때문이다. 풀 내부에 소유하고 있던 객체를 외부에 공개할 때 적절한 동기화 작업이 되어 있고, 그와 함께 풀에서 객체를 빌려다 사용하는 스레드 역시 빌려온 객체를 외부에 공개하거나 풀에 반납한 이후에 계속해서 사용하는 등의 일을 하지 않는다면 풀 스레드와 사용자 스레드 간에 소유권이 원할하게 이전되는 모습을 볼 수 있다.  

가변 객체의 소유권을 이전해야 할 필요가 있다면, 위에서 설명한 것과 다른 객체 공개방법을 사용할 수도 있다. 하지만 항상 소유권을 이전받는 스레드는 단 하나여야 한다는 점을 주의하자. 블로킹 큐를 사용하면 이런 점을 정확하게 지킬 수 있다. 덧붙여 ConcurrentMap의 remove 메소드를 사용하거나 AtomicReference의 compareAndSet 메소드를 사용하는 경웅에도 약간의 추가 작업만 해준다면 원할하게 처리할 수 있다.  

##### 5.3.3. 덱, 작업 가로채기
<br/>
자바 6.0에서는 두 가지 컬렉션이 추가됐는데, 바로 Deque과 BlockingDeque이다. Deque과 BlockingDeque은 각각 Queue와 BlockingQueue를 상속받은 인터페이스이다. Deque은 앞과 뒤 어느 쪽에도 객체를 쉽게 삽입하거나 제거할 수 있도록 준비된 큐이며, Deque을 상속받은 실제 클래스로는 ArrayDeque과 LinkedBlockingDeque이 있다.  

프로듀서-컨슈머 패턴에서 블로킹 큐의 긴으을 그대로 가져다 사용하는 것처럼 작업 가로채기(work stealing)라는 패턴을 적용할 때에는 덱을 그대로 가져다 사용할 수 있다. 알다시피 프로듀서-컨슈머 패턴에서는 모든 컨슈머가 하나의 큐를 공유해 사용한다. 하지만 작업 가로채기 패턴에서는 모든 컨슈머가 각자의 덱을 갖는다. 만약 특정 컨슈머가 자신의 덱에 들어 있던 작업을 모두 처리하고 나면 다른 컨슈머의 덱에 쌓여있는 작업 가운데 맨 뒤에 추가된 작업을 가로채 가져올 수 있다. 작업 가로채기 패턴은 그 특성상 컨슈머가 하나의 큐를 바라보면서 서로 작업을 가져가려고 경쟁하지 않기 때문에 일반적인 프로듀서-컨슈머 패턴보다 규모가 큰 시스템을 구현하기에 적당하다. 더군다나 컨슈머가 다른 컨슈머의 큐에서 작업을 가져오려 하는 경우에도 앞이 아닌 맨 뒤의 작업을 가져오기 때문에 맨 앞의 작업을 가져가려는 원래 소유자와 경쟁이 일어나지 않는다.  

작업 가로채기 패턴은 또한 컨슈머가 프고듀서의 역할도 갖고 있는 경우에 적용하기에 좋은데, 이를테면 하나의 작업을 처리하고 나면 더 많은 작업이 생길 수 있는 상황을 생각해 볼 수 있다. 예를 들어 웹 크롤러(crawler)가 웹 페이지를 하나 처리하고 나면 따라가야 할 또 다른 링크가 여러 개 나타날 수 있기 때문이다. 이와 유사하게 가비지 컬렉션 도중에 힙을 마킹하는 작업과 같이 대부분의 그래프 탐색 알고리즘을 구현할 때 작업 가로채기 패턴을 적용하면 멀티스레드를 사용해 손쉽게 병렬화할 수 있다. 스레드가 작업을 진행하는 도중에 새로 처리해야 할 작업이 생기면 자신의 덱에 새로운 작업을 추가한다(작업을 서로 공유하도록 수성하는 경우에는 다른 작업 스레드의 덱에 추가하기도 한다). 만약 자신의 덱이 비었다면 다른 작업 스레드의 덱을 살펴보고 밀린 작업이 있다면 가져다 처리해 자신의 덱이 비었다고 쉬는 스레드가 없도록 관리한다.  

#### 5.4. 블로킹 메소드, 인터럽터블 메소드
<br/>
스레드는 여러 가지 원인에 의해 블록 당하거나, 멈춰질 수 있다. 예를 들어 I/O 작업이 끝나기를 기다리는 경우도 있고, 락을 확보하기 위해 기다리는 경우도 있고, Thread.sleep 메소드가 끝나기를 기다리는 경우도 있고, 다른 스레드가 작업 중인 내용의 결과를 확인하기 위해 기다리는 경우도 있다. 스레드가 블록되면 동작이 멈취진 다음 블록된 상태(BLOCKED, WAITING, TIMED_WAITING) 가운데 하나를 갖게 된다.  

+ 블로킹 연산  
단순히 실행 시간이 오래 걸리는 일반 연산과는 달리 멈춘 상태에서 특정한 신호(예를 들어 I/O 작업이 끝나기를 기다리거나, 기다리던 락을 확보했거나, 다른 스레드이 작업 결과를 받아오는 등의 신호)를 받아야 계속해서 실행할 수 있는 연산  

이와 같이 기다리던 외부 신호가 확인되면 스레드의 상ㅇ태가 다시 RUNNABLE 상태로 넘어가고 다시 시스템 스케줄러를 통해 CPU를 사용할 수 있게 된다.  

BlockingQueue 인터페이스의 put 메소드와 take 메소드는 Thread.sleep 메소드와 같이 InterruptedExcpetion을 발생시킬 수 있다. 특정 메소드가 InterruptedExcpetion을 발생시킬 수 있다는 것은 해당 메소드가 블로킹 메소드라는 의미이고, 만약 메소드에 인터럽트가 걸리면 해당 메소드는 대기 중인 상태에서 풀려나고자 노력한다.  

Thread 클래스는 해당 스레드를 중단시킬 수 있도록 interrupt 메소드를 제공하며, 해당 스레드에 인터럽트가 걸려 중단된 상태인지를 확인할 수 있는 메소드도 있다. 모든 스레드에는 인터럽트가 걸린 상태인지를 확인할 수 있는 메소드도 있다. 모든 스레드에는 인터럽트가 걸린 상태인지를 알려주는 불린 값이 있으며, 외부에서 인터럽트를 걸면 불린 변수에 true가 설정된다.  

인터럽트는 스레드가 서로 협력해서 실행하기 위한 방법이다. 어떤 스레드라도 다른 스레드가 하고 있는 일을 중간에 강제로 멈추라고 할 수는 없다. 자바 API나 언어 명세 어디를 보더라도 인터럽트를 거는 것에 대한 명확한 의미를 설명하는 부분은 없지만, 일반적으로 인터럽트는 특정 작업을 중간에 멈추게 하려는 경우에 사용한다. 인터럽트를 원할하게 처리하도록 만들어진 메소드는 실행 시간이 너무 길어질 때 일정 시간이 지난 이후 실행을 중단할 수 있도록 구성하기 좋다.  

프로그램이 호출하는 메소드 가운데 InterruptedExcpetion이 발생할 수 있는 메소드가 있다면 그 메소드를 호출하는 여러분위 메소드 역시 블로킹 메소드이다. 따라서 InterruptedExcpetion이 발생했을 때 그에 대처할 수 있는 방법을 마련해둬야 한다. 라이브러리 형태의 코드라면 일반적으로 두 가지 방법을 사용할 수 있다.  

+ InterruptedExcpetion을 전달  
받아낸 InterruptedExcpetion을 그대로 호출한 메소드에게 넘겨버리는 방법이다. 인터럽트에 대한 처리가 복잡하거나 귀찮을 때 쉽게 책임을 떠넘길 수 있다. 호출하는 메소드에서 발생할 수 있는 InterruptedExcpetion을 catch로 잡지 않는 방법도 있고, catch로 InterruptedExcpetion을 받은 다음 몇 가지 정리 작업을 진행한 이후 호출한 메소드에 throw하는 방법도 있다.  

+ 인터럽트를 무시하고 복구  
특정 상황에서는 InterruptedExcpetion을 throw할 수 없을 수도 있는데, 예를 들어 Runnable 인터페이스를 구현한 경우가 해당된다. 이런 경우에는 InterruptedExcpetion을 catch한 다음, 현재 스레드의 interrupt 메소드를 호출해 인터럽트 상태를 설정해 상위 호출 메소드가 인터럽트 상황이 발생했을을 알 수 있도록 해야 한다.  

인터럽트를 잘 활용하면 훨씬 세밀하게 고급 기능을 구현할 수 있지만 위의 두 가지 방법을 사용하면 대부분의 경웨 대응할 수 있다. 하지만 InterruptedExcpetion을 처리함에 있어서 하지 말아야 할 일이 한 가지 있다. 바로 InterruptedExcpetion을 catch하고는 무시하고 아무 대응도 하지 않는 일이다. 이렇게 아무런 대응을 하지 않으면 인터럽트가 발생했었다는 증거를 인멸하는 것이며, 호출 스택의 상위 메소드가 인터럽트에 대응해 조치를 취할 수 있는 기회를 주지 않는다. 발생한 InterruptedExcpetion을 먹여버리고 더 이상 전파하지 않을 수 있는 경우는 Thread 클래스를 직접 상속하는 경우뿐이며, 이럴 때는 인터럽트에 필요한 대응 조치를 모두 취했다고 간주한다.  

#### 5.5. 동기화 클래스
<br/>
+ 동기화 클래스(synchronizer)  
상태 정보를 사용해 스레드 간의 작업 흐름을 조절할 수 있도록 만들어진 모든 클래스  

모든 동기화 클래스는 구조적인 특징을 갖고 있다. 모두 동기화 클래스에 접근하려는 스레드가 어느 경우에 통과하고 어느 경우에는 대기하도록 멈추게 해야 하는지를 결정하는 상태 정보를 갖고 있고, 그 상태를 변경할 수 있는 메소드를 제공하고, 동기화 클래스가 특정 상태에 진입할 때까지 효과적으로 대기할 수 있는 메소드도 제공한다.  

##### 5.5.1. 래치
<br/>
+ 래치  
스수로가 터미널(terminal) 상태에 이를 때까지의 스레드가 동작하는 과정을 늦출 수 있도록 해주는 동기화 클래스로 일종의 관무과 같은 형태로 동작한다. 즉 터미널 상태에 이르기 전에는 관문이 닫혀 있다고 볼 수 있으며, 어떤 스레드도 통과할 수 없다. 래치가 터미널 상태에 다다르면 관문이 열리고 모든 스레드가 통과한다. 한 번 터미널 상태에 다다르면 그 상태를 다시 이전으로 되돌릴 수는 없으며, 따라서 한 번 열린 관문은 계속해서 열린 상태로 유지된다.  

이런 특정을 갖고 있는 래치는 특정한 단일 동작이 완료되기 이전에는 어떤 기능도 동작하지 않도록 막아내야 하는 경우에 요긴하게 사용할 수 있다.  

+ 특정 자원을 확보하기 전에는 작업을 시작하지 말아야 하는 경우에 사용할 수 있다. 아주 간단한 이진(binary) 래치를 사용해 "자원 R을 확보했다"는 상태를 표현하고, 자원 R을 사용해야 하는 모든 작업은 이 래치의 관문이 열리기를 기다리도록 한다.
+ 의존성을 갖고 있는 다른 서비스가 시작하기 전에는 특정 서비스가 실행되지 않도록 막아야 하는 경우에 사용할 수 있다. 각 서비스마다 이진 래치를 갖고 있으며, S라는 서비스를 시작하면 먼저 S가 의존성을 갖고 있는 모든 서비스의 래치가 열리기를 기다린다. 기다리던 모든 래치가 열리고 나면 서비스 S는 자신의 래치를 열어, 자신이 시작되기를 기다리는 서비스가 실행될 수 있도록 한다.
+ 특정 작업에 필요한 모든 객체가 실행할 준비를 갖출 때까지 기다리는 경우에도 사용할 수 있다. 예를 들어 여러 사용자가 동시에 참여하는 게임을 최초에 시작하기 전에, 모든 사용자가 게임을 시작할 준비가 끝났는지 확인하는 데 요긴하다. 이런 경우에는 모든 사용자가 준비됐다는 상태에 이르면 래치가 터미널 상태에 다다르게 구성할 수 있다.  

CountDownLatch는 위에서 소개한 모든 경우에 쉽게 적용할 수 있는 유연한 구조를 갖고 있는데, 하나 또는 둘 이상의 스레드가 여러 개의 이벤트가 일어날 때까지 대기할 수 있도록 되어 있다. 래치의 상태는 양의 정수 값으로 카운터를 초기화하며, 이 값은 대기하는 동안 발생해야 하는 이벤트의 건수를 의미한다. CountDownLatch 클래스의 countDown 메소드는 대기하던 이벤트가 발생했을 때 내부에 갖고 있는 이벤트 카운터를 하나 낮춰주고, await 메소드는 래치 내부의 카운터가 0이 될 때까지, 즉 대기하던 이벤트가 모두 발생했을 때까지 대기하도록 하는 메소드이다. 외부 스레드가 await 메소드를 호출할 때 래치 내부의 카운터가 0보다 큰 값이었다면, await 메소드는 카운터가 0이 되거나, 대기하던 스레드에 인터럽트가 걸리거나, 대기 시간이 길어 타임아웃이 걸릴 때까지 대기한다.  

```java
public class TestHarness {
  public long timeTasks(int nThreads, final Runnable task) throws InterruptedExcpetion {
    final CountDownLatch startGate = new CountDownLatch(1);
    final CountDownLatch endGate = new CountDownLatch(nThreads);

    for (int i = 0; i < nThreads; i++) {
      Thread t = new Thread() {
        public void run() {
          try {
            startGate.await();
            try {
              task.run();
            } finally {
              endGate.countDown();
            }
          } catch (InterruptedExcpetion ignored) { }
        }
      };
      t.start();
    }

    long start = System.nanoTime();
    startGate.countDown();
    endGate.await();
    long end = System.nanoTime();
    return end-start;
  }
}
```

##### 5.5.2. FutureTask
<br/>
FutureTask 역시 래치와 비슷한 형태로 동작한다.(FutureTask는 Future 인터페이스를 구현하며, Future 인터페이스는 결과를 알려주는 연산 작업을 나타낸다). FutureTask가 나타내는 연산 작업은 Callable 인터페이스(Runnable 인터페이스와 유사한 역할을 하지만 작업의 결과 값을 알려줄 수 있다)를 구현하도록 되어 있는데, 시작 전 대기, 시작됨, 종료됨과 같은 세 가지 상태를 가질 수 있다. 종료된 상태는 정상적인 종료, 취소, 예외 상황 발생과 같이 연산이 끝나는 모든 종류의 상태를 의미한다. FutureTask가 한 번 종료됨 상태에 이르고 나면 더 이상 상태가 바뀌는 일은 없다.  

Future.get 메소드의 동작하는 모습도 실행 상태에 따라 다르다. FutureTask로 작업이 종료됐다면 get 메소드는 그 결과를 즉시 알려준다. 종료 상태에 이르지 못했다면 get 메소드는 종료 상태에 이를 때까지 대기하고, 종료된 이후에 연산 결과나 예외 상황을 알려준다. FutureTask는 실제로 연산을 실행했던 스레드에서 만들어 낸 결과 객체를 실행시킨 스레드에게 넘겨준다. FutureTask 클래스에 명시된 것처럼 결과 객체는 안전한 공개 방법을 넘겨주게 되어 있다.  

FutrueTask는 Executor 프레임웍에서 비동기적인 작업을 실행하고자 할 때 사용하며, 기타 시간이 많이 필요한 모든 작업이 있을 때 실제 결과가 필요한 시점 이전에 미리 작업을 실행시켜두는 용도로 사용한다.  

Callable 인터페이스로 정의되어 있는 작업에서는 예외를 발생시킬 수 있으며, 어디에서든 Error도 발생시킬 수 있다. Callable의 내부 작업에서 어떤 예외를 발생시키건 간에 그 내용은 Future.get 메소드에서 ExecutionException으로 한 번 감싼 다음 다시 throw한다. 이 부분은 사실 오류 처리 과정을 약간 복잡하게 만드는 경향이 있는데, Future.get 메소드에서 발생하는 ExecutionException을 잡아서 처리해야 하고, (제대로 만들려면 RuntimeException의 일종인 CancellationException도 잡아야 한다) ExecutionException.getCause 메소드를 사용해 원인(cause) 예외를 가져올 때 Throwable로 받아와야 하기 때문에 실제로 어떤 예외가 발생했는지 확인하기가 쉽지 않다.  

Future.get 메소드에서 ExecutionException이 발생하면 그 원인은 세 가지 가운데 하나여야 한다. 첫 번째는 Callable이 던지는 예외, 두 번째는 RuntimeException, 세 번째는 Error이다.  

##### 5.5.3. 세마포어
<br/>
카운팅 세마포어(counting semaphore)는 특정 자원이나 특정 연산을 동시에 사용하거나 호출할 수 있는 스레드의 수를 제한하고자 할 때 사용한다. 카운팅 세마포어의 이런 기능을 활요하면 자원 풀(pool)이나 컬렉션의 크기에 제한을 두고자 할 때 유용하다.  

Semaphore 클래스는 가상의 퍼밋(permit)을 만들어 내부 상태를 관리하며, Semaphore를 생성할 때 생성 메소드에 최초로 생성할 퍼밋의 수를 넘겨준다. 외부 스레드는 퍼밋을 요청해 확보(남은 퍼밋이 있는 경우)하거나, 이전에 확보한 퍼밋을 반납할 수도 있다. 현재 사용할 수 있는 남은 퍼밋이 없는 경우, acquire 메소드는 남는 퍼밋이 생기거나, 인터럽트가 걸리거나, 지정한 시간을 넘겨 타임아웃이 걸리기 전까지 대기한다. release 메소드는 확보했던 퍼밋을 다시 세마포어에게 반납하는 기능을 한다. 카운팅 세마포어를 좀더 간단한 형태로 살펴보자면 이진 세마포어를 생각해 볼 수 있는데, 이진 세마포어는 초기 퍼밋 값이 1로 지정된 카운팅 세마포어이다. 이진 세마포어는 비재진입(nonreentrant) 락의 역할을 하는 뮤텍스(mutex)로 활용할 수 있다. 이진 세마포어의 퍼밋을 갖고 있는 스레드가 뮤텍스를 확보한 것이다.  

세마포어는 데이터베이스 연결 풀과 같은 자원 풀에서 요긴하게 사용할 수 있다. 자원 풀을 만들 때, 모든 자원을 빌려주고 남아 있는 자원이 없을 때 요청이 들어오는 경우에 단순하게 오류를 발생시키고 끝나버리는 정도의 풀은 아주 쉽게 구현할 수 있다. 하지만 일반적으로 풀을 생각할 때는 객체를 요청했지만 남은 객체가 없을 때, 다른 스레드가 확보했던 객체를 반납받아 사용할 수 있을 때까지 대기하도록 하는 방법이 옳은 방법일 것이다. 이럴 때 카운팅 세마포어를 만들면서 최초 퍼밋의 개수로 원하는 풀의 크기를 지정해보자. 그리고 풀에서 자원을 할당받아 가려고 할 때에는 먼저 acquire를 호출해 퍼밋을 확보하도록 하고, 다 사용한 자원을 반납하고 난 다음에는 항상 release를 호출해 퍼밋도 반납하도록 한다. 그러면 풀에 자원이 남아 있지 않은 경우에 acquire 메소드가 대기 상태에 들어가기 때문에 객체가 반납될 때까지 자연스럽게 대기하게 된다. 이런 기법은 길이가 제한된(bounded) 버퍼 클래스에서도 사용한다(물론 이와 같이 크기가 제한된 객체 풀이 필요한 경우에는 BlockingQueue 컬렉션 클래스를 사용하는 것도 간편한 방법이다).

세마포어는 해당하는 컬렉션 클래스가 가질 수 있는 최대 크기에 해당하는 숫자로 초기화한다. add 메소드는 객체를 내부 데이터 구조에 추가하기 전에 acquire를 호출해 추가할 여유가 있는지 확인한다. 만약 add 메소드가 내부 데이터 구조에 실제로 값을 추가하지 못했다면, 그 즉시 release를 호출해 세마포어에 퍼밋을 반납해야 한다. 이와 비슷하게 remove 메소드는 객체를 삭제한 다음 퍼밋을 하나 반납해 남은 공간에 객체를 추가할 수 있도록 해준다.  

실제 구현된 내용을 보면 퍼밋이라는 객체는 존재하지 않는다. 그리고 세마포어가 실제로 퍼밋을 나눠주지도 않는다. 따라서 스레드 A에서 확보한 퍼밋을 스레드 B에서 반납할 수도 있다. 결국 acquire 메소드는 퍼밋을 '소모'하는 것이라고 생각하고, release는 퍼밋을 새로 '생성'하는 것으로 생각할 수도 있겠다. 참고로 세마포어는 지정한 숫자 이외의 퍼밋을 관리할 수도 있다.  

##### 5.5.4. 배리어
<br/>
배리어(barrier)는 특정 이벤트가 발생할 때까지 여러 개의 스레드를 대기 상태로 잡아둘 수 있다는 측면에서 래치와 비슷하다고 볼 수 있다. 래치와의 차이점은 모든 스레드가 배리어 위치에 동시에 이르러야 관문이 열리고 계속해서 실행할 수 있다는 점이 다르다. 래치는 '이벤트'를 기다리기 위한 동기화 클래스이고, 배리어는 '다른 스레드'를 기다리기 위한 동기화 클래스이다. 배리어는 사람들이 어딘가에서 만날 약속을 하는 것과 비슷한 형태로 동작한다.  

CyclicBarrier 클래스를 사용하면 여러 스레드가 특정한 배리어 포인트에서 반복적으로 서로 만나는 기능을 모델링할 수 있고, 커다란 문제 하나를 여러 개의 작은 부분 문제로 분리해 반복적으로 병렬 처리하는 알고리즘을 구현하고자 할 때 적용하기 좋다. 스레드는 각자가 배리어 포인트에 다다르면 await 메소드를 호춣하며, await 메소드는 모든 스레드가 배리어 포인트에 도달하면 배리어는 모든 스레드를 통과시키며, await 메소드에서 대기하고 있던 스레드는 대기 상태가 모두 풀려 실행되고, 배리어는 다시 초기 상태로 돌아가 다음 배리어 포인트를 준비한다. 만약 await를 호출하고 시간이 너무 오래 지나 타임아웃이 걸리거나 await 메소드에서 대기하던 스레드에 인터럽트가 걸리면 배리어는 깨진 것으로 간주하고, await에서 대기하던 모든 스레드에 BrokenBarrierException이 발생한다. 배리어가 성공적으로 통과하면 await 메소드는 각 스레드별로 배리어 포인트에 도착한 순서를 알려주며, 다음 배리어 포인트로 반복 작업을 하는 동안 뭔가 특별한 작업을 진행할 일종의 리더를 선출하는데 이 값을 사용할 수 있다. CyclicBarrier는 생성 메소드를 통해 배리어 작업을 넘겨받을 수 있도록 되어 있다. 배리어 작업은 Runnable 인터페이스를 구현한 클래스인데, 배리어 작업은 배리어가 성공적으로 통과된 이후 대기하던 스레드를 놓아주기 직전에 실행된다.  

배리어는 대부분 실제 작업은 모두 여러 스레드에서 병렬로 처리하고, 다음 단계로 넘어가기 전에 이번 단계에서 계산해야 할 내용을 모두 취합해야 하는 등의 작업이 많이 일어나는 시뮬레이션 알고리즘에서 유용하게 사용할 수 있다.

더 이상 작업할 단계가 없는 시점에 이르렀는지 확인할 때에는 isDone이라는 메소드를 사용한다.  

배리어와 약간 다른 형태로 Exchanger 클래스를 살펴보자. Exchanger는 두 개의 스레드가 연결되는 배리어이며, 배리어 포인트에 도달하면 양쪽의 스레드가 서로 갖고 있던 값을 교환한다. Exchanger 클래스는 양쪽 스레드가 서로 대칭되는 작업을 수행할 때 유용하다. 예를 들어 한쪽 스레드는 데이터 버퍼에 값을 채워 넣는 일을 하고, 다른 스레드는 데이터 버퍼에 있는 값을 빼내어 사용하는 일을 한다고 해보자. 이 두 개의 스레드를 Exchanger로 묶고 배리어 포인트에 도달할 때마다 데이터 버퍼를 교환하도록 할 수 있다. Exchanger 객체를 통해 양쪽의 스레드가 각자의 값을 교환하는 과정에서 서로 넘겨지는 객체는 안전한 공개 방법으로 넘겨주기 때문에 동기화 문제를 걱정할 필요가 없다.  

교환이 일어나는 타이밍은 전적으로 해당 애플리케이션의 반응성에 대한 요구 사항에 따라 결정된다. 가장 간단한 방법을 보자면, 데이터를 채우는 스레드는 데이터를 모두 채우고 나면 교환하고, 데이터를 소모하는 스레드는 데이터를 모두 소모한 이후에 교환한다. 이런 방법은 교환 횟수를 최소한으로 줄일 수 있다는 장점이 있지만, 양쪽의 스레드가 동작하는 기간을 충분히 예측할 수 없다면 전체적인 데이터 처리 속도를 늦추는 겱과를 가져올 수 있다. 또 다른 방법으로, 데이터가 모두 채워지면 교환하는 것은 그대로지만, 특정 시간이 지나면 데이터가 모두 채워지지 않았더라도 즉시 교환하는 방법도 있다.  

### 1부 요약
<br/>
+ 상태가 바뀔 수 있단 말이다!  
병렬성과 관련된 모든 문제점은 변경 가능한 변수에 접근하려는 시도를 적절하게 조율하는 것으로 해결할 수 있다. 변경 가능성이 낮으면 낮을수록 스레드 안전성을 확보하기가 쉽다.  

+ 변경 가능한 값이 아닌 변수는 모두 final로 선언하라.  

+ 불변 객체는 항상 그 자체로 스레드 안전하다.  
불변 객체는 병렬 프로그램을 엄청나게 간편하게 작성할 수 있도록 해준다. 불변 객체는 간결하면서 안전하고, 락이나 방어적 복사 과정을 거치지 않고도 얼마든지 공유해 사용할 수 있다.  

+ 캡슐화하면 복잡도를 손쉽게 제어할 수 있다.  
모든 값을 전역 변수에 넣어 두더라도 프로그램을 스레드 안전하게 작성할 수는 있다. 하지만 도대체 무엇 때문에 그런 짓을 하는가? 데이터를 객체 내부에 캡슐화하면 값이 변경되는 자유도를 쉽게 제어할 수 있다. 객체 내부에서 동기화하는 기법을 캡슐화하면 동기화 정책을 손쉽게 적용할 수 있다.  

+ 변경 가능한 객체는 항상 락으로 막아줘야 한다.  

+ 불변 조건 내부에 들어가는 모든 변수는 같은 락으로 막아줘야 한다.  

+ 여러 스레드에서 변경 가능한 변수의 값을 사용하도록 되어 있으면서 적절한 동기화 기법이 적용되지 않은 프로그램은 올바른 결과를 내놓지 못한다.  

+ 동기화할 필요가 없는 부분에 대해서는 일부러 머리를 서서 고민할 필요가 없다(동기화할 필요가 없다고 이래저래 추측한 결론에 의존해서는 안 된다).  

+ 설계 단계부터 스레드 안전성을 염두에 두고 있어야 한다. 아니면 최소한 결과물로 작성된 클래스가 스레드에 안전하지 않다고 반드시 문서로 남겨야 한다.  

+ 프로그램 내부의 동기화 정책에 대한 문서를 남겨야 한다.
