---
title: Effective Typescript
categories:
- Typescript
feature_text: |
  ## Effective Typescript
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---
<style>
	thead td { text-align: center; }
	td { border: 1px solid #444444; }
</style>

### 아이템 1. 타입스크립트와 자바스크립트의 관계 이해하기  
<br/>

+ 타입스크립트는 자바스크립트의 상위집합입니다. 다시 말해서, 모든 자바스크립트 프로그램은 이미 타입스크립트 프로그램입니다. 반대로, 타입스크립트는 별도의 문법을 가지고 있기 때문에 일반적으로는 유효한 자바스크립트 프로그램이 아닙니다.  

+ 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 합니다. 그러나 모든 오류를 찾아내리라 기대하면 안 됩니다. 타입 체커를 통과하면서도 런타임 오류를 발생시키는 코드는 충분히 존재할 수 있습니다.  

+ 타입스크립트 타입 시스템은 전반적으로 자바스크립트 동작을 모델링합니다. 그러나 잘못된 매개변수 개수로 함수를 호출하는 경우처럼, 자바스크립트에서는 허용되지만 타입스크립트에서는 문제가 되는 경우도 있습니다. 이러한 문법의 엄격함은 온전히 취향의 차이이며 우열을 가릴 수 없는 문제입니다.  

### 아이템 2. 타입스크립트 설정 이해하기  
<br/>

noImplicitAny는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어합니다.  

noImplicitAny 설정 해제는, 자바스크립트로 되어 있는 기존 프로젝트를 타입스크립트로 전환하는 상황에만 필요합니다.  

strictNullChecks는 null과 undefined가 모든 타입에서 허용되는지 확인하는 설정입니다.  

strictNullChecks를 설정하려면 noImplicitAny를 먼저 설정해야 합니다.  

이 모든 체크를 설정하고 싶다면 strict 설정을 하면 됩니다.  

### 아이템 3. 코드 생성과 타입이 관계없음을 이해하기  
<br/>

+ 트랜스파일(transpile)  
소스코드를 동일한 동작을 하는 다른 형태의 소스코드(다른 버전, 다른 언어 등)로 변환하는 행위  

+ 컴파일과 타입 체크  
코드에 오류가 있을 때 "컴파일에 문제가 있다"고 말하는 경우를 보았을 겁니다. 그러나 이는 기술적으로 틀린 말입니다. 엄밀히 말하면 오직 코드 생성만이 '컴파일'이라고 할 수 있기 때문입니다. 작성한 타입스크립트가 유효한 자바스크립트라면 타입스크립트 컴파일러는 컴파일을 해 냅니다. 그러므로 코드에 오류가 있을 때 "타입 체크에 문제가 있다"고 말하는 것이 더 정확한 표현입니다.  

+ 타입 오류가 있는 코드도 컴파일이 가능합니다.  

+ 만약 오류가 있을 때 컴파일하지 않을려면, tsconfig.json에 noEmitOnError를 설정하거나 빌드 도구에 동일하게 적용하면 됩니다.  

+ 런타임에는 타입 체크가 불가능합니다.  

+ 타입을 클래스로 만들면 타입(런타임 접근 불가)과 값(런타임 접근 가능)을 둘 다 사용할 수 있다.  

+ 타입 연산은 런타임에 영향을 주지 않습니다.  

+ 런타임 타입은 선언된 타입과 다를 수 있습니다.  

+ 타입스크립트 타입오르는 함수를 오버로드할 수 없습니다.  

+ 타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다.  

+ '런타임' 오버헤드가 없는 대신, 타입스크립트 컴파일러는 '빌드타임' 오버헤드가 있습니다. 타입스크립트 팀은 컴파일러 성능을 매우 중요하게 생각합니다. 따라서 컴파일은 일반적으로 상당히 빠른 편이며 특히 증분(incremental) 빌드 시에 더욱 체감됩니다. 오버헤드가 커지면, 빌드 도구에서 '트랜스파일만(transpile only)'을 설정하여 타입 체크를 건너뛸 수 있습니다.  

+ 타입스크립트가 컴파일하는 코드는 오래된 런타임 환경을 지원하기 위해 호환성을 높이고 성능 오버헤드를 감안할지, 호환성을 포기하고 성능 중심의 네이티브 구현체를 선택할지의 문제에 맞닥뜨릴 수도 있습니다. 예를 들어 제너레이터 함수가 ES5 타깃으로 컴파일되려면, 타입스크립트 컴파일러는 호환성을 위한 특정 헬퍼 코드를 추가할 것입니다. 이런 경우가 제너레이터의 호환성을 위한 오버헤드 도는 성능을 위한 네이티브 구현체 선택의 문제입니다. 어떤 경우든지 호환성과 성능 사이의 선택은 컴파일 타깃과 언어의 레벨의 문제이며 연전히 타입과는 무관합니다.  

### 아이템 4. 구조적 타이핑에 익숙해지기  
<br/>

+ 자바스크립트가 덕 타이핑(duck typing) 기반이고 타입스크립트가 이를 모델링하기 위해 구조적 타이핑을 사용함을 이해해야 합니다. 어떤 인터페이스에 할당 가능한 값이라면 타입 선언에 명시적으로 나열된 속성들을 가지고 있을 겁니다. 타입은 '봉인'되어 있지 않습니다.
+ 클래스 역시 구조적 타이핑 규칙을 다른다는 것을 명심해야 합니다. 클래스의 인스턴스가 예상과 다를 수 있습니다.
+ 구조적 타이핑을 사용하면 유닛 테스팅을 손쉽게 할 수 있습니다.  

### 아이템 5. any 타입 지양하기  
<br/>

+ any 타입에는 타입 안전성이 없습니다.
+ any는 함수 시그니처를 무시해 버립니다.
+ any 타입에는 언어 서비스가 적용되지 않습니다.
+ any 타입은 코드 리팩터링 때 버그를 감춥니다.
+ any는 타입 설계를 감춰버립니다.
+ any는 타입시스템의 신뢰도를 떨어뜨립니다.

### 아이템 6. 편집기를 사용하여 타입 시스템 탐색하기  
<br/>

+ 편집기에 타입스크립트 언어 서비스를 적극 활용해야 합니다.
+ 편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있습니다.
+ 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 터득해야 합니다.  

### 아이템 7. 타입이 값들의 집합이라고 생각하기  
<br/>

+ never 타입  
타입스크립트에 가장 작은 집합이고 아무 값도 포함하지 않는 공집합입니다. 그러므로 아무런 값도 할당할 수 없습니다.  

+ 유닛(unit) 타입  
리터럴(literal) 타입으로 한 가지 값만 포함하는 타입입니다.  

+ 타입을 값의 집합으로 생각하면 이해하기 편합니다(타입의 '범위'). 이 집합은 유한(boolean 또는 리터럴 타입)하거나 무한(number 또는 string)합니다.
+ 타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합(벤 다이어그램)으로 표현됩니다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있습니다.
+ 한 객체 의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있습니다.
+ 타입 연산은 집합의 범위에 적용됩니다. A와 B의 인터섹션은 A의 범위와 B의 범위의 인터섹션입니다. 객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미합니다.
+ 'A는 B를 상속', 'A는 B에 할당 가능', 'A는 B의 서브타입'은 'A는 B의 부분 집합'과 같은 의미입니다.  

### 아이템 8. 타입 공간과 값 공간의 심벌 구분하기  
<br/>

타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중의 한 곳에 존재합니다.  

심벌은 이름이 같더라도 속하는 공간에 다라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있습니다.  

+ 값으로 쓰이는 this는 자바스크립트의 this 키워드입니다(아이템 49). 타입으로 쓰이는 this는, 일명 '다형성(polymorphic) this'라고 불리는 this의 타입스크립트 타입입니다. 서브클래스의 메서드 체인을 구현할 때 유용합니다.
+ 값에서 &와 |는 AND와 OR 비트연산입니다. 타입에서는 인터섹션과 유니온입니다.
+ const는 새 변수를 선언하지만, as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꿉니다(아이템 21).
+ extends는 서브클래스 또는 서브타입 또는 제너릭 타입의 한정자를 정의할 수 있습니다.
+ in은 루프 또는 매핑된(mapped) 타입에 등장합니다.  

+ 타입 스크립트 코드를 읽을 대 타입인지 값인지 구분하는 방법을 터득해야 합니다. 타입스크립트 플레이그라운드를 활용해 개념을 잡는 것이 좋습니다.
+ 모든 값은 타입을 가지지만, 타입은 값을 가지지 않습니다. type과 interface 같은 키워드는 타입 공간에만 존재합니다.
+ class나 enum 같은 키워드는 타입과 값 두 가지로 사용될 수 있습니다.
+ typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있습니다.  

### 아이템 9. 타입 단언보다는 타입 선언을 사용하기  
<br/>

+ 타입 단언(as Type)보다 타입 선언(: Type)을 사용해야 합니다.
+ 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 합니다.
+ 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문과 null 아님 단언문을 사용하면 됩니다.  

### 아이템 10. 객체 래퍼 타입 피하기  
<br/>

자바스크립트에는 객체 이외에도 기본형 값들에 대한 일곱 가지 타입(string, number, boolean, null, undefined, symbol, bigint)이 있습니다. string, number, boolean, null은 자바스크립트 초창기부터 존재해 왔으며, symbol 기본형은 ES2015에서 추가되었고, bigint는 최종 확장 단계에 있습니다.  

기본형들은 불변(immutable)이며 메서드를 가지지 않는다는 점에서 객체와 구분됩니다.  

자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환합니다. string 기본형에 charAt 같은 메서드를 사용할 때, 자바스크립트는 기본형을 String 객체로 래핑(wrap)하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버립니다.  

만약 String.prototype을 몽키-패치(monkey-patch)한다면 앞서 설명한 내부적인 동작들을 관찰할 수 있습니다(아이템 43).  

+ 몽키-패치  
런타임에 프로그램의 어떤 기능을 수정해서 사용하는 기법으로 자바스크립트에서는 주로 프로토타입을 변경하는 것이 해당  

래퍼 객체는 타입 구문의 첫 글자를 대문자로 표기하는 방법으로도 사용할 수 있습니다.  

당연히 런타임의 값은 객체가 아니고 기본형입니다. 그러나 기본형 타입은 객체 래퍼에 할당할 수 있기 때문에 타입스크립트는 기본형 타입을 객체 래퍼에 할당하는 선언을 허용합니다. 그러나 기본형 타입을 객체 래퍼에 할당하는 선언을 허용합니다. 그러나 기본형 타입을 객체 래퍼에 할당하는 구문은 오해하기 쉽고, 굳이 그렇게 할 필요도 없습니다(아이템 19). 그냥 기본형 타입을 사용하는 것이 낫습니다.  

그런데 new 없이 BigInt와 Symbol를 호출하는 경우는 기본형을 생성하기 때문에 사용해도 좋습니다.  

이들은 BigInt와 Symbol '값'이지만, 타입스크립트 타입은 아닙니다(아이템 8).  

+ 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 합니다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 합니다.
+ 타입스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야 합니다.  

### 아이템 11. 잉여 속성 체크의 한계 인지하기  
<br/>

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 '그 외의 속성은 없는지' 확인합니다.  

잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않습니다.  

잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름의 오타 같은 실수를 잡는 데 효과적인 방법입니다.  

+ 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 대 잉여 속성 체크가 수행됩니다.
+ 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다릅니다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있습니다.
+ 잉여 속성 체크에는 한계가 있습니다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다는 점을 기억해야 합니다.  

### 아이템 12. 함수 표현식에 타입 적용하기  
<br/>

자바스크립트(그리고 타입스크립트)에서는 함수 '문장(statement)'과 함수 '표현식(expression)'을 다르게 인식합니다.  

타입스크립트에서는 함수 표현식을 사용하는 것이 좋습니다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문입니다.  

+ 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋습니다.
+ 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 합니다. 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야 합니다.
+ 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 됩니다.  

### 아이템 13. 타입과 인터페이스의 차이점 알기  
<br/>

타입과 인터페이스의 공통점  
+ 인덱스 시그니처
+ 제네릭
+ 클래스 구현(implements)

타입과 인터페이스의 차이점
+ 인터페이스는 타입을 확장할 수 있지만, 유니온은 할 수 없습니다.
+ 인터페이스로 튜플과 비슷하게 구현하면 튜플에서는 사용할 수 있는 메서드들을 사용할 수 없으므로 튜플은 type은 키워드로 구현하는 것이 낫습니다.
+ 인터페이스는 '보강(argment)'이 가능합니다.  

+ 선언 병합(declaration merging)  
속성을 확장하는 것  

타입은 기존 타입에 추가적인 보강이 없는 경우에만 사용해야 합니다.  

복잡한 타입이라면 타입 별칭을 사용하면 됩니다. 그러나 타입과 인터페이스, 두 가지 방법으로 모두 표현할 수 있는 간단한 객체 타입이라면 일관성과 보강의 관점에서 고려해 봐야 합니다. 일관되게 인터페이스를 사용하는 코드베이스에서 작업하고 있다면 인터페이스를 사용하고, 일관되게 타입을 사용 중이라면 타입을 사용하면 됩니다.  

아직 스타일이 확립되지 않은 프로젝트라면, 향후에 보강의 가능성이 있을지 생각해 봐야 합니다. 어떤 API에 대한 타입 선언을 작성해야 한다면 인터페이스를 사용하는 게 좋습니다. API가 변경될 때 사용자가 인터페이스를 통해 새로운 필드를 병합할 수 있어 유용하기 때문입니다. 그러나 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설계입니다. 다라서 이럴 때는 타입을 사용해야 합니다.  

### 아이템 14. 타입 연산과 제너릭 사용으로 반복 줄이기  
<br/>

값으로부터 타입을 만들어 낼 때는 선언의 순서에 주의해야 합니다. 타입 정의를 먼저 하고 값이 그 타입에 할당 가능하다고 선언하는 것이 좋습니다. 그렇게 해야 타입이 더 명확해지고, 예상하기 어려운 타입 변동을 방지할 수 있습니다(아이템 21).  

제너릭 타입은 타입을 위한 함수와 같습니다. 그리고 함수는 코드에 대한 DRY 원칙을 지킬 때 유용하게 사용됩니다. 따라서 타입에 대한 DRY 원칙의 햇미이 제너릭이라는 것은 어쩌면 당연해 보이는데, 관과한 부분이 있습니다. 함수에서 매개변수로 매핑할 수 있는 값을 제한하기 위해 타입 시스템을 사용하는 것처럼 제너릭 타입에서 매개변수를 제한할 수 있는 방법이 필요합니다.  

제너릭 타입에서 매개변수를 제한할 수 있는 방법은 extends를 사용하는 것입니다. extends를 이용하면 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있습니다.  

+ DRY(don't repeat yourself) 원칙을 타입에도 최대한 적용해야 합니다.
+ 타입에 이름을 붙여서 반복을 피해야 합니다. extends를 사용해서 인터페이스 필드의 반복을 피해야 합니다.
+ 타입들 간의 매핑을 위해 타입스크립트가 제공한 도구들을 공부하면 좋습니다. 여기에는 keyof, typeof, 인덱싱, 매핑된 타입들이 포함됩니다.
+ 제너릭 타입은 타입을 위한 함수와 같습니다. 타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는 것이 좋습니다. 제너릭 타입을 제한하려면 extends를 사용하면 됩니다.
+ 표준 라이브러리에 정의된 Pick, Partial, ReturnType 같은 제너릭 타입에 익숙해져야 합니다.  

### 아이템 15. 동적 데이터 인덱스 시그니처 사용하기  
<br/>

```typescript
type Rocket = {[property: string]: string};
const rocket: Rocket = {
	name: 'Falcon 9',
	variant: 'v1.0',
	thrust: '4,940 kN',
} // 정상
```

인덱스 시그니처
+ 키의 이름: 키의 위치만 표시하는 용도로 타입 체커에서는 사용하지 않습니다.
+ 키의 타입: string이나 number 또는 symbol의 조합이어야 하지만, 보통은 string을 사용합니다(아이템 16).
+ 값의 타입: 어떤 것이든 될 수 있습니다.  

이렇게 타입 체크가 수행되면 네 가지 단점이 드러납니다.  

+ 잘못된 키를 포함해 모든 키를 허용합니다. name 대신 Name으로 작성해도 유효한 Rocket 타입이 됩니다.
+ 특정 키가 필요하지 않습니다. {}도 유효한 Rocket 타입입니다.
+ 키마다 다른 타입을 가질 수 없습니다. 예를 들어, thrust는 string이 아니라 number여야 할 수도 있습니다.
+ 타입스크립트 언어 서비스는 다음과 같은 경우에 도움이 되지 못합니다. name:을 입력할 때, 키는 무엇이든 가능하기 때문에 자동 완성 기능이 동작하지 않습니다.  

인덱스 시그니처는 부정확하므로 더 나은 방법을 찾아야 합니다.  

인덱스 시그니처는 동적 데이터를 표현할 때 사용합니다.  

어떤 타입에 가능한 필드가 제한되어 있는 경우라면 인덱스 시그니처로 모델링하지 말아야 합니다. 얼마나 많이 있는지 모른다면 선택적 필드 또는 유니온 타입으로 모델링하면 됩니다.  

string 타입이 너무 광범위해서 인덱스 시그니처를 사용하는 데 문제가 있다면, 두 가지 다른 대안을 생각해 볼 수 있습니다.  

첫 번째, Record를 사용하는 방법입니다. Record는 키 타입에 유연성을 제공하는 제너릭 타입입니다. 특히, string의 부분 집합을 사용할 수 있습니다.  

```typescript
type Vec3D = Record<'x' | 'y' | 'z', number>;
// Type Vec3D = {
// 	x: number;
// 	y: number;
// 	z: number;
// }
```

두 번째, 매핑된 타입을 사용하는 방법입니다. 매핑된 타입은 키마다 별도의 타입을 사용하게 해 줍니다.  

```typescript
type Vec3D = {[k in 'x' | 'y' | 'z']: number};
// Type Vec3D = {
// 	x: number;
// 	y: number;
// 	z: number;
// }
type ABC = {[k in 'a' | 'b' | 'c']: k extends 'b' ? string : number};
// Type Vec3D = {
// 	x: number;
// 	y: string;
// 	z: number;
// }
```

+ 런타임 때까지 객체의 속성을 알 수 없을 경우에만(예를 들어 CSV 파일에서 로드하는 경우) 인덱스 시그니처를 사용하도록 합니다.
+ 안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려해야 합니다.
+ 가능하다면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋습니다.  

### 아이템 16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기  
<br/>

파이썬이나 자바에서 볼 수 있는 '해시 가능' 객체라는 표현이 자바스크립트에는 없습니다. 만약 더 복잡한 객체를 키로 사용하려고 하면, toString 메서드가 호출되어 객체가 문자열로 변환됩니다.  

특히, 숫자는 키로 사용할 수 없습니다, 만약 속성 이름으로 숫자를 사용하려고 하면, 자바스크립트 런타임은 문자열로 변환할 겁니다.  

타입스크립트는 이러한 혼란을 바로잡기 위해 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식합니다. Array에 대한 타입 선언은(아이템 6), lib.es5.d.ts에서 확인할 수 있습니다.  

런타임에는 ECMAScript 표준이 서술하는 것처럼 문자열 키로 인식하므로 이 코드는 완전히 가상이라고 할 수 있지만, 타입 체크 시점에 오류를 잡을 수 있어 유용합니다.  

한편 Object.keys 같은 구문은 여전히 문자열로 반환됩니다.  

배열을 순회하는 코드 스타일에 대한 실용적인 허용이라고 생각하는 것이 좋습니다. 인덱스에 신경 쓰지 않는다면, for-of를 사용하는 게 더 좋습니다.  

만약 인덱스의 타입이 중요하다면, number 타입을 제공해 줄 Array.prototype.forEach를 사용하면 됩니다.  

루프 중간에 멈춰야 한다면, C 스타일인 for(;;) 루프를 사용하는 것이 좋습니다.  

타입이 불확실하다면, (대부분의 브라우저와 자바스크립트 엔진에서) for-in 루프는 for-of 또는 C 스타일 for 루프에 비해 몇 배나 느립니다.  

인덱스 시그니처가 number로 표현되어 있다면 입력한 값이 number여야 한다는 것을 의미하지만(for-in 루프는 확실히 제외하고), 실제 런타임에 사용되는 키는 string 타입입니다.  

이 부분이 혼란스럽게 느껴질 수 있습니다. 일반적으로 string 대신 number를 타입의 인덱스 시그니처로 사용할 이유는 많지 않습니다. 만약 숫자를 사용하여 인덱스할 항목을 지정한다면 Array 또는 튜플 타입을 대신 사용하게 될 겁니다. number를 인덱스 타입으로 사용하면 숫자 속성이 어떤 특별한 의미를 지닌다는 오해를 불러 일으킬 수 있습니다.  

한편 Array 타입이 사용하지도 않을 push나 concat 같은 다른 속성(프로토타입에서 온)을 가지는 게 납득하기 어려울 수 있습니다. 납득하기 어렵다는 것은 구조적인 고려를 하고 있다는 뜻이기 대문에 타입스크립트를 잘 이해하고 있다고 볼 수 있습니다(아이템 4에서 다룹니다).  

어떤 길이를 가지는 배열과 비슷한 형태의 튜플릉 사용하고 싶다면 타입스크립트에 있는 ArrayLike 타입을 사용합니다.  

```typescript 
function checkedAccess<T>(xs: ArrayLike<T>, i: number): T {
	if (i < xs.length) {
		return xs[i];
	}
	throw new Error(`배열의 끝을 지나서 ${i}를 접근하려고 했습니다.`)
}
```

+ 배열은 객체이므로 키는 숫자가 아니라 문자열입니다. 인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 타입스크립트 코드입니다.
+ 인덱스 시그니처에 number를 사용하기보다 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋습니다.  

### 아이템 17. 변경 관련된 오류 방지를 위해 readonly 사용하기  
<br/>

매개변수를 readonly로 선언하면 다음과 같은 일이 생깁니다.  

+ 타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크합니다.
+ 호출하는 쪽에서는 함수가 매개변수를 변경하지 않는다는 보장을 받게 됩니다.
+ 호출하는 쪽에서 함수에 readonly 배열을 매개변수로 넣을 수도 있습니다.  

자바스크립트에서는(타입스크립트에서도 마찬가지) 명시적으로 언급하지 않는 한, 함수가 매개변수를 변경하지 않는다고 가정합니다. 그러나 이러한 암묵적인 방법은 타입 체크에 문제를 일으킬 수 있습니다(자세한 내용은 아이템 30과 아이템 31에서 다룹니다). 명시적인 방법을 사용하는 것이 컴파일러와 사람 모두에게 좋습니다.  

만약 함수가 매개변수를 변경하지 않는다면, readonly로 선언해야 합니다. 더 넓은 타입으로 호출할 수 있고(아이템 29), 의도치 않은 변경은 방지될 것입니다. 이로 인한 단점은 상대적으로 적습니다.  

굳이 찾아보자면 매개변수가 readonly로 선언되지 않은 함수를 호출해야 할 경우도 있다는 것입니다. 만약 함수가 매개변수를 변경하지 않고도 제어가 가능하다면 readonly로 선언하면 됩니다. 그런데 어떤 함수를 readonly로 만들면, 그 함수를 호출하는 다른 함수도 모두 readonly로 만들어야 합니다. 그러면 인터페이스를 명확히 하고 타입 안전성을 높일 수 있기 때문에 꼭 단점이라고 볼 순 없습니다. 그러나 다른 라이브러리에 있는 함수를 호출하는 경우라면, 타입 선언을 바꿀 수 없으므로 타입 단언문을 사용해야 합니다.  

readonly를 사용하면 지역 변수와 관련된 모든 종류의 변경 오류를 방지할 수 있습니다.  

readonly는 얕게(shallow) 동작한다는 것에 유의하며 사용해야 합니다. 만약 객체의 readonly 배열이 있다면, 그 객체 자체는 readonly가 아닙니다.  

비슷한 경우가 readonly의 사촌 격이자 객체에 사용되는 Readonly 제너릭에도 해당됩니다.  

현재 시점에는 깊은(deep) readonly 타입이 기본으로 지원되지 않지만, 제너릭을 만들면 깊은 readonly 타입을 사용할 수 있습니다. 그러나 제너릭은 만들기 까다롭기 때문에 라이브러리를 사용하는 게 낫습니다. 예를 들어 ts-essentials에 있는 DeepReadonly 제너릭을 사용하면 됩니다.  

인덱스 시그니처에도 readonly를 쓸 수 있습니다. 읽기는 허용하되 쓰기를 방지하는 효과가 있습니다.  

```typescript
let obj: {readonly [k: string]: number} = {};
// 또는 Readonly<{[k: string]: number}>
obj.hi = 45;
// ~~... 형식의 인덱스 시그니처는 읽기만 허용됩니다.
obj = {...obj, hi: 12}; // 정상
obj = {...obj, bye: 34}; // 정상
```

이 코드처럼 인덱스 시그니처에 readonly를 사용하면 객체의 속성이 변경되는 것을 방지할 수 있습니다.  

+ 만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는 것이 좋습니다. readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수가 변경되는 것을 방지합니다.
+ readonly를 사용하면 변경하면서 발생하는 오류를 방지할 수 있고, 변경이 발생하는 코드도 쉽게 찾을 수 있습니다.
+ const와 readonly의 차이를 이해해야 합니다.
+ readonly는 얕게 동작한다는 것을 명심해야 합니다.  

### 아이템 18. 매핑된 타입을 사용하여 값을 동기화하기  
<br/>

산점도(scatter plot)를 그리기 위한 UI 컴포넌트를 작성한다고 가정해 보겠습니다. 여기에는 디스플레이와 동작을 제어하기 위한 몇 가지 다른 타입의 속성이 포함됩니다.  

```typescript
interface ScatterProps {
	// The data
	xs: number[];
	ys: number[];

	// Display
	xRange: [number, number];
	yRange: [number, number];
	color: string;

	// Events
	onClick: (x: number, y: number, index: number) => void;
}
```

불필요한 작업을 피하기 위해, 필요할 때에만 차트를 다시 그릴 수 있습니다. 데이터나 디스플레이 속성이 변경되면 다시 그려야 하지만, 이벤트 핸들러가 변경되면 다시 그릴 필요가 없습니다. 이런 종류의 최적화는 리액트 컴포넌트에서는 일반적인 일인데, 렌더링할 때마다 이벤트 핸들러 Prop이 새 화살표 함수로 설정됩니다.  

리액트의 useCallback 훅은 렌더링할 때마다 새 함수를 생성하지 않도록 하는 또 다른 기법입니다.  

최적화를 두 가지 방법으로 구현해 보겠습니다. 다음 예제는 첫 번째 방법입니다.  

```typescript
function shouldUpdate(
	oldProps: ScatterProps,
	newProps: ScatterProps,
) {
	let k: keyof ScatterProps;
	for (k in oldProps) {
		if (oldProps[k] !== newProps[k]) {
			if (k !== 'onClick') return true;
		}
	}
	return false;
}
```

(예제의 루프에 있는 keyof 선언에 대한 설명은 아이템 54에 있습니다.)  

+ 실패에 닫힌 방법  
오류 발생 시에 적극적으로 대처하는 방향으로 대처하는 방법

+ 실패에 열린 방법  
오류 발생 시에 소극적으로 대처하는 방향으로 대처하는 방법  

만약 보안과 관련된 곳이라면 실패에 닫힌 방법을 써야 할 것이고, 기능에 무리가 없고 사용성이 중요한 곳이라면 실패에 열린 방법을 써야 할 것입니다.  

만약 새로운 속성이 추가되면 shouldUpdate 함수는 값이 변경될 때마다 차트를 다시 그릴 것입니다. 이렇게 처리하는 것을 '보수적(conservative) 접근법' 또는 '실패에 닫힌(fail close) 접근법'이라고 합니다. 이 접근법을 이용하면 차트가 정확하지만 너무 자주 그려질 가능성이 있습니다.  


두 번째 최적화 방법은 다음과 같습니다. '실패에 열린' 접근법을 사용했습니다.  

```typescript
function shouldUpdate(
	oldProps: ScatterProps,
	newProps: ScatterProps,
) {
	return (
		oldProps.xs == newProps.xs ||
		oldProps.ys == newProps.ys ||
		oldProps.xRange == newProps.xRange ||
		oldProps.yRange == newProps.yRange ||
		oldProps.color == newProps.color
		// (no check for onClick)
	);
}
```

이 코드는 차트를 불필요하게 다시 그리는 단점이 해결했습니다. 하지만 실제로 차트를 다시 그려야 할 경우에 누락되는 일이 생길 수 있습니다. 이는 히프크라테스 전집에 나오는 원칙 중 하나인 '우선, 망치지 말 것(first, do no harm)'을 어기기 때문에 일반적인 경우에 쓰이는 방법은 아닙니다.  

앞선 두 가지 최적화 방법 모두 이상적이지 않습니다. 새로운 속성이 추가될 때 직접 shouldUpdate를 고치도록 하는 게 낫습니다. 이 내용을 주석으로 추가해 보겠습니다.  

```typescript
interface ScatterProps {
	xs: number[];
	ys: number[];
	// ...

	onClick: (x: number, y: number, index: number) => void;

	// 참고: 여기에 속성을 추가하려면, shouldUpdate를 고치세요!
}
```

그러나 이 방법 역시 최선이 아니며, 타입 체커가 대신할 수 있게 하는 것이 좋습니다.  

다음은 타입 체커가 동작하도록 개선한 코드입니다. 핵심은 매핑된 타입과 객체를 사용하는 것입니다.  

```typescript
const REQUIRES_UPDATE: {[k in keyof ScatterProps]: boolean} = {
	xs: true,
	ys: true,
	xRange: true,
	yRange: true,
	color: true,
	onClick: false,
};

function shouldUpdate(
	oldProps: ScatterProps,
	newProps: ScatterProps,
) {
	let k: keyof ScatterProps;
	for (k in oldProps) {
		if (oldProps[k] !== newProps[k] && REQUIRES_UPDATE) {
			return true;
		}
	}
	return false;
}
```

[k in keyof ScatterProps]은 타입 체커에게 REQUIRES_UPDATE가 ScatterProps과 동일한 속성을 가져야 한다는 정보를 제공합니다. 나중에 ScatterProps에 새로운 속성을 추가하는 경우 다음 코드와 같은 형태가 될 것입니다.  

```typescript
interface ScatterProps {
	// ...
	onDoubleClick: () => void;
}
```

그리고 REQUIRES_UPDATE의 정의에 오류가 발생합니다.  

```typescript
const REQUIRES_UPDATE: {[k in keyof ScatterProps]: boolean} = {
	// ~~~~~~~~~~~~~ 'onDoubleClick' 속성이 타입에 없습니다.
	// ...
};
```

이런 방식은 오류를 정확히 잡아 냅니다. 속성을 삭제하거나 이름을 바꾸어도 비슷한 오류가 발생합니다.  

여기서 boolean 값을 가진 객체를 사용했다는 점이 중요합니다. 배열을 사용했다면 다음과 같은 코드가 됩니다.  

```typescript
const PROPS_REQUIRING_UPDATE: (keyof ScatterProps)[] = [
	'xs',
	'ys',
	// ...
];
```

여기서 우리는 앞에서 다루었던 최적화 예제에서처럼 실패에 열린 방법을 선택할지, 닫힌 방법을 선택할지 정해야 합니다.  

매핑된 타입은 한 객체가 또 다른 객체와 정확히 같은 속성을 가지게 할 때 이상적입니다.  

+ 매핑된 타입을 사용해서 관련된 값과 타입을 동기화하도록 합니다.
+ 인터페이스에 새로운 속성을 추가할 때, 선택을 가제하도록 매핑된 타입을 고려해야 합니다.  

### 아이템 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기  
<br/>

보통 타입 정보가 있는 라이브러리에서, 콜백 함수의 매개변수 타입은 자동으로 추론됩니다.  

함수의 반환에도 타입을 명시하여 오류를 방지할 수 있습니다. 타입 추론이 가능할지라도 구현상의 오류가 함수를 호출한 곳까지 영향을 미치지 않도록 하기 위해 타입 구문을 명시하는 게 좋습니다.  

```typescript
const cache: {[ticker: string]: number} = {};
function getQuote(ticker: string): Promise<number> {
	if (ticker in cache) {
		return cache[ticker];
		// ~~~~~~~~~~~ 'number' 형식은 'Promise<number>' 형식에
		// 할당할 수 있습니다.
	}
	// ...
}
```

반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표시되지 않습니다. (Promise와 관련된 특정 오류를 피하는 데는 async 함수가 효과적입니다. async 함수에 대한 논의는 아이템 25를 참고하기 바랍니다.)  

오류의 위치를 제대로 표시해 주는 이점 외에도, 반환 타입을 명시해야 하는 이유가 두 가지 더 있습니다.  

첫 번째는 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있기 때문입니다. 반환 타입을 명시하려면 구현하기 전에 입력 타입과 출력 타입이 무엇인지 알아야 합니다. 추후에 코드가 조금 변경되어도 그 함수의 시그니처는 쉽게 바뀌지 않습니다. 추후에 코드가 조금 변경되어도 그 함수의 시그니처는 쉽게 바뀌지 않습니다. 미리 타입을 명시하는 방법은, 함수를 구현하기 전에 테스트를 먼저 작성하는 테스트 주도 개발(test driven development, TDD)과 비슷합니다. 전체 타입 시그니처를 먼저 작성하면 구현에 맞추어 주먹구구식으로 시그니처가 작성되는 것을 방지하고 제대로 원하는 모양을 얻게 됩니다.  

반환값의 타입을 명시해야 하는 두 번째 이유는 명명된 타입을 사용하기 위해서입니다. 예를 들어, 다음 함수에서는 반환 타입을 명시하지 않기로 했습니다.  

```typescript
interface Vector2D { x: number; y: number; }
function add(a: Vector2D, b: Vector2D) {
	return { x: a.x + b.x, y: a.y + b.y };
}
```

타입스크립트는 반환 타입을 { x: number, y: number; }로 추론했습니다. 이런 경우 Vector2D와 호환되지만, 입력이 Vector2D인데 반해 출력은 Vector2D가 아니기 때문에 사용자 입장에서 당황스러울 수 있습니다.  

반환 타입을 명시하면 더욱 직관적인 표현이 됩니다. 그리고 반환 값을 별도의 타입으로 정의하면 타입에 대한 주석을 작성할 수 있어서(아이템 48), 더욱 자세한 설명이 가능합니다. 추론된 반환 타입이 복잡해질수록 명명된 타입을 제공하는 이점은 커집니다.  

린터(linter)를 사용하고 있다면 eslint 규칙 중 no-inferrable-types(스펠링 주의, r이 두 개)을 사용해서 작성된 모든 타입 구문이 정말로 필요한지 확인할 수 있습니다.  

+ 타입스크립트가 타입을 추론할 수 있다면 타입 구문을 작성하지 않는 게 좋습니다.
+ 이상적인 경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없습니다.
+ 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 합니다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 줍니다.  

### 아이템 20. 다른 타입에는 다른 변수 사용하기  
<br/>

자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 됩니다.  

```javascript
let id = "12-34-56";
fetchProduct(id); // string으로 사용
id = 123456;
fetchProductBySerialNumber(id); // number로 사용
```

반면 타입스크립트에서는 두 가지 오류가 발생합니다.  

```typescript
let id = "12-34-56";
fetchProduct(id);

id = 123456;
// ~~ '123456' 형식은 'string' 형식에 할당할 수 없습니다.
fetchProductBySerialNumber(id);
// ~~ 'string' 형식의 인수는
// 'number' 형식의 매개변수에 할당될 수 없습니다.
```

편집기에서 첫 번째 id 위에 마우스 커서를 올려 놓으면 무엇이 문제인지 알 수 있습니다.  

타입스크립트는 "12-34-56"이라는 값을 보고, id의 타입을 string으로 추론했습니다. string 타입에는 number 타입을 할당할 수 없기 때문에 오류가 발생합니다.  

여기서 "변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다"는 중요한 관점을 알 수 있습니다. 타입을 바꿀 수 있는 한 한 가지 방법은 범위를 좁히는 것인데(아이템 22), 새로운 변수값을 포함하도록 확장하는 것이 아니라 타입을 더 작게 제한하는 것입니다. 이 관점에 반하는 타입 지정 방법(아이템 41)이 있는데, 이 방법은 어디까지나 예외이지 규칙은 아닙니다.  

변수를 무분별하게 재사용하면 타입 체커와 사람 모두에게 혼란을 줄 뿐입니다.  

다른 타입에는 별도의 변수를 사용하는 게 바람직한 이유는 다음과 같습니다.  

+ 서로 관련이 없는 두 개의 값을 분리합니다.
+ 변수명을 더 구체적으로 지을 수 있습니다.
+ 타입 추론을 향상시키며, 타입 구문이 불필요해집니다.
+ 타입이 좀 더 간결해집니다.
+ let 대신 const로 변수를 선언하게 됩니다. const로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에도 좋습니다.  

타입이 바뀌는 변수는 되도록 피해야 하며, 목적이 다른 곳에는 별도의 변수명을 사용해야 합니다.  

+ 변수의 값은 바뀔 수 있지만 타입은 일반적으로 바뀌지 않습니다.
+ 혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록합니다.  

### 아이템 21. 타입 넓히기  
<br/>

런타임에 모든 변수는 유일한 값을 가집니다. 그러나 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 '가능한' 값들의 집합인 타입을 가집니다. 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 합니다. 이 말은 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다는 뜻입니다. 타입스크립트에서는 이러한 과정을 넓히기(widening)'라고 부릅니다. 넓히기의 과정을 이해한다면 오류의 원인을 파악하고 타입 구문을 더 효과적으로 사용할 수 있을 것입니다.  

타입 넓히기가 진행될 때, 주어진 값으로 추론 가능한 타입이 여러 개이기 때문에 과정이 상당히 모호합니다. 다음 코드를 예로 들어 보겠습니다.  

```typescript
const mixed = ['x', 1];
```

mixed의 타입이 어떻게 추론되는지 살펴보겠습니다.  

정보가 충분하지 않다면 mixed가 어떤 타입으로 추론되어야 하는지 알 수 없습니다. 그러므로 타입스크립트는 작성자의 의도를 추측합니다. 그러나 타입스크립트가 아무리 영리하더라도 사람의 마음까지 읽을 수는 없고 따라서 추측한 답이 항상 옳을 수도 없습니다.  

일반적인 규칙은 변수가 선언된 후로는 타입이 바뀌지 않아야 합니다.  

타입스크립트는 넓히기의 과정을 제어할 수 있도록 몇 가지 방법을 제공합니다. 넓히기 과정을 제어할 수 있는 첫 번째 방법은 const입니다. 만약 let 대신 const로 변수를 선언하면 더 좁은 타입이 됩니다.  

객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것처럼 다룹니다.  

타입스크립트는 명확성과 유연성 사이의 균현을 유지하려고 합니다. 오류를 잡기 위해서는 충분히 구체적으로 타입을 추론해야 하지만, 잘못된 추론(false positive)을 할 정도로 구체적으로 수행하지는 않습니다.  

타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의해야 합니다. 타입스크립트의 기본 동작을 재정의하는 세 가지 방법이 있습니다.  

첫 번째, 명시적 타입 구문을 제공하는 것입니다.  

두 번째, 타입 체커에 추가적인 문맥을 제공하는 것입니다(예를 들어, 함수의 매개변수로 값을 전달). 아이템 26은 타입 추론 과정에서 문맥의 역할에 대한 자세한 내용을 다룹니다.  

세 번째, const 단언문을 사용하는 것입니다. const 단언문과 변수 선언에 쓰이는 let이나 const와 혼동해서는 안 됩니다. const 단언문은 온전히 타입 공간의 기법입니다.  

```typescript
const v3 = {
	x: 1,
	y: 2,
} as const; // 타입은 { readonly x: 1; readonly y: 2; }
```

값 뒤에 as const를 작성하면, 타입스크립트는 최대한 좁은 타입으로 추론합니다. v3에는 넓히기가 동작하지 않았습니다. v3이 진짜 상수라면, 주석에 보이는 추론된 타입이 실제로 원하는 형태일 겁니다. 또한 배열을 튜플 타입으로 추론할 때에도 as const를 사용할 수 있습니다.  

넓히기로 인해 오류가 발생한다고 생각되면, 명시적 타입 구문 또는 const 단언문을 추가하는 것을 고려해야 합니다. 단언문으로 인해 추론이 어떻게 변화하는지 편집기에서 주기적으로 타입을 살펴보기 바랍니다(아이템 6).  

+ 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 합니다.
+ 동작에 영향을 줄 수 있는 방법인 const, 타입 구문, 문맥, as const에 익숙해져야 합니다.  

### 아이템 22. 타입 좁히기  
<br/>

타입 좋비기는 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말합니다. 아마도 가장 일반적인 예시는 null 체크일겁니다.  

타입 체커는 일반적으로 이러한 조건문에서 타입 좁히기를 잘 해내지만, 타입 별칭이 존재한다면 그러지 못할 수도 있습니다.  

분기문에서 예외를 던지거나 함수를 반환하여 블록의 나머지 부분에서 변수의 타입을 좁힐 수도 있습니다.  

Array.isArray 같은 일부 내장 함수로도 타입을 좁힐 수 있습니다.  

타입스크립트는 일반적으로 조건문에서 타입을 좁히는 데 매우 능숙합니다. 그러나 타입을 섣불리 판단하는 실수를 저지르기 쉬우므로 다시 한번 꼼꼼히 따져 봐야 합니다.  

자바스크립트에서 typeof null이 "object"이기 때문에, if 구문에서 null이 제외되지 않았습니다. 또한 기본형 값이 잘못되어도 비슷한 사례가 발생합니다.  

타입을 좁히는 또 다른 일반적인 방법은 명시적 '태그'를 붙이는 것입니다.  

이 패턴은 '태그된 유니온(tagged union)' 또는 '구별된 유니온(discriminated union)'이라고 불리며, 타입스크립트 어디에서나 찾아볼 수 있습니다.  

만약 타입스크립트가 타입을 식별하지 못한다면, 식별을 돕기 위해 커스텀 함수를 도입할 수 있습니다.  

```typescript
function isInputElement(el: HTMLElement): el is HTMLInputElement {
	return 'value' in el;
}

function getElementContent(el: HTMLElement) {
	if (isInputElement(el)) {
		el; // 타입이 HTMLInputElement
		return el.value;
	}
	el; // 타입이 HTMLElement
	return el.textContent;
}
```

이러한 기법을 '사용자 정의 타입 가드'라고 합니다. 반환 타입이 el is HTMLInputElement는 함수의 반환이 true인 경우, 타입 체커에게 매개변수의 타입을 좁힐 수 있다고 알려줍니다.  

어떤 함수들은 타입 가드를 사용하여 배열과 객체의 타입 좁히기를 할 수 있습니다. 예를 들어, 배열에서 어떤 탐색을 수행할 때 undefined가 될 수 있는 타입을 사용할 수 있습니다.  

```typescript
const jackson5 = ['Jackie', 'Tito', 'Jermaine', 'Marlon', 'Michael'];
const members = ['Janet', 'Michael'].map(
	who => jackson5.find(n => n === who)
); // 타입이 (string | undefined)[]
```

filter 함수를 사용해 undefined를 걸러 내려고 해도 잘 동작하지 않을 겁니다.  

```typescript
const members = ['Janet', 'Michael'].map(
	who => jackson5.find(n => n === who)
).filter(who => who !== undefined); // 타입이 (string | undefined)[]
```

이럴 때 타입 가드를 사용하면 타입을 좁힐 수 있습니다.  

```typescript
function isDefined<T>(x: T | undefined): x is T {
	return x !== undefined;
}
const members = ['Janet', 'Michael'].map(
	who => jackson5.find(n => n === who)
).filter(isDefined); // 타입이 string[]
```

편집기에서 타입을 조사하는 습관을 가지면 타입 좁히기가 어떻게 동작하는지 자연스레 익힐 수 있습니다. 타입스크립트에서 타입이 어떻게 좁혀지는지 이해한다면 타입 추론에 대한 개념을 잡을 수 있고, 오류 발생의 원인을 알 수 있으며, 타입 체커를 더 효율적으로 이용할 수 있습니다.  

+ 분기문 외에도 여러 종류의 제어 흐름을 살펴보며 타입스크립트가 타입을 좁히는 과정을 이해해야 합니다.
+ 태그된/구별된 유니온과 사용자 정의 타입 가드를 사용하여 타입 좁히기 과정을 원활하게 만들 수 있습니다.  

### 아이템 23. 한꺼번에 객체 생성하기  
<br/>

변수의 값은 변경될 수 있지만, 타입스크립트의 타입은 일반적으로 변경되지 않습니다. 이러한 특성 덕분에 일부 자바스크립트 패턴을 타입스크립트로 모델링하는 게 쉬워집니다. 즉, 객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리합니다.  

객체를 반드시 제각각 나눠서 만들어야 한다면, 타입 단언문(as)을 사용해서 타입 체커를 통과하게 할 수 있습니다.  

```typescript
const pt = {} as Point;
pt.x = 3;
pt.y = 4; // 정상
```

물론 이 경우에도 선언할 때 객체를 한꺼번에 만드는 게 더 낫습니다(아이템 9).  

```typescript
const pt: Point = {
	x: 3,
	y: 4,
};
```

작은 객체들을 조합해서 큰 객체를 만들어야 하는 경우에도 여러 단계를 거치는 것은 좋지 않은 생각입니다.  

```typescript
const pt = {x: 3, y: 4};
const id = {name: 'Pythagoras'};
const namedPoint = {};
Object.assign(namedPoint, pt, id);
namedPoint.name;
// ~~~~ '{}' 형식에 'name' 속성이 없습니다.
```

다음과 같이 '객체 전개 연산자' ...를 사용하면 큰 객체를 한꺼번에 만들어 낼 수 있습니다.  

```typescript
const namedPoint = {...pt, ...id};
namedPoint.name; // 정상, 타입이 string
```

객체 전개 연산자를 사용하면 타입 걱정 없이 필드 단위로 객체를 생성할 수도 있습니다. 이때 모든 업데이트마다 새 변수를 사용하여 각각 새로운 타입을 얻도록 하는 게 중요합니다.  

```typescript
const pt0 = {};
const pt1 = {...pt0, x: 3};
const pt: Point = {...pt1, y: 4}; // 정상
```

이 방법은 간단한 객체를 만들기 위해 우회하기는 했지만, 객체에 속성을 추가하고 타입스크립트가 새로운 타입을 추론할 수 있게 해 유용합니다.  

타입에 안전한 방식으로 조건부 속성을 추가하려면, 속성을 추가하지 않는 null 또는 {}으로 객체 전개를 사용하면 됩니다.  

전개 연산자로 한꺼번에 여러 속성을 추가할 수도 있습니다.  

이 점을 고려하면 유니온을 사용하는 게 가능한 값의 집합을 더 정확히 표현할 수 있습니다(아이템 32). 그런데 유니온보다는 선택적 필드가 다루기에는 더 쉬울 수 있습니다. 선택적 필드 방식으로 표현하려면 다음처럼 헬퍼 함수를 사용하면 됩니다.  

```typescript
function addOptional<T extends object, U extends object>(
	a: T, b: U | null
): T & Partial<U> {
	return {...a, ...b};
}

const pharaoh = addOptional(
	nameTitle,
	hasDates ? (start: -2589, end: -2566) : null
);
pharaoh.start // 정상, 타입이 number | undefined
```

가끔 객체나 배열을 변환해서 새로운 객체나 배열을 생성하고 싶을 수 있습니다. 이런 경우 루프 대신 내장된 함수형 기법 또는 로대시(Lodash) 같은 유틸리티 라이브러리를 사용하는 것이 '한꺼번에 객체 생성하기' 관점에서 보면 옳습니다. 아이템 27에서 더 자세히 다룹니다.  

+ 속성을 제각각 추가하지 말고 한꺼번에 객체로 만들어야 합니다. 안전한 타입으로 속성을 추가하려면 객체 전개({...a, ...b})를 사용하면 됩니다.
+ 객체에 조건부로 속성을 추가하는 방법을 익히도록 합니다.  

### 아이템 24. 일관성 있는 별칭 사용하기  
<br/>

+ 별칭은 타입스크립트가 타입을 좁히는 것을 방해합니다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 합니다.
+ 비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋습니다.
+ 함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 합니다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있습니다.  

### 아이템 25. 비동기 코드에는 콜백 대신 async 함수 사용하기  
<br/>

과거의 자바스크립트에서는 비동기 동작을 모델링하기 위해 콜백을 사용했습니다. 그렇기 때문에 악명 높은 '콜백 지옥(callback hell)'을 필연적으로 마주할 수밖에 없었습니다.  

ES2015는 콜백 지옥을 극복하기 위해 프로미스(promise) 개념을 도입했습니다. 프로미스는 미래에 가능해질 어떤 것을 나타냅니다(future라고 부르기도 합니다).  

ES2017에서는 async와 await 키워드를 도입하여 콜백 지옥을 더욱 간단하게 처리할 수 있게 되었습니다.  

await 키워드는 각각의 프로미스가 처리(resolve)될 때까지 함수의 실행을 멈춥니다. async 함수 내에서 await 중인 프로미스가 거절(reject)되면 예외를 던집니다. 이를 통해 일반적인 try/catch 구문을 사용할 수 있습니다.  

ES5 또는 더 이전 버전을 대상으로 할 때, 타입스크립트 컴파일러는 async와 await가 동작하도록 정교한 변환을 수행합니다. 다시 말해, 타입스크립트는 런타임에 관계없이 async/await를 사용할 수 있습니다.  

콜백보다는 프로미스나 async/await를 사용해야 하는 이유는 다음과 같습니다.  

+ 콜백보다는 프로미스가 코드를 작성하기 쉽습니다.
+ 콜백보다는 프로미스가 타입을 추론하기 쉽습니다.  

가끔 프로미스를 직접 생성해야 할 때, 특히 setTimeout과 같은 콜백 API를 래핑할 경우가 있습니다. 그러나 선택의 여지가 있다면 일반적으로는 프로미스를 생성하기보다는 async/await를 사용해야 합니다. 그 이유는 다음 두 가지입니다.  

+ 일반적으로 더 간결하고 직관적인 코드가 됩니다.
+ async 함수는 항상 프로미스를 반환하도록 강제됩니다.  

async 화살표 함수를 만들 수도 있습니다.  

```typescript
const getNumber = async () => 42; // 타입이 () => Promise<number>
```

프로미스를 직접 생성하면 다음과 같습니다.  

```typescript
const getNumber = () => Promise.resolve(42); // 타입이 () => Promise<number>
```

즉시 사용 가능한 값에도 프로미스를 반환하는 것이 이상하게 보일 수 있지만, 실제로는 비동기 함수로 통일하도록 강제하는 데 도움이 됩니다. 함수는 항상 동기 또는 항상 비동기로 실행되어야 하며 절대 혼용해서는 안 됩니다. 예를 들어 fetchURL 함수에 캐시를 추가하기 위해 다음처럼 시도해 봤다고 가정해 보겠습니다.  

```typescript
// 이렇게 하지 맙시다!
const _cache: {[url: string]: string} = {};
function fetchWithCache(url: string, callback: (text: string) => void) {
	if (url in _cache) {
		callback(_cache[url]);
	} else {
		fetchURL(url, text => {
			_cache[url] = text;
			callback(text);
		});
	}
}
```

코드가 최적화된 것처럼 보일지 몰라도, 캐시된 경우 콜백 함수가 동기로 호출되기 때문에 fetchWithCache 함수는 이제 사용하기가 무척 어려워집니다.  

```typescript
let requestStatus: 'loading' | 'success' | 'error';
function getUser(userId: string) {
	fetchWithCache(`/user/${userId}`, profile => {
		requestStatus = 'success';
	});
	requestStatus = 'loading';
}
```

getUser를 호출한 후에 requestStatus의 값은 온전히 profile이 캐시되었는지 여부에 달렸습니다. 캐시되어 있지 않다면 requestStatus는 조만간 'success'가 됩니다. 캐시되어 있다면 'success'가 되고 나서 바로 'loading'으로 다시 돌아가 버립니다.  

async를 두 함수에 모두 사용하면 일관적인 동작을 강제하게 됩니다.  

```typescript
const _cache: {[url: string]: string} = {};
async function fetchWithCache(url: string) {
	if (url in _cache) {
		return _cache[url];
	}
	const response = await fetch(url);
	const text = await response.text();
	_cache[url] = text;
	return text;
}

let requestStatus: 'loading' | 'success' | 'error';
async function getUser(userId: string) {
	requestStatus = 'loading';
	const profile = await fetchWithCache(`/user/${userId}`);
	requestStatus = 'success';
}
```

이제 requestStatus가 'success'로 끝나는 것이 명백해졌습니다. 콜백이나 프로미스를 사용하면 실수로 반(half)동기 코드를 작성할 수 있지만, async를 사용하면 항상 비동기 코드를 작성하는 셈입니다.  

async 함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않습니다. 반환 타입은 Promise&lt;Promise&lt;T&gt;&gt;가 아닌 Promise&lt;T&gt;가 됩니다. 타입스크립트를 사용하면 타입 정보가 명확히 드러나기 때문에 비동기 코드의 개념을 잡는 데 도움이 됩니다.  

+ 콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론 면에서 유리합니다.
+ 가능하면 프로미스를 생성하기보다는 async와 await를 사용하는 것이 좋습니다. 간결하고 직관적인 코드를 작성할 수 있고 모든 종류의 오류를 제거할 수 있습니다.
+ 어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋습니다.  

### 아이템 26. 타입 추론에 문맥이 어떻게 사용되는지 이해하기  
<br/>

타입스크립트는 타입을 추론할 때 단순히 값만 고려하지는 않습니다. 값이 존재하는 곳의 문맥까지도 살핍니다. 그런데 문맥을 고려해 타입을 추론하면 가끔 이상한 결과가 나옵니다. 이때 타입 추론에 문맥이 어떻게 사용되는지 이해하고 있다면 제대로 대처할 수 있습니다.  

자바스크립트는 코드의 동작과 실행 순서를 바꾸지 않으면서 표현식을 상수로 분리해 낼 수 있습니다. 예를 들어, 다음 두 문장은 동일합니다.  

```typescript
// 인라인 상태
setLanguage('Javascript');

// 참조 형태
let language = 'JavaScript';
setLanguage(language);
```

타입스크립트에서는 다음 리팩터링이 여전히 동작합니다.  

```typescript
function setLanguage(language: string) { /* ... */ }

setLanguage('Javascript'); // 정상

let language = 'Javascript';
setLanguage(language); // 정상
```

이제 문자열 타입을 더 특정해서 문자열 리터럴 타입의 유니온으로 바꾼다고 가정해 보겠습니다(아이템 33에서 자세히 다룹니다).  

```typescript
type Language = 'JavaScript' | 'TypeScript' | 'Python';
function setLanguage(language: Language) { /* ... */ }

setLanguage('JavaScript'); // 정상

let language = 'JavaScript';
setLanguage(language);
// ~~~~~~~~~ 'string' 형식의 인수는
// 'Language' 형식의 매개변수에 할당될 수 없습니다.
```

인라인(inline) 형태에서 타입스크립트는 함수 선언을 통해 매개변수가 Language 타입이어야 한다는 것을 알고 있습니다. 해당 타입에 문자열 리터럴 'JavaScript'는 할당 시점에 타입을 추론합니다. 이번 경우는 string으로 추론했고, Language 타입으로 할당이 불가능하므로 오류가 발생했습니다.  

어떤 언어는 변수의 최종 사용처에 기반하여 타입을 추론하기도 합니다. 그러나 이런 방법 역시 혼란스럽습니다. 타입스크립트 창시자인 아네르스 하일스베르(Anders Hejisberg)'는 이를 '먼 곳의 소름끼치는 일(spookey action at a distance)'이라고 했습니다. 타입스크립트는 일반적으로 값이 처음 등장할 때 타입을 결정합니다. 아이템 41에서 이 규칙에 대한 중요한 예외 상황을 다룹니다.  

이런 문제를 해결하는 두 가지 방법이 있습니다. 첫 번재 해법은 타입 선언에서 language의 가능한 값을 제한하는 것입니다.  

```typescript
let language: Language = 'JavaScript';
setLanguage(language); // 정상
```

만약 language의 값에 'TypeScript'(대문자 'S'여야 합니다) 같은 오타가 있었다면 오류를 표시해 주는 장점도 있습니다.  

두 번째 해법은 language를 상수로 만드는 것입니다.  

```typescript
const language = 'JavaScript';
setLanguage(language); // 정상
```

const를 사용하여 타입 체커에게 language는 변경할 수 없다고 알려 줍니다. 따라서 타입스크립트는 language에 대해서 더 정확한 타입인 문자열 리터럴 "JavaScript"로 추론할 수 있습니다. "JavaScript"는 Language에 할당할 수 있으므로 타입 체크를 통과합니다. 물론, language를 재할당해야 한다면 타입 선언이 필요합니다(아이템 21에서 자세히 다룹니다).  

그런데 이 과정에서 사용되는 문맥으로부터 값을 분리했습니다. 문맥과 값을 분리하면 추후에 근복적인 문제를 발생시킬 수 있습니다. 이제부터 이러한 문맥의 소실로 인해 오류가 발생하는 몇 가지 경우와, 이를 어떻게 해결하는지 하나하나 살펴보겠습니다.  

#### 아이템 26.1. 튜플 사용 시 주의점  
<br/>

문자열 리터럴 타입과 마찬가지로 튜플 타입에서도 문제가 발생합니다. 이동이 가능한 지도를 보여 주는 프로그램을 작성한다고 생각해 보겠습니다.  

```typescript
// 매개변수는 (latitude, longitude) 쌍입니다.
function panTo(where: [number, number]) { /* ... */ }

panTo([10, 10]); // 정상

const loc = [10, 20];
panTo(loc);
// ~~~ 'number[]' 형식의 인수는
// '[number, number]' 형식의 매개변수에 할당될 수 없습니다.
```

이전 예제처럼 여기서도 문맥과 값을 분리했습니다. 첫 번째 경우는 [10, 20]이 튜플 타입 [number, number]에 할당 가능합니다. 두 번재 경우는 타입스크립트가 loc가 타입을 number[]로 추론합니다(즉, 길이를 알 수 없는 숫자의 배열). 많은 배열이 이와 맞지 않는 수의 요소를 가지므로 튜플 타입에 할당할 수 없습니다.  

그러면 any를 사용하지 않고 오류를 고칠 수 있는 방법을 생각해 보겠습니다. any 대신 const로 선언하면 된다는 답이 떠오를 수도 있겠지만 loc는 이미 const로 선언한 상태입니다. 그보다는 타입스크립트가 의도를 정확히 파악할 수 있도록 타입 선언을 제공하는 방법을 시도해 보겠습니다.  

```typescript
const loc: [number, number] = [10, 20];
panTo(loc); // 정상
```

any를 사용하지 않고 오류를 고칠 수 있는 또 다른 방법은 '상수 문맥'을 제공하는 것입니다. const는 단지 값이 가리키는 참조가 변하지 않는 얕은(shallow) 상수인 반면, as const는 그 값이 내부까지(deeply) 상수라는 사실을 타입스크립트에게 알려 줍니다.  

```typescript
const loc = [10, 20] as const;
panTo(loc);
// ~~~ 'readonly [10, 20]' 형식은 'readonly'이며
// 변경 가능한 형식 '[number, number]'에 할당할 수 없습니다.
```

편집기에서 loc에 마우스를 올려 보면, 타입은 이제 number[]가 아니라 readonly [10, 20]으로 추론됨을 알 수 있습니다. 그런데 안타깝게도 이 추론은 '너무 과하게' 정확합니다. panTo의 타입 시그니처는 where의 내용이 불변이라고 보장하지 않습니다. 즉, loc 매개변수가 readonly 타입이므로 동작하지 않습니다.  

따라서 any를 사용하지 않고 오류를 고칠 수 있는 최선이 해결책은 panTo 함수에 readonly 구문을 추가하는 것입니다.  

```typescript
function panTo(where: readonly [number, number]) { /* ... */ }
const loc = [10, 20] as const;
panTo(loc); // 정상
```

타입 시그니처를 수정할 수 없는 경우라면 타입 구문을 사용해야 합니다.  

as const는 문맥 손실과 관련한 문제를 깔끔하게 해결할 수 있지만, 한 가지 단점을 가지고 있습니다. 만약 타입 정의에 실수가 있다면(예를 들어, 튜플에 세 번째 요소를 추가한다면) 오류는 타입 정의가 아니라 호출되는 곳에서 발생한다는 것입니다. 특히 여러 겹 중첩된 객체엇 오류가 발생한다면 근본적인 원인을 파악하기 어렵습니다.  



많은 배열이 이와 맞지 않는 수의 요소를 가지므로 튜플 타입에 할당할 수 없습니다.  

#### 아이템 26.2. 객체 사용 시 주의점  
<br/>

문맥에서 값을 분리하는 문제는 문자열 리터럴이나 튜플을 포함하는 큰 객체에서 상수를 뽑아낼 때도 발생합니다.  

```typescript
type Language = 'JavaScript' | 'TypeScript' | 'Python';
interface GovernedLanguage {
	language: Language;
	organization: string;
}

function complain(language: GovernedLanguage) { /* ... */ }

complain({ language: 'TypeScript', organization: 'Microsoft' }); // 정상

const ts = {
	language: 'TypeScript',
	organization: 'Microsoft',
};
complain(ts);
// ~~ '{ language: string; organization: string; }' 형식의 인수는
// 'GovernedLanguage' 형식의 매개변수에 할당될 수 없습니다.
// 'language' 속성의 형식이 호환됮 않습니다.
// 'string' 형식은 'Language' 형식에 할당할 수 없습니다.
```

ts 객체에서 language 타입은 string으로 추론됩니다. 이 문제는 타입 선언을 추가하거나(const ts: GovernedLanguage = ...) 상수 단언(as const)을 사용해 해결합니다(아이템 9).  

#### 아이템 26.3. 콜백 사용 시 주의점  
<br/>

콜백을 다른 함수로 전달할 때, 타입스크립트는 콜백의 매개변수 타입을 추론하기 위해 문맥을 사용합니다.  

```typescript
function callWithRandomNumbers(fn: (n1: number, n2: number) => void) {
	fn(Math.random(), Math.random());
}

callWithRandomNumbers((a, b) => {
	a; // 타입이 number
	b; // 타입이 number
	console.log(a + b);
});
```

callWithRandom의 타입 선언으로 인해 a와 b의 타입이 number로 추론됩니다. 콜백을 상수로 뽑아내면 문맥이 소실되고 noImplicitAny 오류가 발생하게 됩니다.  

```typescript
const fn = (a, b) => {
	// ~ 'a' 매개변수에는 암시적으로 'any' 형식이 포함됩니다.
	// ~ 'b' 매개변수에는 암시적으로 'any' 형식이 포함됩니다.
	console.log(a + b);
}
callWithRandomNumbers(fn);
```

이런 경우는 매개변수에 타입 구문을 추가해서 해결할 수 있습니다.  

```typescript
const fn = (a: number, b: number) => {
	console.log(a + b);
}
callWithRandomNumber(fn);
```

또는 가능할 경우 전체 함수 표현식에 타입 선언을 적용하는 것입니다(자세한 내용은 아이템 12에서 다뤘습니다).  

+ 타입 추론에서 문맥이 어떻게 쓰이는지 주의해서 살펴봐야 합니다.
+ 변수를 뽑아서 별도로 선언했을 때 오류가 발생한다면 타입 선언을 추가해야 합니다.
+ 변수가 정말로 상수라면 상수 단언(as const)을 사용해야 합니다. 그러나 상수 단언을 사용하면 정의한 곳이 아니라 사용한 곳에서 오류가 발생하므로 주의해야 합니다.  

### 아이템 27. 함수형 기법과 라이브러리로 타입 흐름 유지하기  
<br/>

파이썬, C, 자바 등에서 볼 수 있는 표준 라이브러리가 자바스크립트에는 포함되어 있지 않습니다. 수년간 많은 라이브러리들은 표준 라이브러리의 역할을 대신하기 위해 노력해 왔습니다. 제이쿼리(jQuery)는 DOM과의 상호작용뿐만 아니라 객체와 배열을 순회하고 매핑하는 기능을 제공했습니다. 언더스코어(Underscore)는 주로 일반적인 유틸리티 함수를 제공하는 데 초점을 맞추었고, 이러한 노력을 바탕으로 로대시(Lodash)가 만들어졌습니다. 람다(Ramda) 같은 최근의 라이브러리는 함수형 프로그래밍의 개념을 자바스크립트 세계에 도입하고 있습니다.  

이러한 아리브러리들의 일부 기능(map, flatMap, filter, reduce 등)은 순수 자바스크립트로 구현되어 있습니다. 이러한 기법(그리고 로대시에서 제공되는 다른 것들)은 루프를 대체할 수 있기 때문에 자바스크립트에서 유용하게 사용되는데, 타입스크립트와 조합하여 사용하면 더욱 빛을 발합니다. 그 이유는 타입 정보가 그대로 유지되면서 타입 흐름(flow)이 계속 전달되도록 하기 때문입니다. 반면에 직접 루프를 구현하면 타입 체크에 대한 관리도 직접 해야 합니다.  

예를 들어, 어떤 CSV 데이터를 파싱한다고 생각해 보겠습니다. 순수 자바스크립트에서는 절차형(imperative) 프로그래밍 형태로 구현할 수 있습니다.  

```typescript
const csvData = "...";
const rawRows = csvData.split('\n');
const headers = rawRows[0].split(',');

const rows = rawRows.slice(1).map(rowStr => {
	const row = {};
	rowStr.split(',').forEach((val, j) => {
		row[headers[j]] = val;
	});
	return row;
});
```

함수형 마인드를 조금이라도 가진 자바스크립트 개발자라면 reduce를 사용해서 행 객체를 만드는 방법을 선호할 수도 있습니다.  

```typescript
const rows = rawRows.slice(1).map(rowStr => rowStr.split(',').reduce((row, val, i) => (row[headers[i]] = val, row), {}));
```

이 코드는 절차형 코드에 비해 세 줄(약 20개의 글자)을 절약했지만 보는 사람에 따라 더 복잡하게 느껴질 수도 있습니다. 키와 값 배열로 취합(zipping)해서 객체로 만들어 주는, 로대시와 zipObject 함수를 이용하면 코드를 더욱 짧게 만들 수 있습니다.  

```typescript
import _ from 'lodash';
const rows = rawRows.slice(1).map(rowStr => _.zipObject(headers, rowStr.split(',')));
```

코드가 매우 짧아졌습니다. 그런데 자바스크립트에서는 프로젝트에 서드파티 라이브러리 종속성을 추가할 때 신중해야 합니다. 만약 서드파티 라이브러리 기반으로 코드를 짧게 줄이는 데 시간이 많이 든다면, 서드파티 라이브러리를 사용하지 않는 게 낫기 때문입니다.  

그러나 같은 코드를 타입스크립트로 작성하면 서드파티 라이브러리를 사용하는 것이 무조건 유리합니다. 타입 정보를 참고하며 작업할 수 있기 때문에 서드파티 라이브러리 기반으로 바꾸는 데 시간이 훨씬 단축됩니다.  

한편, CSV 파서의 절차형 버전과 함수형 버전 모두 같은 오류를 발생시킵니다.  

```typescript
const rowsA = rawRows.slice(1).map(rowStr => {
	const row = {};
	rowStr.split(',').forEach((val, j) => {
		row[headers[j]] = val;
		//~~~~~~~~~~~~~ '{}' 형식에서 'string' 형식의 매개변수가 포함된 인덱스 시그니처를 찾을 수 없습니다.
	});
	return row;
});
const rowsB = rawRows.slice(1)
	.map(rowStr => rowStr.split(',').reduce(
		(row, val, i) => (row[headers[i]] = val, row), {}));
		//                ~~~~~~~~~~~~~~~ '{}' 형식에서 'string' 형식의 매개변수가 포함된 인덱스 시그니처를 찾을 수 없습니다.
```

두 버전 모두 {}의 타입으로 {[column: string]: string} 또는 Record&lt;string, string&gt;을 제공하면 오류가 해결됩니다.  

반면 로대시 버전은 별도의 수정 없이도 타입 체커를 통과합니다.  

Dictionary는 로대시의 타입 별칭입니다. Dictionary&lt;string&gt;은 {[key: string]: string} 또는 Record&lt;string, string&gt;과 동일합니다. 여기서 중요한 점은 타입 구문이 없어도 rows의 타입이 정확하다는 것입니다.  

데이터의 가공(munging)이 정교해질수록 이러한 장점은 더욱 분면해집니다.  

Array.prototype.flat 메서드는 다차원 배열을 평탕화해(flatten)줍니다. 타입 시그니처는 T[][] => T[] 같은 형태입니다. 이 버전이 가장 간결하고 타입 구문도 필요 없습니다.  

로대시의 어떤 기발한 단축 기법이라도 타입스크립트로 정확하게 모델링될 수 있습니다. 그런데 내장된 Array.prototype.map 대신 _.map을 사용하려는 이유가 무엇일까요? 한 가지 이유는 콜백을 전달하는 대신 속성의 이름을 전달할 수 있기 때문입니다.  

사실 함수 내부적으로는 문자열 리터럴 타입과 인덱스 타입의 조합으로만 이루어져 있기 때문에 타입이 자연스럽게 도출됩니다(아이템 14).  

내장된 함수형 기법들과 로대시 같은 라이브러리에 타입 정보가 잘 유지되는 것은 우연이 아닙니다. 함수 호출 시 전달된 매개변수 값을 건드리지 않고 매번 새로운 값을 반환함으로써, 새로운 타입으로 안전하게 반환할 수 있습니다(아이템 20). 넓게 보면, 타입스크립트의 많은 부분이 자바스크립트 라이브러리의 동작을 정확히 모델링하기 위해서 개발되었습니다. 그러므로 라이브러리를 사용할 때 타입 정보가 잘 유지되는 점을 십분 활용해야 타입스크립트의 원래 목적을 달성할 수 있습니다.  

+ 타입 흐름을 개선하고, 가독성을 높이고, 명시적인 타입 구문의 필요성을 줄이기 위해 직접 구현하기보다는 내장된 함수형 기법과 로대시 같은 유틸리티 라이브러리를 사용하는 것이 좋습니다.  

### 아이템 28. 유효한 상태만 표현하는 타입을 지향하기  
<br/>

타입을 잘 설계하면 코드는 직관적으로 작성할 수 있습니다. 그러나 타입 설계가 엉망이라면 어떠한 기억이나 문서도 도움이 되지 못합니다. 코드는 뒤죽박죽이 되고 버그는 창궐하게 됩니다.  

효과적으로 타입을 설계하려면, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 가장 중요합니다.  

타입을 설계할 때는 어떤 값들을 포함하고 어떤 값들을 제외할지 신중하게 생각해야 합니다. 유효한 상태를 표현하는 값만 허용한다면 코드를 작성하기 쉬워지고 타입 체크가 용이해집니다. 유효한 상태만 허용하는 것은 매우 일반적인 원칙입니다.  

+ 유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 됩니다.
+ 유효한 상태만 표현하는 타입을 지향해야 합니다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있습니다.  

### 아이템 29. 사용할 때는 너그럽게, 생성할 때는 엄격하게  
<br/>

+ 포스텔의 법칙(Postel's Law)  
존 포스텔(Jon Postel)이 쓴 견고성 원칙(robustness principle)에서 나온 것으로 TCP 구현체는 견고성의 일반적 원칙을 따라야 한다. 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다.  

함수의 시그니처에도 비슷한 규칙을 적용해야 합니다. 함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이어야 합니다.  

+ 보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있습니다. 선택적 속성과 유니온 타입은 반환 타입보다 매개겹눗 타입에 더 일반적입니다.
+ 매개변수와 반환 타입의 재사용을 위해서 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)를 도입하는 것이 좋습니다.  

### 아이템 30. 문서에 타입 정보를 쓰지 않기  
<br/>

타입스크립트의 타입 구문 시스템은 간결하고, 구체적이며, 쉽게 읽을 수 있도록 설계되었습니다. 타입 시스템 개발자들은 수십 년의 경험을 가진 언어 전문가입니다. 타입 시스템 개발자들은 수십 년의 경험을 가진 언어 전문가입니다. 함수의 입력과 출력의 타입을 코드로 표현하는 것이 주식보다 더 나은 방법이라는 것은 자명합니다.  

그리고 타입 구문은 타입스크립트 컴파일러가 체크해 주기 때문에, 절대로 구현체와의 정합성이 어긋나지 않습니다.  

누군가 강제하지 않는 이상 주석은 코드와 동기화되지 않습니다. 그러나 타입 구문은 타입스크립트 타입 체커가 타입 정보를 동기화하도록 강제합니다. 주석 대신 타입 정보를 작성한다면 코드가 변경된다 하더라도 정보가 정확히 동기화됩니다.  

특정 매개변수를 설명하고 싶다면 JSDoc의 @param 구문을 사용하면 됩니다. JSDoc은 아이템 48에서 자세히 다룹니다.  

값을 변경하지 않는다고 설명하는 주석도 좋지 않습니다. 또한 매개변수를 변경하지 않는다는 주석도 사용하지 않는 것이 좋습니다.  

그 대신, readonly로 선언하여(아이템 17) 타입스크립트가 규칙을 강제할 수 있게 하면 됩니다.  

주석에 적용한 규칙은 변수명에도 그대로 적용할 수 있습니다. 변수명에 타입 정보를 넣지 않도록 합니다.  

그러나 단위가 있는 숫자들은 예외입니다. 단위가 무엇인지 확실하지 않다면 변수명 또는 속성 이름에 단위를 포함할 수 있습니다.  

+ 주석과 변수명에 타입 정보를 적는 것은 피해야 합니다. 타입 선언이 중복되는 것으로 끝나면 다행이지만 최악의 경우는 타입 정보에 모순이 발생하게 됩니다.
+ 타입이 명확하지 않은 경우는 변수명에 단위 정보를 포함하는 것을 고려하는 것이 좋습니다.  

### 아이템 31. 타입 주변에 null 값 배치하기  
<br/>

+ 한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안 됩니다.
+ API 작성 시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야 합니다. 사람과 타입 체커 모두에게 명료한 코드가 될 것입니다.
+ 클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋습니다.
+ strictNullChecks를 설정하면 코드에 많은 오류가 표시되겠지만, null 값과 관련도니 문제점을 찾아낼 수 있기 때문에 반드시 필요합니다.  

### 아이템 32. 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기  
<br/>

유니온 타입의 속성을 가지는 인터페이스를 작성 중이라면, 혹시 인터페이스와 유니온 타입을 사용하는 게 더 알맞니는 않을지 검토해 봐야 합니다.  

태그된 유니온은 타입스크립트 타입 체커와 잘 맞기 때문에 타입스크립트 코드 어디에서나 찾을 수 있습니다. 이 패턴은 잘 기억해서 필요할 때 적용할 수 있도록 해야 합니다. 어떤 데이터 타입을 태그된 유니온으로 표현할 수 있다면, 보통은 그렇게 하는 것이 좋습니다. 또는 여러 개의 선택적 필드가 동시에 값이 있거나 동시에 undefined인 경우도 태그된 유니온 패턴이 잘 맞습니다.  

타입 정보를 담고 있는 주석은 문제가 될 소지가 매우 높습니다(아이템 30).  

두 개의 속성을 하나의 객체로 모으는 것이 더 나은 설계입니다. 이 방법은 null 값을 경계로 두는 방법과 비슷합니다(아이템 31).  

+ 유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의해야 합니다.
+ 유니온의 인터페이스보다 인터페이스이 유니온이 더 정확하고 타입스크립트가 이해하기도 좋습니다.
+ 타입스크립트가 제어 흐름을 분석할 수 있도록 타입에 태그를 넣는 것을 고려해야 합니다. 태그된 유니온은 타입스크립트와 매우 잘 맞기 때문에 자주 볼 수 있는 패턴입니다.  

### 아이템 33. string 타입보다 더 구체적인 타입 사용하기  
<br/>

string 타입의 범위는 매우 넓습니다. string 타입으로 변수를 선언하려 한다면, 혹시 그보다 더 좁은 타입이 적절하지는 않을지 검토해 보아야 합니다.  

타입을 좁히는 방식에는 세 가지 장점이 더 있습니다.  

첫 번째, 타입을 명시적으로 정의함으로써 다른 곳으로 값이 전달되어도 타입 정보가 유지됩니다.  

두 번째, 타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여 넣을 수 있습니다(아이템 48).  

세 번째, keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능해집니다.  

string은 any와 비슷한 문제를 가지고 있습니다. 따라서 잘못 사용하게 되면 무효한 값을 허용하고 타입 간의 관계도 감추어 버립니다. 이러한 문제점은 타입 체커를 방해하고 실제 버그를 찾지 못하게 만듭니다. 타입스크립트에서 string의 부분 집합을 정의할 수 있는 기능은 자바스크립트 코드에 타입 안전성을 크게 높입니다. 보다 정확한 타입을 사용하면 오류를 방지하고 코드의 가독성도 향상시킬 수 있습니다.  

+ '문자열을 남발하여 선언된' 코드를 피합시다. 모든 문자열을 할당할 수 있는 string 타입보다는 더 구체적인 타입을 사용하는 것이 좋습니다.
+ 변수의 범위를 보다 정확하게 표현하고 싶다면 string 타입보다는 문자열 리터럴 타입의 유니온을 사용하면 됩니다. 타입 체크를 더 엄격히 할 수 있고 생산성을 향상시킬 수 있습니다.
+ 객체의 속성 이름을 함수 매개변수로 받을 때는 string보다 keyof T를 사용하는 것이 좋습니다.  

### 아이템 34. 부정확한 타입보다는 미완성 타입을 사용하기  
<br/>

타입 선언을 작성하다 보면 코드의 동작을 더 구체적으로 또는 덜 구체적으로 모델링하게 되는 상황을 맞닥뜨리게 됩니다. 일반적으로 타입이 구체적일수록 버그를 더 많이 잡고 타입스크립트가 제공하는 도구를 활용할 수 있게 됩니다. 그러나 타입 선언의 정밀도를 높이는 일에는 주의를 기울여야 합니다. 실수가 발생하기 쉽고 잘못된 타입은 차라리 타입이 없는 것보다 못할 수 있기 때문입니다.  

타입을 구체적으로 만들수록 정밀도가 손상되는 것을 방지하는 데 도움이 됩니다(아이템 52).  

각 함수의 매개변수 개수가 정확한지 확인하기 위해 모든 함수 호출을 확인할 수도 있지만 재귀적으로 동작하기 때문에 좋은 방법은 아닙니다. 타입스크립트 3.6에서는 함수의 매개변수 개수를 알아내기 위해 최소한 하나의 인터페이스를 추가해야 합니다. 여러 인터페이스를 호출 표현식으로 한번에 묶을 수는 없기 때문에, 각 인터페이스를 나열해서 호출 표현식을 작성합니다.  

+ 불쾌한 골짜기(uncanny valley)  
로봇 공학과 인공 지능에서 많이 쓰이는 용어로 어설프게 인간과 비슷한 로봇에서 느끼는 불쾌함

타입 정제(refine)할 때, 불쾌한 골짜기(uncanny valley) 은유를 생각해 보면 도움이 될 수 있습니다. 일반적으로 any 같은 매우 추상적인 타입은 정제하는 것이 좋습니다. 그러나 타입이 구체적으로 정제된다고 해서 정확도가 무조건 올라가지는 않습니다. 타입에 의존하기 시작하면 부정확함으로 인해 발생하는 문제는 더 커질 것입니다.  

+ 타입 안전성에서 불쾌한 골짜기는 피해야 합니다. 타입이 없는 것보다 잘못된 게 더 나쁩니다.
+ 정확하게 타입을 모델링할 수 없다면, 부정확하게 모델링하지 말아햐 합니다. 또한 any와 unknown를 구별해서 사용해야 합니다.
+ 타입 정보를 구체적으로 만들수록 오류 메시지와 자동 완성 기능에 주의를 기울여야 합니다. 정확도뿐만 아니라 개발 경험과도 관련됩니다.  

### 아이템 35. 데이터가 아닌, API와 명세를 보고 타입 만들기  
<br/>

명세를 참고해 타입을 생성하면 타입스크립트는 사용자가 실수를 줄일 수 있게 도와줍니다. 반면에 예시 데이터를 참고해 타입을 생성하면 눈앞에 있는 데이터들만 고려하게 되므로 예기치 않은 곳에서 오류가 발생할 수 있습니다.  

명세를 기반으로 타입을 작성한다면 현재까지 경험한 데이터뿐만 아니라 사용 가능한 모든 값에 대해서 작동한다는 확신을 가질 수 있습니다.  

API 호출에도 비슷한 고려 사항들이 적용됩니다. API의 명세로부터 타입을 생성할 수 있다면 그렇게 하는 것이 좋습니다. 특히 GraphQL처럼 자체적으로 타입이 정의된 API에서 잘 동작합니다.  

GraphQL API는 타입스크립트와 비슷한 타입 시스템을 사용하여, 가능한 모든 쿼리와 인터페이스를 명세하는 스키마로 이루어집니다. 우리는 이러한 인터페이스를 사용해서 특정 필드를 요청하는 쿼리를 작성합니다.  

GraphQL의 장점은 특정 쿼리에 대해 타입스크립트 타입을 생성할 수 있다는 것입니다.  

GraphQL 쿼리를 타입스크립트 타입으로 변환해 주는 많은 도구가 존재합니다. 그중 하나는 Apollo입니다. 다음은 Apollo를 어떻게 사용하는지 보여 줍니다.  

쿼리에서 타입을 생성하려면 GraphQL 스키마가 필요합니다.  

자동으로 생성된 타입 정보는 API를 정확히 사용할 수 있도록 도와줍니다. 쿼리가 바뀐다면 타입도 자동으로 바뀌며 스키마가 바뀐다면 타입도 자동으로 바뀝니다. 타입은 단 하나의 원천 정보인 GraphQL 스키마로부터 생성되기 때문에 타입과 실제 값이 항상 일치합니다.  

만약 명세 정보나 공식 스키마가 없다면 데이터로부터 타입을 생성해야 합니다. 이를 위해 quicktype 같은 도구를 사용할 수 있습니다. 그러나 생성된 타입이 실제 데이터와 일치하지 않을 수 있다는 점을 주의해야 합니다. 예외적인 경우가 존재할 수 있습니다.  

우리는 이미 자동 타입 생성의 이점을 누리고 있습니다. 브라우저 DOM API에 대한 타입 선언은 공식 인터페이스로부터 생성되었습니다(아이템 55). 이를 통해 복잡한 시스템을 정확히 모델링하고 타입스크립트가 오류나 코드상의 의도치 않은 실수를 잡을 수 있게 합니다.  

+ 코드의 구석 구석까지 타입 안전성을 얻기 위해 API 또는 데이터 형식에 대한 타입 생성을 고려해야 합니다.
+ 데이터에 드러나지 않는 예외적인 경우들이 문제가 될 수 있기 때문에 데이터보다는 명세로부터 코드를 생성하는 것이 좋습니다.  

### 아이템 36. 해당 분야의 용어로 타입 이름 짓기  
<br/>

코드로 표현하고자 하는 모든 분야에는 주제를 설명하기 위한 전문 용어들이 있습니다. 자체적으로 용어를 만들어 내려고 하지 말고, 해당 분야에 이미 존재하는 용어를 사용해야 합니다. 이런 용어들은 수 년, 수십 년, 수 세기에 걸쳐 다듬어져 왔으며 현장에서 실제로 사용되고 있을 겁니다. 이런 용어들을 사용하면 사용자와 소통에 유리하며 타입의 명확성을 올릴 수 있습니다.  

전문 분야의 용어는 정확하게 사용해야 합니다. 특정 용어를 다른 의미로 잘못 쓰게 되면, 직접 만들어 낸 용어보다 더 혼란을 주게 됩니다.  

타입, 속성, 변수에 이름을 붙일 때 명심해야 할 세 가지 규칙이 있습니다.  

+ 동일한 의미를 나타낼 때는 같은 용어를 사용해야 합니다. 글을 쓸 때나 말을 할 때, 같은 단어를 반복해서 사용하면 지루할 수 있기 때문에 동의어(의미가 같지만 다른 단어)를 사용합니다. 동의어를 사용하면 글을 읽을 때는 좋을 수 있지만, 코드에서는 좋지 않습니다. 정말로 의미적으로 구분이 되어야 하는 경우에만 다른 용어를 사용해야 합니다.
+ data, info, thing, item, object, entity 같은 모호하고 의미 없는 이름은 피해야 합니다. 만약 entity라는 용어가 해당 분야에서 특별한 의미를 가진다면 괜찮습니다. 그러나 귀찮다고 무심코 의미 없는 이름을 붙여서는 안 됩니다.
+ 이름을 지을 때는 포함된 내용이나 계산 방식이 아니라 데이터 자체가 무엇인지를 고려해야 합니다. 좋은 이름은 추상화 수준을 높이고 의도치 않은 충돌의 위험성을 줄여 줍니다.  

+ 가독성을 높이고, 추상화 수준을 올리기 위해서 해당 분야의 용어를 사용해야 합니다.
+ 같은 의미에 다른 이름을 붙이면 안 됩니다. 특별한 의미가 있을 때만 용어를 구분해야 합니다.  

### 아이템 37. 공식 명칭에는 상표를 붙이기  
<br/>

상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있습니다. 타입 시스템이기 때문에 런타임 오버헤드를 없앨 수 있고 추가 속성을 붙일 수 없는 string이나 number 같은 내장 타입도 상표화할 수 있습니다.  

상표 기법은 타입 시스템 내에서 표현할 수 없는 수많은 속성들을 모델링하는 데 사용되기도 합니다. 예를 들어, 목록에서 한 요소를 찾기 위해 이진 탐색을 하는 경우를 보겠습니다.  

```typescript
function binarySearch<T>(xs: T[], x: T): boolean {
	let low = 0, high = xs.length - 1;
	while (high >= low) {
		const mid = low + Math.floor((high - low) / 2);
		const v = xs[mid];
		if (v === x) return true;
		[low, high] = x > v ? [mid + 1, high] : [low, mid - 1];
	}
	return false;
}
```

이진 검색은 이미 정렬된 상태를 가정하기 때문에, 목록이 이미 정렬되어 있다면 문제가 없습니다. 하지만 목록이 정렬되어 있지 않다면 잘못된 결과가 나옵니다. 타입스크립트 타입 시스템에서는 목록이 정렬되어 있다는 의도를 표현하기 어렵습니다. 따라서 다음 예제처럼 상표 기법을 사용해 보겠습니다.  

```typescript
type SortedList<T> = T[] & {_brand: 'sorted'};

function isSorted<T>(xs: T[]): xs is SortedList<T> {
	for (let i = 1; i < xs.length; i++) {
		if (xs[i] < xs[i - 1]) {
			return false;
		}
	}
	return true;
}

function binarySearch<T>(xs: SortedList<T>, x: T): boolean {
	// ...
}
```

binarySearch를 호출하려면, 정렬되었다는 상표가 붙은 SortedList 타입의 값을 사용하거나 isSorted를 호출하여 정렬되었음을 증명해야 합니다. isSorted에서 목록 전체를 루프 도는 것이 효율적인 방법은 아니지만 적어도 안전성은 확보할 수 있습니다.  

앞의 예제는 타입 체커를 유용하게 사용하는 일반적인 패턴입니다. 예를 들어, 객체의 메서드를 호출하는 경우 null이 아닌 객체를 받거나 조건문을 사용해서 해당 객체가 null이 아닌지 체크하는 코드와 동일한 형태입니다.  

+ 타입스크립트는 구조적 타이핑(덕 타이핑)을 사용하기 때문에, 값을 세밀하게 구분하지 못하는 경우가 있습니다. 값을 구분하기 위해 공식 명칭이 필요하다면 상표를 붙이는 것을 고려홰야 합니다.
+ 상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있습니다.  

### 아이템 38. any 타입은 가능한 한 좁은 범위에서만 사용하기  
<br/>

타입스크립트가 함수의 반환 타입을 추론할 수 있는 경우에도 함수의 반환 타입을 명시하는 것이 좋습니다. 함수의 반환 타입을 명시하면 any 타입이 함수 바깥으로 영향을 미치는 것을 방지할 수 있습니다.  

+ 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 합니다.
+ 함수의 반환 타입이 any인 경우 타입 안정성이 나빠집니다. 따라서 any 타입을 반환하면 절대 안 됩니다.
+ 강제로 타입 오류를 제거하려면 any 대신 @ts-ignore 사용하는 것이 좋습니다.  

### 아이템 39. any를 구체적으로 변형해서 사용하기  
<br/>

any는 자바스크립트에서 표현할 수 있는 모든 값을 아우르는 매우 큰 범위의 타입입니다. any 타입에는 모든 숫자, 문자열, 배열, 객체, 정규식, 함수, 클래스, DOM 엘리먼트는 물론 null과 undefined까지도 포함됩니다. 반대로 말하면, 일반적인 상황에서는 any보다 더 구체적으로 표현할 수 있는 타입이 존재할 가능성이 높기 때문에 더 구체적인 타입을 찾아 타입 안전성을 높이도록 해야 합니다.  

예를 들어, any 타입의 값을 그대로 정규식이나 함수에 넣는 것은 권장되지 않습니다.  

함수의 매개변수를 구체화할 때, (요소의 타입에 관계없이) 배열의 배열 형태라면 any[][]처럼 선언하면 됩니다. 그리고 함수의 매개변수가 객체이긴 하지만 값을 알 수 없다면 {[key: string]: any}처럼 선언하면 됩니다.  

함수의 매개변수가 객체지만 값을 알 수 없다면 {[key: string]: any} 대신 모든 비기본형(non-primitive) 타입을 포함하는 object 타입을 사용할 수도 있습니다. object 타입은 객체의 키를 열거할 수는 있지만 속성에 접근할 수 없다는 점에서 {[key: string]: any}와 약간 다릅니다.  

객체지만 속성에 접근할 수 없어야 한다면 unknown 타입이 필요한 상황일 수 있습니다.  

함수의 타입에도 단순히 any를 사용해서는 안 됩니다.  

+ any를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 합니다.
+ any보다 더 정확하게 모델링할 수 있도록 any[] 또는 {[id: string]: any} 또는 () => any처럼 구첵적은 형태를 사용해야 합니다.  

### 아이템 40. 함수 안으로 타입 단언문 감추기  
<br/>

함수를 작성하다보면, 외부로 드러난 타입 정의는 간단하지만 내부 로직이 복잡해서 안전한 타입으로 구현하기 어려운 경우가 많습니다. 함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이지만, 불필요한 예외 상황까지 고려해 가며 타입 정보를 힘들게 구성할 필요는 없습니다. 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝내는 게 낫습니다. 프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다, 제대로 타입이 정의된 함수 안으로 타입 단언문을 감추는 것이 더 좋은 설계입니다.  

+ 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 합니다. 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 합니다.  

### 아이템 41. any의 진화를 이해하기  
<br/>

타입스크립트에서 일반적으로 변수의 타입은 변수를 선언할 때 결정됩니다. 그 후에 정제될 수 있지만(예를 들어 null인지 체크해서), 새로운 값이 추가되도록 확장할 수는 없습니다. 그러나 any 타입과 관련해서 예외인 경우가 존재합니다.  

자바스크립트에서 일정 범위의 숫자들을 생성하는 함수를 예로 들어 보겠습니다.  

```typescript
function range(start, limit) {
	const out = [];
	for (let i = start; i < limit; i++) {
		out.push(i);
	}
	return out;
}
```

이 코드를 타입스크립트로 변환하면 예상한 대로 정확히 동작합니다.  

```typescript
function range(start: number, limit: number) {
	const out = [];
	for (let i = start; i < limit; i++) {
		out.push(i);
	}
	return out; // 반환 타입의 number[]로 추론됨.
}
```

그러나 자세히 살펴보면 한 가지 이상한 점을 발견할 수 있습니다. out의 타입이 처음에는 any 타입 배열인 []로 초기화되었는데, 마지막에는 number[]로 추론되고 있습니다.  

코드에 out이 등장하는 세 가지 위치를 조사해 보면 이유를 알 수 있습니다.  

out의 타입은 any[]로 선언되었지만 number 타입의 값을 넣는 순간부터 타입은 number[]로 진화(evolve)합니다.  

타입의 진화는 타입 좁히기(아이템 22)와 다릅니다. 배열에 다양한 타입의 요소를 넣은 배열의 타입이 확장되며 진화합니다.  

```typescript
const result = []; // 타입이 any[]
result.push('a');
result // 타입이 string[]
result.push(1);
result // 타입이 (string | number)[]
```

또한 조건문에서는 분기에 따라 타입이 변할 수도 있습니다. 다음 코드에서는 배열이 아닌 단순 값으로 예를 들어 보았습니다.  

```typescript
let val; // 타입이 any
if (Math.random() < 0.5) {
	val = /hello/;
	val // 타입이 RegExp
} else {
	val = 12;
	val // 타입이 number
}
val // 타입이 number | RegExp
```

변수의 초깃값이 null인 경우도 any의 진화가 일어납니다. 보통은 try/catch 블록 안에서 변수를 할당하는 경우에 나타납니다.  

```typescript
let val = null; // 타입이 any
try {
	somethingDangerous();
	val = 12;
	val // 타입이 number
} catch (e) {
	console.log('alas!');
}
val // 타입이 number | null
```

any 타입의 진화는 noImplicitAny가 설정된 상태에서 변수의 타입이 암시적으로 any인 경우에만 일어납니다. 그러나 다음처럼 명시적으로 any를 선언하면 타입이 그대로 유지됩니다.  

```typescript
let val; // 타입이 any
if (Math.random() < 0.5) {
	val = /hello/;
	val // 타입이 any
} else {
	val = 12;
	val // 타입이 any
}
val // 타입이 any
```

타입의 진화는 값을 할당하거나 배열에 요소를 넣은 후에만 일어나기 때문에, 편집기에서는 이상하게 보일 수 있습니다. 할당이 일어난 줄의 타입을 조사해 봐도 여전히 any 또는 any[]로 보일 겁니다.  

다음 코드처럼, 암시적 any 상태인 변수에 어떠한 할당도 하지 않고 사용하려고 하면 암시적 any 오류가 발생하게 됩니다.  

any 타입의 진화는 암시적 any 타입에 어떤 값을 할당할 때만 발생합니다. 그리고 어떤 변수가 암시적 any 상태일 때 값을 읽으려고 하면 오류가 발생합니다.  

암시적 any 타입은 함수 호출을 거쳐도 진화하지 않습니다. 다음 코드에서 forEach 안의 화살표 함수는 추론에 영향을 미치지 않습니다.  

```typescript
function makeSquares(start: number, limit: number) {
	const out = [];
	//    ~~~ 'out' 변수는 일부 위치에서 암시적으로 'any[]' 형식입니다.
	range(start, limit).forEach(i => {
		out.push(i * i);
	});
	return out;
	//     ~~~ 'out' 변수에는 암시적으로 'any[]' 형식이 포함됩니다.
}
```

앞의 코드와 같은 경우라면 루프로 순회하는 대신, 배열의 map과 filter 메서드를 통해 단일 구문으로 배열을 생성하여 any 전체를 진화시키는 방법을 생각해 볼 수 있습니다. 아이템 23과 27을 참고하길 바랍니다.  

any가 진화하는 방식은 일반적인 변수가 추론되는 원리와 동일합니다. 예를 들어, 진화한 배열의 타입이 (string|number)[]라면, 원래 number[] 타입이어야 하지만 실수로 string이 섞여서 잘못 진화한 것일 수 있습니다. 타입을 안전하게 지키기 위해서는 암시적 any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 더 좋은 설계입니다.  

+ 일반적인 타입들은 정제되기만 하는 반면, 암시적 any와 any[] 타입은 진화할 수 있습니다. 이러한 동작이 발생하는 코드를 인지하고 이해할 수 있어야 합니다.
+ any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 안전한 타입을 유지하는 방법입니다.  

### 아이템 42. 모르는 타입의 값에는 any 대신 unknown을 사용하기  
<br/>

any가 강력하면서도 위험한 이유는 다음 두 가지 특징으로부터 비롯됩니다.  

+ 어떠한 타입이든 any 타입에 할당 가능하다.
+ any 타입은 어떠한 타입으로도 할당 가능하다.  

'타입을 값의 집합으로 생각하기(아이템 7)'의 관점에서, 한 집합은 다른 모든 집합의 부분 집합이면서 동시에 상위집합이 될 수 없기 때문에, 분명히 any는 타입 시스템과 상충되는 면을 가지고 있습니다. 이러한 점이 any의 강력함의 원천이면서 동시에 문제를 일으키는 원인이 됩니다. 타입 체커는 집합 기반이기 때문에 any를 사용하면 타입 체커가 무용지물이 된다는 것을 주의해야 합니다.  

unknown은 any 대신 쓸 수 있는 타입 시스템에 부합하는 타입입니다. unknown 타입은 앞에서 언급한 any의 첫 번째 속성(어떠한 타입이든 unknown에 할당 가능)을 만족하지만, 두 번째 속성(unknown은 오직 unknown과 any에만 할당 가능)은 만족하지 않습니다. 반면 never 타입은 unknown과 정반대입니다. 첫 번째 속성(어떤 타입도 never에 할당할 수 없음)은 만족하지 않지만, 두 번째 속성(어떠한 타입으로도 할당 가능)은 만족합니다.  

한편 unknown 타입인 채로 값을 사용하면 오류가 발생합니다. unknown인 값에 함수 호출을 하거나 연산을 하려고 해도 마찬가지입니다. unknown 상태로 사용하려고 하면 오류가 발생하기 때문에, 적절한 타입으로 변환하도록 강제할 수 있습니다.  

어떠한 값이 있지만 그 타입을 모르는 경우에 unknown을 사용합니다.  

타입 단언문이 unknown에서 원하는 타입으로 변환하는 유일한 방법은 아닙니다. instanceof를 체크한 후 unknown에서 원하는 타입으로 변환할 수 있습니다.  

```typescript
function processValue(val: unknown) {
	if (val instanceof Date) {
		val // 타입이 Date
	}
}
```

또한 사용자 정의 타입 가드도 unknown에서 원하는 타입으로 변환할 수 있습니다.  

```typescript
function isBook(val: unknown): val is Book {
	return (
		typeof(val) === 'object' && val !== null && 'name' in val && 'author' in val
	);
}
function processValue(val: unknown) {
	if (isBook(val)) {
		val; // 타입이 Book
	}
}
```

unknown 타입의 범위를 좁히기 위해서는 상당히 많은 노력이 필요합니다. in 연산자에서 오류를 피하기 위해 먼저 val이 객체임을 확인해야 하고, typeof null === 'object'이므로 별도로 val이 null이 아님을 확인해야 합니다.  

가끔 unknown 대신 제너릭 매개변수가 사용되는 경우도 있습니다.  

```typescript
function safeParseYAML<T>(yaml: string): T {
	return parseYAML(yaml);
}
```

제너릭을 사용한 스타일은 타입 단언문과 달라 보이지만 기능적으로는 동일합니다. 제너릭보다는 unknown을 반환하고 사용자가 직접 단언문을 사용하거나 원하는 대로 타입을 좁히도록 강제하는 것이 좋습니다.  

```typescript
declare const foo: Foo;
let barAny = foo as any as Bar;
let barUnk = foo as unknown as Bar;
```

barAny와 barUnk는 기능적으로 동일하지만, 나중에 두 개의 단언문을 분리하는 리팩터링을 한다면 unknwon 형태가 더 안전합니다. any의 경우는 분리되는 순간 그 영향력이 전염병처럼 퍼지게 됩니다. 그러나 unknown의 경우는 분리되는 즉시 오류를 발생하게 되므로 더 안전합니다.  

마지막으로 unknown과 유사하지만 조금 다른 타입들도 알아보겠습니다. 이번 아이템에서 unknown에 대해서 설명한 것과 비슷한 방식으로 object 또는 {}를 사용하는 코드들이 존재합니다. object 또는 {}를 사용하는 방법 역시 unknown만큼 범위가 넓은 타입이지만, unknown보다는 범위가 약간 좁습니다.  

+ {} 타입은 null과 undefined를 제외한 모든 값을 포함합니다.
+ object 타입은 모든 비기본형(non-primitive) 타입으로 이루어집니다. 여기에는 true 또는 12 또는 "foo"가 포함되지 않지만 객체와 배열은 포함됩니다.  

unknown 타입이 도입되기 전에는 {}가 더 일반적으로 사용되었지만, 최근에는 {}를 사용하는 경우가 꽤 드뭅니다. 정말로 null과 undefined가 불가능하다고 판단되는 경우만 unknown 대신 {}를 사용하면 됩니다.  

+ unknown은 any 대신 사용할 수 있는 안전한 타입입니다. 어떠한 값이 있지만 그 타입을 알지 못하는 경우라면 unknown을 사용하면 됩니다.
+ 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제하려면 unknown을 사용하면 됩니다.
+ {}, object, unknown의 차이점을 이해해야 합니다.  

### 아이템 43. 몽키 패치보다는 안전한 타입을 사용하기  
<br/>

자바스크립트의 가장 유명한 특징 중 하나는, 객체와 클래스에 임의의 속성을 추가할 수 있을 만큼 유연하다는 것입니다.  

예를 들어 window 또는 DOM 노드에 데이터를 추가한다고 가정해 보겠습니다. 그러면 그 데이터는 기본적으로 전역 변수가 됩니다. 전역 변수를 사용하면 은연중에 프로그램 내에서 서로 멀리 떨어진 부분들 간에 의존성을 만들게 됩니다. 그러면 함수를 호출할 때마다 부작용(side effect)을 고려해야만 합니다.  

타입스크립트까지 더하면 또 다른 문제가 발생합니다. 타입 체커는 Document와 HTMLElement의 내장 속서엥 대해서는 알고 있지만, 임의로 추가한 속성에 대해서는 알지 못합니다.  

```typescript
document.monkey = 'Tamarin';
//      ~~~~~~~ 'Document' 유형에 'monkey' 속성이 없습니다.
```

이 오류를 해결하는 가장 간단한 방법은 any 단언문을 사용하는 것입니다.  

```typescript
(document as any).monkey = 'Tamarin'; // 정상
```

타입 체커는 통과하지만 단점이 있습니다. any를 사용함으로써 타입 안전성을 상실하고, 언어 서비스를 사용할 수 없게 된다는 것입니다.  

```typescript
(document as any).monkey = 'Tamarin'; // 정상, 오타
(document as any).monkey = /Tamarin/; // 정상, 잘못된 타입
```

최선의 해결책은 document 또는 DOM으로부터 데이터를 분리하는 것입니다. 분리할 수 없는 경우(객체와 데이터가 붙어 있어야만 하는 라이브러리를 사용중이거나 자바스크립트 애플리케이션을 마이그레이션하는 과정 중이라면), 두 가지 차선책이 존재합니다.  

첫 번째, interface의 특수 기능 중 하나인 보강(augmentation)을 사용하는 것입니다(아이템 13).  

```typescript
interface Document {
	/** 몽기 패치의 속(genus) 또는 종(species) */
	monkey: string;
}

document.monkey = 'Tamarin'; // 정상
```

보강을 사용한 방법이 any보다 나은 점은 다음과 같습니다.  

+ 타입이 더 안전합니다. 타입 체커는 오타나 잘못된 타입의 할당을 오류로 표시합니다.
+ 속성에 주석을 붙일 수 있습니다(아이템 48).
+ 속성에 자동완성을 사용할 수 있습니다.
+ 몽키 패치가 어떤 부분에 적용되었는지 정확한 기록이 남습니다.  

그리고 모듈의 관점에서(타입스크립트 파일이 import / export를 사용하는 경우), 제대로 동작하게 하려면 global 선언을 추가해야 합니다.  

```typescript
export {};
declare global {
	interface Document {
		/** 몽기 패치의 속(genus) 또는 종(species) */
		monkey: string;
	}
}
document.monkey = 'Tamarin'; // 정상
```

보강을 사용할 때 주의해야 할 점은 모듈 영역(scope)과 관련이 있습니다. 보강은 전역적으로 적용되기 때문에, 코드의 다른 부분이나 라이브러리로부터 불리할 수 없습니다. 그리고 애플리케이션이 실행되는 동안 속성을 할당하면 실행 시점에서 보강을 적용할 방법이 없습니다. 특히 웹 페이지 내의 HTML 엘리먼트를 조작할 때, 어떤 엘리먼트는 속성이 있고 어떤 엘리먼트는 속성이 없는 경우 문제가 됩니다. 이러한 이유로 속성을 string|undefined로 선언할 수도 있습니다. 이렇게 선언하면 더 정확할 수 있지만 다루기에는 더 불편해집니다.  

두 번째, 더 구체적인 타입 단언문을 사용하는 것입니다.  

```typescript
interface MonkeyDocument extends Document {
	/** 몽기 패치의 속(genus) 또는 종(species) */
	monkey: string;
}
(document as MonkeyDocument).monkey = 'Macaque';
```

MonkeyDocument는 Document를 확장하기 때문에(아이템 9) 타입 단언문은 정상이며 할당문의 타입은 안전합니다. 또한 Document 타입을 건드리지 않고 별도로 확장하는 새로운 타입을 도입했기 때문에 모듈 영역 문제도 해결할 수 있습니다(import하는 곳의 영역에만 해당됨). 따라서 몽키 패치된 속성을 참조하는 경우에만 단언문을 사용하거나 새로운 변수를 도입하면 됩니다. 그러나 몽키 패치를 남용해서는 안 되며 궁극적으로 더 잘 설계된 구조로 리팩터링하는 것이 좋습니다.  

+ 전역 변수나 DOM에 데이터를 저장하지 말고, 데이터를 분리하여 사용해야 합니다.
+ 내장 타입에 데이터를 저장해야 하는 경우, 안전한 타입 접근법 중 하나(보강이나 사용자 정의 인터페이스로 단언)를 사용해야 합니다.
+ 보강의 모듈 영역 문제를 이해해야 합니다.  

### 아이템 44. 타입 커버리지를 추적하여 타입 안전성 유지하기  
<br/>

noImplicitAny를 설정하고 모든 암시적 any 대신 명시적 타입 구문을 추가해도 any 타입과 관련된 문제들로부터 안전하다고 할 수 없습니다. any 타입이 여전히 프로그램 내에 존재할 수 있는 두 가지 경우가 있습니다.  

+ 명시적 any 타입  
아이템 38과 아이템 39의 내용에 따라 any 타입의 범위를 좁히고 구체적으로 만들어도 여전히 any 타입입니다. 특히 any[]와 {[key : string] : any} 같은 타입은 인덱스를 생성하면 단순 any가 되고 코드 전반에 영향을 미칩니다.  

+ 서드파티 타입 선언  
이 경우는 @types 선언 파일로부터 any 타입이 전파되기 때문에 특별히 조심해야 합니다. noImplicitAny를 설정하고 절대 any를 사용하지 않았다 하더라도 여전히 any 타입은 코드 전반에 영향을 미칩니다.  

any 타입은 타입 안전성과 생산성에 부정적 영향을 미칠 수 있으므로(아이템 5), 프로젝트에서 any의 개수를 추적하는 것이 좋습니다. npm의 type-cover-age 패키지를 활용하여 any를 추적할 수 있는 몇 가지 방법이 있습니다.  

타입 커버리지 정보를 수집해 보는 것도 유용할 수 있습니다. type-coverage를 실행할 때 --detail 플래그를 붙이면, any 타입이 있는 곳을 모두 출력해 줍니다.  

이것을 조사해 보면 미처 발견하지 못한 any의 근원지를 찾을 수도 있습니다.  

코드에 any가 남아 있는 이유는 다양합니다. 오류를 간단히 해결하기 위해 종종 명시적으로 any를 선언했을 수 있습니다. 타입 오류가 발생했지만 해결하는 데 시간을 쏟고 싶지 않았을 수도 있습니다. 또는 아직까지 타입을 제대로 작성하지 못했을 수도 있습니다. 아니면 급하게 작업하느라 any인 채로 놔두었을 수도 있습니다.  

서드파티 라이브러리로부터 비롯되는 any 타입은 몇 가지 형태로 등장할 수 있지만 가장 극단적인 예는 전체 모듈에 any 타입을 부여하는 것입니다.  

```typescript
declare module 'my-module';
```

앞의 선언으로 인해 my-module에서 어떤 것이든 오류 없이 임포트할 수 있습니다. 임프토한 모든 심벌은 any 타입이고, 임포트한 값이 사용되는 곳마다 any 타입을 양산하게 됩니다.  

```typescript
import {someMethod, someSymbol} from 'my-module'; // 정상

const pt1 = {
	x: 1,
	y: 2,
}; // 타입이 {x: number, y: number}
const pt2 = someMethod(pt1, someSymbol); // 정상, pt2의 타입이 any
```

일반적인 모듈의 사용법과 동일하기 때문에, 타입 정보가 모두 제거됐다는 것을 간과할 수 있습니다. 또는 동료가 모든 타입 정보를 날려 버렸지만, 알아채지 못하는 경우일 수도 있습니다. 그렇기 때문에 가끔 해당 모듈을 점검해야 합니다. 어느 순간 모듈에 대한 공식 타입 선언이 릴리스되었을지도 모릅니다. 또는 모듈을 충분히 이해한 후에 직접 타입 선언을 작성해서 커뮤니티에 공개할 수도 있습니다.  

서드파티 라이브러리로부터 비롯되는 any의 또 다른 형태는 타입에 버그가 있는 경우입니다. 예를 들어 아이템 29의 조언(값을 생성할 때는 엄격하게 타입을 적용)을 무시한 채로, 함수가 유니온 타입을 반환하도록 선언하고 실제로는 유니온 타입보다 훨씬 더 특정된 값을 반환하는 경우입니다. 선언된 타입과 실제 반환된 타입이 맞지 않는다면 어쩔 수 없이 any 단언문을 사용해야 합니다. 그러나 나중에 라이브러리가 업데이트되어 함수의 선언문이 제대로 수정된다면 any를 제거해야 합니다. 또는 직접 라이브러리의 선언문을 수정하고 커뮤니티에 공개할 수도 있습니다.  

any 타입이 사용되는 코드가 살제로는 더 이상 실행되지 않는 코드일 수 있습니다. 또는 어쩔 수 없이 any를 사용했던 부분이 개선되어 제대로 된 타입으로 바뀌었다면 any가 더 이상 필요 없을 수도 있습니다. 버그가 있는 타입 선언문이 업데이트되어 제대로 타입 정보를 가질 수도 있습니다. 타입 커버리지를 추적하면 이러한 부분들을 쉽게 발견할 수 있기 때문에 코드를 꾸준히 점검할 수 있게 해 줍니다.  

+ noImplicitAny가 설정되어 있어도, 명시적 any 또는 서드파티 타입 선언(@types)을 통해 any 타입은 코드 내에 여전히 존재할 수 있다는 점을 주의해야 합니다.
+ 작성한 프로그램의 타입이 얼마나 잘 선언되었는지 추적해야 합니다. 추적함으로써 any의 사용을 줄여 나갈 수 있고 타입 안전성을 꾸준히 높일 수 있습니다.  

### 아이템 45. devDependencies에 typescript와 @types 추가하기  
<br/>

npm(node package manager)은 자바스크립트 세상에서 필수적입니다. npm은 자바스크립트 라이브러리 저장소(npm 레지스트리)와, 프로젝트가 의존하고 있는 라이브러리들의 버전을 지정하는 방법(package.json)을 제공합니다.  

npm은 세 가지 종류의 의존성을 구분해서 관리하며, 각각의 의존성은 package.json 파일 내의 별도 영역에 들어 있습니다.  

+ dependency  
현재 프로젝트를 실행하는 데 필수적인 라이브러리들이 포함됩니다. 프로젝트를 npm에 공개하여 다른 사용자가 해당 프로젝트를 설치한다면, dependencies에 들어 있는 라이브러리도 함께 설치될 것입니다. 이러한 현상을 전이(trnasitive) 의존성이라고 합니다.  

+ devDependencies  
현재 프로젝트를 개발하고 테스트하는 데 사용되지만, 런타임에는 필요 없는 라이브러리들이 포함됩니다. 프로젝트를 npm에 공개하여 다른 사용자가 해당 프로젝트를 설치한다면, devDependencies에 포함된 라이브러리들은 제외된다는 것이 dependencies와 다른 점입니다.  

+ peerDependencies  
런타임에 필요하긴 하지만, 의존성을 직접 관리하지 않는 라이브러리들이 포함됩니다. 단적인 예로 플러그인을 들 수 있습니다. 제이쿼리의 플러그인은 다양한 버전의 제이쿼리와 호환되므로 제이쿼리의 버전을 플러그인에서 직접 선택하지 않고, 플러그인이 사용되는 실제 프로젝트에서 선택하도록 만들 때 사용합니다.  

이 세 가지 의존성 중에서는 dependencies와 devDependencies가 일반적으로 사용됩니다. 타입스크립트 개발자라면 라이브러리를 추가할 때 어떤 종류의 의존성을 사용해야 하는지 알고 있어야 합니다. 타입스크립트는 개발 도구일 뿐이고 타입 정보는 런타임에 존재하지 않기 때문에(아이템 3), 타입스크립트와 관련된 라이브러리는 일반적으로 devDependencies에 속합니다.  

모든 타입스크립트 프로젝트에서 공통적으로 고려해야 할 의존성 두 가지를 살펴보겠습니다.  

첫 번째, 타입스크립트 자체 의존성을 고려해야 합니다. 타입스크립트를 시스템 레벨로 설치할 수도 있지만, 다음 두 가지 이유 때문에 추천하지는 않습니다.  

+ 팀원들 모두가 항상 동일한 버전을 설치한다는 보장이 없습니다.
+ 프로젝트를 셋업할 때 별도의 단계가 추가됩니다.  

따라서 타입스크립트를 시스템 레벨로 설치하기보다는 devDependencies에 넣는 것이 좋습니다. devDependencies에 포함되어 있다면, npm install을 실행할 대 팀원들 모두 항상 정확한 버전의 타입스크립트를 설치할 수 있습니다. 그리고 타입스크립트 버전 업데이트는 다른 라이브러리의 업데이트와 같은 방법을 사용하게 됩니다.  

대부분의 타입스크립트 IDE와 빌드 도구는 devDependencies를 통해 설치된 타입스크립트의 버전을 인식할 수 있도록 되어 있습니다. 또한 커맨드 라인에서 npx를 사용해서 devDependencies를 통해 설치된 타입스크립트 컴파일러를 실행할 수 있습니다.  

두 번째, 타입 의존성(@types)을 고려해야 합니다. 사용하려는 라이브러리에 타입 선언이 포함되어 있지 않더라도, DefinitelyTyped(타입스크립트 커뮤니티에서 유지보수하고 있는 자바스크립트 라이브러리의 타입을 정의한 모음)에서 타입 정보를 얻을 수 있습니다. DefinitelyTyped의 타입 정의들은 npm 레지스트리의 @types 스코프에 공개됩니다. 즉, @types/jquery에는 제이쿼리의 타입 정의가 있고, @types/lodash에는 로대시의 타입 정의가 있습니다. @types 라이브러리는 타입 정보만 포함하고 있으며 구현체는 포함하지 않습니다.  

원본 라이브러리 자체가 dependencies에 있더라도 @types 의존성은 devDependencies에 있어야 합니다. 예를 들어, 리액트의 타입 선언과 리액트를 의존성에 추가하려면 다음처럼 실행해야 합니다.  

```shell
npm install react
npm install --save-dev @types/react
```

그러면 package.json 파일이 생성됩니다.  

그러나 타입 의존성을 devDependencies에 넣는 방식이 항상 유효한 것은 아니며 @types 의존성과 관련된 몇 가지 문제점이 있습니다.  

+ 타입스크립트를 시스템 레벨로 설치하면 안 됩니다. 타입스크립트를 프로젝트의 devDependencies에 포함시키고 팀원 모두가 동일한 버전을 사용하도록 해야 합니다.
+ @types 의존성은 dependencies가 아니라 devDependencies에 포함시켜야 합니다. 런타임에 @types가 필요한 경우라면 별도의 작업이 필요할 수 있습니다.  

### 아이템 43. 타입 선언과 관련된 세 가지 버전 이해하기  
<br/>

의존성 관리는 개발자에게 매우 힘든 일입니다. 그래서 여러분은 아마 단순히 라이브러리를 프로젝트에 추가해서 사용할 뿐이지 라이브러리의 전이적(transitive) 의존성이 호환되는지 깊게 생각하지 않았을 겁니다.  

그런데 실제로 타입스크립트는 알아서 의존성 문제를 해결해 주기는커녕, 의존성 관리를 오히려 더 복잡하게 만듭니다. 왜냐하면 타입스크립트를 사용하면 다음 세 가지 사항을 추가로 고려해야 하기 때문입니다.  

+ 라이브러리의 버전
+ 타입 선언(@types)의 버전
+ 타입스크립트의 버전  

세 가지 버전 중 하나라도 맞지 않으면, 의존성과 상관없어 보이는 곳에서 엉뚱한 오류가 발생할 수 있습니다. 이렇게 발생한 오류의 원인을 파악하고 고치기 위해서는 타입스크립트 라이브러리 관리의 복잡한 메커니즘을 모두 이해해야 합니다. 라이브러리 관리의 메커니즘을 이해하게 된다면 프로젝트 내에서 작성한 타입 선언을 외부에 공개해야 하는 시점이 되었을 때, 버전과 관련해서 제대로 된 결정을 내릴 수 있습니다.  

타입스크립트에서 일반적으로 의존성을 사용하는 방식은 다음과 같습니다. 특정 라이브러리를 dependencies로 설치하고, 타입 정보는 devDependencies로 설치합니다(아이템 45).  

그러나 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식은 다음 네 가지 문제점이 있습니다.  

첫 번째, 라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트하지 않는 경우입니다. 이런 경우 라이브러리 업데이트와 관련된 새로운 기능을 사용하려 할 때마다 타입 오류가 발생하게 됩니다. 특히 하위 호환성이 깨지는 변경이 있었다면, 코드가 타입 체커를 통과하더라도 런타임에 오류가 발생할 수 있습니다.  

일반적인 해결책은 타입 선언도 업데이트하여 라이브러리와 버전을 맞추는 것입니다. 그러나 업데이터해야 할 타입 선언의 버전이 아직 준비되지 않은 경우라면 두 가지 선택지가 있습니다. 보강(augmentation) 기법을 활용하여, 사용하려는 세 함수와 메서드의 타입 정보를 프로젝트 자체에 추가하는 것입니다. 또는 타입 선언의 업데이트를 직접 작성하고 공개하여 커뮤니티에 기여하는 방법도 있습니다.  

두 번째, 라이브러리보다 타입 선언의 버전이 최신인 경우입니다. 이런 경우는 타입 정보 없이 라이브러리를 사용해 오다가(아마도 declare module을 사용해서 any 타입으로 사용했을 겁니다)타입 선언을 설치하려고 할 때 뒤늦게 발생합니다. 그 사이에 버전 정보는 어긋나게 될 것입니다. 첫 번째 문제와 상황이 비슷하지만 버전의 대소 관계가 반대입니다. 타입 체커는 최신 API를 기준으로 코드를 검사하게 되지만 런타임에 실제로 쓰이는 것은 과거 버전입니다. 해결책은 라이브러리와 타입 선언의 버전이 맞도록 라이브러리 버전을 올리거나 타입 선언의 버전을 내리는 것입니다.  

세 번째, 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우입니다. 일반적으로 로대시(Lodash), 리액트(React), 람다(Ramda) 같은 유명 자바스크립트 라이브러리의 타입 정보를 더 정확하게 표현하기 위해서 타입스크립트에서 타입 시스템이 최신 타입 정보를 얻기 위해서라면 당연히 타입스크립트의 최신 버전을 사용해야 합니다.  

현재 프로젝트보다 라이브러리에게 필요한 타입스크립트 버전이 높은 상황이라면, @types 선언 자체에서 타입 오류가 발생하게 됩니다. 이 오류를 해결하려면 프로젝트의 타입스크립트 버전을 올리거나, 라이브러리 타입 선언의 버전을 원래대로 내리거나, declare module 선언으로 라이브러리의 타입 정보를 없애 버리면 됩니다. 라이브러리에서 typesVersion를 통해 타입스크립트 버전별로 다른 타입 선언을 제공하는 방법도 있지만 실제로는 매우 드뭅니다. 최근까지도 DefinitelyType의 라이브러리들 중 1%미만에서만 typesVersion을 제공합니다.  

타입스크립트의 특정 버전에 대한 타입 정보를 설치하려면 다음처럼 실행하면 됩니다.  

```shell
npm install --save-dev @types/lodash@ts3.1
```

라이브러리와 타입 선언의 버전을 일치시키는 것이 최선이겠지만, 상황에 따라 해당 버전의 타입 정보가 없을 수도 있습니다. 그러나 유명한 라이브러리일수록 타입 선언이 존재할 가능성이 높습니다.  

네 번째, @types 의존성이 중복될 수도 있습니다. @types/foo와 @types/bar에 의존하는 경우를 가정해 봅시다. 만약 @types/bar가 현재 프로젝트와 호환되지 않는 버전의 @types/foo에 의존한다면 npm은 중첩된 폴더에 별도로 해당 버전을 설치하여 문제를 해결하려고 합니다.  

런타임에 사용되는 모듈이라면 괜찮을 수 있지만, 전역 네임스페이스(namespace)에 있는 타입 선언 모듈이라면 대부분 문제가 발생합니다. 전역 네임스페이스에 타입 선언이 존재하면 중복된 선언, 또는 선언이 병합될 수 없다는 오류로 나타나게 됩니다. 이런 상황이라면 npm ls @types/foo를 실행하여 어디서 타입 선언 중복이 발생했는지 추적할 수 있습니다. 해결책은 보통 @types/foo를 업데이트하거나 @types/bar를 업데이트해서 서로 버전이 호환되게 하는 것입니다. 그러나 @types이 전이(transitive) 의존성을 가지도록 만드는 것은 종종 문제를 일으키기도 합니다. 만약 타입 선언을 작성하고 공개하려고 한다면, 아이템 51을 참고하여 이러한 무제를 피하기 바랍니다.  

일부 라이브러리, 특히 타입스크립트로 작성된 라이브러리들은 자체적으로 타입 선언을 포함(번들링, bundling)하게 됩니다. 자체적인 타입 선언은 보통 package.json의 "types" 필드에서 .d.ts 파일을 가리키도록 되어 있습니다.  

"types": "index.d.ts"를 추가하면 모든 문제가 해결될까요?  

번들링하여 타입 선언을 포함하는 경우, 특히 라이브러리가 타입스크립트로 작성되고 컴파일러를 통해 타입 선언이 생성된 경우라면 버전 불일치 문제를 해결하기는 합니다. 그러나 번들링 방식은 부수적인 네 가지 문제점을 가지고 있습니다.  

첫 번째, 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는 잘 동작했지만 타입스크립트 버전이 올라가면서 오류가 발생하는 경우에 문제가 됩니다. @types을 별도로 사용하는 경우라면 라이블러리 자체의 버전에 맞추어 선택할 수 있습니다. 그러나 번들된 타입에서는 @types의 버전 선택이 불가능합니다. 단 하나의 잘못된 타입 선언으로 인해 타입스크립트의 버전을 올리지 못하는 불상사가 생길 수 있는 것입니다. 번들된 타입과 DefinitelyTyped이 비교되는 부분입니다. 마이크로소프트는 타입스크립트 버전이 올라감에 따라 DefinitelyTyped의 모든 타입 선언을 점검하며, 문제가 발견된 곳은 빠른 시간 내에 해결하고 있습니다.  

두 번째, 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존하다면 문제가 됩니다. 보통은 의존성이 devDependencies에 들어갑니다(아이템 45). 그러나 프로젝트를 공개하여 다른 사용자가 설치하게 되면 devDependencies가 설치되지 않을 것이고 타입 오류가 발생하게 됩니다. 반면 자바스크립트 사용자 입장에서는 @types를 설치할 이유가 없기 때문에 dependencies에 포함하고 싶지 않을 겁니다. 아이템 51에서는 타입 선언을 공개하는 경우라면 첫 번째 상황은 전혀 문제가 되지 않습니다. 타입 선언은 @types에 있을 것이고 타입스크립트 사용자만이 타입 정보를 사용하게 됩니다.  

세 번째, 프로젝트이 과거 버전에 있는 타입 선언에 문제가 있는 경우에는 과거 버전으로 돌아가서 패치 업데이트를 해야 합니다. 번들링된 타입 선언에서는 어려운 일이지만, DefinitelyTyped는 동일 라이브러리의 여러 버전의 타입 선언을 동시에 유지보수할 수 있는 메커니즘을 가지고 있습니다.  

네 번째, 타입 선언의 패치 업데이트를 자주 하기 어렵다는 문제가 있습니다.  

타입스크립트에서 의존성을 관리한다는 것은 쉽지 않은 일이지만, 잘 관리한다면 그에 따른 보상이 함께 존재합니다. 잘 작성된 타입 선언은 라이브러리를 올바르게 사용하는 방법을 배우는 데 도움이 되며 생산성 역시 크게 향상시킬 수 있습니다. 만약 의존성 관리에 문제가 생긴다면 이번 아이템의 처음에 언급했던 세 가지 버전을 기억해야 합니다.  

라이브러리를 공개하려는 경우, 타입 선언을 자체적으로 포함하는 것과 타입 정보만 분리하여 DefinitelyTyped에 공개하는 것은 장단점을 비교해 봐야합니다. 공식적인 권장사항은 라이브러리가 타입스크립트로 작성된 경우만 타입 선언을 라이브러리에 포함하는 것입니다. 실제로 타입스크립트 컴파일러가 타입 선언을 대신 생성해 주기 때문에, 타입스크립트로 작성된 라이브러리에 타입 선언을 포함하는 방식은 잘 동작합니다(declaration 컴파일러 옵션을 사용). 자바스크립트로 작성된 라이브러리라면 손수 작성한 타입 선언은 오류가 있을 가능성이 높고 잦은 업데이트가 필요하게 됩니다. 자바스크립트로 작성된 라이브러리는 타입 선언을 DefinitelyTyped에 공개하여 커뮤니티에서 관리하고 유지보수하도록 맡기는 것이 좋습니다.  

+ @types 의존성과 관련된 세 가지 버전이 있습니다. 라이브러리 버전, @types 버전, 타입스크립트 버전입니다.
+ 라이브러리를 업데이트하는 경우, 해당 @types 역시 업데이트해야 합니다.
+ 타입 선언을 라이브러리에 포함하는 것과 DefinitelyTyped에 공개하는 것 사이의 장단점을 이해해야 합니다. 타입스크립트로 작성된 라이브러리라면 타입 선언을 자체적으로 포함하고, 자바스크립트로 작성된 라이브러리라면 타입 선언을 DefinitelyTyped에 공개하는 것이 좋습니다.  

### 아이템 47. 공개 API에 등장하는 모든 타입을 익스포트하기  
<br/>

타입스크립트를 사용하다 보면, 언젠가는 서드파티의 모듈에서 익스포트되지 않은 타입 정보가 필요한 경우가 생깁니다. 다행히 타입 간의 매핑을 해 주는 도구가 많이 있으며, 왠만하면 필요한 타입을 참조하는 방법을 찾을 수 있습니다. 다른 관점으로 생각해 보면, 라이브러리 제작자는 프로젝트 초기에 타입 익스포트부터 작성해야 한다는 의미입니다. 만약 함수의 선언에 이미 타입 정보가 있다면 제대로 익스포트되고 있는 것이며, 타입 정보가 없다면 타입을 명시적으로 작성해야 합니다.  

공개 API 매개변수에 놓이는 순간 타입은 노출됩니다. 그러므로 굳이 숨기려 하지 말고 라이브러리  사용자를 위해 명시적으로 익스포트하는 것이 좋습니다.  

+ 공개 메서드에 등장한 어떤 형태의 타입이든 익스포트합시다. 어차피 라이브리 사용자가 추출할 수 있으므로, 익스포트하기 쉽게 만드는 것이 좋습니다.  

### 아이템 48. API 주석에 TSDoc 사용하기  
<br/>

사용자를 위한 문서라면 JSDoc 스타일의 주석으로 만드는 것이 좋습니다.  

왜냐하면 대부분의 편집기는 함수가 호출되는 곳에서 함수에 붙어 있는 JSDoc 스타일의 주석을 툴팁으로 표시해 주기 때문입니다.  

그러나 인라인(inline) 주석은 편집기가 표시해 주지 않습니다.  

타입스크립트 언어 서비스가 JSDoc 스타일을 지원하기 때문에 적극적으로 활용하는 것이 좋습니다. JSDoc에는 @param과 @returns 같은 일반적 규칙을 사용할 수 있습니다. 한편 타입스크립트 관점에서는 TSDoc이라고 부르기도 합니다.  

@param과 @returns를 추가하면 함수를 호출하는 부분에서 각 매개변수와 관련된 설명을 보여 줍니다.  

타입 정의 TSDoc을 사용할 수도 있습니다.  

TSDoc 주석은 마크다운(markdown) 형식으로 꾸며지므로 굵은 글씨, 기울임 글씨, 글머리기호 목록을 사용할 수 있습니다.  

주석을 수필처럼 장황하게 쓰지 않도록 주의해야 합니다. 훌륭한 주석은 간단히 요점만 언급합니다.  

JSDoc에는 타입 정보를 명시하는 규칙(@param {string} name ...)이 있지만, 타입스크립트에서는 타입 정보가 코드에 있기 때문에 TSDoc에서는 타입 정보를 명시하면 안 됩니다(아이템 30).  

+ 익스포트된 함수, 클래스, 타입에 주석을 달 때는 JSDoc/TSDoc 형태를 사용합시다. JSDoc/TSDoc 형태의 주석을 달면 편집기가 주석 정보를 표시해 줍니다.
+ @param, @returns 구문과 문서 서식을 위해 마크다운을 사용할 수 있습니다.
+ 주석에 타입 정보를 포함하면 안 됩니다(아이템 30).  

### 아이템 49. 콜백에서 this에 대한 타입 제공하기  
<br/>

+ this 바인딩이 동작하는 원리를 이해해야 합니다.
+ 콜백 함수에서 this를 사용해야 한다면, 타입 정보를 명시해야 합니다.  

### 아이템 50. 오버로딩 타입보다는 조건부 타입을 사용하기  
<br/>

타입스크립트는 오버로딩 타입 중에서 일치하는 타입을 찾을 때까지 순차적으로 검색합니다.  

오버로딩 타입이 작성하기는 쉽지만, 조건부 타입은 개별 타입의 유니온으로 일반화하기 때문에 타입이 더 정확해집니다. 타입 오버로딩이 필요한 경우에 가끔 조건부 타입이 필요한 상황이 발생합니다. 각각의 오버로딩 타입이 독립적으로 처리되는 반면, 조건부 타입은 타입 체커가 단일 표현식으로 받아들이기 때문에 유니온 문제를 해결할 수 있습니다. 오버로딩 타입을 작성 중이라면 조건부 타입을 사용해서 개선할 수 있을지 검토해 보는 것이 좋습니다.  

+ 오버로딩 타입보다 조건부 타입을 사용하는 것이 좋습니다. 조건부 타입은 추가적인 오버로딩 없이 유니온 타입을 지원할 수 있습니다.  

### 아이템 51. 의존성 분리를 위해 미러 타입 사용하기  
<br/>

만약 작성 중인 라이브러리가 의존하는 라이브러리의 구현과 무관하게 타입에만 의존한다면, 필요한 선언부만 추출하여 작성 중인 라이브러리에 넣는 것(미러링, mirroring)을 고려해 보는 것도 좋습니다.  

다른 라이브러리의 타입이 아닌 구현에 의존하는 경우에도 동일한 기법을 적용할 수 있고 타입 의존성을 피할 수 있습니다. 그러나 프로젝트의 의존성이 다양해지고 필수 의존성을 피할 수 있습니다. 그러나 프로젝트의 의존성이 다양해지고 필수 의존성이 추가됨에 따라 미러링 기법을 적용하기가 어려워집니다. 다른 라이브러리의 타입 선언의 대부분을 추출해야 한다면, 차라리 명시적으로 @types 의존성을 추가하는 게 낫습니다.  

미러링 기법은 유닛 테스트와 상용 시스템 간의 의존성을 분리하는 데도 유용합니다.  

+ 함수가 아닌 의존성을 분리할 때는 구조적 타이핑을 사용하면 됩니다.
+ 공개한 라이브러리를 사용하는 자바스크립트 사용자가 @types 의존성을 가지지 않게 해야 합니다. 그리고 웹 개발자가 NodeJS 관련된 의존성을 가지지 않게 해야 합니다.  

### 아이템 52. 테스팅 타입의 함정에 주의하기  
<br/>

프로젝트를 공개하려면 테스트 코드를 작성하는 것은 필수이며, 타입 선언도 테스트를 거쳐야 합니다. 그러나 타입 선언을 테스트하기는 매우 어렵습니다. 그래서 타입 선언에 대한 테스트 코드를 작성할 때 타입스크립트가 제공하는 도구를 사용하여 단언문으로 때우기 십상이지만, 이런 방법에는 몇 가지 문제가 있습니다. 궁극적으로는 dtslint 또는 타입 시스템 외부에서 타입을 검사하는 유사한 도구를 사용하는 것이 더 안전하고 간단합니다.  

타입 선언 파일을 테스팅할 때는 단순히 함수를 실행하는 방식을 일반적으로 적용하게 되는데, 그 이유는 라이브러리 구현체의 기존 테스트 코드를 복사하면 간단히 만들 수 있기 때문입니다. 함수를 실행만 하는 테스트 코드가 의미 없는 것은 아니지만, 실제로 반환 타입을 체크하는 것이 훨씬 좋은 테스트 코드입니다.  

반환값을 특정 타입의 변수에 할당하여 간단히 반환 타입을 체크할 수 있는 방법을 알아봅시다.  

```typescript
const length: number[] = map(['john', 'paul'], name => name.length);
```

이 코드는 일반적으로 불필요한 타입 선언(아이템 19)에 해당합니다. 그러나 테스트 코드 관점에서는 중요한 역할을 하고 있습니다. number[] 타입 선언은 map 함수의 반환 타입이 number[]임을 보장합니다. 실제로 DefinitelyTyped를 살펴보면, 테스팅을 위해 정확히 동일한 방식을 사용한 수많은 타입 선언을 볼 수 있습니다. 그러나 테스팅을 위해 할당을 사용하는 방법에는 두 가지 근본적인 문제가 있습니다.  

첫 번째, 불필요한 변수를 만들어야 합니다. 반환값을 할당하는 변수는 샘플코드처럼 쓰일 수도 있지만, 일부 린팅 규칙(미사용 변수 경고)을 비활성해야 합니다.  

일반적인 해결책은 변수를 도입하는 대신 핼퍼 함수를 정의하는 것입니다.  

```typescript
function assertType<T>(x: T) {}
assertType<number[]>(map(['john', 'paul'], name => name.length));
```

이 코드는 불필요한 변수 문제를 해결하지만, 또 다른 문제점이 남아 있습니다.  

두 번째, 두 타입이 동일한지 체크하는 것이 아니라 할당 가능성을 체크하고 있습니다.  

다시 assertType 문제로 돌아와 보겠습니다. 제대로 된 assertType 사용 방법은 무엇일까요? 다음 코드처럼 Parameters와 ReturnType 제너릭 타입을 이용해 함수의 매개변수 타입과 반환 타입만 분리하려 테스트할 수 있습니다.  

```typescript
const double = (x: number) => 2 * x;
let p: Parameters<typeof double> = null;
assertType<[number, number]>(p);
//                           ~ '[number]' 형식의 인수는 '[number, number]'
// 형식의 매개변수에 할당될 수 없습니다.
let r: ReturnType<typeof double> = null;
assertType<number>(r); // 정상
```

타입 시스템 내에서 암시적 any 타입을 발견해 내는 것은 매우 어렵습니다. 이러한 어려움 때문에 타입 체커와 독립적으로 동작하는 도구를 사용해 타입 선언을 테스트하는 방법이 권장됩니다.  

DefinitelyTyped의 타입 선언을 위한 도구는 dtslint입니다. dtslint는 특별한 형태의 주석을 통해 동작합니다. dtslint를 사용하면 beatles 관련 예제의 테스트를 다음처럼 작성할 수 있습니다.  

```typescript
const beatles = ['john', 'paul', 'george', 'ringo'];
map(beatles, function(
	name, // $ExpectType string
	i,    // $ExpectType number
	array // $ExpectType string[]
) {
	this  // $ExpectType string[]
	return name.length
})		  // $ExpectType number[]
```

dtslint는 할당 가능성을 체크하는 대신 각 심벌의 타입을 추출하여 글자 자체가 같은지 비교합니다. 이 비교 과정은 편집기에서 타입 선언을 눈으로 보고 확인하는 것과 같은데, dtslint는 이러한 과정을 자동화합니다. 그러나 글자 자체가 같은지 비교하는 방식에는 단점이 있습니다. number|string과 string|number는 같은 타입이지만 글자 자체로 보면 다르기 때문에 다른 타입으로 인식됩니다. string과 any를 비교할 때도 마찬가지인데, 두 타입은 서로 간에 할당이 가능하지만 글자 자체는 다르기 때문에 다른 타입으로 인식됩니다.  

타입 선언을 테스트한다는 것은 어렵지만 반드시 해야 하는 작업입니다. 앞에서 소개한 몇 가지 일반적인 기법의 문제점을 인지하고, 문제점을 방지하기 위해 dtslint 같은 도구를 사용하도록 합시다.  

+ 타입을 테스트할 때는 특히 함수 타입의 동일성(equality)과 할당 가능성(assignability)의 차이점을 알고 있어야 합니다.
+ 콜백이 있는 함수를 테스트할 때, 콜백 매개변수의 추론된 타입을 체크해야 합니다. 또한 this가 API의 일부분이라면 역시 테스트해야 합니다.
+ 타입 관련된 테스트에서 any를 주의해야 합니다. 더 엄격한 테스트를 위해 dtslint 같은 도구를 사용하는 것이 좋습니다.  

### 아이템 53. 타입스크립트 기능보다는 ECMAScript 기능을 사용하기  
<br/>

타입스크립트가 태동하던 2010년경, 자바스크립트는 결함이 많고 개선해야 할 부분이 많은 언어였습니다. 그리고 클래스. 데코레이터, 모듈 시스템 같은 기능이 없어서 프레임워크나 트랜스파일러로 보완하는 것이 일반적인 모습이었습니다. 그렇기 때문에 타입스크립트도 초기 버전에는 독립적으로 개발한 클래스. 열거형(enum), 모듈 시스템을 포함시킬 수밖에 없었습니다.  

시간이 흐르며 TC39(자바스크립트를 관장하는 표준 기구)는 부족했던 점들을 대부분 내장 기능으로 추가했습니다. 그러나 자바스크립트에 새로 추가된 기능은 타입스크립트 초기 버전에서 독립적으로 개발했던 기능과 호환성 문제를 발생시켰습니다. 그렇기에 타입스크립트 진영에서는 다음 전략 중 하나를 선택해야 했습니다. 한 가지 전략은 타입스크립트 초기 버전의 형태를 유지하기 위해 자바스크립트 신규 기능을 변형해서 끼워 맞추는 것입니다. 또 다른 전략은 자바스크립트의 신규 기능을 그대로 채택하고 타입스크립트 초기 버전의 호환성을 포기하는 것입니다.  

타입스크립트 팀은 대부분 두 번째 전략을 선택했습니다. 결국 TC39는 런타임 기능을 발전시키고, 타입스크립트 팀은 타입 기능만 발전시킨다는 명확한 원칙을 세우가 현재까지 지켜오고 있습니다.  

그런데 이 원칙이 세워지기 전에, 이미 사용되고 있던 몇 가지 기능이 있습니다. 이 기능들은 타입 공간(타입스크립트)과 값 공간(자바스크립트)의 경계를 혼란스럽게 만들기 때문에 사용하지 않는 것이 좋습니다. 여기서는 피해야 하는 기능을 몇 가지 살펴봅니다. 그리고 불가피하게 이 기능을 사용하게 될 경우 어떤 점에 유의해야 호환성 문제를 일으키지 않는지 알아봅니다.  

+ 일반적으로 타입스크립트 코드에서 모든 타입 정보를 제거하면 자바스크립트가 되지만, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 타입 정보를 제거한다고 자바스크립트가 되지는 않습니다.
+ 타입스크립트의 역할을 명확하게 하려면, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 사용하지 않는 것이 좋습니다.  

#### 아이템 53-1. 열거형(enum)  
<br/>

```typescript
enum Flavor {
	VANILLA = 0,
	CHOCOLATE = 1,
	STRAWBERRY = 2,
}

let flavor = Flavor.CHOCOLATE; // 타입이 Flavor

Flavor // 자동완성 추천: VANILLA, CHOCOLATE, STRAWBERRY
Flavor[0] // 값이 "VANILLA"
```

타입스크립트의 열거형은 몇 가지 문제가 있습니다. 타입스크립트의 열거형은 다음 목록처럼 상황에 따라 다르게 동작합니다.  

+ 숫자 열거형에 0, 1, 2 외의 다른 숫자가 할당되면 매우 위험합니다. (이 방법은 원래 비트 플래그 구조를 표현하기 위해 설계되었습니다.)
+ 상수 열거형은 보통의 열거형과 달리 런타임에 완전히 제거됩니다. 앞의 예제를 const enum Flavor로 바꾸면, 컴파일러는 Flavor.CHOCOLATE를 0으로 바꿔 버립니다. 이런 결과는 기대하지 않은 것이며, 문자열 열거형과 숫자 열거형과 전혀 다른 동작입니다.
+ preserveConstEnums 플래그를 설정한 상태의 상수 열거형은 보통의 열거형처럼 런타임 코드에 상수 열거형 정보를 유지합니다.
+ 문자열 열거형은 런타임의 타입 안전성과 투명성을 제공합니다. 그러나 타입스크립트의 다른 타입과 달리 구조적 타이핑이 아닌 명목적 타이핑을 사용합니다(바로 이어서 설명합니다).  

타입스크립트의 일반적인 타입들이 할당 가능성을 체크하기 위해서 구조적 타이핑(아이템 4)을 사용하는 반면, 문자열 열거형은 명목적 타이핑(nominally typing)을 사용합니다.  

구조적 타이핑은 구조가 같으면 할당이 허용되는 반면, 명목적 타이핑은 타입의 이름이 같아야 할당이 허용됩니다.  

명목적 타이핑은 라이브러리를 공개할 때 필요합니다. Flavor를 매개변수로 받는 함수를 가정해 봅시다.  

```typescript
function scoop(flavor: Flavor) { /* ... */ }
```

Flavor는 런타임 시점에는 문자열이기 때문에, 자바스크립트에서 다음처럼 호출할 수 있습니다.  

```javascript
scoop('vanilla'); // 자바스크립트에서 정상
```

그러나 타입스크립트에서는 열거형을 임포트하고 문자열 대신 사용해야 합니다.  

```typescript
scoop('vanilla');
//    ~~~~~~~~~ '"vanilla"' 형식은 'Flavor' 형식의 매개변수에 할당될 수 없습니다.

import (Flavor) from 'ice-cream';
scoop(Flavor.VANILLA); // 정상
```

이처럼 자바스크립트의 타입스크립트에서 동작이 다르기 때문에 문자열 열거형은 사용하지 않는 것이 좋습니다. 열거형 대신 리터럴 타입의 유니온을 사용하면 됩니다.  

```typescript
type Flavor = 'vanilla' | 'chocolate' | 'strawberry';

let flavor: Flavor = 'chocolate'; // 정상
flavor = 'mint chip';
//~~~~ '"mint chip"' 유형은 'Flavor' 유형에 할당할 수 없습니다. 
```

리터럴 타입의 유니온은 열거형만큼 안전하며 자바스크립트와 호환되는 장점이 있습니다. 그리고 편집기에서 열거형처럼 자동완성 기능을 사용할 수 있습니다.  

#### 아이템 53-2. 매개변수 속성  
<br/>

매개변수 속성과 관련된 몇 가지 문제점이 존재합니다.  

+ 일반적으로 타입스크립트 컴파일은 타입 체커가 이루어지므로 코드가 줄어들지만, 매개변수 속성은 코드가 늘어나는 문법입니다.
+ 매개변수 속성이 런타임에는 실제로 사용되지만, 타입스크립트 관점에서는 사용되지 않는 것처럼 보입니다.
+ 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스의 설계가 혼란스러워집니다.  

매개변수 속성은 타입스크립트의 다른 패턴들과 이질적이고, 초급자에게 생소한 문법이라는 것을 기억해야 합니다. 또한 매개변수 속성과 일반 속성을 같이 사용하면 설계가 혼란스러워지기 때문에 한 가지만 사용하는 것이 좋습니다.  

#### 아이템 53-3. 네임스페이스와 트리플 슬래시 임포트  
<br/>

ECMAScript 2015 이전에는 자바스크립트에 공식적인 모듈 시스템이 없었습니다. 그래서 각 환경마다 자신만의 방식으로 모듈 시스템을 마련했습니다. Node.js는 require와 module.exports를 사용한 반면, AMD는 define 함수와 콜백을 사용했습니다.  

타입스크립트 역시 자체적으로 모듈 시스템을 구축했고, module 키워드와 '트리플 슬래시' 임포트를 사용했습니다. ECMAScript 2015가 공식적으로 모듈 시스템을 도입한 이후, 타입스크립트는 충돌을 피하기 위해 module과 같은 기능을 하는 namespace 키워드를 추가했습니다.  

```typescript
namespace foo {
	function bar() {}
}

/// <reference path="other.ts"/>
foo.bar();
```

트리플 슬래시 임포트와 module 키워드는 호환성을 위해 남아 있을 뿐이며, 이제는 ECMAScript 2015 스타일의 모듈(import와 export)을 사용해야 합니다. 아이템 58을 참고하시길 바랍니다.  

#### 아이템 53-4. 데코레이터  
<br/>

데코레이터는 클래스, 메서드, 속성에 애너테이션(annotation)을 붙이거나 기능을 추가하는 데 사용할 수 있습니다. 예를 들어, 클래스의 메서드가 호출될 때마다 로그를 남기려면 logged 애너테이션을 정의할 수 있습니다.  

```typescript
class Greeter {
	greeting: string;
	constructor(message: string) {
		this.greeting = message;
	}
	@logged
	greet() {
		return "Hello, " + this.greeting;
	}
}

function logged(target: any, name: string, descriptor: PropertyDescriptor) {
	const fn = target[name];
	descriptor.value = function() {
		console.log(`Calling ${name}`);
		return fn.apply(this, argument);
	};
}

console.log(new Greeter('Dave').greet());
```

데코레이터는 처음에 앵귤러 프레임워크를 지원하기 위해 추가되었으며 tsconfig.json에 experimentalDecorators 속성을 설정하고 사용해야 합니다. 현재까지도 표준화가 완료되지 않았기 때문에, 사용 중인 데코레이터가 비표준으로 바뀌거나 호환성이 깨질 가능성이 있습니다. 앵귤러를 사용하거나 애너테이션이 필요한 프레임워크를 사용하고 있는 게 아니라면, 데코레이터가 표준이 되기 전에는 타입스크립트에서 데코레이터를 사용하지 않는 게 좋습니다.  

### 아이템 54. 객체를 순회하는 노하우  
<br/>

골치 아픈 타입 문제 없이, 단지 객체의 키와 값을 순회하고 싶다면 어떻게 해야 할까요? Object.entries를 사용하면 됩니다.  

```typescript
functin foo(abc: ABC) {
	for (const [k, v] of Object.entries(avc)) {
		k // string 타입
		v // any 타입
	}
}
```

Object.entries를 사용한 루프가 직관적이지는 않지만, 복잡한 기교 없이 사용할 수 있습니다.  

Object.entries는 타입스크립트 3.8 기준으로 표준 함수가 아니며, tsconfig.json에 ES2017(ES8) 설정을 추가하여 사용할 수 있습니다.  

한편, 객체를 다룰 때에는 항상 '프로토타입 오염'의 가능성을 염두에 두어야 합니다. for-in 구문을 사용하면, 객체의 정의에 없는 속성이 갑자기 등장할 수 있습니다.  

실제 작업에서는 Object.prototype에 순회 가능한 속성을 절대로 추가하면 안됩니다. for-in 루프에서 k가 string 키를 가지게 된다면 프로토타입 오염의 가능성을 의심해 봐야 합니다.  

객체를 순회하며 키와 값을 얻으려면, (let k: keyof T) 같은 keyof 선언이나 Object.entries를 사용하면 됩니다. keyof 선언은 상수이거나 추가적인 키 없이 정확한 타입을 원하는 경우에 적절합니다. Object.entries는 더욱 일반적으로 쓰이지만, 키와 값의 타입을 다루기 까다롭습니다.  

+ 객체를 순회할 때, 키가 어떤 타입인지 정확히 파악하고 있다면 let k: keyof T와 for-in 루프를 사용합시다. 함수의 매개변수로 쓰이는 객체에는 추가적인 키가 존재할 수 있다는 점을 명심합시다.
+ 객체를 순회하며 키와 값을 얻는 가장 일반적인 방법은 Object.entries를 사용하는 것입니다.  

### 아이템 55. DOM 계층 구조 이해하기  
<br/>

타입스크립에서는 DOM 엘리먼트의 계층 구조를 파악하기 용이합니다. Element와 EventTarget에 달려 있는 Node의 구체적인 타입을 안다면 타입 오류를 디버깅할 수 있고, 언제 타입 단언을 사용해야 할지 알 수 있습니다. 그리고 대다수의 브라우저 API가 DOM을 기반으로 하기 때문에, 리액트나 d3 같은 프레임워크도 DOM이 관련되어 있습니다.  

계층 구조별로 타입을 좀 더 자세히 알아보겠습니다.  

첫 번째, EventTarget은 DOM 타입 중 가장 추상화된 타입입니다. 이벤트 리스너를 추가하거나 제거하고, 이벤트를 보내는 것밖에 할 수 없습니다.  

일반적으로 타입 단언문은 지양해야 하지만(아이템 9), DOM 관련해서는 타입스크립트보다 우리가 더 정확히 알고 있는 경우이므로 단언문을 사용해도 좋습니다.  

strictNullChecks가 설정된 상태라면, document.getElementById가 null인 경우를 체크해야 합니다. 실제 코드에서 document.getElementById가 null일 가능성이 있다면 if 분기문을 추가해야 합니다.  

Event는 가장 추상화된 이벤트입니다. 더 구체적인 타입들은 다음과 같습니다.  

+ UIEvent: 모든 종류의 사용자 인터페이스 이벤트
+ MouseEvent: 클릭처럼 마우스로부터 발생되는 이벤트
+ TouchEvent: 모바일 기기의 터치 이벤트
+ WheelEvent: 스크롤 휠을 돌려서 발생되는 이벤트
+ KeyboardEvent: 키 누름 이벤트  

+ 자바스크립트를 사용할 때는 신경 쓰지 않았겠지만, DOM에는 타입 계층 구조가 있습니다. DOM 타입은 타입스크립트에서 중요한 정보이며, 브라우저 관련 프로젝트에서 타입스크립트를 사용할 때 유용합니다.
+ Node, Element, HTMLElement, EventTarget 간의 차이점, 그리고 Event와 MouseEvent의 차이점을 알아야 합니다.
+ DOM의 엘리먼트와 이벤트에는 충분히 구체적인 타입 정보를 사용하거나, 타입스크립트가 추론할 수 있도록 문맥 정보를 활용해야 합니다.  

### 아이템 56. 정보를 감추는 목적으로 private 사용하지 않기  
<br/>

자바스크립트는 클래스에 비공개 속성을 만들 수 없습니다. 많은 이가 비공개 속성임을 나타내기 위해 언더스코어(_)를 접두사로 붙이던 것이 관례로 인정될 뿐이었습니다.  

그러나 속성에 언더스코어를 붙이는 것은 단순히 비공개라고 표시한 것뿐입니다. 따라서 일반적인 속성과 동일하게 클래스 외부로 공개되어 있다는 점을 주의해야 합니다.  

타입스크립트에는 public, protected, private 접근 제어자를 사용해서 공개 규칙을 강제할 수 있는 것으로 오해할 수 있습니다.  

그러나 public, protected, private 같은 접근 제어자는 타입스크립트 키워드이기 때문에 컴파일 후에는 제거됩니다(아이템 3).  

타입스크립트의 접근 제어자들은 단지 컴파일 시점에만 오류를 표시해 줄 뿐이며, 언더스코어 관례와 마찬가지로 런타임에는 아무런 효력이 없습니다. 심지어 단언문을 사용하면 타입스크립트 상태에서도 private 속성에 접근할 수 있습니다.  

즉, 정보를 감추기 위해 private을 사용하면 안 됩니다.  

자바스크립트에서 정보를 숨기기 위해 가장 효과적인 방법은 클로저(closure)를 사용하는 것입니다.  

일반적인 객체지향 언어에서는 동일 클래스의 개별 인스턴스낄 private 속성 접근이 가능합니다(클래스 단위 비공개). 그러나 클로저 방식은 동일 클래스와 개별 인스턴스 간에 속성 접근이 불가능(인스턴스 단위 비공개)하기 때문에 불편합니다.  

또 하나의 선택지로, 현재 표준화가 진행 중인 비공개 필드 기능을 사용할 수도 있습니다. 비공개 필드 기능은 접두사로 #를 붙여서 타입 체크의 런타임 모두에서 비공개로 만드는 역할을 합니다.  

비공개 필드를 지원하지 않는 자바스크립트 버전으로 컴파일하게 되면, WrapMap을 사용한 구현을 대체됩니다. 어쨋든 구현 방식과 무관하게 데이터는 동일하게 비공개입니다. 2021년 기준으로 비공개 필드는 자바스크립트 표준화 3단계이고, 타입스크립트에서 사용 가능합니다.  

비공개 필드는 2020년 2월 20일에 릴리즈된 타입스크립트 3.8부터 지원합니다.  

만약 설계 관점의 캡슐화가 아닌 '보안'에 대해 걱정하고 있다면, 내장된 프로토타입과 함수에 대한 변조 같은 문제를 알고 있어야 합니다.  

+ public, protected, private 접근 제어자는 타입 시스템에서만 강제될 뿐입니다. 런타임에는 소용이 없으며 단언문을 통해 우회할 수 있습니다. 접근 제어자로 데이터를 감추려고 해서는 안 됩니다.
+ 확실히 데이터를 감추가 싶다면 클로저를 사용해야 합니다.  

### 아이템 57. 소스맵을 사용하여 타입스크립트 디버깅하기  
<br/>

타입스크립트 코드를 실행한다는 것은, 엄밀힐 말하자면 타입스크립트 컴파일러가 생성한 자바스크립트 코드를 실행한다는 것입니다. 사실 컴파일러뿐 아니라 압축기(minifier)나 전처리기(preprocessor)처럼, 기존 코드를 다른 형태의 코드로 변환하는 도구들에도 모두 해당됩니다. 이러한 변환 과정들이 투명하고 직관적이라면 이상적일 것입니다. 자바스크립트 코드를 살펴볼 필요 없이 마치 타입스크립트 모드가 직접 실행되는 것처럼 느겨진다면 말입니다. 하지만 현실은 그렇지 못합니다.  

여러분은 디버깅이 필요한 시점에 비로서 타입스크립트가 직접 실행되는 것이 아니라는 사실을 깨닫게 될 겁니다. 디버거는 런타임에 동작하며, 현재 동작하는 코드가 어떤 과정을 거쳐서 만들어진 것인지 알지 못합니다. 디버깅을 하면 보게 되는 전처리기, 컴파일러, 압축기를 거친 자바스크립트 코드일 겁니다. 이렇게 변환된 자바스크립트 코드는 복잡해 디버깅하기 매우 어렵습니다.  

디버깅 문제를 해결하기 위해 브라우저 제조사들은 서로 협력하여 소스맵(source map)이라는 해결책을 내놓았습니다. 소스맵은 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑합니다. 대부분의 브라우저와 많은 IDE가 소스맵을 지원합니다.  

오래된 브라우저에서 async와 await를 지원하기 위해, 타입스크립트는 이벤트 핸들러를 상태 머신(state machine)으로 재작성합니다. 재작성된 코드는 원본 코드와 동일하게 동작하지만, 코드의 형태는 매우 다른 모습을 띠게 됩니다.  

코드가 복잡하게 변환된다면 소스맵이 필요합니다. 타입스크립트가 소스맵을 생성할 수 있도록 tsconfig.json에서 sourceMap 옵션을 설정해보겠습니다.  

이제 컴파일을 실행하면 각 .ts 파일에 대해서 .js와 .js.map 두 개의 파일을 생성합니다. .js.map 파일이 바로 소스맵입니다.  

소스맵이 .js 파일과 같이 있으면, 브라우저의 디버기에서 새로운 index.ts 파일이 나타납니다. 이제 원하는 대로 브레이크포인트를 설정할 수 있고 변수를 조사할 수 있습니다.  

소스맵에 대해 알아야 할 몇 가지 사항을 알아보고 이 아이템을 마무리하겠습니다.  

+ 타입스크립트와 함께 번들러(bundler)나 압축기(minifier)를 사용하고 있다면, 번들러나 압축기가 각자의 소스맵을 생성하게 됩니다. 이상적인 디버깅 환경이 되려면 생성된 자바스크립트가 아닌 원본 타입스크립트 소스로 매핑되도록 해야 합니다. 번들러가 기본적으로 타입스크립트를 지원한다면 별도 설정 없이 잘 동작해야 합니다. 그렇지 않다면 번들러가 소스맵을 인식할 수 있도록 추가적인 설정이 필요합니다.
+ 상용 환경에 소스맵이 유출되고 있는지 확인해야 합니다. 디버거를 열지 않는 이상 소스맵이 로드되지 않으므로, 실제 사용자에게 성능 저하는 발생하지 않습니다. 그러나 소스맵에 원본 코드의 인라인 복사본이 포함되어 있다면 공개해서는 안 될 내용이 들어 있을 수 있습니다. 저질 주석이나 내부 버그 추적을 위한 URL을 공개할 필요는 없습니다.  

Node.js 프로그램의 디버깅에도 소스맵을 사용할 수 있습니다. 보통 편집기가 자동 인식하거나 NodeJS 프로세스를 브라우저 디버거와 연결하면 됩니다.  

타입 체커가 코드를 실행하기 전에 많은 오류를 잡을 수 있지만, 디버거를 대체할 수는 없습니다. 소스맵을 사용해서 제대로 된 타입스크립트 디버깅 환경을 구축하기 바랍니다.  

+ 원본 코드가 아닌 변환된 자바스크립트 코드를 디버깅하지 맙시다. 소스맵을 사용해서 런타임에 타입스크립트 코드를 디버깅합시다.
+ 소스맵이 최종적으로 변환된 코드에 완전히 매핑되었는지 확인합시다.
+ 소스맵에 원본 코드가 그대로 포함되도록 설정되어 있을 수도 있습니다. 공개되지 않도록 설정을 확인합시다.  

### 아이템 58. 모던 자바스크립트로 작성하기  
<br/>

타입스크립트는 타입 체크 기능 외에, 타입스크립트 코드를 특정 버전의 자바스크립트로 컴파일하는 기능도 가지고 있습니다. 심지어 1999년에 나온 ES3 버전의 자바스크립트 코드로 컴파일할 수도 있습니다. 즉, 타입스크립트 컴파일러를 자바스크립트 '트랜스파일러(transpiler)'로 사용할 수 있습니다. 타입스크립트는 자바스크립트의 상위집합이기 때문에, 최신 버전의 자바스크립트 코드를 옛날 버전의 자바스크립트 코드로 변환할 수 있습니다.  

옛날 버전의 자바스크립트 코드를 타입스크립트 컴파일러에게 동작하게 만들면 이후로는 최신 버전의 자바스크립트 기능을 코드에 추가해도 문제가 없습니다. 옛날 버전의 자바스크립트 코드를 최신 버전의 자바스크립트로 바꾸는 작업은 타입스크립트로 전환하는 작업의 일부로 볼 수 있습니다. 따라서 마이그레이션을 어디서부터 시작해야 할지 몰라 막막하다면 옛날 버전의 자바스크립트 코드를 최신 버전의 자바스크립트로 바꾸는 작업부터 시작해 보기 바랍니다. 타입스크립트는 자바스크립트와 상위집합이기 때문에, 코드를 최신 버전으로 바구다 보면 타입스크립트의 일부를 저절로 익힐 수 있게 됩니다.  

+ 타입스크립트 개발 환경은 모던 자바스크립트도 실행할 수 있으므로 모던 자바스크립트의 최신 기능들을 적극적으로 사용하길 바랍니다. 코드 품질을 향상시킬 수 있고, 타입스크립트의 타입 추론도 더 나아집니다.
+ 타입스크립트 개발 환경에서는 컴파일러와 언어 서비스를 통해 클래스, 구조 분해, async/await 같은 기능을 쉽게 배울 수 있습니다.
+ 'use strict'는 타입스크립트 컴파일러 수준에서 사용되므로 코드에서 제거해야 합니다.
+ TC39의 깃헙 저장소와 타입스크립트의 릴리스 노트를 통해 최신 기능을 확인할 수 있습니다.  

#### 아이템 58-1. 연관 배열에 객체 대신 Map과 Set 사용하기  
<br/>

#### 아이템 58-2. 타입스크립트에 use strict 넣지 않기  
<br/>

타입스크립트에서 수행되는 안전성 검사(sanity check)가 엄격 모드보다 훨씬 더 엄격한 체크를 하기 때문에, 타입스크립트 코드에서 'use strict'는 무의미합니다.  

실제로는 타입스크립트 컴파일러가 생성하는 자바스크립트 코드에서 'use strict'가 추가됩니다. alwaysStrict 또는 strict 컴파일러 옵션을 설정하면, 타입스크립트는 엄격 모드로 코드를 파싱하고 생성되는 자바스크립트에 'use strict'를 추가합니다. 즉, 타입스크립트 코드에 'use strict'를 쓰지 않고 대신 alwaysStrict 설정을 사용해야 합니다.  

### 아이템 59. 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기  
<br/>

본격적으로 타입스크립트로 전환하기에(아이템 60) 앞서, @ts-check 지시자를 사용하면 타입스크립트 전환시에 어떤 문제가 발생하는지 미리 시험해 볼 수 있습니다. @ts-check 지시자를 사용하여 타입 체커가 파일을 분석하고, 발견된 오류를 보고하도록 지시합니다. 그러나 @ts-check 지시자는 매우 느슨한 수준으로 타입 체크를 수행하는데, 심지어 noImplicitAny 설정을 해제한 것보다 헐거운 체크를 수행한다는 점을 주의해야 합니다(아이템 2).  

타입스크립트 언어 서비스는 타입을 추론해서 JSDoc을 자동으로 생성해 줍니다.  

자동 생성 기능은 타입 정보를 빠르게 추가할 수 있기 때문에 유용하지만, 잘 동작하지 않는 경우도 있습니다.  

자바스크립트 환경에서도 @ts-check 지시자와 JSDoc 주석이라면 타입스크립트와 비슷한 경험으로 작업이 가능합니다. 특별한 작업이 필요 없기 때문에 점진적 마이그레이션 과정 중에 유용하지만, @ts-check 지시자와 JSDoc 주석을 너무 장기간 사용하는 것은 좋지 않습니다. 주석이 코드 분량을 늘려서 로직을 해석하는 데 방해가 될 수 있기 때문입니다. 타입스크립트는 .ts 파일에서 가장 잘 동작하며, 마이크레이션의 궁극적인 목표는 자바스크립트에 JSDoc 주석이 있는 형태가 아니라 모든 코드가 타입스크립트 기반으로 전환되는 것임을 잊지 말아야 합니다. 다만, 이미 JSDoc 주석으로 타입 정보가 많이 담겨 있는 프로젝트라면 @ts-check 지시자만 간단히 추가함으로써 기존 코드에 타입 체커를 실험해 볼 수 있고 초기 오류를 빠르게 잡아낼 수 있다는 점을 기억해야 하겠습니다.  

+ 파일 상단에 // @ts-check를 추가하면 자바스크립트에서도 타입 체크를 수행할 수 있습니다.
+ 전역 선언과 서드파티 라이브러리의 타입 선언은 추가하는 방법을 익힙시다.
+ JSDoc 주석을 잘 활용하면 자바스크립트 상태에서도 타입 단언과 타입 추론을 할 수 있습니다.
+ JSDoc 주석은 중간 단계이기 대문에 너무 공들일 필요는 없습니다. 최종 목표는 .ts로 된 타입스크립트 코드임을 명심합시다.  

### 아이템 60. allowJS로 타입스크립트와 자바스크립트 같이 사용하기  
<br/>

소규모 프로젝트는 한꺼번에 타입스크립트로 전환할 수 있습니다. 그러나 대규모 프로젝트는 한꺼번에 작업하는 것이 불가능하므로 점진적으로 전환할 수 있어야 합니다. 그러려면 마이그레이션 기간 중에 자바스크립트와 타입스크립트가 동시에 동작할 수 있도록 해야 합니다.  

타입스크립트와 자바스크립트가 공존하는 방법의 핵심은 allowJs 컴파일러 옵션인데, 타입스크립트 파일과 자바스크립트 파일을 서로 임포트할 수 있게 해 줍니다. 자바스크립트 파일은 특별히 건드릴 것이 없습니다. @ts-check(아이템 59) 지시자를 추가하기 전까지는 문법 오류 이외에 다른 오류가 발생하지 않습니다. '타입스크립트는 자바스크립트의 상위집합이다'라는 명세를 떠올려 보시면 쉽게 이해할 수 있습니다.  

타입 체크와 관련이 없지만, 기존 빌드 과정에 타입스크립트 컴파일러를 추가하기 위해서 allowJs 옵션이 필요합니다. 또한 모듈 단위로 타입스크립트로 전환(아이템 61)하는 과정에서 테스트를 수행해야 하기 때문에 allowJs 옵션이 필요합니다.  

번들러에 타입스크립트가 통합되어 있거나, 플러그인 방식으로 통합이 가능하다면 allowJs를 간단히 적용할 수 있습니다. 예를 들어, npm install --save-dev tsify를 실행하고 browserify를 사용하여 플러그인으로 추가해 보겠습니다.  

```shell
browserify index.ts -p [ tsify --allowJs ] > bundle.js
```

대부분의 유닛 테스트 도구에는 동일한 역할을 하는 옵션이 있습니다. 예를 들어, jest를 사용할 대 ts-jest를 설치하고 jest.config.js에 전달할 타입스크립트 소스를 지정합니다.  

```javascript
module.exports = {
	transform: {
		'^.+\\.tsx?$': 'ts-jest',
	},
}
```

만약, 프레임워크 없이 빌드 체인을 직접 구성했다면 복잡한 작업이 필요할 것입니다. 한 가지 방책으로 outDir 옵션을 사용할 수 있습니다. outDir 옵션을 사용하면 타입스크립트가 outDird에 지정된 디렉터리에 소스 디렉터리와 비슷한 구조로 자바스크립트 코드를 생성하게 되고, outDir로 지정된 디렉터리를 대상으로 기존 빌드 체인을 실행하면 됩니다. 참고로 기존 자바스크립트 코드에 특별한 규칙이 있었다면, 타입스크립트가 생성한 코드가 기존 자바스크립트 코드의 규칙을 따르도록 출력 옵션을 조정해야 할 수도 있습니다(예를 들어 target과 module 옵션).  

타입스크립트로 마이그레이션하는 동시에 빌드와 테스트가 동작하게 하는 것이 힘들기는 하지만, 제대로 된 점진적 마이그레이션을 시작하기 위해 반드시 필요합니다.  

+ 점진적 마이그레이션을 위해 자바스크립트와 타입스크립트를 동시에 사용할 수 있게 allowJs 컴파일러 옵션을 사용합시다.
+ 대규모 마이그레이션 작업을 시작하기 전에, 테스트와 빌드 체인에 타입스크립트를 적용해야 합니다.  

### 아이템 61. 의존성 관계에 따라 모듈 단위로 전환하기  
<br/>

점진적 마이그레이션을 할 때는 모듈 단위로 각개격파하는 것이 이상적입니다. 그런데 한 모듈을 골라서 타입 정보를 추가하면, 해당 모듈이 의존(임포트)하는 모듈에서 비롯되는 타입 오류가 발생하게 됩니다. 의존성과 관련된 오류없이 작업하려면, 다른 모듈에 의존하지 않는 최하단 모듈부터 작업을 시작해서 의존성의 최상단에 있는 모듈을 마지막으로 완성해야 합니다.  

프로젝트 내에 존재하는 모듈은 서드파티 라이브러리에 의존하지만 서드파티 라이브러리는 해당 모듈에 의존하지 않기 때문에, 서드파티 라이브러리 타입 정보를 가장 먼저 해결해야 합니다. 일반적으로 @types 모듈을 설치하면 됩니다.  

외부 API를 호출하는 경우도 있기 때문에 외부 API의 타입 정보도 추가해야 합니다. 서드파티 라이브러리와 마찬가지로, 프로젝트 내의 모듈은 API에 의존하지만 API는 해당 모듈에 의존하지 않기 때문에 먼저 해결하는 것이 좋습니다. 외부 API의 타입 정보는 특별한 문맥이 없기 때문에 타입스크립트가 추론하기 어렵습니다. 그러므로 API에 대한 사양을 기반으로 타입 정보를 생성해야 합니다(아이템 35).  

모듈 단위로 마이그레이션을 시작하기 전에, 모듈 간의 의존성 관계를 시각화해 보면 많은 도움이 됩니다.  

대부분의 프로젝트에서 의존성의 최하단에 유틸리티 종류의 모듈이 위치하는 패턴을 발견할 수 있으며 일반적인 현상입니다.  

마이그레이션할 때는 타입 정보 추가만 하고, 리팩터링을 해서는 안 됩니다. 오래된 프로젝트일수록 개선이 필요한 부분을 자주 마주치겠지만, 당장의 목표는 개선이 아니라 타입스크립트로 전환하는 것임을 명심해야 합니다. 개선이 필요한 부분을 찾게 된다면 나중에 리팩터링할 수 있도록 목록을 만들어 두면 됩니다.  

+ 마이그레이션의 첫 단계는, 서드파티 모듈과 외부 API 호출에 대한 @types를 추가하는 것입니다.
+ 의존성 관계도의 아래에서부터 위로 올라가며 마이그레이션을 하면 됩니다. 첫 번째 모듈은 보통 유틸리티 모듈입니다. 의존성 관계도를 시각화하여 진행 과정을 추적하는 것이 좋습니다.
+ 이상한 설계를 발견하더라도 리팩터링을 하면 안됩니다. 마이그레이션 작업은 타입스크립트 전환에 집중해야 하며, 나중의 리팩터링을 위해 목록을 만들어 두는 것이 좋습니다.
+ 타입스크립트로 전환하며 발견하게 되는 일반적인 오류들을 놓치지 않아야 합니다. 타입 정보를 유지하기 위해 필요에 따라 JSDoc 주석을 활용해야 할 수도 있습니다.  

#### 아이템 61-1. 선언되지 않은 클래스 멤버  
<br/>

자바스크립트는 클래스 멤버 변수를 선언할 필요가 없지만, 타입스크립트에서는 명시적으로 선언해야 합니다. 멤버 변수를 선언하지 않은 클래스가 있는 .js파일을 .ts로 바꾸면, 참조하는 속성마다 오류가 발생합니다.  

자바스크립트 코드를 타입스크립트로 전환하다 보면, 잘못된 설계를 발견하는 효과가 있습니다. 잘못된 설계를 발견했을 때, 잘못된 설계 그대로 타입스크립트로 전환하는 것은 납득하기 어려운 일입니다. 그러나 다시 한번 언급하지만 리팩터링을 하면 안 됩니다. 개선할 부분을 기록해 두고, 리팩터링은 타입스크립트 전환 작업이 완료된 후에 생각해야 합니다.  

### 아이템 62. 마이그레이션의 완성을 위해 noImplicitAny 설정하기  
<br/>

처음에는 noImplicitAny를 로컬에만 설정하고 작업하는 것이 좋습니다. 왜냐하면 원격에서는 설정에 변화가 없기 때문에 빌드가 실패하지 않기 때문입니다. 로컬에서만 오류로 인식되기 때문에, 수정된 부분만 커밋할 수 있어서 점진적 마이그레이션이 가능합니다. 한편, 타입 체커가 발생하는 오류의 개수는 noImplicitAny와 관련된 작업의 진척도를 나타내는 지표로 활용할 수 있습니다.  

타입 체크의 강도를 높이는 설정에는 여러 가지가 있습니다. noImplicitAny는 상당히 엄격한 설정이며, strictNullChecks 같은 설정을 적용하지 않더라도 대부분의 타입 체크를 적용한 것으로 볼 수 있습니다. 그리고 최종적으로 가장 강력한 설정은 "strict": true입니다. 타입 체크의 강도는 팀 내의 모든 사람이 타입스크립트에 익숙해진 다음에 조금씩 높이는 것이 좋습니다.  

+ noImplicitAny 설정을 활성화하여 마이그레이션의 마지막 단계를 진행해야 합니다. noImplicitAny 설정이 없다면 타입 선언과 관련된 실제 오류가 드러나지 않습니다.
+ noImplicitAny를 전면 적용하기 전에 로컬에서부터 타입 오류를 점진적으로 수정해야 합니다. 엄격한 타입 체크를 적용하기 전에 팀원들이 타입스크립트에 익숙해질 수 있도록 시간을 줍시다.