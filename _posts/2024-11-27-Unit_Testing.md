---
title: Unit Testing
categories:
- Test
feature_text: |
  ## Unit Testing
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---
<style>
	thead td { text-align: center; }
	td { border: 1px solid #444444; }
	.align-center { text-align: center; }
</style>


### 1. 단위 테스트의 목표
<br/>

#### 1.1. 단위 테스트 현황
<br/>

##### 1.1.1. 기업용 애플리케이션이란?
<br/>

기업용 애플리케이션은 조직 내부 프로세스르르 자동화하거나 지원하기 위한 응용프로그램이다. 다양한 형태이지만, 일반적으로 다음과 같은 특성이 있다.  

+ 높은 비즈니스 복잡도
+ 긴 프로젝트 수명
+ 중간 크기의 데이터
+ 낮은 수준이나 중간 수준 정도의 성능 요구  

#### 1.2. 단위 테스트의 목표  
<br/>

흔히 단위 테스트 활동이 더 나은 설계로 이어진다고 한다. 이는 사실이다. 코드베이스(code base)에 대해 단위 테스트 작성이 필요하면 일반적으로 더 나은 설걔로 이어진다. 하지만 단위 테스트의 주목표는 아니다. 더 나은 설계는 단지 좋은 부수 효과일 뿐이다.  

+ 단위 테스트와 코드 설계의 관계  
코드 조각을 단위 테스트하는 것은 훌륭한 리트머스 시험이지만, 한 방향으로만 작동한다. 이는 괜찮은 부정지표다. 즉, 비교적 높은 정확도로 저품질 코드를 가려낸다. 코드를 단위 테스트하기 어렵다면 코드 개선이 반드시 필요하다는 것을 의미한다. 보통 강결합(tight coupling)에서 저품질이 나타나는데, 여기서 강결합은 제품 코드가 서로 충분히 분리되지 않아서 따로 테스트하기 어려움을 뜻한다. 안타깝게도 코드 조각을 단위 테스트할 수 있다는 것은 좋지 않은 긍정 지표다. 코드베이스를 쉽게 단위 테스트할 수 있다고 해도 반드시 코드 품질이 좋은 것을 의미하지는 않는다. 낮은 결합도를 보여도 프로젝트는 '대참사'가 될 수 있다.  

+ 소프트웨어 엔트로피(software entropy)  
개발 속도가 빠르게 감소하는 현상으로 품질을 떨어뜨리는 코드 형태로 나타나고 코드베이스에서 무언가를 변경할 때마다 혹은 지속적인 정리와 리팩터링 등과 같은 적절한 관리를 하지 않고 방치하면 증가  

+ 회귀(regression)  
특정 사건(일반적으로 코드 수정) 후에 기능이 의도한 대로 작동하지 않는 경우  

##### 1.2.1. 좋은 테스트와 좋지 않은 테스트를 가르는 요인
<br/>

모든 테스트를 작성할 필요는 없다. 일부 테스트는 아주 중요하고 소프트웨어 품질에 매우 많은 기여를 한다. 그 밖에 다른 테스트는 그렇지 않다. 잘못된 경고가 발생하고, 회귀 오류를 알아내는 데 도움이 되지 않으며, 유지 보수가 어렵고 느리다. 프로젝트에 도움이 되는지 여부를 명확하게 파악하지 않고 단위 테스트를 작성하는 데만 빠져들기 쉽다.  

+ 기반 코드를 리팩터링할 때 테스트도 리팩터링하라.
+ 각 코드 변경 시 테스트를 실행하라.
+ 테스트가 잘못된 경고를 발생시킬 경우 처리하라.
+ 기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자하라.  

높은 유지 보수 비용으로 인해 순가치가 0에 가깝거나 심지어 0보다 작은 테스트를 만들기 쉽다. 지속 가능한 프로젝트 성장을 위해서는 고품질 테스트에만 집중해야 한다. 고품질 테스트만이 테스트 스위트에 남을 만한 테스트 유형이다.  

+ 제품 코드 대 테스트 코드  
사람들은 종종 제품 코드와 테스트 코드가 다르다고 생각한다. 테스트는 제품 코드에 추가된 것으로 간주되며 소유 비용이 없다. 또한 사람들은 종종 테스트가 많으면 많을수록 좋다고 생각한다. 하지만 그렇지 않다. 코드는 자산이 아니라 책임이다. 코드가 더 많아질수록, 소프트웨어 내의 잠재적인 버그에 노출되는 표면적이 더 넓어지고 프로젝트 유지비가 증가한다. 따라서 가능한 한 적은 코드로 문제를 해결하는 것이 좋다. 테스트도 역시 코드다. 특정 문제를 해결하는 것, 즉 애플리케이션의 정확성을 보장하는 것을 목표로 하는 코드베이스의 일부로 봐야 한다. 다른 코드와 마찬가지로 단위 테스트도 버그에 취약하고 유지보수가 필요하다.  

#### 1.3. 테스트 스위트 품질 측정을 위한 커버리지 지표  
<br/>

커버리지 지표는 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸다.  

커버리지 지표는 각기 다른 유형이 있으며, 테스트 스위트의 품질을 평가하는 데 자주 사용된다. 일반적으로 커버리지 숫자가 높을수록 더 좋다.  

안타깝게도 그렇게 간단하지만은 않다. 커버러지 지표는 중요한 피드백을 주더라도 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다. 코드를 단위 테스트하는 것과 같은 상황이다. 즉, 커버리지 지표는 괜찮은 부정 지표이지만 좋지 않은 긍정 지표다.  

코드 커버리지가 너무 적을 때는(에를 들면, 10%) 테스트가 충분치 않다는 좋은 증거다. 그러나 반대의 경우는 그렇지 못하다. 100% 커버리지라고 해서 반드시 양질의 테스트 스위트라고 보장하지는 않는다. 높은 커버리지의 테스트 스위트도 품질이 떨어질 수 있다.  

##### 1.3.1. 코드 커버리지 지표에 대한 이해  
<br/>

우선 가장 많이 사용되는 커버리지 지표로 코드 커버리지(code coverage)가 있으며, 테스트 커버리지(test converage)로도 알려져 있다.  

코드 커버리지(테스트 커버리지) = 제품 코드 라인 수 / 전체 라인 수  

##### 1.3.2. 분기 커버리지 지표에 대한 이해  
<br/>

+ 분기 커버리지 지표  
원시 코드 라인 수를 사용하는 대신 if 문과 switch 문과 같은 제어 구조에 중점을 둔다.  

분기 커버리지 = 통과 분기 / 전체 분기 수  

##### 1.3.3. 커버리지 지표에 관한 문제점
<br/>

분기 커버리지로 코드 커버리지보다 더 나은 결과를 얻을 수 있지만, 테스트 스위트의 품질을 결정하는 데 어떤 커버리지 지표도 의존할 수 없는 이유는 다음과 같다.  

###### 1.3.3.1. 가능한 모든 결과를 검증한다고 보장할 수 없음
<br/>

단지 코드 경로를 통과하는 것이 아니라 실제로 테스트하려면, 단위 테스트에는 반드시 적절한 검증이 있어야 한다. 다시 말해, 테스트 대상 시스템이 낸 결과가 정확히 예상하는 결과인지 확인해야 한다. 더구나 결과가 여러 개 있을 수 있다. 따라서 커버리지 지표가 의미가 있으려면, 모든 측정 지표를 검증해야 한다.  

+ 외부 라이브러리의 코드 경로를 고려할 수 있는 커버지지 지표는 없다.  

```cs
public static bool WasLastStringLong { get; private set; }

public static bool IsStringLong(string input)
{
	bool result = input.Length > 5;
	WasLastStringLong = result;
	return result;
}

public void Test()
{
	bool result = IsStringLong("abc");
	Assert.Equal(false, result);
}
```

IsStringLong 메서드에는 이제 값을 반환하는 명시적인 결과와 속성에 새로운 값을 쓰는 암묵적인 결과가 있다. 그리고 두 번째 암묵적인 결과를 검증하지 않더라도 커비리지 지표는 100% 코드 커버리지와 50% 분기 커버리지의 동일한 결과를 보여준다. 보다시피 커버리지 지표는 기반 코드를 테스트했다고 보장할 수 없으며 일부 실행된 것만 보장한다.  

이렇게 결과를 부분적으로 테스트한 것보다 더 극단적인 상황은 검증이 전혀 없는 테스트의 경우다. 다음은 검증이 없는 테스트를 보여주는 예제다.  

```cs
public void Test()
{
	bool result = IsStringLong("abc");
	bool result2 = IsStringLong("abcdef");
}
```

이 테스트에서는 코드 커버리지와 분기 커버리지가 둘 다 100%를 나타내고 있다. 그러나 아무것도 검증하지 않기 때문에 전혀 쓸모가 없다.  

+ 고된 작업 이야기
검증 없는 테스트의 개념은 어리석은 생각으로 보일 수 있지만, 현장에서 실제로 일어난다. 모든 프로젝트에서 코드 프로젝트에서 코드 커버리지 100%를 엄격히 요구하는 관리자가 담당하는 프로젝트에서는 심각한 제한에 짓눌려 시스템을 속일 방법을 찾기 시작하고 모든 테스트를 try-catch 구문으로 감싸고 검증문을 빼면 테스트는 통과를 보증했기 때문에 테스트는 결과적으로 아무런 가치도 부여하지 않게 되어 생산적인 활동에서 벗어나는 모든 노력과 시간 그리고 테스트를 계속 유지하는 데 필요한 유지비로 인해 프로젝트를 망치된 사례가 있다.  

그러면 테스트 대상 코드에 대해 각각의 결과를 철저히 검증한다고 가정하자. 이렇게 하면 분기 커버리지 지표와 함께 신뢰할 수 있는 구조라고 할 수 있는가? 또 테스트 스위트 품질을 결정하는 데 사용할 수 있는가? 안타깝게도 아니다.  

###### 1.3.3.2. 외부 라이브러리의 코드 경로를 고려할 수 없음
<br/>

두 번째 문제는 모든 커러지 지표가 테스트 대상 시스템이 메서드를 호출할 때 외부 라이브러리가 통과하는 코드 경로를 고려하지 않는다는 것이다.  

```cs
public static int Parse(string input)
{
	return int.Parse(input);
}

public void Test()
{
	int result = Parse("5");
	Assert.Equal(5, result);
}
```

분기 커버리지 지표는 100%로 표시되며, 테스트는 메서드 결과의 모든 구성 요소를 검증한다. 단지 값을 반환하는 한 줄이라 하더라도 단일한 구성 요소이기는 하다. 하지만 이 테스트는 완벽하지 않다. .NET 프레임워크의 int.Parse 메서드가 수행하는 코드 경로는 고려하지 않는다.  

빌트인(built-in) 정수 타입에는 메서드의 입력 매개변수를 변경하면 다른 결과로 이어질 수 있고 테스트로부터 숨어있는 분기가 많다. 다음은 정수로 변환할 수 없는 몇 가지 가능한 인수다.  

+ 널(null) 값
+ 빈 문자열
+ "정수가 아님"
+ 너무 긴 문자열  

수 많은 예외 상황(stage case)에 빠질 수 있지만, 테스트에서 모든 예외 상황을 다루는지 확인할 방법이 없다.  

이는 커버리지 지표가 외부 라이브러리의 코드 경로를 고려해야 한다는 것이 아니라고(고려하면 안 된다.), 해당 지표로는 단위 테스트가 얼마나 좋은지 나쁜지를 판단할 수 없다는 것을 보여준다. 커버리지 지표로 테스트가 철저한지 또는 테스트가 충분한지 알 수는 없다.  

##### 1.3.4. 특정 커버리지 숫자를 목표로 하기  
<br/>

이제 테스트 스위트 품질을 결정하기에 커버리지 지표만으로는 충분치 않다는 거을 알길 바란다. 100%, 90%; 심지어 중간 정도인 70%까지 특정 커버리지 숫자를 목표로 삼기 시작하면 위험 영역으로 이어질 수 있다. 커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안 된다.  

특정 커버리지 숫자를 목표로 하는 것은 단위 테스트의 목표와 반대되는 그릇된 동기 부여가 된다. 사람들은 중요한 것을 테스트하는 데 집중하는 대신 인공적인 목표를 달성하기 위한 방법을 찾기 시작한다. 적절한 단위 테스트는 이미 충분히 어렵다. 커버리지 숫자를 강요하면 개발자들은 테스트 대상에 신경 쓰지 못하고, 결국 적절한 단위 테스트는 더욱 달성하기 어려워진다.  

+ 시스템의 핵심 부분은 커버러지를 높게 두는 것이 좋다. 하지만 이 높은 수준을 요구 사항으로 삼는 것은 좋지 않다. 그 차이는 미미하지만 매우 중요하다.  

다시 말하면, 커버리지 지표는 좋은 부정 지표이지만 나쁜 긍정 지표다. 커버리지 숫자가 낮으면(예: 60% 미만) 문제 징후라 할 수 있다. 코드베이스 테스트되지 않은 코드가 많다는 뜻이다. 그러나 높은 숫자도 별 의미는 없다. 그러므로 코드 커버리지를 측정하는 것은 품질 테스트 스위트로 가는 첫걸음일 뿐이다.  

#### 1.4. 무엇이 성공적인 테스트 스위트를 만드는가?
<br/>

믿을 만한 방법은 스위트 내 각 테스트를 하나씩 따로 평가하는 것뿐이다. 물론 한 번에 모든 것을 평가할 필요는 없다. 꽤 큰 작업이 될 수 있고, 이에 앞서 노력을 상당히 들여야 할 수도 있다. 평가를 하나씩 늘려가며 수행할 수도 있다. 요점은 테스트 스위트가 얼마나 좋은지 자동으로 확인할 수 없다는 것이다. 개인 판단에 맡겨야 한다.  

##### 1.4.1. 개발 주기에 통합돼 있음  
<br/>

자동화된 테스트를 할 수 있는 방법은 끊임없이 하는 것뿐이다. 모든 테스트는 개발 주기에 통합돼야 한다. 이상적으로는 코드가 변경될 때마다 아무리 작은 것이라도 실행해야 한다.  

##### 1.4.2. 코드베이스에서 가장 중요한 부분만을 대상으로 함
<br/>

모든 테스트가 똑같이 작성되지 않은 것처럼 단위 테스트 측면에서 코드베이스의 모든 부분에 똑같이 주목할 필요는 없다. 테스트가 주는 가치는 테스트 구조뿐만 아니라 검증하는 코드에도 있다.  

시스템의 가장 중요한 부분에 단위 테스트 노력을 기울이고, 다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋다. 대부분이 애플리케이션에서 가장 중요한 부분은 비즈니스 로직(도메인 모델)이 있는 부분이다. 비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다.  

다른 모든 부분은 세 가지 범주로 나눌 수 있다.  

+ 인프라 코드가
+ 데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성
+ 모든 것을 하나로 묶는 코드  

그러나 이 중 일부는 단위 테스트를 철저히 해야 할 수도 있다. 예를 들어 인프라 코드에 복잡하고 중요한 알고리즘이 있을 수 있으므로, 테스트를 많이 하는 것이 좋다. 그러나 일반적으로 도메인 모델에 관심을 더 많이 갖는 것이 옳다.  

통합 테스트와 같이 일부 테스트는 도메인 모델을 넘어 코드베이스의 중요하지 않은 부분을 포함해 시스템이 전체적으로 어떻게 작동하는지 확인할 수 있다. 이것도 괜찮다. 그러나 초점은 도메인 모델에 머물러 있어야 한다.  

이 지침을 따르려면 도메인 모델을 코드베이스 중 중요하지 않은 부분과 분리해야 한다. 도메인 모델을 다른 애플리케이션 문제와 분리해야 단위 테스트에 대한 노력을 도메인 모델에만 집중할 수 있다.  

##### 1.4.3. 최소 유지비로 최대 가치를 끌어냄  
<br/>

단위 테스트에서 가장 어려운 부분은 최소 유지비로 최대 가치를 달성하는 것이다.  

테스트를 빌드 시스템에 통합하는 것만으로는 충분하지 않으며, 도메인 모델에 높은 테스트 커버리지를 유지하는 것도 충분하지 않다. 또한 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다.  

+ 가치 있는 테스트(더 나아가, 가치가 낮은 테스트) 식별하기
+ 가치 있는 테스트 작성하기  

이러한 기술은 비슷해 보일지 모르지만, 선천적으로 다르다. 가치가 높은 테스트를 식별하려면 기준틀(frame of reference)이 필요하다. 반면에 가치 있는 테스트를 작성하려면 코드 설계 기술도 알아야 한다. 단위 테스트와 기반 코드는 서로 얽혀 있으므로 코드베이스에 노력을 많이 기울이지 않으면 가치 있는 테스트를 만들 수 없다.  

새로운 테스트를 작성하는 것은 기존 테스트를 시험하는 것보다 더 많은 노력이 드는데, 대부분 아무것도 없는 상태에서 테스트를 작성하지 않고 기반 코드를 고려해야 하기 때문이다.

#### 1.6. 요약  
<br/>

+ 코드는 점점 나빠지는 경향이 있다. 코드베이스에 변경이 생길 때마다 무질서도, 즉 엔트로피가 증가한다. 지속적인 정리와 리팩터링 등과 같은 적절한 관리가 없으면 시스템은 점점 더 복잡해지고 흐트러진다. 테스트로 이러한 경향을 뒤집을 수 있다. 테스트는 안전망 역할을 하며, 대부분의 회귀에 대한 보험을 제공하는 도구라 할 수 있다.

+ 단위 테스트를 작성하는 것이 중요하다. 마찬가지로 좋은 단위 테스트를 작성하는 것도 중요하다. 잘못된 테스트를 가졌거나 테스트 자체가 없는 프로젝트는 모두 똑같이 침체 단계에 있거나 매 릴리스마다 회귀가 많이 생긴다.

+ 단위 테스트의 목표는 소프트웨어 프로젝트가 지속적으로 성장하게 하는 것이다. 좋은 단위 테스트 스위트는 개발 속도를 지키면서 침체 단계에 빠지지 않게 한다. 이러한 테스트 스위트가 있다면 변경 사항이 회귀로 이어지지 않을 것이라고 확신해도 좋다. 이렇게 하면 코드를 리팩터링하거나 새로운 기능을 추가하는 것이 더 쉬워진다.

+ 모든 테스트를 똑같이 작성할 필요는 없다. 각각의 테스트는 비용과 편익 요소가 있으며, 둘 다 신중하게 따져볼 필요가 있다. 테스트 스위트 내에 가치 있는 테스트만 남기고 나머지는 모두 제거하라. 애플리케이션과 테스트 코드는 모두 자산이 아니라 부채다.

+ 단위 테스트 코드 기능은 좋은 리트머스 시험이지만, 한 방향으로만 작동한다. 좋은 부정 지표(단위 테스트를 할 수 없는 코드는 품질이 좋지 않음)이지만 나쁜 긍정 지표(단위 테스트를 할 수 있다고 품질을 보중하지는 않음)이기도 하다.

+ 마찬가지로 커버리지 지표는 좋은 부정 지표이지만 나쁜 긍정 지표다. 커버리지가 낮다는 것은 문제의 징후이지만, 커버리지가 높다고 해서 테스트 스위트의 품질이 높은 것은 아니다.

+ 분기 커버리지로 테스트 스위트의 완전성에 대해 더 나은 인사이트를 얻을 수 있지만, 테스트 스위트가 충분한지는 여전히 알 수 없다. 검증문이 있는지 신경 쓰지 않고, 코드베이스가 사용하는 서드파티 라이브러리의 코드 경로도 다루지 않는다.

+ 특정 커버리지 숫자를 부과하면 동기 부여가 잘못된 것이다. 시스템의 핵심 부분에 커버리지를 높게 갖는 것은 좋지만, 이 높은 수준을 요건으로 삼는 것은 좋지 않다.

+ 성공적인 테스트 스위트는 다음과 같은 특성을 나타낸다.
> 개발 주기 통합돼 있다.
> 코드베이스 중 가장 중요한 부분만을 대상으로 한다.
> 최소한의 유지비로 최대의 가치를 끌어낸다.

+ 단위 테스트의 목표를 달성하기 위한 유일한 방법은 다음과 같다.
> 좋은 테스트와 좋지 않은 테스트를 구별하는 방법을 배운다.
> 테스트를 리팩터링해서 더 가치 있게 만든다.

### 2. 단위 테스트란 무엇인가
<br/>

#### 2.1. '단위 테스트'의 정의
<br/>

단위 테스트는 
+ 작은 코드 조각(단위라고도 함)을 검증하고,
+ 빠르게 수행하고,
+ 격리된 방식으로 자동화된 테스트다.  

##### 2.1.1. 격리 문제에 대한 런던파의 접근
<br/>

코드 조각(단위)을 격리된 방식으로 검증한다는 것은 무엇을 의하는가? 런던파에서는 테스트 대상 시스템을 협력자(collaborator)에게서 격리하는 것을 일컫는다. 즉, 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역(test double)으로 대체해야 한다. 이런 식으로 동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중할 수 있다.  

이 방법은 한 가지 이점은 테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알 수 있다는 것이다. 즉, 확실히 테스트 대상 시스템이 고장 난 것이다. 클래스의 모든 의존성은 테스트 대역으로 대체됐기 때문에 의심할 여지가 없다.  

또 다른 이점은 객체 그래프(object graph, 같은 문제를 해결하는 클래스의 통신망)를 분할할 수 있는 것이다. 모든 클래스가 각각 직접적인 의존성을 갖고 있으며 도 그 의존성이 또 다른 의존성을 갖고 있는 식으로, 그래프가 상당히 복잡해질 수 있다. 클래스는 심지어 순환 의존성이 있을 수도 있는데, 이는 의존성 사슬이 결국 시작된 위치로 돌아오는 것이다.  

의존성을 가진 코드베이스를 테스트하는 것은 테스트 대역 없이는 어렵다. 유일하게 남은 선택은 전체 객체 그래프를 다시 만드는 것이다. 테스트를 하려면 실제 제품에 해당하는 의존성 외에 테스트 목적의 의존성들로 구성해서 대체해야 하는데, 직접 참조하는 의존성을 테스트 목적의 의존성으로 대체하고 해당 의존성들이 다시 테스트 목적의 의존성을 참조하는 식으로 모두 대체하게 되면 결국 이 작업은 객체 그래프를 다시 만든다고 할 수 있다. 하지만 클래스의 수가 너무 많으면 어려운 작업일 수 있다.  

테스트 대역을 사용하면 객체 그래프를 다시 만들지 않아도 된다. 또한 클래스의 직접적인 의존성을 대체할 수 있고, 더 나아가 의존성의 의존성을 다룰 필요도 없다. 그래프를 효과적으로 분해해 단위 테스트에서 준비를 크게 줄일 수 있다.  

또한 단위 테스트 격리에는 작지만 유익한 부가적인 이점이 더 있다. 프로젝트 전반적으로 한 번에 한 클래스만 테스트하라는 지침을 도입하면 전체 단위 테스트 스위트를 간단한 구조로 할 수 있다. 더 이상 코드베이스를 테스트하는 방법을 고민할 필요가 없다. 클래스가 있는가? 클래스에 해당하는 단위 테스트 클래스를 생성하라!  

테스트 대상 클래스를 의존성에서 분리하면 단순한 테스트 스위트 구조(제품 코드의 각 클래스에 대해 테스트 클래스가 하나씩 있는 구조)를 확립하는 데 도움이 된다.  

이제 몇 가지 예를 살펴보자. 고전적인 스타일이 대부분의 사람들에게 더 익숙하기 때문에 먼저 고적적인 스타일로 작성된 샘플 테스트를 살펴본 후 런던 방식을 사용해 다시 작성해볼 것이다.  

온라인 상점을 운영한다고 가정하자. 샘플 애플리케이션에는 고객이 제품을 구매할 수 있다는 간단한 유스케이스(use case)가 하나 있다. 상점에 재고가 충분하면 구매는 성공으로 간주되고, 구매 수량만큼 상점의 제품 수량이 줄어든다. 제품이 충분하지 않으면 구매는 성공하지 못하며 아무 일도 일어나지 않는다.  

다음 예제에는 상점에 재고가 충분히 있을 때만 구매가 성공하는지 검증하는 두 가지 테스트가 있다. 테스트는 고전적인 스타일로 작성됐으며 일반적인 3단 구성인 준비, 실행, 검증 패턴(간단히 AAA(Assert, Act, Assert) 패턴이라고 하며)을 사용한다.  

```cs
[Fact]
public void Purchage_succeeds_when_enough_inventory()
{
	// 준비
	var store = new Store();
	store.AddInventory(Product.Shampoo, 10);
	var customer = new customer();

	// 실행
	bool success = customer.Purchase(store, Product.Shampoo, 5);

	// 검증
	Assert.True(success);
	Assert.Equal(5, store.GetInventory(Product.Shampoo));
}

[Fact]
public void Purchase_fails_when_not_enough_inventory()
{
	// 준비
	var store = new Store();
	store.AddInventory(Product.Shampoo, 10);
	var customer = new Customer();

	// 실행
	bool success = customer.Purchase(store, Product.Shampoo, 15);

	// 검증
	Assert.True(success);
	Assert.Equal(10, store.GetInventory(Product.Shampoo));
}

public enum Product
{
	Shampoo,
	Book
}
```

보다시피 준비 부분은 의존성과 테스트 대상 시스템을 모두 준비하는 부분이다. customer.Purchase() 호출은 실행 단계이며 검증하고자 하는 동작을 수행한다. 검증문(assert statement)은 검증 단계이며, 동작이 예상 결과로 이어지는지 확인한다.  

준비 단계에서는 테스트 대상 시스템(SUT, System Under Test)과 하나의 협력자를 준비한다. 이 경우 고객(Customer)의 SUT에, 상점(Store)이 협력자에 해당한다. 다음 두 가지 이유로 협력자가 필요하다.  

+ 테스트 대상 메서드를 컴파일하려면 customer.Purchase()가 Store 인스턴스를 인수로 필요로 하기 때문에
+ 검증 단계에서 customer.Purchase()의 결과 중 하나로 상점 제품 수량이 감소할 가능성이 있기 때문에  

Product.Shampoo, 숫자 5와 15는 모두 상수다.  

+ 테스트 대상 메서드(MUT, Method Under Test)는 테스트에서 호출한 SUT의 메서드다. MUT와 SUT는 흔히 동의어라 사용하지만, 일반적으로 MUT는 메서드를 가리키는 데 반해 SUT는 클래스 전체를 가리킨다.  

이 코드는 단위 테스트의 고전 스타일 예로, 테스트는 협력자(Store 클래스)를 대체하지 않고 운영용 인스턴스를 사용한다. 고전적인 방식의 자연스러운 결과로, 이제 Customer만이 아니라 Customer와 Store 둘 다 효과적으로 검증한다. 그러나 Customer가 올바르게 작동하더라도 Customer에 영향을 미치는 Store 내부에 버그가 있으면 단위 테스트에 실패할 수 있다. 테스트에서 두 클래스는 서로 격리돼 있지 않다.  

이제 런던 스타일로 예제를 수정해보자. 동일한 테스트에서 Store 인스턴스는 테스트 대역, 구체적으로 목으로 교체해본다.  

예제에서는 목 프레임워크로 Moq(https://github.com/moq/moq4)를 사용하지만, NSubstitute(https://github.com/nsubstitute/NSubstitute)와 같은 다른 대안을 찾을 수 있다. 모든 객체지향 언어는 유사한 프레임워크가 있다. 예를 들어, 자바에는 Mockito나 JMock 또는 EasyMock을 사용할 수 있다.  

+ 목은 테스트 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역이다.  

+ 테스트 대역은 실행과 관련 없이 모든 종류의 가짜 의존성으 설명하는 포괄적인 용어다.
+ 목은 그러한 의존성의 한 종류일 뿐이다.  

```cs
[Fact]
public void Purchage_succeeds_when_enough_inventory()
{
	// 준비
	var storeMock = new Mock<IStore>();
	storeMock.Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
			 .Returns(true);
	var customer = new customer();

	// 실행
	bool success = customer.Purchase(storeMock.Object, Product.Shampoo, 5);

	// 검증
	Assert.True(success);
	storeMock.Verify(x => x.RemoveInventory(Product.Shampoo, 5),
					 Times.Once);
}

[Fact]
public void Purchase_fails_when_not_enough_inventory()
{
	// 준비
	var storeMock = new Mock<IStore>();
	storeMock.Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
			 .Returns(true);
	var customer = new Customer();

	// 실행
	bool success = customer.Purchase(storeMock.Object, Product.Shampoo, 5);

	// 검증
	Assert.False(success);
	storeMock.Verify(x => x.RemoveInventory(Product.Shampoo, 5),
					 Times.Never);
}
```

고전 스타일로 작성된 테스트와 얼마나 다른지 살펴보자. 준비 단계에서 테스트는 Store의 실제 인스턴스를 생성하지 않고 Moq의 내장 클래스인 Mock&lt;T&gt;를 사용해 대체한다.  

또한 샴푸 재고를 추가해 Store 상태를 수정하는 대신 HasEnoughInventory() 메서드 호출에 어떻게 응답하는지 목에 직접 정의한다. Store의 실제 상태와 관계없이 테스트가 요구하는 방식으로 요청에 응답한다. 사실 테스트는 더 이상 Store를 사용하지 않는다. Store 클래스 대신 IStore 인터페이스로 목을 만들어 사용했다.  

검증 단계도 바뀌었고 중요한 차이점이 여기에 있다. 여전히 이전과 같이 customer.Purchase 호출 결과를 확인하지만, 고객이 상점에서 올바르게 했는지 확인하는 방법이 다르다. 이전에는 상점 상태를 검증했다. 지금은 Customer와 Store 간의 상호 작용을 검사한다. 즉, 고객이 상점에서 호출을 올바르게 했는지 확인한다. 고객이 상점으로 호출해야 하는 메서드(x.RemoveInventory)뿐만 아니라 호출 횟수까지 검증할 수 있다. 고객은 구매가 성공하면 이 메서드를 한 번만 호출해야 하고(Times.Once), 구매가 실패하면 절대로 호출하면 안 된다(Times.Never).  

##### 2.1.2. 격리 문제에 대한 고전파의 접근
<br/>

다시 말하면, 런던 스타일은 테스트 대역(목)으로 테스트 대상 코드 조각을 분리해서 격리 요구 사항에 다가간다. 흥미롭게도 이 관점은 무엇이 작은 코드 조각(단위)에 해당하는지에 대한 견해에도 영향을 미친다.  

각각의 모든 클래스를 격리해야 한다면 테스트 대상 코드 조각은 당연히 단일 클래스이거나 해당 클래스 내의 메서드여야 한다. 격리 문제에 접근하는 방식 때문에 이보다 더 클 수가 없다. 때에 따라 한 번에 몇 개의 클래스를 테스트할 수도 있기는 하다. 그러나 일반적으로 한 번에 한 클래스로 테스트하는 지침을 따르려고 노력해야 한다.  

앞에서 언급했듯이 격리 특성을 해석하는 또 다른 방법으로 고전적인 방법이 있다. 고전적인 방법에서 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아니다. 대신 단위 테스트는 서로 격리해서 실행해야 한다. 이렇게 하면 테스트를 어떤 순서(명령이나 순차 등)로든 가장 적합한 방식으로 실행할 수 있으며 서로의 결과에 영향을 미치지 않는다.  

각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 한 번에 테스트해도 괜찮다는 뜻이다. 이를 통해 테스트가 서로 소통하고 실행 컨텍스트에 영향을 줄 수 있다. 데이터베이스, 파일 시스템 등 프로세스 외부 의존성이 이러한 공유 상태의 대표적인 예다.  

예를 들어 어떤 테스트가 준비 단계에서 데이터베이스에서 고객을 생성할 수 있고, 이 테스트가 실행되기 전에 다른 테스트의 준비 단계에서 고객을 삭제할 수도 있다. 이 두 가지 테스트를 병렬로 실행하면 첫 번째 테스트가 실패하는데, 이는 제품 코드가 고장 나서가 아니라 두 번째 테스트의 간섭 때문이다.  

+ 공유 의존성(shared dependency)  
테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성이다. 전형적인 예는 정적 가변 필드(static mutable field)다. 이러한 필드의 변경 사항은 동일한 프로세스 내에서 실행되는 모든 단위 테스트에서 볼 수 있다. 데이터베이스도 전형적인 예가 될 수 있다.  

+ 비공개 의존성(private dependency)  
공유하지 않는 의존성  

+ 프로세스 외부 의존성(out-of-process dependency)  
애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 아직 메모리에 없는 데이터에 대한 프록시(proxy)다. 프로세스 외부 의존성은 대부분 공유 의존성에 해당하지만 모두 그런 것은 아니다. 예를 들어 데이터베이스는 프로세스 외부이면서 공유 의존성이다. 그러나 각 테스트 실행 전에 도커 컨테이너로 데이터베이스를 시작하면 테스트가 더 이상 동일한 인스턴스로 작동하지 않기 때문에 프로세스 외부이면서 공유하지 않는 의존성이 된다. 이러한 데이터베이스 환경에서는 테스트가 데이터를 변경할 수 없으므로 결과에 서로 영향을 미칠 수 있다.  

격리 문제에 대한 이러한 견해는 목과 기타 테스트 대역의 사용에 대한 훨씬 더 평범한 견해를 수반한다. 테스트 대역을 사용할 수 있지만, 보통 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 사용한다.  

단위 테스트를 서로 격리하는 것은 테스트 대상 클래스에서 공유 의존성만 격리하는 것을 의미한다. 비공개 의존성은 그대로 둘 수 있다.  

공유 의존성은 테스트 대상 클래스(단위) 간이 아니라 단위 테스트 간에 공유한다. 그런 의미에서 싱글턴(singleton) 의존성은 각 테스트에서 새 인스턴스를 만들 수 있기만 하면 공유되지 않는다. 제품 코드에는 싱글턴 인스턴스가 단 하나만 있지만, 테스트는 이 패턴을 따르지 않고 재사용하지도 않는다. 따라서 이러한 의존성은 비공개인 것이다.  

예를 들어 설정 클래스(configuration class)는 일반적으로 한 개뿐이며, 모든 제품 코드에서 이 인스턴스를 재사용한다. 그러나 생성자 등을 통해 다른 모든 의존성이 SUT에 주입되면 각 테스트에서 새 인스턴스를 만들 수 있다. 테스트 스위트 전체에서 단일 인스턴스를 유지할 필요는 없다. 그러나 새 파일 시스템이나 데이터베이스를 만들 수는 없으며, 테스트 간에 공유되거나 테스트 대역으로 대체돼야 한다.  

+ 휘발성 의존성(volatile dependency)  
> 개발자 머신에 기본 설치된 환경 외에 런타임 환경의 설정 및 구성을 요구한다. 데이터베이스와 API 서비스가 좋은 예다. 추가 설정이 필요하며 시스템에 기본으로 설치돼 있지 않다.
> 비결정적 동작(nondeterministic behavior)을 포함한다. 예를 들어 난수 생성기 도는 현재 날짜와 시간을 반환하는 클래스 등이 있다. 이런 의존성은 각 호출에 대해 다른 결과를 제공하기 때문에 비결정적이라 한다.  
> 예를 들어 데이터베이스에 대한 의존성은 공유 의존성이자 휘발성 의존성이다. 파일 시스템은 모든 개발자 머신에 설치되고 대부분 결정적으로 작동하므로 휘발성이 아니다. 파일 시스템은 단위 테스트가 실행 컨텍스트를 서로 방해할 수 있는 수단이 될 수 있으므로 공유 의존성이다. 마찬가지로 난수 생성기는 휘발성이지만, 각 테스트에 별도의 인스턴스를 제공할 수 있으므로 공유 의존성이 아니다.  

공유 의존성을 대체하는 또 다른 이유는 테스트 실행 속도를 높이는 데 있다. 공유 의존성은 거의 항상 실행 프로세스 외부에 있는 데 반해, 비공개 의존성은 보통 그 경계를 넘지 않는다. 따라서 데이터베이스나 파일 시스템 등의 공유 의존성에 대한 호출은 비공개 의존성에 대한 호출보다 더 오래 걸린다. 그리고 단위 테스트 두 번째 속성으로 빨리 실행해야 하는 필요성이 있으므로, 이러한 호출을 포함하는 공유 의존성을 가진 테스트는 단위 테스트 영역에서 통합 테스트 영역으로 넘어간다.  

이러한 격리에 대한 대안적 견해는 또한 단위(작은 코드 조각)를 구성하는 것에 대한 다른 견해로 이어진다. 단위가 반드시 클래스에 국한될 필요는 없다. 공유 의존성이 없는 한 여러 클래스를 묶어서 단위 테스트할 수도 있다.  

#### 2.2. 단위 테스트의 런던파와 고전파  
<br/>

보다시피 런던파와 고전파로 나눠진 원인은 격리 특성에 있다. 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보는 반면, 고전파는 단위 테스트끼리 격리하는 것으로 본다.  

종합하면 세 가지 주요 주제에 대해 의견 차이가 있다.  

+ 격리 요구 사항
+ 테스트 대상 코드 조각(단위)의 구성 요소
+ 의존성 격리  

<table>
	<thead>
		<tr>
			<th></th>
			<th>격리 주체</th>
			<th>단위의 크기</th>
			<th>테스트 대역 사용 대상</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>런던파</td>
			<td>단위</td>
			<td>단일 클래스</td>
			<td>불변 의존성 외 모든 의존성</td>
		</tr>
		<tr>
			<td>고전파</td>
			<td>단위 테스트</td>
			<td>단일 클래스 또는 클래스 세트</td>
			<td>공유 의존성</td>
		</tr>
	</tbody>
</table>
<br/><br/>

##### 2.2.1. 고전파와 런던파가 의존성을 다르는 방법
<br/>

테스트 대역을 어디에서나 흔히 사용할 수 있지만, 런던파는 테스트에서 일부 의존성을 그래도 사용할 수 있도록 하고 있다.  

불변 객체는 값 객체(value object) 또는 값(value)이라고 한다. 주요 특징은 각각의 정체성이 없다는 것이다. 즉, 내용에 대해서만 식별된다. 그 결과, 두 객체가 동일한 내용을 갖고 있다면 어떤 객체를 사용하든 상관없다. 즉, 이러한 인스턴스는 서로 바꿔 사용할 수 있다.  

값 객체의 개념은 언어에 구애받지 않고 특정 프로그래밍 언어나 프레임워크가 필요하지 않다.  

결국 비공개 의존성은 변경 가능하거나 불변일 수 있다.  

+ 협력자(collaborator)  
공유하거나 변경 가능한 의존성  

모든 프로세스 외부 의존성이 공유 의존성의 범주에 속하는 것은 아니다. 공유 의존성은 거의 항상 프로세스 외부에 있지만, 그 반대는 그렇지 않다. 프로세스 외부 의존성을 공유하려면 단위 테스트가 서로 통신할 수 있는 수단이 있어야 한다. 의존성 내부 상태를 수정하면 통신이 이뤄진다. 그런 의미에서 프로세스 외부의 불변 의존성은 그런 수단을 제공하지 않는다. 테스트는 내부의 어떤 것도 수정할 수 없기 때문에 서로 실행 컨텍스트에 영향을 줄 수 없다.  

공유 의존성과 프로세스 외부 의존성 간의 관계, 공유이지만 프로세스 외부가 아닌 의존성의 예로, 싱글턴(모든 테스트에서 재사용하는 인스턴스)이나 클래스의 정적 필드 등이 있다. 데이터베이스는 공유이면서 프로세스 외부에 있다. 즉, 주 프로세스 외부에 상주하며 변경이 가능하다. 읽기 전용 API는 프로세스 외부에 있지만 공유되지 않는다, 수정할 수 없고, 이로 인해 서로의 실행 흐름에 영향을 줄 수 없기 때문이다.  

API는 기능을 노출하지 않는 한 공유 의존성이 아니다. 이러한 의존성은 휘발성이고 애플리케이션 경계를 벗어나는 것이 사실이지만, 테스트가 반환하는 데이터에 영향을 미칠 수 없기 때문에 공유가 아니다. 대부분의 경우 테스트 속도를 높이려면 테스트 대역으로 교체해야 한다. 그러나 프로세스 외부 의존성이 충분히 빠르고 연결이 안정적이면 테스트에서 그대로 사용하는 것도 괜찮다.  

실제 프로젝트에서 프로세스 외부가 아닌 공유 의존성은 거의 없다. 의존성이 프로세스 내부에 있으면 각 테스트에서 별도의 인스턴스를 쉽게 공급할 수 있으므로 테스트 간에 공유할 필요가 없다. 마찬가지로 공유되지 않는 프로세스 외부 의존성은 일반적으로 접할 일이 없다. 이러한 의존성 대부분은 변경 가능하며 테스트로 수정될 수 있다.  

#### 2.3. 고전파와 런던파의 비교  
<br/>

고전파는 고품질의 테스트를 만들고 단위 테스트의 궁극적인 목표인 프로젝트의 지속 가능한 성장을 달성하는 데 적합하다. 그 이유는 취약성(fragility)에 있다. 목을 사용하는 테스트는 고전적인 테스트보다 불안정한 경향이 있기 때문이다.  

런던파의 접근 방식은 다음과 같은 이점을 제공한다.  

+ 입자성(granularity)이 좋다. 테스트가 세밀해서(fine-grained) 한 번에 한 클래스만 확인한다.
+ 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체되기 때문에 작성 시 걱정할 필요가 없다.
+ 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다. 클래스의 협력자가 없으면 테스트 대상 클래스 외에 다른 것을 의심할 여지가 없다. 물론 테스트 대상 시스템이 값 객체를 사용하는 상황이 있을 수 있으며, 이 값 객체의 변경으로 인해 테스트가 실패하게 된다. 그러나 테스트 내 다른 의존성을 모두 제거했기 때문에 이러한 경우는 흔하지 않다.  

##### 2.3.1. 한 번에 한 클래스만 테스트하기  
<br/>

테스트는 코드의 단위를 검증해서는 안 된다. 오히려 동작의 단위, 즉 문제 영역에 의미가 있는 것. 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다. 동작 단위를 구현하는 데 클래스가 얼마나 필요한지는 상관없다. 단위는 여러 클래스에 걸쳐 있거나 한 클래스에만 있을 수 있고, 심지어 아주 작은 메서드가 될 수도 있다.  

그래서 좋은 코드 입자성을 목표로 하는 것은 도움이 되지 않는다. 테스트가 단일 동작 단위를 검증하는 한 좋은 테스트다. 이보다 적은 것을 목표로 삼는다면 사실 단위 테스트를 훼손하는 결과를 가져온다. 이 테스트가 무엇을 검증하는지 정확히 이해하기가 더 어려워지기 때문이다. 테스트는 해결하는 데 도움이 되는 문제에 대한 이야기를 들려줘야 하며, 이 이야기는 프로그래머가 아닌 일반 사람들에게 응집도가 높고 의미가 있어서 한다.  

##### 2.3.2. 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
<br/>

실제 협력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다. 특히 테스트 대상 클래스에 의존성이 있고, 이 의존성에 다시 각각의 의존성이 있고, 이렇게 여러 계층에 걸쳐서 계속되는 식으로 의존성 그래프가 복잡하게 있을 때 쉽게 테스트할 수 있다. 테스트 대역을 쓰면 클래스의 직접적인 의존성을 대체해 그래프를 나눌 수 있으며, 이는 단위 테스트에서 준비해야 할 작업량을 크게 줄일 수 있다. 고전파를 따라 테스트 대상 시스템을 설정하려면 (공유 의존성을 제외하고) 전체 객체 그래프를 다시 생성해야 하는데, 작업이 많을 수 있다.  

모두 사실이지만, 이 추리 과정은 잘못된 문제에 초점을 맞추고 있다. 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다. 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다.  

테스트에서 이 문제를 지적한 것은 사실 좋은 일이다. 코드 조각을 단위 테스트하는 능력은 좋은 부정 지표다. 즉, 비교적 높은 정확도로 저품질을 예측한다. 클래스를 단위 테스트하려면 테스트 준비 단걔를 적정선을 넘게 늘려야 해서 이는 틀림없이 문제의 징후가 있다. 목을 사용하는 것은 이 문제를 감추기만 할 뿐, 원인을 해결하지 못한다.  

##### 2.3.3. 버그 위치 정확히 찾아내기
<br/>

런던 스타일 테스트가 있는 시스템에 버그가 생기면, 보통 SUT에 버그가 포함된 테스트만 실패한다. 하지만 고전적인 방식이면, 오작동하는 클래스를 참조하는 클라이언트를 대상으로 하는 테스트도 실패할 수 있다. 즉, 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기하는 파급 효과를 초래한다. 결국 문제의 원인을 찾기가 더 어려워진다. 문제를 파악하고자 테스트를 디버깅하는 데 시간이 걸릴 수 있다.  

우려할 만하지만, 큰 문제는 아니다. 테스트를 정기적으로 (이상적으로는 소스 코드가 변경될 때마다) 실행하면 버그의 원인을 알아낼 수 있다. 즉, 마지막으로 한 수정이 무엇인지 알기 때문에 문제를 찾는 것은 그리 어렵지 않다. 또한 실패한 테스트를 모두 볼 필요는 없다. 하나를 고치면 다른 것들도 자동으로 고쳐진다.  

게다가 테스트 스위트 전체에 걸쳐 계단식으로 실패하는 데 가치가 있다. 버그가 테스트 하나뿐만 아니라 많은 테스트에서 결함으로 이어진다면, 방금 고장 낸 코드 조각이 큰 가치가 있다는 것을 보여준다. 즉, 전체 시스템이 그것에 의존한다. 이는 코드 작업 시 명심해야 할 유용한 정보다.  

##### 2.3.4. 고전파와 런던파 사이의 다른 차이점
<br/>

고전파와 런던파 사이에 남아있는 두 가지 차이점은 다음과 같다.  

+ 테스트 주도 개발(TDD, Test-Driven Development)을 통한 시스템 설계 방식
+ 과도한 명세(over-specification) 문제  

###### 2.3.4.1. 테스트 주도 개발  
<br/>

테스트 주도 개발은 테스트에 의존해 프로젝트 개발을 추진하는 소프트웨어 개발 프로세스다. 이 프로세스는 세 단계로 구성되며, 각 테스트 케이스마다 반복해서 적용한다.  

(1) 추가해야 할 기능과 어떻게 동작해야 하는지를 나타내는 실패 테스트를 작성한다.  
(2) 테스트가 통과할 만큼 충분히 코드를 작성한다. 이 단계에서 코드가 깨끗하거나 명쾌할 필요는 없다.  
(3) 코드를 리팩터링한다. 통과 테스트 보호하에서 코드를 안전하게 정리해 좀 더 읽기 쉽고 유지하기 쉽도록 만들 수 있다.  

런던 스타일의 단위 테스트는 하향식 TDD로 이어지며, 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작한다. 목을 사용해 예상 결과를 달성하고자 시스템이 통신해야 하는 협력자를 지정한다. 그런 다음 모든 클래스를 구현할 때까지 클래스 그래프를 다져나간다. 목은 한 번에 한 클래스에 집중할 수 있기 때문에 이 설계 프로세스를 가능하게 한다. 테스트할 대 SUT의 모든 협력자를 차단해 해당 협력자의 구현을 나중으로 미룰 수 있다.  

고전파는 테스트에서 실제 객체를 다뤄야 하기 때문에 지침을 똑같이 두지 않는다. 대신 일반적으로 상향식으로 한다. 고전적 스타일에서는 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둔다.  

그러나 고전파와 런던파 간의 가장 중요한 차이점은 과도한 명세 문제, 즉 테스트가 SUT의 구현 세부 사항에 결합되는 것이다. 런던 스타일은 고전 스타일보다 테스트가 구현에 더 자주 결합되는 편이다. 이로 인해 런던 스타일과 목을 전반적으로 아무 데나 쓰는 것에 대해 주로 이의가 제기된다.  

#### 2.4. 두 분파의 통합 테스트
<br/>

런던파와 고전파는 통합 테스트의 정의에도 차이가 있다. 격리 문제에 대한 견해에서 차이가 나면서 자연스럽게 다른 의견으로 이어졌다.  

런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다. 고전 스타일로 작성된 대부분의 테스트는 런던파 지지자들에게 통합 테스트로 느껴질 것이다.  

여기에서는 단위 테스트와 통합 테스트의 고전적인 정의를 사용한다. 다시 말하지만, 단위 테스트는 다음과 같은 특징이 있는 자동화된 테스트다.  

+ 작은 코드 조각을 검증하고
+ 빠르게 수행하고
+ 격리된 방식으로 처리한다.  

첫 번째 속성과 세 번째 속성의 의미를 명확히 밝혔으니 고전파의 관점에서 다시 정의해본다. 단위 테스트는  

+ 단일 동작 단위를 검증하고
+ 빠르게 수행하고
+ 다른 테스트와 별도로 처리한다.  

통합 테스트는 이러한 기준 중 하나를 충족하지 않는 테스트다. 예를 들어 공유 의존성(말하자면, 데이터베이스)에 접근하는 테스트는 다른 테스트와 분리해 실행할 수 없다. 어떤 테스트에서 데이터베이스 상태 변경이 생기면 병렬로 실행할 때 동일한 데이터베이스에 의존하는 다른 모든 테스트의 결과가 변경될 것이다. 이런 간섭을 피하려면 추가 조치를 취해야 할 것이다. 특히 이러한 테스트는 순차적으로 실행해서 각 테스트가 공유 의존성과 함께 작동하려고 기다릴 수 있다.  

마찬가지로 프로세스 외부 의존성에 접근하면 테스트가 느려진다. 데이터베이스에 대한 호출은 실행 시간에 수백 밀리초(최대 1초)를 추가한다. 처음에는 밀리초가 미미해 보일 수 있지만, 테스트 스위트가 충분히 커지면 1초가 중요하다.  

이론적으로, 메모리 내 객체로만 작도하는 테스트를 느리게 작성할 수도 있지만, 그렇게 쉽지는 않다. 동일한 메모리 공간에 있는 객체 간 통신은 별도 프로세스 간 통신보다 훨씬 저렴하다. 테스트가 메모리 내 객체 수백 개와 함께 작동하더라도, 데이터베이스 호출보다 빠르게 실행될 것이다.  

마지막으로, 둘 이상의 동작 단위를 검증할 때의 테스트는 통합 테스트다. 이는 종종 테스트 스위트의 실행 속도를 최적화하려는 노력의 결과다. 비슷한 단걔를 따르지만 다른 동작 단위를 검증하는 느린 테스트가 두 개 있을 때, 하나로 합치는 것이 타당할 수 있다. 즉, 비슷한 두 동작을 검증하는 하나의 테스트이지만 세밀한 테스트 두 개보다 빠르게 실행할 수 있다. 원래 이 두 테스트는 이미 (느려서) 통합 테스트였기 때문에 일반적으로 결정적인 특징은 아니다.  

또한 다른 팀이 개발한 모듈이 둘 이상 있을 대 통합 테스트로 어떻게 작동하는지 검증할 수 있다. 이는 또한 여러 동작 단위를 한 번에 검증하는 제3의 테스트 유형에 해당한다. 그러나 다시 말하지만, 이러한 통합은 통상적으로 프로세스 외부 의존성을 필요로 하므로 테스트는 하나뿐만 아니라 세 가지 기준 모두를 충족시키지 못할 것이다.  

통합 테스트는 시스템 전체를 검증해 소프트웨어 품질을 기여하는 데 중요한 역할을 한다.  

##### 2.4.1. 통합 테스트의 일부인 엔드 투 엔드 테스트  
<br/>

+ 통합 테스트  
공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트  

+ 엔드 투 엔드 테스트  
코드가 프로세스 외부 종속과 함께 어떻게 작동하는지 검증하는 테스트로 통합 테스트보다 일반적으로 의존성을 더 많이 포함  

가끔 경계가 흐리지만, 일반적으로 통합 테스트는 프로세스 외부 의존성을 한두 개만 갖고 작동한다. 반면에 엔드 투 엔드 테스트는 프로세스 외부 의존성을 전부 또는 대다수 갖고 작동한다. 따라서 엔드 투 엔드라는 명칭은 모든 외부 애플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것을 의미한다.  

또한 UI(User Interface, 사용자 인터페이스) 테스트, GUI(Graphic User Interface, 그래픽 사용자 인터페이스) 테스트, 기능 테스트(functional test)와 같은 용어도 사용한다. 용어들이 잘 정의돼 있지 않지만, 일반적으로 모두 동의어다.  

애플리케이션이 데이터베이스, 파일 시스템, 결제 게이트웨이라는 세 가지 프로세스 외부 의존성으로 작동한다고 가정하자. 일반적인 통합 테스트는 데이터베이스와 파일 시스템만 포함하고, 결제 게이트웨이는 테스트 대역으로 대체한다. 데이터베이스와 파일 시스템은 완전히 제어할 수 있기 때문에 테스트에서 필요한 상태로 쉽게 가져올 수 있는 반면, 결제 게이트웨이의 제어 권한은 그렇지 않다. 실제 결제 게이트웨이를 사용하면 결제 처리 부서에 연락해서 특수 테스트 계정을 설정해야 할 수도 있다. 또한 과거 테스트 실행에서 남긴 모든 결제 비용을 수동으로 정리하고자 때때로 해당 계정을 확인해야 할 수도 있다.  

엔드 투 엔드 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋다. 또한 개인 개발자 머신이 아닌 빌드 서버에서만 실행할 수도 있다.  

엔드 투 엔드 테스트를 하더라도 모든 프로세스 외부 의존성을 처리하지 못할 수도 있다. 일부 의존성의 테스트 버전이 없거나 해당 의존성을 필요한 상태로 자동으로 가져오는 것이 불가능할 수 있다. 따라서 여전히 테스트 대역을 사용할 필요가 있고, 통합 테스트와 엔드 투 엔드 테스트 사이에 뚜렸한 경계가 없다.  

#### 2.5. 요약  

+ 단위 테스트는 단일 동작 단위를 검증하고 빠르게 수행하고 다른 테스트와 별도로 처리한다.

+ 격리 분제를 주로 논의하고 있는데, 이 논쟁으로 고전파(디트로이트)와 런던파(목 추종자)라는 두 개의 단위 테스트 분파로 나뉘었다. 이러한 의견 차이는 무엇이 단위를 의미하는지에 대한 관점과 테스트 대상 시스템(SUT)의 의존성 처리 방식에 영향을 미친다.  

+ 런던파는 테스트 대상 단위를 서로 분리해야 한다고 한다. 테스트 대상 단위는 코드의 단위, 보통 단일 클래스다. 불변 의존성을 제외한 모든 의존성을 테스트 대역으로 대체해야 한다.

+ 고전파는 단위가 아니라 단위 테스트를 서로 분리해야 한다고 한다. 또한 테스트 대상 단위는 코드 단위가 아니라 동작 단위다. 따라서 공유 의존성만 테스트 대역으로 대체해야 한다. 공유 의존성은 테스트가 서로 실행 흐름에 영향을 미치는 수단을 제공하는 의존성이다.

+ 런던파는 더 나은 입자성의 이점, 상호 연결된 클래스의 큰 그래프에 대한 테스트 용이성 그리고 테스트 실패 후 버그가 있는 기능을 쉽게 찾을 수 있는 편의성 등을 제공한다.

+ 런던파의 장점이 처음에는 매력적으로 보인다. 그러나 몇 가지 문제가 있다. 먼저 테스트 대상 클래스에 대한 초점이 잘못됐다. 테스트는 코드 단위가 아니라 동작 단위를 검증해야 한다. 더욱이 코드 조작을 단위 테스트할 수 없다는 것은 코드 설계에 문제가 있다는 사실을 알려주는 강한 징후다. 테스트 대역을 사용한다고 해도 이 문제를 해결하는 게 아니라 오히려 숨길 뿐이다. 마지막으로 테스트 실패 후 어떤 기능에 버그가 있는지 판단하는 것이 도움은 되지만, 종종 버그의 원인을 알고 있기 때문에 그리 큰 문제는 아니다. 즉, 바로 마지막에 수정한 것이 버그의 원인일 것이다.  

+ 런던파 테스트의 가장 큰 문제는 과잉 명세, 즉 SUT 세부 구현에 결합된 테스트 문제다.

+ 통합 테스트는 단위 테스트 기준 중 하나 이상을 충족하지 못하는 테스트다. 엔드 투 엔드 테스트는 통합 테스트의 일부다. 최종 사용자의 관점에서 시스템을 검증한다. 엔드 투 엔드 테스트는 애플리케이션과 함께 작동하는 프로세스 외부 의존성의 전부 또는 대부분에 직접 접근한다.

+ 고전적인 스타일을 다른 명저로 켄트 벡(Kent Beck)의 『Test-Driven Development: By Example』을 추천한다. 런던 스타일에 대한 자세한 내용은 스티브 프리먼과 냇 스파이스의 『Growing Object-Oriented Software, Guided by Tests』를 참조하라. 의존성 작업에 대한 자세한 내용을 알고 싶다면 스티븐 반 듀르센(Steven van Deursen)과 마크 시먼(Mark Seemann)의 『Dependency Injection: Principle, Parctices, Patterns』를 추천한다.  

### 3. 단위 테스트 구조
<br/>

#### 3.1. 단위 테스트를 구성하는 방법
<br/>

##### 3.1.1. AAA 패턴 사용
<br/>

AAA 패턴은 각 테스트를 준비, 실행, 검증이라는 세 부분으로 나눌 수 있다.  

AAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다. 이러한 일관성이 이 패턴의 가장 큰 장점 중 하나다. 일단 익숙해지면 모든 테스트를 쉽게 읽을 수 있고 이해할 수 있다. 결국 전체 테스트 스위트의 유지 보수 비용이 줄어든다. 구조는 다음과 같다.  

+ 준비 구절에서는 테스트 대상 시스템(SUT, System Under Test)과 해당 의존성을 원하는 상태로 만든다.
+ 실행 구절에서는 SUT에서 메서드를 호출하고 준비된 의존성을 전달하며 (출력이 있으면) 출력 값을 캡처한다.
+ 검증 구절에서는 결과를 검증한다. 결과는 반환 값이나 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메서드 등으로 표시될 수 있다.  

###### 3.1.1.1. Given-When-Then 패턴
<br/>

AAA와 유사한 Given-When-Then 패턴에 대해 들어봤을 것이다. 이 패턴도 테스트를 세 부분으로 나눈다.  

+ Given - 준비 구절에 해당
+ When - 실행 구절에 해당
+ Then - 검증 구절에 해당  

테스트 구성 측면에서 두 가지 패턴 사이에 차이는 없다. 유일한 차이점은 프로그래머가 아닌 사람에게 Given-When-Then 구조가 더 읽기 쉽다는 것이다. 그러므로 Given-When-Then은 비기술자들과 공유하는 테스트에 더 적합하다.  

테스트를 작성할 때는 준비 구절부터 시작하는 것이 자연스럽다. 그다음 다른 두 구절을 작성한다. 이 방법은 대부분의 경우에 효과적이지만, 검증 구절로 시작하는 것도 가능한 옵션이다. 테스트 주도 개발(TDD, Test-Driven Development)을 실천할 때, 즉 기능을 개발하기 전에 실패할 테스트를 만들 때는 아직 기능이 어떻게 동작할지 충분히 알지 못한다. 따라서 먼저 기대하는 동작으로 윤곽을 잡은 다음, 이러한 기대에 부응하기 위한 시스템을 어떻게 개발할지 아는 것이 좋다.  

직관적이지는 않지만, 이것이 문제를 해결하는 방식이다. 특정 동작이 무엇을 해야 하는지에 대한 목표를 생각하면서 시작한다. 그다음이 실제 문제 해결이다. 다른 것을 하기 전에 검증문을 작성하는 것은 단지 사고 과정의 형식이다. 그러나 다시 말하지만, 이 지침은 TDD를 실천할 때, 즉 제품 코드 전에 테스트를 작성할 때만 적용될 수 있다. 테스트 전에 제품 코드를 작성한다면 테스트를 작성할 시점에 실행에서 무엇을 예상하는지 이미 알고 있으므로 준비 구절부터 시작하는 것이 좋다.  

##### 3.1.2. 여러 개의 준비, 실행, 검증 구절 피하기
<br/>

때로는 준비, 실행 또는 검증 구절이 여러 개 있는 테스트를 만날 수 있다.  

여러 개의 준비, 실행, 검증 구절은 테스트가 너무 낳은 것을 한 번에 검증한다는 의미다. 이러한 테스트는 여러 테스트로 나눠서 해결한다.  

검증 구절(어쩌면 준비 구절)로 구분된 여러 개의 실행 구절을 보면, 여러 개의 동작 단위를 검증하는 테스트를 뜻한다. 이러한 테스트는 단위 테스트가 아니라 통합 테스트다. 이러한 테스트 구조는 피하는 것이 좋다. 실행이 하나면 테스트가 단위 테스트 범주에 있게끔 보장하고, 간단하고, 빠르며, 이해하기 쉽다. 일련의 실행과 검증이 포함된 테스트를 보면 리팩터링하라. 각 동작을 고유의 테스트로 도출하라.  

통합 테스트에서는 실행 구절을 여러 개 두는 것이 괜찮을 때도 있다. 통합 테스트는 느릴 수 있다. 속도를 높이는 한 가지 방법은 여러 개의 통합 테스트를 여러 실행과 검증이 있는 단일한 테스트로 묶는 것이다. 시스템 상태의 흐름이 자연스럽다면, 즉 실행이 동시에 후속 실행을 위한 준비로 제공될 때 특히 유용하다.  

그러나 다시 말하지만, 이 최적화 기법은 통합 테스트에만 적용할 수 있다. 그것도, 전부가 아니라 이미 느리고 더 느려지게 하고 싶지 않은 테스트들만이다. 단위 테스트나 충분히 빠른 통합 테스트에서는 이러한 최적화가 필요하지 않다. 항상 다단계 단위 테스트를 여러 개의 테스트로 나누는 것이 더 좋다.  

##### 3.1.3. 테스트 내 if 문 피하기
<br/>

준비, 실행, 검증 구절이 여러 차례 나타나는 것과 비슷하게, if 문이 있는 단위 테스트를 만날 수 있다. 이것도 안티 패턴이다. 단위 테스트든 통합 테스트든 테스트는 분기가 없는 간단한 일련의 단계여야 한다.  

if 문은 테스트가 한 번에 너무 많은 것을 검증한다는 표시다. 그러므로 이러한 테스트는 반드시 여러 테스트로 나눠야 한다. 여러 AAA 구절과 달리. 통합 테스트에도 예외는 없다. 테스트에 분기가 있어서 얻는 이점은 없다. 단지 추가 유지비만 불어난다. if 문은 테스트를 읽고 이해하는 것을 더 어렵게 만든다.  

##### 3.1.4. 각 구절은 얼마나 커야 하는가?
<br/>

AAA 패턴으로 시작할 대 보통 하는 질문은 다음과 같다. 각 구절의 크기가 얼마나 되는가? 테스트가 끝난 후에 정리하는 종료(teardown) 구절은 어떻게 하는가? 테스트 구절의 크기에 따라 각기 다른 지침이 있다.  

###### 3.1.4.1. 준비 구절이 가장 큰 경우
<br/>

일반적으로 준비 구절이 세 구절 중 가장 크며, 실행과 검증을 합친 만큼 클 수도 있다. 그러나 이보다 훨씬 크면, 같은 테스트 클래스 내 비공개 메서드 또는 별도의 팩토리 클래스로 도출하는 것이 좋다. 준비 구절에서 코드 재사용에 도움이 되는 두 가지 패턴으로 오브젝트 마더(Object Mother)와 테스트 데이터 빌더(Test Data Builder)r가 있다.  

###### 3.1.4.2. 실행 구절이 한 줄 이상인 경우를 경계하라
<br/>

실행 구절은 보통 코드 한 줄이다. 실행 구절이 두 줄 이상인 경우 SUT의 공개 API에 문제가 있을 수 있다.  

이 문제는 예를 들어 설명하는 것이 좋기 때문에 2장에서 예제를 가져왔다. 고객이 상점에서 구매하는 예제다.  

```cs
[Fact]
public void Purchage_succeeds_when_enough_inventory() {
	// 준비
	var store = new Store();
	store.AddInventory(Product.Shampoo, 10);
	var customer = new customer();

	// 실행
	bool success = customer.Purchase(store, Product.Shampoo, 5);

	// 검증
	Assert.True(success);
	Assert.Equal(5, store.GetInventory(Product.Shampoo));
}
```

이 테스트의 실행 구절은 단일 메서드 호출이며 잘 설계된 클래스 API임을 보여준다.  

이제 다음 예제와 비교해보자. 이 실행 구절은 두 줄로 돼 있다. SUT에 문제가 있다는 신호다. 구매를 마치려면 두 번째 메서드를 호출해야 하므로, 캡슐화가 깨지게 된다.  

```cs
[Fact]
public void Purchage_succeeds_when_enough_inventory() {
	// 준비
	var store = new Store();
	store.AddInventory(Product.Shampoo, 10);
	var customer = new customer();

	// 실행
	bool success = customer.Purchase(store, Product.Shampoo, 5);
	store.RemoveInventory(success, Product.Shampoo, 5);

	// 검증
	Assert.True(success);
	Assert.Equal(5, store.GetInventory(Product.Shampoo));
}
```

예제의 실행 구절로 알 수 있는 내용은 다음과 같다.  

+ 첫 번째 줄에서는 고객이 상점에서 다섯 개를 얻으려고 한다.
+ 두 번째 줄에서는 재고가 감소되는데, Purchase() 호출이 성공을 반환하는 경우에만 수행된다.  

새 버전의 문제점은 단일 작업을 수행하는 데 두 개의 메서드 호출이 필요하다는 것이다. 테스트 자체는 문제가 되지 않는다. 테스트는 구매 프로세스라는 동일한 동작 단위를 검증한다. Customer 클래스의 API에 문제가 있으며, 클라이언트에게 메서드 호출을 더 강요해서는 안 된다.  

비즈니스 관점에서 구매가 정상적으로 이뤄지면 고객의 제품 획득과 매장 재고 감소라는 두 가지 결과가 만들어진다. 이러한 결과는 같이 만들어야 하고, 이는 다시 단일한 공개 메서드가 있어야 한다는 뜻이다. 그렇게 하지 않으면 클라이언트 코드가 첫 번째 메서드를 호출하고 두 번째 메서드를 호출하지 않을 때 모순이 생긴다. 고객은 제품을 얻을 수 있지만, 재고 수량은 줄어들지 않을 것이다.  

이러한 모순을 불변 위반(invariant violation)이라고 하며, 잠재적 모순으로부터 코드를 보호하는 행위를 캡슐화(encapsulation)라고 한다. 데이터베이스에 모순이 생기면 큰 문제가 된다. 단순히 애플리케이션을 재시작해서는 상태를 돌려놓을 수 없다. 데이터베이스의 손상된 데이터를 처리하고, 어쩌면 고객에게 연락해서 상황별로 처리해야 할 수도 있다. 애플리케이션이 재고를 수정하지 않고 영수증을 발행하면 어떻게 될지 상상해보라. 조만간 부족한 재고에 대해 클레임이 생길 수 있고 심지어 비용을 청구할 수도 있다.  

해결책은 코드 캡슐화를 항상 지키는 것이다. 이전 예제에서 Purchase 메서드의 한 부분으로 고객이 매입한 재고를 제거하고, 클라이언트 코드에 의존하지 않아야 했다. 불변을 지키는 한, 불변 위반을 초래할 수 있는 잠재적인 행동을 제거해야 한다.  

실행 구절을 한 줄로 하는 지침은 비즈니스 로직을 포함하는 대부분 코드에 적용되지만, 유틸리티나 인프라 코드는 덜 적용된다. 그러므로 절대 두 줄 이상 두지 말라고 할 수 없다. 각각의 사례에서 캡슐화 위반이 있을 수 있는지 살펴보자.  

##### 3.1.5. 검증 구절에는 검증문이 얼마나 있어야 하는가
<br/>

단위 테스트의 단위는 동작의 단위이지 코드의 단위가 아니다. 단일 동작 단위는 여러 결과를 낼 수 있으며, 하나의 테스트로 그 모든 결과를 평가하는 것이 좋다.  

그렇기는 해도 검증 구절이 너무 커지는 것은 경계해야 한다. 제품 코드에서 추상화가 누락됐을 수 있다. 예를 들어 SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버(equality member)를 정의하는 것이 좋다. 그러면 단일 검증문으로 객체를 기대값과 비교할 수 있다.  

##### 3.1.6. 종료 단계는 어떤가
<br/>

준비, 실행, 검증 이후의 네 번째 구절로 종료 구절을 따로 구분하기도 한다. 예를 들면 테스트에 의해 작성된 파일을 지우거나 데이터베이스 연결을 종료하고자 이 구절을 사용할 수 있다, 종료는 일반적으로 별도의 메서드로 도출돼, 클래스 내 모든 테스트에서 재사용된다. AAA 패턴에는 이 단계를 포함하지 않는다.  

대부분의 단위 테스트는 종료 구절이 필요 없다. 단위 테스트는 프로세스 외부에 종속적이지 않으므로 처리해야 할 부작용을 남기지 않는다. 종료는 통합 테스트의 영역이다.  

##### 3.1.7. 테스트 대상 시스템 구별하기
<br/>

SUT는 테스트에서 중요한 역할을 하는데, 애플리케이션에서 호출하고자 하는 동작에 대한 진입점을 제공한다. 동작은 여러 클래스에 걸쳐 있을 만큼 클 수도 있고 단일 메서드로 작을 수도 있다. 그러나 진입점은 오직 하나만 존재할 수 있다(동작을 수행할 하나의 클래스다).  

따라서 SUT를 의존성과 구분하는 것이 중요하다. 특히 SUT가 꽤 많은 경우, 테스트 대상을 찾는 데 시간을 너무 많이 들일 필요가 없다. 그렇게 하기 위해 테스트 내 SUT 이름을 sut로 하라.  

##### 3.1.8. 준비, 실행, 검증 주석 제거하기
<br/>

의존성에서 SUT를 떼어내는 것이 중요하듯이, 테스트 내에서 특정 부분이 어떤 구절에 속해 있는지 파악하는 데 시간을 많이 들이지 않도록 세 구절을 서로 구분하는 것 역시 중요하다. 이를 위한 한 가지 방법은 각 구절을 시작하기 전에 주석(// 준비, // 실행, // 검증)을 다는 것이다. 다른 방법은 빈 줄로 분리하는 것이다.  

빈 줄로 구절을 구분하면 대부분의 단위 테스트에서 효과적이며, 간결성과 가독성 사이에서 균형을 잡을 수 있다. 그러나 대규모 테스트에서는 잘 작동하지 않는다. 대규모 테스트에서는 준비 단계에 빈 줄을 추가해 설정 단계를 구분할 수도 있다. 통합 테스트에는 복잡한 설정을 포함하는 경우가 많다.  

+ AAA 패턴을 따르고 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트면 구절 주석들을 제거하라.
+ 그렇지 않으면 구절 주석을 유지하라.  

#### 3.2. xUnit 테스트 프레임워크 살펴보기
<br/>

xUnit(https://github.com/xunit/xunit)은 .NET에서만 작동하지만, 모든 객체지향 언어(자바, C++, 자바스크립트 등)에 단위 테스트 프레임워크가 있으며 모든 프레임워크는 매우 비슷하다. 그중 하나라도 써봤다면 다른 프레임워크를 쓰는 데 별다른 어려움이 없을 것이다.  

.NET만 생각해볼 때, 몇 가지 대안으로 NUnit(https://github.com/nunit/nunit)이나 기본으로 제공하는 Microsoft MSTest 등을 선택할 수 있다. xUnit을 선호하지만, NUnit을 사용할 수도 있다. 이 두 프레임워크는 기능 면에서 거의 비슷하다. 그러나 MSTest는 권장하지 않는다. xUnit과 NUnit의 수준보다 유연하지 않기 때문이다. 그리고 확실치 않지만, 마이크로소프트 직원들조차 MSTest를 사용하지 않는다. 예를 들어 ASP.NET Core 팀은 xUnit을 사용한다.  

[Fact] 특성은 테스트가 아니라 사실이라고 한다. '각 테스트는 이야기가 있어야 한다.'는 점을 강조한다. 이 이야기는 문제 영역에 대한 개별적이고 원자적(atomic)인 사실이나 시나리오이며, 테스트가 통과하는 것은 이 사실 또는 시나리오가 실제 사실이라는 증거다. 테스트가 실패하면 이야기가 더 이상 유효하지 않아 테스트를 다시 작성해야 하거나 시스템 자체를 수정해야 한다.  

단위 테스트를 작성할 때는 이렇게 사고방식을 갖는 것이 좋으며, 테스트가 제품 코드의 기능을 무조건 나열하면 안 된다. 오히려 애플리케이션 동작에 대해 고수준의 명세가 있어야 한다. 이상적으로 이 명세는 프로그래머뿐만 아니라 비즈니스 담당자에게도 의미가 있어야 한다.  

#### 3.3. 테스트 간 테스트 픽스쳐 재사용
<br/>

테스트에서 언제 어떻게 코드를 재사용하는지 아는 것이 중요하다. 준비 구절에서 코드를 재사용하는 것이 테스트를 줄이면서 단순화하기 좋은 방법이다.  

앞서, 테스트 픽스처를 준비하기 위해 코드를 너무 많이 작성해야 한다고 자주 서술했다. 이러한 준비는 별도의 메서드나 클래스로 도출한 후 테스트 간에 재사용하는 것이 좋다. 재사용하는 방법은 두 가지가 있는데, 그중 하나만 유용하다. 다른 하나는 유지비를 증가시킨다.  

+ 테스트 픽스터  
테스트 실행 대상 객체로 정규 의존성, 즉 SUT로 전달되는 인수. 예를 들어 데이베이스에 있는 데이터나 하드 디스크의 파일일 수도 있다. 이러한 객체는 각 테스트 실행 전에 알려진 고정 상태로 유지하기 때문에 동일한 결과를 생성한다. 따라서 픽스처라는 단어가 나왔다.  

테스트 픽스처를 재사용하는 첫 번째 (올바르지 않은) 방법은 다음과 같이 테스트 생성자(또는 NUnit을 사용하는 경우[SetUp] 특성으로 표시된 메서드)에서 픽스처를 초기화하는 것이다.  

이 방법으로 테스트 코드의 양을 크게 줄일 수 있으며, 테스트에서 테스트 픽스처 구성을 전부 또는 대부분 제거할 수 있다. 그러나 이 기법은 두 가지 중요한 단점이 있다.  

+ 테스트 간 결합도가 높아진다.
+ 테스트 가독성이 떨어진다.  

##### 3.3.1. 테스트 간의 높은 결합도는 안티 패턴이다
<br/>

테스트를 수정해도 다른 테스트에 영향을 주어서는 안 된다. 테스트는 서로 격리돼 실행해야 한다는 것과 비슷하다. 그래도 완전히 같지는 않다. 여기서는 테스트의 독립적인 수정이지, 독립적인 실행이 아니다. 둘 다 잘 설계된 테스트의 중요한 특성이다.  

이 지침을 따르려면 테스트 클래스에 공유 상태를 두지 말아야 한다.  

##### 3.3.2. 테스트 가독성을 떨어뜨리는 생성자 사용
<br/>

준비 코드를 생성자로 추출할 때의 또 다른 단점은 테스트 가독성을 떨어뜨리는 것이다. 테스트만 보고는 더 이상 전체 그림을 볼 수 없다. 테스트 메서드가 무엇을 하는지 이해하려면 클래스의 다른 부분도 봐야 한다.  

준비 로직이 별로 없더라도(예: 픽스처의 인스턴화만 있을 때) 테스트 메서드로 바로 옮기는 것이 좋다. 그렇지 않으면 단순히 인스턴스를 만드는 것일까? 아니면 다른 무언가가 환경 설정을 하는 것일까? 독립적인 테스트는 이러한 불확실성을 두지 않는다.  

##### 3.3.3. 더 나은 테스트 픽스처 재사용법
<br/>

테스트 픽스처를 재사용할 때 생성자 사용이 최선의 방법은 아니다. 두 번째 방법은 다음 예제와 같이 테스트 클래스에 비공개 팩토리 메서드(private factory method)를 두는 것이다.  

```cs
public class CustomerTests
{
	[Fact]
	public void Purchase_succeeds_when_enough_inventory() {
		Store store = CreateStoreWithInventory(Product.Shampoo, 10);
		Customer sut = CreateCustomer();
		bool success = sut.Purchase(store, Product.Shampoo, 5);
		Assert.True(success);
		Assert.Equal(5, store.GetInventory(Product.Shampoo));
	}

	[Fact]
	public void Purchase_fails_when_enough_inventory() {
		Store store = CreateStoreWithInventory(Product.Shampoo, 10);
		Customer sut = CreateCustomer();
		bool success = sut.Purchase(store, Product.Shampoo, 15);
		Assert.True(success);
		Assert.Equal(10, store.GetInventory(Product.Shampoo));
	}

	private Store CareteStoreWithInventory(Product product, int quantity)
	{
		Store store = new Store();
		store.AddInventory(product, quantity);
		return store;
	}

	private static Customer CreateCustomer()
	{
		return new Customer();
	}
}
```

공통 초기화 코드를 비공개 팩토리 메서드로 추출해 테스트 코드를 짧게 하면서, 동시에 테스트 진행 상황에 대한 전체 맥락을 유지할 수 있다. 게다가 비공개 메서드를 충분히 일반화하는 한 테스트가 서로 결합되지 않는다. 테스트에 픽스처를 어떻게 생성할지 지정할 수 있다.  

테스트 픽스처 재사용 규칙에 한 가지 예외가 있다. 테스트 전부 또는 대부분에 사용되는 생성자에 픽스처를 인스턴스화할 수 있다. 이는 데이터베이스와 작동하는 통합 테스트에 종종 해당한다. 이러한 모든 테스트는 데이터베이스 연결이 필요하며, 이 연결을 한 번 초기화한 다음 어디에서나 재사용할 수 있다. 그러나 기초 클래스(base class)를 둬서 개별 테스트 클래스가 아니라 클래스 생성자에서 데이터베이스 연결을 초기화하는 것이 더 합리적이다. 기초 클래스의 공통 초기화 코드 예로 다음 예제를 참고하자.  

```cs
public class CustomerTests: IntegrationTests
{
	[Fact]
	public void Purchase_succeeds_when_enough_inventory()
	{
		/* 여기서 _database 사용 */
	}
}

public abstract class IntegrationTests: IDisposable
{
	protected readonly Database _database;

	protected IntegrationTests()
	{
		_database = new Database();
	}

	public void Dispose()
	{
		_database.Dispose();
	}
}
```

#### 3.4. 단위 테스트 명명법
<br/>

테스트에 표현력이 있는 이름을 붙이는 것이 중요하다. 올바른 명칭은 테스트가 검증하는 내용과 기본 시스템의 동작을 이해하는 데 도움이 된다.  

그렇다면, 단위 테스트 이름을 어떻게 정해야 하는가? 가장 유명하지만 가장 도움이 되지 않는 방법 중 하나가 다음과 같은 관습이다.  

[테스트 대상 메서드]&#95;[시나리오]&#95;[예상 결과]  

+ 테스트 대상 메서드: 테스트 중인 메서드의 이름
+ 시나리오: 메서드를 테스트하는 조건
+ 예상 결과: 현재 시나리오에서 테스트 대상 메서드에 기대하는 것  

동작 대신 구현 세부 사항에 집중하게끔 부추기기 때문에 분명히 도움이 되지 않는다.  

간단하고 쉬운 영어 구문이 더 효과적이며, 엄격한 명명 구조에 얽매이지 않고 표현력이 뛰어나다. 간단한 문구로 고객이나 도메인 전문가에게 의미 있는 방식으로 시스템 동작을 설명할 수 있다.  

##### 3.4.1. 단위 테스트 명명 지침
<br/>

표현력 있고 읽기 쉬운 테스트 이름을 지으려면 다음 지침을 따르자.  

+ 엄격한 명명 정책을 따르지 않는다. 복잡한 동작에 대한 높은 수준의 설명을 이러한 정책의 좁은 상자 안에 넣을 수 없다. 표현의 자유를 허용하자.
+ 문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자, 도메인 전문가나 비즈니스 분석가가 좋은 예다.
+ 단어를 밑줄(underscore, &#95;) 표시로 구분한다. 그러면 특히 긴 이름에서 가독성을 향상시키는 데 도움이 된다.  

보통 클래스 이름은 그리 길지 않아서 밑줄 표시가 없어도 잘 읽을 수 있다.  

또 테스트 클래스 이름을 지정할 때 [클래스명]Tests 패턴을 사용하지만, 테스트가 해당 클래스만 검증하는 것으로 제한하는 것은 아니다. 단위 테스트에서 단위는 동작의 단위지, 클래스의 단위가 아닌 것을 명심하자. 이 단위는 하나 이상의 클래스에 걸쳐 있을 수 있으며, 실제 테스트 크기에 영향을 주지 않는다. 그래도 어딘가에서는 시작해야 한다. [클래스명]Tests에서 클래스는 동작 단위로 검증할 수 있는 진입점 또는 API로 여기자.  

##### 3.4.2 예제: 지침에 따른 테스트 이름 변경
<br/>

+ 테스트명 내 테스트 대상 메서드  
테스트 이름에 SUT의 메서드 이름을 포함하지 말라. 코드를 테스트하는 것이 아니라 애플리케이션 동작을 테스트하는 것이라는 점을 명심하자. 이 지침의 유일한 예외는 유틸리티 코드를 작업할 때다. 유틸리티 코드는 비즈니스 로직이 없고, 코드의 동작이 단순한 보조 기능에서 크게 벗어나지 않으므로 비즈니스 담당자에게는 아무런 의미가 없다.  

should be 문구는 또 다른 일반적인 안티 패턴이다. 사실을 서술할 때는 소망이나 욕구가 들어가지 않는다. 여기에 따라 테스트 이름을 짓자. should be를 다음과 같이 is로 바꿔보자.  

마지막으로 기초 영문법을 지켜야 한다. 관사를 붙이면 테스트를 완벽하게 읽을 수 있다.  

#### 3.5. 매개변수화된 테스트 리팩터링하기
<br/>

보통 테스트 하나로는 동작 단위를 완전하게 설명하기에 충분하지 않다. 이 단위는 일반적으로 여러 구성 요소를 포함하며, 각 구성 요소는 자체 테스트로 캡처해야 한다. 동작이 충분히 복잡하면, 이를 설명하는 데 테스트 수가 급격히 증가할 수 있으며 관리하기 어려워질 수 있다. 다행히도 대부분의 단위 테스트 프레임워크는 매개변수화된 테스트(parameterized test)를 사용해 유사한 테스트를 묶을 수 있는 기능을 제공한다.  

먼저 별도의 테스트 기술된 각 동작 구성 요소를 살펴본 다음 이 테스트들을 그룹핑하는 방법을 시연한다.  

가장 빠른 배송일이 오늘로부터 이틀 후가 되도록 작동하는 배송 기능이 있다고 가정하자. 분명히 테스트 하나로는 충분하지 않다. 지난 배송일을 확인하는 테스트 외에 오늘 날짜. 내일 날짜 그리고 그 이후의 날짜까지 확인하는 테스트도 필요하다.  

작성했던 테스트를 Delivery&#95;with&#95;a&#95;past&#95;date&#95;is&#95;invalid로 하자. 다음 메서드 세 개를 추가해보자.  

public void Delivery&#95;for&#95;today&#95;is&#95;invalid()  
public void Delivery&#95;for&#95;tomorrow&#95;is&#95;invalid()  
public void The&#95;soonest&#95;delivery&#95;&#95;two&#95;days&#95;for&#95;now()  

하지만 이로 인해 네 가지의 테스트 메서드가 나왔지만, 유일한 차이점은 배송 날짜뿐이다.  

더 좋은 방법은 테스트 코드의 양을 줄이고자 이러한 테스트를 하나로 묶는 것이다. xUnit에 있는(대부분의 다른 테스트 프레임워크도 마찬가지로) 매개변수화된 테스트라는 기능으로 묶을 수 있다. 다음 예제가 어떻게 그룹화하는지 보여준다. 각각의 [InlineData] 특성은 시스템에 대한 별도의 사실을 나타낸다. 이 자체로 테스트 케이스에 해당한다.  

```cs
public class DeliveryServiceTests
{
	[InlineData(-1, false)] // [InlineData] 특성은 테스트 메서드에 입력 값 집합을 보낸다. 각 라인은 동작에 대해 별개의 사실을 나타낸다.
	[InlineData(0, false)]	
	[InlineData(1, false)]	
	[InlineData(2, true)]
	public void Can_detect_an_invalid_delivery_data(int daysFromNow, bool expected)
	{
		DeliveryService sut = new DeliveryService();
		DataTime deliveryDate = DateTime.Now.AddDay(daysFromNow);
		Delivery delivery = new Delivery{ Date = deliveryDate };

		bool isValid = sut.IsDeliveryValid(delivery);

		Assert.Equal(expected, isValid);
	}
}
```

[Fact] 특성 대신 [Theory] 특성을 사용했다. 이론은 동작에 대한 사실의 묶음이다.  

각 사실은 이제 별도의 테스트가 아니라 [InlineData] 라인으로 표현한다. 또 테스트 이름에서 더 이상 구성된 날짜가 올바른지 또는 잘못됐는지에 대해 언급할 필요가 없으므로 좀 더 일반적으로 바꿨다.  

매개변수화된 테스트를 사용하면 테슽 코드의 양을 크게 줄일 수 있지만, 비용이 발생한다. 이제 테스트 메서드가 나타내는 사실을 파악하기가 어려워졌다. 그리고 매개변수가 많을수록 더 어렵다. 절충안으로 긍정적인 테스트 케이스는 고유한 테스트로 도출하고, 가장 중요한 부분을 잘 설명하는 이름을 쓰면 좋다.  

이러한 방법으로 부정적인 테스트 케이스를 단순하게 할 수 있는데, 테스트 메서드에서 예상되는 불(boolean) 매개변수를 제거할 수 있기 때문이다. 그리고 물론 긍정적인 테스트 메서드도 매개변수화된 테스트로 바꿔서 여러 날짜를 테스트해볼 수 있다.  

보다시피, 테스트 코드의 양과 그 코드의 가독성은 서로 상충된다. 경험상 입력 매개변수만으로 테스트 케이스를 판단할 수 있다면 긍정적인 테스스트 케이와 부정적인 테스트 케이스 모두 하나의 메서드로 두는 것이 좋다. 그렇지 않으면 긍정적인 테스트 케이스를 도출하라. 그리고 동작이 너무 복잡하면 매개변수화된 테스트를 조금도 사용하지 말라. 긍정적인 테스트 케이스와 부정적인 테스트 케이스 모두 각각 고유의 테스트 메서드로 나타내라.  

##### 3.5.1. 매개변수화된 테스트를 위한 데이터 생성
<br/>

(적어도 .NET에서는) 매개변수화된 테스트를 사용하는 데 주의해야 할 점이 있다. 다음 예제에서는 daysFromNow 매개변수를 테스트 메서드의 입력으로 사용했다. 왜 실제 날짜와 시간이 아닐까? 안타깝게도 다음 코드는 작동하지 않는다.  

```cs
[InlineData(DateTime.Now.AddDays(-1), false)] // [InlineData] 특성은 테스트 메서드에 입력 값 집합을 보낸다. 각 라인은 동작에 대해 별개의 사실을 나타낸다.
[InlineData(DateTime.Now(0), false)]	
[InlineData(DateTime.Now.AddDays(1), false)]	
[InlineData(DateTime.Now.AddDays(2), true)]
public void Can_detect_an_invalid_delivery_data(DateTime deliveryDate, bool expected)
{
	DeliveryService sut = new DeliveryService();
	Delivery delivery = new Delivery{ Date = deliveryDate };

	bool isValid = sut.IsDeliveryValid(delivery);

	Assert.Equal(expected, isValid);
}
```

C#에서는 모든 특성의 내용을 컴파일할 때 평가한다. 컴파일러가 이해할 수 있는 값만 사용해야 한다. 즉, 다음과 같다.  

+ 상수
+ 리터럴(literal)
+ typeOf() 표현식  

DateTime.Now 호출은 .NET 런타임에 의존하고 있으므로 허용되지 않는다.  

이 문제를 극복할 수 있는 방법이 있다. xUnit에는 테스트 메서드에 공급할 사용자 정의 데이터를 생성하는 데 사용할 수 있는 기능이 있다. 다음 예제는 이 기능을 사용해 어떻게 이전 테스트를 다시 작성하는지를 보여준다.  

```cs
[Theory]
[MemberData(nameof(Data))]
public void Can_detect_an_invalid_delivery_date(DateTime deliveryDate, bool expected)
{
	/* ... */
}

public static List<object[]> Data()
{
	return new List<object[]>
	{
		new object[] { DateTime.Now.AddDays(-1), false },
		new object[] { DateTime.Now, false },
		new object[] { DateTime.Now.AddDays(1), false },
		new object[] { DateTime.Now.AddDays(2), true },
	};
}
```

[MemberData]는 입력 데이터 컬렉션을 생성하는 정적 메서드 이름을 받는다(컴파일러는 nameof(Data)를 "Data" 리터럴로 변환함). 컬렉션의 각 요소는 deliveryDate와 expected라는 두 개의 입력 매개변수로 매핑되는 컬렉션이다. 이 기능을 사용하면 컴파일러의 제한을 극복하고 매개변수화된 테스트에서 모든 유형의 매개변수를 사용할 수 있다.  

#### 3.6. 검증문 라이브러리를 사용한 테스트 가독성 향상
<br/>

테스트 가독성을 높이기 위한 방법을 하나 더 소개하면, 검증문 라이브러리를 사용하는 것을 들 수 있다. 개인적으로 Fluent Assertions(https://fluentassertions.com)를 선호하지만, .NET에는 다른 라이브러리도 있다.  

검증문 라이브러리를 사용하는 주요 이점은 검증문을 재구성해 가독성을 높이는 방법이다.  

Fluent Assertions 라이브러리는 숫자, 문자열, 컬렉션, 날짜 및 시간 등에 대해 검증할 수 있는 수많은 헬퍼 메서드(helper method)를 제공한다. 유일한 단점은 (개발에서만 해당되고 제품으로 나가지는 않을지라도) 프로젝트에 의존성을 추가해야 한다는 것이다.  

#### 3.6. 요약
<br/>

+ 모든 단위 테스트는 AAA 패턴(준비, 실행, 검증)을 따라야 한다. 테스트 내 준비나 실행 또는 검증 구절이 여러 개 있으면, 테스트가 여러 동작 단위를 한 번에 검증한다는 표시다. 이 테스트가 각 동작에 하나씩 여러 개의 테스트로 나눠야 한다.  

+ 실행 구절이 한 줄 이상이면 SUT의 API에 문제가 있다는 뜻이다. 클라이언트가 항상 이러한 작업을 같이 수행해야 하고, 이로 인해 잠재적으로 모순으로 이어질 수 있다. 이러한 모순을 분별 위반이라고 한다. 잠재적인 불변 위반으로부터 코드를 보호하는 것을 캡슐화라고 한다.  

+ SUT의 이름을 sut로 지정해 SUT를 테스트에서 구별하자. 구절 사이에 빈 줄을 추가하거나 준비, 실행, 검증 구절 주석을 각각 앞에 둬서 구분하라.  

+ 테스트 픽스처 초기화 코드는 생성자에 두지 말고 팩토리 메서드를 도입해서 재사용하자. 이러한 재사용은 테스트 간 결합도를 낮게 유지하고 가독성을 향상시킨다.  

+ 엄격한 테스트 명명 정책을 시행하지 말라. 문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 각 테스트의 이름을 지정하자. 테스트 이름에서 밑줄 표시로 단어를 구분하고, 테스트 대상 메서드 이름을 넣지 말자.  

+ 검증문 라이브러리를 사용하면, 쉬운 영어처럼 읽도록 검증문에서 단어 순서를 재구성해 테스트 가독성을 더욱 향상시킬 수 있다.  

### 4. 개발자에게 도움이 되는 테스트 만들기
<br/>

#### 4.1. 좋은 단위 테스트의 4대 요소 자세히 살펴보기
<br/>

##### 4.1.1. 첫 번째 요소: 회귀 방지
<br/>

회귀는 소프트웨어 버그다. 코드를 수정한 후 (일반적으로 새 기능을 출시한 후) 기능이 의도한 대로 작동하지 않는 경우다. 이러한 회구는 (아무리 좋게 봐도) 귀찮다. 그렇지만 최악의 상황은 아니다. 최악인 것은 개발할 기능이 많을수록, 새로운 릴리스에서 기능이 하나라도 고장 날 가능성이 높다는 점이다. 프로그래밍을 하는 삶에 있어 불행한 사실은 코드가 자산이 아니라 책이라는 점이다. 코드베이스가 커질수록 잠재적인 버그에 더 많이 노출된다. 그렇기 때문에 회구에 대해 효과적인 보호를 개발하는 것이 중요하다. 이러한 보호가 없다면 프로젝트가 오랫동안 성장할 수 없으며 점점 더 많은 버그가 쌓일 것이다.  

회귀 방지 지표에 대한 테스트 점수가 얼마나 잘 나오는지 평가하려면 다음 사항을 고려해야 한다.  

+ 테스트 중에 실행되는 코드의 양
+ 코드 복잡도
+ 코드의 도메인 유의성  

일반적으로 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다. 물론 이 테스트에 관련된 일련의 검증이 있다고 가정하면 단지 코드를 실행하기만 원하지는 않는다. 이 코드가 예외를 발생시키지 않고 실행된다는 것을 아는 데 도움은 되지만, 코드가 생성하는 결과가 유효한지도 확인해야 한다.  

코드의 양뿐만 아니라 복잡도와 도메인 유의성도 중요하다. 복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 코드(boilderplate code)보다 훨씬 더 중요하다. 비즈니스에 중요한 기능에서 발생한 버그가 가장 큰 피해를 입히기 때문이다.  

반면에 단순한 코드를 테스트하는 것은 가치가 거의 없다. 이러한 코드는 짧고, 비즈니스 로직을 많이 담고 있지도 않다. 단순한 코드를 다루는 테스트는 실수할 여지가 많지 않기 때문에 회귀 오류가 많이 생기지 않는다.  

게다가 코드 외에 작성하지 않은 코드(예: 라이브러리, 프레임워크 그리고 프로젝트에서 쓰는 외부 시스템)도 중요하다. 이 코드는 작성한 코드만큼이나 소프트웨어 작동에 영향을 미친다. 최상의 보호를 위해서는 테스트가 해당 라이브러리, 프레임워크, 외부 시스템을 테스트 범주에 포함시켜서 소프트웨어가 이러한 의존성에 대해 검증이 올바른지 확인한다.  

회귀 방지 지표를 극대화하려면 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.  

##### 4.1.2. 두 번째 요소: 리팩터링 내성
<br/>

좋은 단위 테스트의 두 번째 특성은 리팩터링 내성이다. 이는 테스트를 '빨간색'(실패)으로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도다.  

리팩터링은 식별할 수 있는 동작을 수정하지 않고 기존 코드를 변경하는 것을 의미한다. 그 의도는 코드의 비기능적 특징을 개선하는 것으로 가독성을 높이고 복잡도를 낮추는 것이다. 몇 가지 예를 들자면, 메서드 이름을 바꾸는 것이나 코드 조각을 새로운 클래스로 추출하는 것을 생각해볼 수 있다.  

이러한 상황을 상상해보자. 새로운 기능을 개발했으며 모든 것이 잘 작동한다. 기능이 제 역할을 하고 있으며, 모든 테스트가 통과하고 있다. 이제 코드를 정리하기로 결정했다. 여기에 리팩터링을 조금 하고 저기를 조금 고치면 모든 것이 전보다 훨씬 좋아 보인다. 단 하나, 테스트가 실패하고 있다는 것만 빼면 말이다. 리팩터링으로 정확히 무엇이 고장 났는지를 자세히 살펴봤지만, 알고 보니 아무것도 고장 나지 않았다. 기능은 예전과 같이 완벽하게 작동한다. 문제는 기반 코드를 수정하면 테스트가 빨간색으로 바뀌게끔 작성됐다는 것이다. 그리고 실제로 기능이 작동하지 않는지는 상관없다.  

이러한 상황을 거짓 양성(false positive)이라고 한다. 거짓 양성은 허위 경보다. 실제로 기능이 의도한 대로 작동하지만 테스트는 실패를 나타내는 결과다. 이러한 거짓 양성은 일반적으로 코드를 리팩터링할 때, 즉 구현을 수정하지만 식별할 수 있는 동작은 유지할 때 발생한다. 따라서 좋은 단위 테스트의 한 가지 특성으로 이름 붙이자면 '리팩터링 내성'이라 할 수 있다.  

리팩터링 내성 지표에서 테스트 점수가 얼마나 잘 나오는지 평가하려면 테스트에서 얼마나 많이 거짓 양성이 발생하는지 살펴봐야 한다. 적을수록 좋다.  

왜 그렇게 거짓 양성을 신경 쓰는가? 전체 테스트 스위트에 치명적인 영향을 줄 수 있기 때문이다. 단위 테스트의 목표는 프로젝트 성장을 지속 가능하게 하는 것이다. 테스트가 지속 가능한 성장을 하게 하는 메커니즘은 회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가할 수 있는 것이다. 여기에는 두 가지 장점이 있다.  

+ 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다. 이러한 조기 경고 덕분에 결함이 있는 모드가 운영 환경에 배포되기 훨씬 전에 문제를 해결할 수 있다. 운영 환경이었으면 문제를 처리하는 데 훨씬 더 많은 노력이 필요했을 것이다.  

+ 코드 변경이 회귀로 이어지지 않을 것이라고 확신하게 된다. 이러한 확신이 없으면 리팩터링 하는 데 주저하게 되고 코드베이스가 나빠질 가능성이 훨씬 높아진다.  

거짓 양성은 이 두 가지 이점을 모두 방해한다.  

+ 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희석된다. 시간이 흐르면서 그러한 실패에 익숙해지고 그만큼 신경을 많이 쓰지 않는다. 이내 타당한 실패도 무시하기 시작해 기능이 고장 나도 운영 환경에 들어가게 된다.  

+ 반면에 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 서서히 떨어지며, 더 이상 믿을 만한 안전망으로 인식하지 않는다. 즉, 허위 경보로 인식이 나빠진다. 이렇게 신뢰가 부족해지면 리팩터링이 줄어든다. 회귀를 피하려고 코드 변경을 최소한으로 하기 때문이다.  

하지만 리팩터링을 중단해서 이러한 상황을 피하고 싶지는 않다. 올바른 대응은 테스트 스위트를 다시 살펴보고 안정성을 높이기 시작하는 것이다.  

##### 4.1.3. 무엇이 거짓 양성의 원인인가?
<br/>

그렇다면 무엇이 거짓 양성의 원인인가? 그리고 어떻게 피할 수 있을까?  

테스트에서 발생하는 거짓 양성의 수는 테스트 구성 방식과 직접적인 관련이 있다. 테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항이 결합할수록 허위 경보가 더 많이 생긴다. 거짓 양성이 생길 가능성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리하는 것뿐이다. 테스트를 통해 SUT가 제공하는 최종 결과(관련된 절차가 아니라 식별할 수 있는 동작)를 검증하는지 확인해야 한다. 테스트는 최종 사용자의 관점에서 SUT를 검증해야 하고 최종 사용자에게 의미 있는 결과만 확인해야 한다. 다른 모든 것은 무시해야 한다.  

테스트를 구성하기에 가장 좋은 방법은 문제 영역에 대해 이야기하는 것이다. 이러한 테스트가 실패하면, 이야기와 실제 애플리케이션 동작이 서로 분리되는 것을 의미한다. 이는 테스트 실패 유형 중 유일하게 도움이 되는 유형이다. 이러한 실패는 항상 적시에 발생하며 무엇이 잘못됐는지 빨리 이해하는 데 도움이 된다. 다른 모든 실패는 중요한 것으로부터 주의를 돌리려는 소음일 뿐이다.  

다음 예를 살펴보자. 여기서 MessageRenderer 클래스는 머리글, 본문, 바닥글을 포함하는 메시지의 HTML 표현을 생성한다.  

```cs
public class Message
{
	public string Header { get; set; }
	public string Body { get; set; }
	public string Footer { get; set; }
}

public interface IRenderer
{
	string Render(Message message);
}

public class MessageRenderer : IRenderer
{
	public IReadOnlyList<IRenderer> SubRenderers { get; }

	public MessageRenderer()
	{
		SubRenderers = new List<IRenderer>
		{
			new HeaderRenderer(),
			new BodyRenderer(),
			new FooterRenderer()
		};
	}

	public string Render(Message message)
	{
		return SubRenderers.Select(x => x.Render(message))
						   .Aggregate("", (str1, str2) => str1 + str2);
	}
}
```

MessageRender 클래스에 여러 하위 렌더링 클래스가 있고, 메시지의 일부에 대한 실제 작업을 위임한다. 그런 다음 결과를 HTML 문서로 결합한다. 하위 렌더링 클래스는 원본 문자열을 HTML 태그로 조정한다. 예를 들면 다음과 같다.  

```cs
public class BodyRenderer : IRenderer
{
	public string Render(Message message)
	{
		return $"<b>{message.Body}</b>";
	}
}
```

MessageRender를 어떻게 테스트할 수 있을까? 한 가지 가능한 방법은 이 클래스가 따르는 알고리즘을 분석하는 것이다.  

```cs
[Fact]
public void MessageRenderer_uses_correct_sub_renderers()
{
	var sut = new MessageRender();

	IReadOnlyList<IRenderer> renderers = sut.SubRenderers;

	Assert.Equal(3, renderers.Count);
	Assert.IsAssignableFrom<HeaderRenderer>(renderers[0]);
	Assert.IsAssignableFrom<BodyRenderer>(renderers[1]);
	Assert.IsAssignableFrom<FooterRenderer>(renderers[2]);
}
```

이 테스트는 하위 렌더링 클래스가 예상하는 모든 유형이고 올바른 순서로 나타나는지 여부를 확인한다. 여기서 MessageRenderer가 메시지를 처리하는 방식도 정확해야 한다고 가정한다. 처음에는 테스트가 좋아 보이지만, MessageRenderer가 메시지를 처리하는 방식도 정확해야 한다고 가정한다. 처음에는 테스트가 좋아 보이지만, MessageRenderer의 식별할 수 있는 동작을 실제로 확인하는가? 하위 렌더링 클래스를 재배열하거나 그중 하나를 새 것으로 교체하면 어떻게 될까? 버그로 이어지는가?  

반드시 그렇지는 않다. 하위 렌더링 클래스르의 구성을 변경해도 HTML 문서가 동일하게 유지될 수 있다. 예를 들어 BodyRenderer를 동일한 작업을 수행하는 BoldRenderer로 바꿀 수 있다. 또는 모든 하위 렌더링 클래스를 제거하고 MessageRenderer에서 직접 렌더링을 구현할 수도 있다.  

최종 결과 바뀌지 않을지라도, 테스트를 수행하면 빨간색으로 변할 것이다. 이는 테스트가 SUT의 구현 세부 사항과 결합했기 때문이다. 이 테스트는 똑같이 적용할 수 있는 다른 구현을 고려하지 않고 특정 구현만 예상해서 알고리즘을 검사한다.  

MessageRenderer 클래스의 상당 부분을 리팩터링하면 테스트가 실패한다. 말하자면, 리팩터링 과정은 애플리케이션의 식별할 수 있는 동작에 영향을 주지 않으면서 구현을 변경하는 것이다. 그리고 변경할 때마다 빨간색으로 변하는 것은 바로 테스트가 구현 세부 사항에 관계돼 있기 때문이다.  

따라서 SUT의 구현 세부 사항과 결합된 테스트는 리팩터링 내성이 없다. 이러한 테스트는 앞에서 설명한 모든 단점을 보여준다.  

+ 회귀 발생 시 조기 경고를 제공하지 않는다. 대부분 잘못된 것이므로 이러한 경고는 무시하게 된다.
+ 리팩터링에 대한 능력과 의지를 방해한다. 당연하다. 버그를 찾을 때 테스트가 어느 방향인지 알려줄 수 없다면 누가 리팩터링하고 싶겠는가?  

##### 4.1.4. 구현 세부 사항 대신 최종 결과를 목표로 하기
<br/>

테스트를 깨지지 않게 하고 리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는 것뿐이다. 즉, 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 하는 것이다. 그러면 한 번 해보자.  

먼저 다음 사항을 확인해야 한다. MessageRenderer에서 얻는 최종 결과는 무엇인가? 메시지의 HTML 표현이다. 그리고 클래스에서 얻을 수 있는 관찰 가능한 결과이기 때문에 이를 확인하는 것이 마땅하다. 이 HTML 표현이 그대로 유지되는 한 정확히 어떻게 생성되는지는 걱정할 필요가 없다. 이러한 구현 세부 사항은 상관없다. 다음 코드는 테스트의 새 버전이다.  

```cs
[Fact]
public void Rendering_a_message()
{
	var sut = new MessageRenderer();
	var message = new Message
	{
		Header = "h",
		Body = "b",
		Footer = "f"
	};
	string html = sut.Render(message);
	Assert.Equal("<h1>h</h1><b>b</b><i>f</i>", html);
}
```

이 테스트는 MessageRenderer를 블랙박스로 취급하고 십려할 수 있는 동작에만 신경 쓴다. 결과적으로 테스트는 내성이 부쩍 늘었다. 즉 HTML 출력을 똑같이 지키는 한, SUT의 변경 사항은 테스트에 영향을 미치지 않는다.  

이 테스트는 원래 버전보다 크게 개선됐다. 최종 사용자에게 의미 있는 유일한 결과, 즉 브라우저에 메시지가 표시되는 방식을 검증해 비즈니스 요구 사항에 들어맞는다. 이 테스트는 항상 적시에 실패하고 고객에게 영향을 줄 수 있는 애플리케이션 동작의 변경을 알려주므로 개발자가 주의를 기울여야 한다. 이 테스트에 거짓 양성은 거의 없을 것이다.  

왜 완전히 없는 것이 아니고 거의 없는 것일까? MessageRenderer에 여전히 테스트가 실패하는 변경 사항이 있을 수 있기 때문이다. 예를 들어 Render() 메서드에 새 매개변수를 도입하면 컴파일 오류가 발생할 수 있다. 기술적으로 이러한 오류도 거짓 양성으로 간주한다. 결국 애플리케이션 동작 변경으로 인해 테스트가 실패하는 것은 아니다.  

그러나 이런 종류의 거짓 양성은 해결하기 쉽다. 컴파일러를 따라 Render() 메서드를 호출하는 모든 테스트에 새 매개변수를 추가하라. 좋지 않은 거짓 양성은 컴파일 오류를 내지 않는 것이다. 이러한 거짓 양성은 처리하기가 까다롭다. 타당한 버그를 가리키는 것처럼 보여서 조사하는 데 시간을 많이 들여야 하기 때문이다.  

#### 4.2. 첫 번째 특성과 두 번째 특성 간의 본질적인 관계
<br/>

##### 4.2.1. 테스트 정확도 극대화
<br/>

코드 정확도와 테스트 결과에 대해서는 네 가지 결과가 있을 수 있다. 테스트는 통과하거나 실패할 수 있다. 그리고 기능이 잘 작동할 수도 있고 고장 날 수도 있다.  

<table>
	<thead>
		<tr>
			<th colspan="2">오류 유형 표</th>
			<th rowsapn="2">기능</th>
		</tr>
		<tr>
			<th></th>
			<th>작동</th>
			<th>고장</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td colspan="2">테스트 결과</td>
			<td>테스트 통과</td>
			<td>올바른 추론(참 음성)</td>
			<td>2종 오류(거짓 음성)</td>
		</tr>
		<tr>
			<td></td>
			<td>테스트 실패</td>
			<td>1종 오류(거짓 양성)</td>
			<td>올바른 추론(참 양성)</td>
		</tr>
	</tbody>
</table>
<br/><br/>

테스트가 통과하고 기본 기능이 의도한 대로 잘 작동하는 상황은 올바른 추론이다. 테스트는 시스템의 상태를 올바르게 유추했다(버그 없음). 작동 기능과 통과 테스트의 조합에 대한 용어로 '참 음성'이라고 한다.  

마찬가지로 기능이 고장 나서 테스트가 실패해도 올바른 추론이다. 기능이 제대로 작동하지 않으면 테스트가 실패할 것으로 예상하기 때문이다. 이것이 단위 테스트의 핵심이다. 이 상황에 해당하는 용어는 '참 양성'이다.  

그러나 테스트에서 오류가 발생하지 않으면 문제가 된다. 이는 '거짓 음성'이다. 거짓 음성을 피하는 데 좋은 테스트의 첫 번째 특성인 회귀 방지가 도움이 된다. 회귀 방지가 훌륭한 테스트는 2종 오류인 거짓 음성의 수를 최소화하는 데 도움이 된다.  

반면에 기능은 올바르지만 테스트가 여전히 실패로 표시되는 대칭적인 상황이 있다. 이는 '거짓 양성', 즉 허위 경보다. 거짓 양성을 피하는 데 두 번째 특성인 리팩터링 내성이 도움이 된다.  

여기서 언급한 모든 용어(거짓 양성, 1종 오류 등)는 통계학에 뿌리를 두고 있지만, 테스트 스위트틀 분석하는 데도 적용할 수 있다. 테스트는 전체적으로 상황을 보지 않는다. 테스트의 맥락에서 긍정은 어떤 조건이 이제 사실임을 의미한다. 이러한 조건은 테스트가 반응하도록 작성자가 설정한 조건이다.  

즉, 확률이 낮을수록 테스트가 더 정확하다.  

이 정확도는 좋은 단위 테스트의 처음 두 개의 특성에 대한 것이다. 회귀 방지와 리팩터링 내성은 테스트 스위트의 정확도를 극대화하는 것을 목표로 한다. 정확도 지표는 다음 두 가지 요소로 구성된다.  

+ 테스트가 버그 있음을 얼마나 잘 나타내는가(거짓 음성(회귀 방지 영역) 제외).
+ 테스트가 버그 없음을 얼나만 잘 나타내는가(거짓 양성(리팩터링 내성 영역) 제외).  

거짓 양성과 거짓 음성을 생각해보는 다른 방법으로 소음 대비 신호 비율 측면에서 볼 수 있다. 테스트 정확도를 향상시키는 방법은 두 가지가 있다. 첫 번째 분자, 즉 신호를 증가시키는 것이다. 이는 회구를 더 잘 찾아내는 테스트로 개선하는 것이다. 두 번째는 분모, 즉 소움을 줄이는 것이다. 이는 허위 경보를 발생시키지 않는 테스트로 개선하는 것이다.  

테스트 정확도 = 신호(발견된 버그 수) / 소음(허위 경보 살행 수)  

가능한 한 소음(허위 경보)이 적은 강한 신호(버그를 찾을 수 있음)를 생성하면 테스트가 정확해진다.  

둘 다 매우 중요하다. 경보가 허위로 울리지 않더라도 버그를 찾을 수 없는 테스트는 소용이 없다. 마찬가지로 코드에서 모든 버그를 찾을 수 있더라도 소음이 많이 발생하면 테스트의 정확도는 0에 가까워진다.  

##### 4.2.2. 거짓 양성과 거짓 음성의 중요성: 역학 관계
<br/>

단기적으로는 거짓 양성도 거짓 음성만큼 나쁘지 않다. 프로젝트가 시작될 때, 잘못된 경고를 받는 것은 경고를 전혀 받지 않아 버그가 운영 환경에 들어갈 위험을 감수하는 것에 비해 별일이 아니다. 그러나 프로젝트가 성장함에 따라 거짓 양성은 테스트 스위트에 점점 더 큰 영향을 미치기 시작한다.  

초기에는 왜 거짓 양성이 중요하지 않은가? 리팩터링은 바로 중요하지는 않으며, 시간이 지나면서 점차 중요해진다. 프로젝트 초기에는 코드 정리를 많이 할 필요가 없다. 새로 작성된 코드는 완벽하고 반짝반짝하다. 개발자의 기억 속에 아직 생생하기 때문에 테스트에서 잘못된 경보가 발생하더라도 쉽게 리팩터링을 할 수 있다.  

그러나 시간이 흐를수록 코드베이스는 나빠진다. 점점 복잡해지고 체계적이지 않게 된다. 따라서 이러한 경향을 줄이려면 정기적으로 리팩터링을 해야 한다. 그렇지 않으면 새로운 기능에 드는 비용이 결국 엄청나게 커진다.  

리팩터링이 점점 더 필요해짐에 따라 테스트에서 리팩터링 내성도 점점 더 중요해진다.  

(특히 프로젝트 후반에) 거짓 양성으로부터 코드를 보호하는 것이 중요해도, 이렇게 거짓 양성을 신경 쓰는 개발자는 거의 없다. 대부분은 좋은 단위 테스트의 첫 번째 특성인 회귀 방지에만 중점을 두는 경향이 있는데, 회귀 방지는 프로젝트 성장을 유지하는 데 도움이 되고, 가치가 있으며, 매우 정확한 테스트 스위트를 구축하기에 충분하지 않다.  

물론 그 이유는 후반까지 너무 커지기 전에 개발이 끝나기 때문이다. 따라서 프로젝트에 가득히 쌓이고 모든 리팩터링 작업을 방해하는 잘못된 경보보다 눈에 띄지 않는 버그 문제에 직면한다. 그래서 사람들은 버그에 따라 최적화한다. 중대형 프로젝트에서 작업하면, 거짓 음성(알려지지 않은 버그)과 거짓 양성(허위 경보)에 대해 똑같이 주의를 기울여야 한다.  

#### 4.3. 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성
<br/>

테스트 속도가 빠를수록 테스트 스위트에서 더 많은 테스트를 수행할 수 있고 더 자주 실행할 수 있다.  

테스트가 빠르게 실행되면 코드에 결함이 생기자마자 버그에 대해 경고하기 시작할 정도로 피드백 루프를 대폭 줄여서, 버그를 수정하는 비용을 거의 0까지 줄일 수 있다. 반면에 느린 테스트는 피드백을 느리게 하고 잠재적으로 버그를 뒤늦게 눈에 띄게 해서 버그 수정 비용이 증가한다. 오래 걸리는 테스트는 자주 실행하지 못하기 때문에 잘못된 방향으로 가면서 시간을 더 많이 낭비하게 된다.  

마지막으로, 좋은 단위 테스트의 네 번째 특성인 유지 보수성 지표는 유지비를 평가한다. 이 지표는 다음 두 가지 주요 요소로 구성된다.  

+ 테스트가 얼마나 이해하기 어려운가  
이 구성 요소는 테스트의 크기와 관련이 있다. 테스트는 코드 라인이 적을수록 더 읽기 쉽다. 작은 테스트는 필요할 때 변경하는 것도 쉽다. 물론 단지 라인 수를 줄이려고 테스트 코드를 인위적으로 압축하지 않는다고 가정할 때다. 테스트 코드의 품질은 제품 코드만큼 중요하다. 테스트를 작성할 때 절차를 생략하지 말라. 테스트 코드를 '일급 시민(first-class citizen)'으로 취급하라.  

+ 테스트가 얼마나 실행하기 어려운가  
테스트가 프로세스 외부 종속성으로 작동하면, 데이터베이스 서버를 재부팅하고 네트워크 연결 문제를 해결하는 등 의존성을 상시 운영하는 데 시간을 들여야 한다.  

#### 4.4. 이상적인 테스트를 찾아서
<br/>

+ 회귀 방지
+ 리팩터링 내성
+ 빠른 피드백
+ 유지 보수성  

가치 주정치 = [0..1] &#42; [0..1] &#42; [0..1] &#42; [0..1]  

가치가 있으려면 테스트는 네 가지 범주 모두에서 점수를 내야 한다.  

물론 이러한 특성을 정확하게 측정하는 것은 불가능하다. 테스트에 붙여서 수치를 정홯기 얻을 수 있는 코드 분석 도구는 없다. 그러나 네 가지 특성과 관련해서 어디쯤 있는지는 비교적 정확하게 평가할 수 있다. 이 평가는 테스트의 가치 추정치를 제시하며, 이 추정치로 테스트 스위트에 테스트를 계속 둘지 여부를 결정할 수 있다.  

테스트 코드를 포함한 모든 코드는 책임(liability)이다. 최소 필수값에 대해 상당히 높은 임계치를 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라. 소수의 매우 가치 있는 테스트는 다수의 평범한 테스트보다 프로젝트가 계속 성장하는 데 훨씬 더 효과적이다.  

##### 4.4.1. 이상적인 테스트를 만들 수 있는가?
<br/>

이상적인 테스트는 네 가지 특성 모두에서 최대 점수를 받는 테스트다. 각 속성마다 최솟값과 최댓값을 각각 0과 1로 했을 때 이상적인 테스트는 모두 1을 얻어야 한다.  

안타깝게도 그런 이상적인 테스트를 만드는 것은 불가능하다. 처음 세 가지 특성인 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문이다. 세 가지 특성 모두 최대로 하는 것은 불가능하다. 셋 중 하나를 희생해야 나머지 둘을 최대로 할 수 있다.  

더욱이 곱셈 원리(이전 절의 가치 추정치 계산) 때문에 균형을 유지하는 것이 더욱 까다롭다. 다른 특성에 집중하려고 하나의 특성을 그냥 버릴 수는 없다. 앞에서 언급했듯이, 네 가지 범주 중 하나에서 0점을 받는 테스트는 가치가 없다. 따라서 특성 중 어느 것도 크게 줄지 않는 방식으로 최대한 크게 해야 한다. 두 특성을 최대로 하는 것을 목표로 해서 한 가지 특성을 희생해 결국 가치가 0에 가까워진 테스트를 몇 가지 예로 살펴보자.  

##### 4.4.2. 극단적인 사례 1: 엔드 투 엔드 테스트
<br/>

첫 번째 예는 엔드 투 엔드 테스트다.  

엔드 투 엔드 테스트는 많은 코드를 테스트하므로 회귀 방지를 훌륭히 해낸다. 실제로 모든 유형의 테스트 중에서 엔드 투 엔드 테스트가 직접 작성한 코드뿐만 아니라 외부 라이브러리, 프레임워크, 서드파티 애플리케이션 등과 같이 직접 작성하지 않았지만 프로젝트에서 사용하는 코드를 가장 많이 수행한다.  

또한 엔드 투 엔드 테스트는 거짓 양성에 면역이 돼 리팩터링 내성도 우수하다. 리팩터링은 (올바르게 했다면) 식별할 수 있는 동작을 변경하지 않으므로 엔드 투 엔드 테스트에 영향을 미치지 않는다. 이러한 테스트의 또 다른 장점으로, 어떤 특정 구현도 강요하지 않는다. 엔드 투 엔드 테스트는 최종 사용자의 관점에서 기능이 어떻게 동작하는지만 볼 수 있으며, 구현 세부 사항을 최대한 제거했다.  

그러나 이러한 이점에도 엔드 투 엔드 테스트에는 큰 단점이 있다. 그것은 바로 느린 속도다. 엔드 투 엔드 테스트에만 의존하는 모든 시스템은 피드백을 빨리 받기가 어려울 것이다. 그리고 많은 개발 팀의 큰 걸림돌이다. 이는 엔드 투 엔드 테스트만으로 코드베이스를 다루기가 불가능한 까닭이다.  

엔드 투 엔드 테스트는 회귀 오류와 거짓 양성에 대한 보호를 훌륭히 해내지만, 빠른 피드백의 지표에서 실패했다.  

##### 4.4.3. 극단적인 사례 2: 간단한 테스트
<br/>

엔드 투 엔드 테스트와 달리, 간단한 테스트는 매우 빠르게 실행되고 빠른 피드백을 제공한다. 또한 거짓 양성이 생길 가능성이 상당히 낮기 때문에 리팩터링 내성도 우수하다. 그러나 기반 코드에 실수할 여지가 많지 않기 때문에 간단한 테스트는 회귀를 나타내지 않을 것이다.  

심지어 간단한 테스트는 이름만 바꿀 뿐 '동어 반복 테스트(tautology test)'를 불러온다. 이러한 테스트는 항상 통과하거나 검증이 무의미하기 때문에 어떤 것도 테스트한다고 할 수 없다.  

간단한 테스트는 우수한 리팩터링 내성과 빠른 피드백을 제공하지만 회귀 방지가 없다.  

##### 4.4.4. 극단적인 사례 3: 깨지기 쉬운 테스트
<br/>

+ 깨지기 쉬운 테스트(brittle test)  
실행이 빠르고 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트  

깨지기 쉬운 테스트는 리팩터링을 견디지 못하고, 해당 기능이 고장 났는지 여부와 관계없이 빨간색으로 바뀐다.  

깨지기 쉬운 테스트는 빠르게 실행되고 회귀 방지를 훌륭히 해내지만, 리팩터링 내성은 거의 없다.  

##### 4.4.5. 이상적인 테스트를 찾아서: 결론
<br/>

좋은 단위 테스트의 처음 세 가지 특성(회귀 방지, 리팩터링 내성, 빠른 피드백) 중 두 가지를 극대화하는 테스트를 만들기는 매우 쉽지만, 나머지 특성 한 가지를 희생해야만 가능하다. 이러한 테스트는 곱셈 규칙으로 인해 가치가 0에 가까워진다. 안타깝게도 세 가지 특성 모두 완벽한 점수를 얻어서 이상적인 테스트를 만드는 것은 불가능하다.  

네 번째 특성인 유지 보수성은 엔 드 투 엔드 테스트를 제외하고 처음 세 가지 특성과 상관관계가 없다. 엔드 투 엔드 테스트는 관련된 모든 의존성을 설정해야 하므로 일반적으로 크기가 더 크다. 또한 이러한 의존성을 계속 운영하려면 추가적인 노력이 더 들게 된다. 따라서 엔드 투 엔드 테스트는 유지비 측면에서 더 비싼 경향이 있다.  

좋은 테스트를 만드는 특성 간에 균형을 이뤄내는 것은 쉽지 않다. 처음 세 가지 범주에서 점수를 모두 최대로 낼 수 없고, 유지 보수 관점을 걔속 지켜야 테스트가 꽤 짧아지고 간결해진다. 따라서 절충해야 한다. 더구나 어떤 특성도 0이 되지 않는 식으로 절충해야 한다. 부분적으로 그리고 전략적으로 희생해야 한다.  

그러나 실제로는 리팩터링 내성을 포기할 수 없다. 엔드 투 엔드 테스트만 쓰거나 테스트가 상당히 빠르지 않는 한, 리팩터링 내성을 최대한 많이 갖는 것을 목표로 해야 한다. 따라서 테스트가 얼마나 버그를 잘 찾아내는지(회귀 방지)와 얼마나 빠른지(빠른 피드백) 사이의 선택으로 절충이 귀결된다.  

최상의 테스트는 유지 보수성과 리팩터링 내성을 최대로 갖기 때문에 항상 이 두 특성을 최대화하도록 노력해야 한다.  

리팩터링 내성을 포기할 수 없는 이유는 테스트가 이 특성을 갖고 있는지 대부분 이진 선택이기 때문이다. 즉, 테스트에 리팩터링 내성이 있거나 없거나 둘 중 하나다. 그 사이에 중간 단계는 거의 없다. 따라서 리팩터링 내성을 조금만 인정할 수는 없다. 결국 리팩터링 내성을 완전히 포기해야 할 것이다. 반면에 회귀 방지와 빠른 피드백에 대한 지표는 조절이 가능하다.  

테스트 스위트를 탄탄하게 만들려면 테스트의 불안정성(거짓 양성)을 제거하는 것이 최우선 과제다.  

###### 4.4.5.1. CAP 정리
<br/>

CAP 정리는 분산 데이터 저장소가 다음 세 가지 보증 모두를 동시에 제공할 수 없음을 나타낸다.  

+ 일관성(consistency): 모든 읽기가 가장 최근의 쓰기 또는 오류를 수신하는 것을 의미한다.
+ 가용성(availability): 모든 요청이 (시스템 내 전체 노드 중단은 제외하고) 응답을 수신하는 것을 의미한다.
+ 분할 내성(partition tolerance): 네트워크 분할(네트워크 노드 간 연결 끊김)에도 시스템이 계속 작동함을 의미한다.  

좋은 단위 테스트의 처음 세 가지 특성과 비슷한 점이 있다.  

+ 첫째, 세 가지 중 두 가지를 선택하는 절충안을 선택해야 한다.
+ 둘째, 대규모 분산 시스템의 분할 내성도 타협할 수 없다.  

시스템 일부는 가용성을 높이고자 일관성을 약간 양보하는 것이 좋다. 병합 충돌을 피하려면 네트워크 노드는 최신 버전에 대한 합의가 필요하다.  

#### 4.5. 대중적인 테스트 자동화 개념 살펴보기
<br/>

##### 4.5.1. 테스트 피라미드 분해
<br/>

+ 테스트 피라미드  
테스트 스위트에서 테스트 유형 간의 일정한 비율  

+ 엔드 투 엔드 테스트
+ 통합 테스트
+ 단위 테스트  

어느 계층도 리팩터링 내성을 포기하지 않는다. 당연히 엔드 투 엔드 테스트와 통합 테스트가 단위 테스트보다 리팩터링 내성 지표가 더 높지만, 제품 코드에서 분리했을 때의 부작용만큼일 뿐이다. 모든 테스트는 거짓 양성을 가능한 한 적게 하는 것을 목표로 해야 한다. 심지어 제품 코드로 직접 작업할 때도 그래야 한다.  

테스트 유형 간의 정확한 비율은 각 팀과 프로젝트마다 다를 것이다. 그러나 일반적으로 피라미드 형태를 유지해야 한다. 즉 엔드 투 엔드 테스트가 가장 적고, 단위 테스트가 가장 많으며, 통합 테스트는 중간 어딘가에 있어야 한다.  

엔드 투 엔드 테스트가 적어야 하는 이유는 곱셈 규칙에 있다. 엔드 투 엔드 테스트는 빠른 피드백 지표에서 매우 낮은 점수를 받는다. 또 유지 보수성이 결여돼 있는데, 이는 크기가 더 큰 편이라 관련 프로세스 외부 의존성을 유지하는 데 노력을 더 들어야 한다. 따라서 엔드 투 엔드 테스트는 가장 중요한 기능(버그를 내고 싶지 않은 기능)에 적용할 때와 단위 테스트나 통합 테스트와 동일한 수준으로 보호할 때만 적용된다. 다른 용도로 엔드 투 엔드 테스트를 쓰는 것은 최소 필수값의 임계치를 넘으면 안 된다. 보통 단위 테스트가 더 안정적이므로 더 많이 있다.  

테스트 피라미드에는 예외가 있다. 예를 들어 모든 애플리케이션이 비즈니스 규칙이나 기타 복잡도가 거의 없는 기본적인 CRUD(생성(Create), 읽기(Read), 수정(Update), 삭제(Delete)) 작업이라면, 테스트 '피라미드'는 단위 테스트와 통합 테스트의 수가 같고 엔드 투 엔드 테스트가 없는 직사각형처럼 보일 것이다.  

단위 테스트는 알고리짐이나 비즈니스 복잡도가 없는 환경에서는 유용하지 않으므로 간단한 테스트 수준까지 빠르게 내려간다. 반면 통합 테스트는 그 가치가 잘 지켜진다. 코드가 아무리 단순하더라도 데이터베이스와 같이 다른 하위 시스템과 통합돼 잘 작동하는지 확인하는 것이 중요하다. 결국 단위 테스트는 더 적어지고 통합 테스트가 더 많아질 수 있다. 아주 단순한 예에서는 통합 테스트가 단위 테스트보다 훨씬 더 많을 수 있다.  

테스트 피라미드의 또 다른 예외는 프로젝트 외부 의존성(예: 데이터베이스) 하나만 연결하는 API다. 엔드 투 엔드 테스트를 더 많이 두는 것이 이러한 애플리케이션에 적합한 옵션일 수 있다. 사용자 인터페이스가 없으므로 엔드 투 엔드 테스트가 상당히 빠르게 실행된다. 단일 외부 의존성(데이터베이스)으로만 작동하기 때문에 유지비도 크지 않다. 기본적으로 엔드 투 엔드 테스트는 이러한 환경에서는 통합 테스트와 구별할 수 없다. 유일한 차이는 진입점이다. 엔드 투 엔드 테스트는 최종 사용자를 완전히 모방하도록 애플리케이션을 어딘가에 호스팅해야 하지만, 통합 테스트는 일반적으로 동일한 프로세스에서 애플리케이션을 호스팅한다.  

##### 4.5.2. 블랙박스 테스트와 화이트박스 테스트 간의 선택
<br/>

+ 블랙박스 테스트(black-box testing)는 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법이다. 일반적으로 몀세와 요구 사항, 즉 애플리케이션이 어떻게 해아 하는지가 아니라 무엇을 해야 하는지를 중심으로 구축된다.  

+ 화이트박스 테스트(white-box testing)는 정반대다. 애플리케이션의 내부 작업을 검증하는 테스트 방식이며, 테스트는 요구 사항이나 명세가 아닌 소스 코드에서 파생된다.  

화이트박스 테스트가 더 철저한 편이다. 소스 코드를 분석하면 외부 명세에만 의존할 때 놓칠 수 있는 많은 오류를 발견할 수 있다. 반면에 화이트박스 테스트는 테스트 대상 코드의 특성 구현과 결합돼 있기 때문에 깨지기 쉽다. 이러한 테스트는 거짓 양성을 많이 내고 리팩터링 내성 지표가 부족하다. 또한 비즈니스 담당자에게 의미가 있는 동작으로 유추할 수 없는데, 화이트 박스 테스트가 취약하고 가치를 많이 부여하지 않는다는 강력한 신호다. 블랙박스 테스트는 이와 정반대의 장단점을 제공한다.  

<table>
	<thead>
		<tr>
			<th></th>
			<th>회귀 방지</th>
			<th>리팩터링 내성</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>화이트박스 테스트</td>
			<td>좋음</td>
			<td>나쁨</td>
		</tr>
		<tr>
			<td>블랙박스 테스트</td>
			<td>나쁨</td>
			<td>좋음</td>
		</tr>
	</tbody>
</table>
<br/><br/>

화이트박스 테스트 대신 블랙박스 테스트를 기본으로 선택하라. 모든 테스트(단위 테스트, 통합 테스트, 엔드 투 엔드 테스트)가 시스템을 블랙박스로 보게 만들고 문제 영역에 의미 있는 동작을 확인하라. 테스트를 통해 비즈니스 요구 사항으로 거슬러 올라갈 수 없다면, 이는 테스트가 깨지기 쉬움을 나타낸다. 이 테스트를 재구성하거나 삭제하라. 기존 테스트 스위트로 두지 말라. 유일한 예외는 알고리즘 복잡도가 높은 유틸리티 코드를 다루는 경우다.  

테스트를 작성할 때는 블랙박스 테스트가 바람직하지만, 테스트를 분석할 때는 화이트박스 방법을 사용할 수 있다. 코드 커버리지 도구를 사용해서 어떤 코드 분기를 실행하지 않았는지 확인한 다음 코드 내부 구조에 대해 전혀 모르는 것처럼 테스트하라. 이러한 화이트박스 방법과 블랙박스 방법의 조합이 가장 효과적이다.  

#### 4.6. 요약
<br/>

+ 좋은 단위 테스트에는 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트 등 자동화된 테스트를 분석하는 데 사용할 수 있는 네 가지 기본 특성이 있다.
+ 회귀 방지
+ 리팩터링 내성
+ 빠른 피드백
+ 유지 보수성  

+ 회귀 방지는 테스트가 얼마나 버그(회귀)의 존재를 잘 나타내는지에 대한 척도다. 테스트가 코드를 더 많이 실행할수록 테스트에서 버그가 드러날 확률이 더 높아진다.  

+ 리팩터링 내성은 테스트가 거짓 양성을 내지 않고 애플리케이션 코드 리팩터링을 유지할 수 있는 정도를 의미한다.  

+ 거짓 양성은 허위 경보다. 즉, 테스트가 실패했다고 나타내지만 그 기능은 의도한대로 작동한다. 거짓 양성은 테스트 스위트에 치염적인 영향을 줄 수 있다.  

+ 허위 경보에 익숙해지고 주의를 기울이지 않기 때문에 코드 문제에 대응하려는 능력과 의지가 희석된다.  

+ 테스트를 신뢰할 수 있는 안전망으로 인식하는 것이 즐어들고 테스트 스위트에 대한 신뢰를 잃게 된다.  

+ 거짓 양성은 테스트 대상 시스템의 내부 구현 세부 사항과 테스트 간의 강결합의 결과다. 결합도를 낮추려면 테스트는 SUT가 수행한 단계가 아니라 SUT가 만든 최종 결과를 검증해야 한다.  

+ 회귀 방지와 리팩터링 내성은 테스트 정확도에 기여한다. 테스트는 가능한 한(리팩터링 내성 영역) 적은 소음(거짓 양성)으로 강한 신호(버그를 찾을 수 있음. 회귀 방지 영역)를 발생시키기 때문에 정확하다.  

+ 거짓 양성은 프로젝트 초기에 부정적인 영향을 미치지는 않지만 프로젝트가 성장함에 따라 점점 더 중요해진다. 즉, 거짓 음성(알려지지 않은 버그)만큼 중요하다.  

+ 빠른 피드백은 테스트가 얼마나 빨리 실행되는지에 대한 척도다.  

+ 유지 보수성은 두 가지 요소로 구성된다.  

+ 테스트 이해 난이도, 테스트가 작을수록 읽기 쉽다.  

+ 테스트 실행 난이도, 테스트에 관련된 프로세스 외부 의존성은 적을수록 쉽게 운영할 수 있다.  

+ 테스트의 가치 추정치는 네 가지 특성 각각에서 얻은 점수의 곱이다. 따라서 특성 중 하나라도 0이면, 테스트 가치도 0이 된다.  

+ 처음 세 가지 특성(회귀 방지, 리팩터링 내성, 빠른 피드백)은 상호 배타적이기 때문에 네 가지 특성 모두 최대 점수를 받는 것은 불가능하다. 테스트는 세 가지 특성 중 두 가지만 최대화할 수 있다.  

+ 리팩터링 내성은 타협할 수 없다. 테스트에 이 속성이 있는지 여부는 대부분 이진 선택, 즉 리팩터링 내성을 갖고 있거나 갖고 있지 않거나 둘 중 하나이기 때문이다. 특성 간의 절충은 회귀 방지와 빠른 피드백 사이의 선택으로 귀결된다.  

+ 테스트 피라미드는 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트의 일정한 비율을 일컫는다. 엔드 투 엔드 테스트가 가장 적고, 단위 테스트가 가장 많으며, 통합 테스트는 그 중간 정도라 할 수 있다.  

+ 피라미드에서는 테스트 유형마다 빠른 피드백과 회귀 방지 사이에서 다른 선택을 한다. 엔드 투 엔드 테스트는 회귀 방지를 선호하는 데 반해, 단위 테스트는 빠른 피드백을 선호한다.  

+ 테스트를 작성할 때는 블랙박스 테스트 방법을 사용하라. 테스트를 분석할 때는 화이트박스 방법을 사용하라.  

### 5. 목과 테스트 취약성
<br/>

#### 5.1. 목과 스텁 구분
<br/>

##### 5.1.1. 테스트 대역 유형
<br/>

+ 테스트 대역  
모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어로 주 용도는 테스트 편리성 재고  

테스트 대상 시스템으로 실제 의존성 대신 전달되므로 설정이나 유지보수가 어려울 수 있다.  

+ 목은 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 된다. 이러한 상호작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다.  

+ 스텁은 내부로 들어노는 상호 작용을 모방하는 데 도움이 된다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.  

+ 스파이는 목과 같은 역할을 한다. 스파이는 수동으로 작성하는 반면, 목은 목 프레임워크의 도움을 받아 생성된다. 가끔 '직접 작성한 목(handwritten mock)'이라고 부르기도 한다.  

+ 더미는 널(null) 값이나 가짜 문자열과 같이 단순하고 하드코딩된 값이다. SUT의 메서드 시그니처를 만족시키기 위해 사용하고 최종 결과를 만드는 데 영향을 주지 않는다.  

+ 스텁은 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성이다.  

+ 페이크는 대다수의 목적에 부합하는 스텁과 같다. 차이점은 의존성이다. 페이크는 아직 존재하지 않는 의존성을 대체하고자 구현한다.  

목은 SUT와 관련 의존성 간의 상호 작용을 모방하고 검사하는 반면, 스텁은 모방만 한다.  

##### 5.1.2. 도구로서의 목과 테스트 대역으로서의 목
<br/>

목 라이브러리에 있는 Mock 클래스는 도구로서의 목인 데 반해, 해당 클래스의 인스턴스인 mock은 테스트 대역으로서의 목이다.  

##### 5.1.3. 스텁으로 상호 작용을 검증하지 마라
<br/>

SUT에서 스텁으로의 호출은 SUT가 생성하는 최종 결과가 아니다. 이러한 호출은 최종 결과를 산출하기 위한 수단일 뿐이다. 즉, 스텁은 SUT가 출력을 생성하도록 입력을 제공한다.  

스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다.  

테스트에서 거짓 양성을 피하고 리팩터링 내성을 향상시키는 방법은 구현 세부 사항이 아니라 최종결과(이상적으로 비개발자들에게 의미가 있어야 함)를 검증하는 것뿐이다.  

+ 과잉 명세(overspecification)  
최종 결과가 아닌 사항을 검증하는 관행  

과잉 명세는 상호 작용을 검사할 때 흔하게 발생한다. 스텁과의 상호 작용을 확인하는 것은 쉽게 발견할 수 있는 결함이다. 테스트가 스텁과의 상호 작용을 확인해서는 안 되기 때문이다. 목은 더 복잡하다. 목을 쓰면 무조건 테스트 취약성을 초래하는 것은 아니지만, 대다수가 그렇다.  

##### 5.1.4. 목과 스텁 함께 쓰기
<br/>

때로는 목과 스텁의 특성을 모두 나타내는 테스트 대역을 만들 필요가 있다.  

```cs
[Fact]
public void Purchase_fails_when_not_enough_inventory()
{
	// 준비
	var storeMock = new Mock<IStore>();
	storeMock.Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
			 .Returns(true);
	var customer = new Customer();

	// 실행
	bool success = customer.Purchase(storeMock.Object, Product.Shampoo, 5);

	// 검증
	Assert.False(success);
	storeMock.Verify(x => x.RemoveInventory(Product.Shampoo, 5),
					 Times.Never);
}
```

테스트 대역은 목이면서 스텁이지만, 여전히 목이라고 부르지 스텁이라고 부르지는 않는다. 이름을 하나 골라야 하기도 하고, 목이라는 사실이 스텁이라는 사실보다 더 중요하기 때문에 대체로 목이라고 한다.  

##### 5.1.5. 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?
<br/>

CQRS(Command Query Responsibility Separation)와 유사하지만, 엄밀히 말하면 CQRS는 CQS에서 확장된 개념이다. CQS는 메서드 단위에서 분리하는 반면, CQRS는 객체나 시스템 단위에서 분리하는 점이 다르다.  

목과 스텁의 개념은 명령 조회 분리(CQS, Command Query Separation) 원칙과 관련이 있다. CQS 원칙에 따르면 모든 메서드는 명령이거나 조회여야 하며, 이 둘을 혼용해서는 안 된다. 명령은 부작용을 일으키고 어떤 값도 반환하지 않는 메서드(void 반환)다. 부작용의 예로는 객체 상태 변경, 파일 시스템 내 파일 변경 등이 있다. 조회는 그 반대로, 부작용이 없고 값을 반환한다.  

명령 조회 분리(CQS) 원칙에서는 명령은 목에 해당하는 반면, 조회는 스텁과 일치한다.  

이 원칙을 따르고자 할 경우, 메서드가 부작용을 일으키면 해당 메서드의 반환 타입이 void인지 확인하라. 그리고 메서드가 값을 반환하면 부작용이 없어야 한다. 다시 말해, 질문을 할 때 답이 달라져서는 안 된다. 멱등성이 보장돼야 한다는 의미와 같다. 이렇게 명확하게 분리하면 코드를 읽기 쉽다. 구현 세부 사항에 대해 자세히 설명하지 않고 시그니처만 봐도 메서드가 무엇을 하는지 알 수 있다.  

물론 항상 CQS 원칙을 따를 수 있는 것은 아니다. 부작용을 초래하고 값을 반환하는 것이 적절한 메서드는 있기 마련이다. 전형적인 예로 stack.Pop()이 있다. 이 메서드는 스택에서 최상위 요소를 제거해 호출자에게 반환한다. 그래도 가능할 때마다 CQS 원칙을 따르는 것이 좋다.  

#### 5.2. 식별할 수 있는 동작과 구현 세부 사항
<br/>

코드와 구현 세부 사항 간의 강결합을 피하는 방법은 코드가 생성하는 최종 결과(식별할 수 있는 동작)를 검증하고 구현 세부 사항과 테스트를 가능한 한 떨어뜨리는 것뿐이다. 즉, 테스트는 '어떻게'가 아니라 '무엇'에 중점을 둬야 한다.  

##### 5.2.1. 식별할 수 임ㅆ는 동작은 공개 API와 다르다
<br/>

모든 제품 코드는 2차원으로 분류할 수 있다.  

+ 공개 API(Application Programming Interface) 또는 비공개 API
+ 식별할 수 있는 동작 또는 구현 세부 사항  

각 차원의 범주는 겹치지 않는다. 즉, 메서드는 공개 API와 비공개 API 둘 다에 속할 수 없다. 마찬가지로, 코드는 내부 구현 세부 사항이거나 시스템의 식별할 수 있는 동작이지만 둘 다는 아니다.  

식별할 수 있는 동작과 내부 구현 세부 사항에는 미묘한 차이가 있다. 코드가 시스템의 식별할 수 있는 동작이려면 다음 중 하나를 해야 한다.  

+ 클라이언트가 목표를 달성하는 데 도움이 되는 연산(operation)을 노출하라. 연산은 계산을 수행하거나 부작용을 초래하거나 둘 다 하는 메서드다.  

+ 클라이언트가 목표를 달성하는 데 도움이 되는 상태(state)를 노출하라. 상태는 시스템의 현재 상태다.  

구현 세부 사항은 이 두 가지 중 아무것도 하지 않는다.  

코드가 식별할 수 있는 동작인지 여부는 해당 클라이언트가 누구인지. 그리고 해당 클라이언트의 목표가 무엇인지에 달려 있다. 식별할 수 있는 동작이 되려면 코드가 이러한 목표 중 하나에라도 직접적인 관계가 있어야 한다. 클라이언트라는 단어는 코드가 있는 위치에 따라 다른 것을 의미할 수 있다. 흔한 예로 동일한 코드베이스, 외부 애플리케이션, 또는 사용자 인터페이스 등의 클라이언트 코드가 있다.  

이상적으로 시스템의 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야 한다.  

그러나 종종 시스템의 공개 API가 식별할 수 있는 동작의 범위를 넘어 구현 세부 사항을 노출하기 시작한다. 이러한 시스템의 구현 세부 사항은 공개 API로 유출된다.  

##### 5.2.2. 구현 세부 사항 유출: 연산의 예
<br/>

클래스가 구현 세부 사항을 유출하는지 판단하는 데 도움이 되는 유용한 규칙이 있다. 단일한 목표를 달성하고자 클래스에서 호출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출할 가능성이 있다. 이상적으로는 단일 연산으로 개별 목표를 달성해야 한다.  

이 규칙은 비즈니스 로직이 포함된 대부분의 경우에 적용된다. 물론 예외가 있을 수 있다. 그래도 구현 세부 사항이 유출될 가능성이 있으면 이 규칙을 위반하는지 점검하라.  

##### 5.2.3. 잘 설계된 API와 캡슐화
<br/>

잘 설계된 API를 유지 보수하는 것은 캡슐화 개념과 관련이 있다. 캡슐화는 불변성 위반이라고도 하는 모순을 방지하는 조치다. 불변성은 항상 참이어야 하는 조건이다.  

불변성 위반으로 구현 세부 사항을 노출하게 된다. 즉, 구현 세부 사항을 노출하면 불변성 위반을 가져온다. 클라이언트는 불변성을 우회해서 이름을 먼저 정규화하지 않고 새로운 이름을 할당할 수 있었다.  

장기적으로 코드베이스 유지 보수에서는 캡슐화가 중요하다. 복잡도 때문이다. 코드 복잡도는 소프트웨어 개발에서 가장 큰 어려움 중 하나다. 코드베이스가 점점 복잡해질수록 작업하기가 더 어려워지고, 개발 속도가 느려지고, 버그 수가 증가하게 된다.  

계속해서 증가하는 코드 복잡도에 대처할 수 있는 방법은 실질적으로 캡슐화 말고는 없다. 코드 API가 해당 코드로 할 수 있는 것을 알려주지 않으면 코드가 변경됐을 때 모순이 생기지 않도록 많은 정보를 염두에 둬야 한다. 이는 프로그래밍 프로세스에 정신적 부담을 증대한다. 최대한 부담을 덜어라. 개발자 스스로가 항상 옳게만 한다고 믿을 수는 없으므로 실수할 가능성을 최대한 없애라. 이렇게 하는 데 가장 좋은 방법은 캡슐화를 올바르게 유지해 코드베이스에서 잘못할 수 있는 옵션조차 제공하지 않도록 하는 것이다. 캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다. 즉, 소프트웨어 프로젝트의 지속적인 성장을 가능하게 하는 것이다.  

'묻지 말고 말하라(tell-don't-ask)'라는 유사한 원칙이 있다. 데이터를 연산 기능과 결합하는 것을 의미한다. 이 원칙을 캡슐화 실천의 귀결로 볼 수 있다. 코드 캡슐화가 목표이지만, 구현 세부 사항을 숨기고 데이터와 기능을 결합하는 것이 해당 목표를 달성하기 위한 수단이다.  

+ 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다.
+ 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.  

##### 5.2.4. 구현 세부 사항 유출: 상태의 예
<br/>

모든 구현 새부 사항을 비공개로 하면 테스트가 식별할 수 있는 동작을 검증하는 것 외에는 다른 선택지가 없으며, 이로 인해 리팩터링 내성도 자동으로 좋아진다.  

잘 설계된 API의 정의에서 비롯된 또 다른 지침으로, 연산과 상태를 최소한으로 노출해야 한다. 클라이언트가 목표를 달ㄹ성하는 데 직접적으로 도움이 되는 코드만 공개해야 하며, 다른 모든 것은 구현 세부 사항이므로 비공개 API 뒤에 숨겨야 한다.  

식별할 수 있는 동작을 유출하는 문제 따위는 있을 수 없고, 이는 구현 세부 사항을 유출하는 문제와 정반대다. 구현 세부 사항(클라이언트가 사용하지 말아야 하는 메서드나 클래스)을 노출할 수 있지만, 식별할 수 있는 동작을 숨길 수는 없다. 식별할 수 있는 동작을 숨긴 메서드나 클래스는 클라이언트에서 더 이상 직접 사용할 수 없기 때문에 클라이언트 목표와 직접적인 연관이 있지 않다.  

<table>
	<thead>
		<tr>
			<th></th>
			<th>식별할 수 있는 동작</th>
			<th>구현 세부 사항</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>공개</td>
			<td>좋음</td>
			<td>나쁨</td>
		</tr>
		<tr>
			<td>비공개</td>
			<td>해당 없음</td>
			<td>좋음</td>
		</tr>
	</tbody>
</table>
<br/><br/>

#### 5.3. 목과 테스트 취약성 간의 관계
<br/>

##### 5.3.1. 육각형 아키텍처 정의
<br/>

전형적인 애플리케이션은 도메인과 애플리케이션 서비스라는 두 계층으로 구성된다. 도메인 계층은 애플리케이션의 중심부이기 때문에 중앙에 위치한다. 여기에는 애플리케이션의 필수 기능으로 비즈니스 로직이 포함돼 있다. 도메인 계층과 해당 비즈니스 로직은 이 애플리케이션을 다른 애플리케이션과 차별화하고 조직의 경쟁력을 향상시킨다.  

애플리케이션 서비스 계층은 도메인 계층 위에 있으며 외부 환경과의 통신을 조정한다. 예를 들어 애플리케이션이 RESTful API인 경우 API에 대한 모든 요청이 먼저 애플리케이션 서비스 계층에 도달한다. 이 계층은 도메인 클래스와 프로세스 외부 의존성 간의 작업을 조정한다. 다음은 애플리케이션 서비스에 대한 조정의 예다.  

+ 데이터베이스를 조회하고 해당 데이터로 도메인 클래스 인스턴스 구체화
+ 해당 인스턴스에 연산 호출
+ 결과를 데이터베이스에 다시 저장  

애플리케이션 서비스 계층과 도메인 계층의 조합은 육각형을 형성하며, 이 육각형은 애플리케이션을 나타낸다. 또한 다른 애플리케이션과 소통할 수 있고, 다른 애플리케이션도 육각형으로 나타낸다. 여기서 말하는 다른 애플리케이션은 SMTP 서비스, 서드파티 시스템, 메시지 버스 등이 될 수 있다. 여러 육각형이 서로 소통하면서 육각형 아키텍처를 구성한다.  

+ 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리  
비즈니스 로직은 애플리케이션의 가장 중요한 부분이다. 따라서 도메인 계층은 해당 비즈니스 로직에 대해서만 책임을 져야 하며, 다른 모든 책임에서는 제외돼야 한다. 외부 애플리케이션과 통신하거나 데이터베이스에서 데이터를 검색하는 것과 같은 책임은 애플리케이션 서비스에 귀속돼야 한다. 반대로 애플리케이션 서비스에는 어떤 비즈니스 로직도 있으면 안 된다. 요청이 들어오면 도메인 클래스의 연산으로 변환한 다음 결과를 저장하거나 호출자에게 다시 반환해서 도메인 계층으로 변환하는 책임이 있다. 도메인 계층을 애플리케이션의 도메인 지식(사용 방법) 모음으로, 애플리케이션 서비스 계층을 일련의 비즈니스 유스케이스(사용 대상)로 볼 수 있다.  

+ 애플리케이션 내부 통신  
육각형 아키텍처는 애플리케이션 서비스 계층에서 도메인 계층으로 흐르는 단방향 의존성 흐름을 규정한다. 도메인 계층 내부 클래스는 도메인 계층 내부 클래스끼리 서로 의존하고 애플리케이션 서비스 계층의 클래스에 의존하지 않는다. 애플리케이션 서비스 계층 간에 관심사를 분리하는 것은 애플리케이션 서비스 계층이 도메인 계층에 대해 아는 것을 의미하지만, 반대는 아니다. 도메인 계층은 외부 환경에서 완전히 격리돼야 한다.  

+ 애플리케이션 간의 통신  
외부 애플리케이션은 애플리케이션 서비스 계층에 있는 공통 인터페이스를 통해 해당 애플리케이션에 연결된다. 아무도 도메인 계층에 직접 접근할 수 없다. 육각형의 각 면은 애플리케이션 내외부 연결을 나타낸다. 육각형에는 여섯 면이 있지만, 애플리케이션이 다른 애플리케이션을 여섯 개만 연결할 수 있는 것은 아니다. 연결 수는 임의로 정할 수 있다. 요점은 이러한 연결이 많을 수 있다는 것이다.  

애플리케이션의 각 계층은 식별할 수 있는 동작을 나타내며 해당 구현 세부 사항을 포함하고 있다. 예를 들어 도메인 계층의 식별할 수 있는 동작은 이 계층의 연산과 상태이고, 연산과 상태는 애플리케이션 서비스 계층이 적어도 하나의 목표를 달성하는 데 도움이 된다. 잘 설계된 API의 원칙에는 프랙탈(fractal) 특성이 있는데, 이는 전체 계층만큼 크게도, 단일 클래스만큼 작게도 똑같이 적용되는 것이다.  

각 계층의 API를 잘 설계하면(즉, 구현 세부 사항을 숨기면) 테스트도 프랙탈 구조를 갖기 시작한다. 즉, 달성하는 목표는 같지만 서로 다른 수준에서 동작을 검증한다. 애플리케이션 서비스를 다루는 테스트는 해당 서비스가 외부 클라이언트에게 매우 중요하고 큰 목표를 어떻게 이루는지 확인한다. 그리고 도메인 클래스 테스트는 그 큰 목표의 하위 목표를 검증한다.  

각 테스트는 도메인 전문가에게 의미 있는 이야기를 전달해야 하며, 그렇지 않으면 테스트가 구현 세부 사항과 결합돼 있으므로 불안정하다는 강한 암시다.  

식별할 수 있는 동작은 바깥 계층에서 안쪽으로 흐른다. 외부 클라이언트에게 중요한 목표는 개별 도메인 클래스에서 달성한 하위 목표로 변환된다. 따라서 도메인 계층에서 식별할 수 있는 동작은 각각 구체적인 비즈니스 유스케이스와 연관성이 있다. 이 연관성을 가장 안쪽(도메인) 계층에서 애플리케이션 서비스 계층 바깥쪽으로, 그리고 외부 클라이언트의 요구 사항까지 재귀적으로 추적할 수 있다. 이 추적성은 식별할 수 있는 동작의 정의에 따른다. 코드 조각이 식별할 수 있는 동작이 되려면 클라이언트가 목표를 달성하도록 도울 필요가 있다. 도메인 클래스의 경우 클라이언트는 애플리케이션 서비스에 해당하고. 애플리케이션 서비스이면 외부 클라이언트에 해당한다.  

잘 설계된 API로 코드베이스를 검증하는 테스트는 식별할 수 있는 동작만 결합돼 있기 때문에 비즈니스 요구 사항과 관계가 있다.  

코드베이스의 공개 API를 항상 비즈니스 요구 사항에 따라 추적하라는 이 지침은 대부분의 도메인 클래스와 애플리케이션 서비스에 적용되지만, 유틸리티나 인프라 코드에는 적용되지 않는다. 해당 코드로 해결하는 문제는 너무 낮은 수준이고 세밀해서 구체적인 비즈니스 유스케이스로 추적할 수 없다.  

##### 5.3.2. 시스템 내부 통신과 시스템 간 통신
<br/>

일반적인 애플리케이션에는 시스템 내부(inter-system) 통신과 시스템 간(infra-system) 통신이 있다. 시스템 내부 통신은 애플리케이션 내 클래스 간의 통신이다. 시스템 간 통신은 애플리케이션이 다른 애플리케이션과 통신하는 것을 말한다.  

시스템 내부 통신은 구현 세부 사항이고, 시스템 간 통신은 그렇지 않다.  

연산을 수행하기 위한 도메인 클래스 간의 협력은 식별할 수 있는 동작이 아니므로 시스템 내부 통신은 구현 세부 사항에 해당한다. 이러한 협력은 클라이언트의 목표와 직접적인 관계가 없다. 따라서 이러한 협력과 결합하면 테스트가 취약해진다.  

애플리케이션 내부의 클래스 간 협력과 달리 시스템 외부 환경과 통신하는 방식은 전체적으로 해당 시스템의 식별할 수 있는 동작을 나타낸다. 이는 애플리케이션에 항상 있어야 한는 계약이다.  

시스템 간 통신의 특성은 별도 애플리케이션과 함께 성장하는 방식에서 비롯된다. 성장의 주요 원칙 중 하나로 하위 호환성을 지키는 것이다. 시스템 내부에서 하는 리팩터링과 다르게, 외부 애플리케이션과 통신할 때 사용하는 통신 패턴은 항상 외부 애플리케이션이 이해할 수 있도록 유지해야 한다. 예를 들어 애플리케이션이 메시지 버스로 전송하는 메시지는 구조를 지키고, SMTP 서비스 호출은 매개변수의 유형과 개수 등을 맞춰야 한다.  

목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다. 반대로 시스템 내 클래스 간의 통신을 검증하는 데 사용하면 테스트가 구현 세부 사항과 결합되며, 그에 따라 리팩터링 내성 지표가 미흡해진다.  

##### 5.3.3. 시스템 내부 통신과 시스템 간 통신의 예
<br/>

#### 5.4. 단위 테스트의 고전파와 런던파 재고
<br/>

런던파는 불변 의존성을 제외한 모든 의존성에 목 사용을 권장하며, 시스템 내 통신과 시스템 간 통신을 구분하지 않는다. 그 결과, 애플리케이션과 외부 시스템 간의 통신을 확인하는 것처럼 클래스 간 통신도 확인한다.  

런던파를 따라 목을 무분별하게 사용하면 종종 구현 세부 사항에 결합돼 테스트에 리팩터링 내성이 없게 된다.  

고전파는 테스트 간에 공유하는 의존성(대부분이 SMTP 서비스나 메시지 버스 등 프로세스 외부 의존성에 해당)만 교체하자고 하므로 이 문제에 훨씬 유리하다. 그러나 고전파 역시 시스템 간 통신에 대한 처리에 이상적이지는 않다. 런던파만큼은 아니지만, 고전파도 목 사용을 지나치게 장려한다.  

##### 5.4.1. 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다
<br/>

고전파에서는 공유 의존성을 피할 것을 권고한다. 테스트가 실행 컨텍스트를 서로 방해하고, 결국 병렬 처리를 할 수 없기 때문이다. 테스트를 병렬적, 순차적 또는 임의의 순서로 실행할 수 있는 것을 테스트 격리라고 한다.  

+ 테스트 격리  
테스트를 병렬적, 순차적 또는 임의의 순서로 실행할 수 있는 것

공유 의존성이 프로세스 외부에 있는 것이 아니면 각 테스트 실행 시 해당 의존성을 새 인스턴스로 써서 재사용을 피하기 쉽다. 공유 의존성이 프로세스 외부에 있으면, 테스트가 더 복잡해진다. 각 테스트 실행 전에 데이터베이스를 인스턴스화거나 메시지 버스를 새로 준비할 수가 없다. (이렇게 하면 테스트 스위트가 현저히 느려질 것이다.) 일반적인 접근법은 이러한 의존성을 테스트 대역, 즉 목과 스텁으로 교체하는 것이다.  

그러나 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다. 프로세스 외부 의존성이 애플리케이션을 통해서만 접근할 수 있으면, 이러한 의존성과의 통신은 시스템에서 식별할 수 있는 동작이 아니다. 실제로 외부에서 관찰할 수 없는 프로세스 외부 의존성은 애플리케이션의 일부로 작용한다.  

애플리케이션과 외부 시스템 간의 통신 패턴을 항상 지켜야 하는 요구 사항은 하위 호환성을 지켜야 한다는 점에서 비롯된다. 애플리케이션이 외부 시스템과 통신하는 방식을 지켜야 한다. 애플리케이션과 외부 시스템을 동시에 변경할 수 없기 때문이다. 또한 배포 주기가 다르거나 단순히 제어 권한이 없을 수 있기 때문이다.  

그러나 애플리케이션이 외부 시스템에 대한 프록시 같은 역할을 하고 클라이언트가 직접 접근할 수 없으면, 하위 호환성 요구 사항은 사라진다. 이제 이 외부 시스템과 애플리케이션을 같이 배포할 수 있으면 클라이언트에 영향을 미치지 않을 것이다. 이러한 시스템의 통신 패턴은 구현 세부 사항이 된다.  

좋은 예로는 애플리케이션 데이터베이스가 있다. 애플리케이션에서만 사용되는 데이터베이스다. 어떤 외부 시스템도 이 데이터베이스에 접근할 수 없다. 따라서 기존 기능을 손상시키지 않는 한 시스템과 애플리케이션 데이터베이스 간의 통신 패턴을 원하는 대로 수정할 수 있다. 해당 데이터베이스는 클라이언트의 시야에서 완전히 숨어있기 때문에 전혀 다른 저장 방식으로 대체할 수 있고, 그렇게 해도 아무도 모를 것이다.  

완전히 통제권을 가진 프로세스 외부 의존성을 목을 사용하면 깨지기 쉬운 테스트로 이어진다. 데이터베이스에서 테이블을 분할하거나 저장 프로시저에서 매개변수 타입을 변경할 때마다 테스트가 빨간색이 되는 것을 원하지 않는다. 데이터베이스와 애플리케이션은 하나의 시스템으로 취급해야 한다.  

이것은 분명히 문제가 될 수 있다.  

##### 5.4.2. 목을 사용한 동작 검증
<br/>

종종 목이 동작을 검증한다고 한다. 하지만 대부분의 경우 그렇지 않다. 목표를 달성하고자 각 개별 클래스가 이웃 클래스와 소통하는 방식은 식별할 수 있는 동작과는 아무런 관계가 없다. (이는 구현 세부 사항이다.)  

목은 애플리케이션의 경계를 넘나드는 상호 작용을 검증할 때와 이러한 상호 작용의 부작용이 외부 환경에서 보일 때만 동작과 관련이 있다.  

#### 5.5. 요약
<br/>

+ 테스트 대역은 테스트에서 비제품 가짜 의존성의 모든 유형을 설명하는 포괄적인 용어다. 테스트 대역에는 더미, 스텁, 스파이, 목, 페이크 등의 다섯 가지 변형이 있는데, 이는 다시 목과 스텁이라는 두 가지 유형으로 분류할 수 있다. 스파이는 기능적으로 목과 같고, 더미와 페이크는 스텁과 같은 역할을 한다.  

+ 목은 외부로 나가는 상호 작용(SUT에서 의존성으로의 호출로, 해당 의존성의 상태를 변경)을 모방하고 검사하는 데 도움이 된다. 스텁은 내부로 들어오는 상호 작용(SUT가 해당 의존성을 호출해 입력 데이터를 가져옴)을 모방하는 데 도움이 된다.  

+ Mock(도구)은 목(테스트 대역)이나 스텁을 만드는 데 사용할 수 있는 목 라이브러리의 클래스다.  

+ 명령 조회 분리(CQS) 원칙에 따르면, 모든 메서드가 명령 또는 조회 중 하나여야 하지만 둘 다는 안 된다. 명령을 대체하는 테스트 대역은 목이다. 조회를 대체하는 테스트 대역은 스텁이다.  

+ 모든 제품 코드는 공개 API인지 비공개 API 인지와 식별할 수 있는 동작인지 구현 세부 사항인지라는 두 가지 차원으로 분류할 수 있다. 코드의 공개성은 prvate, public, internal 키워드 등 접근 제한자에 의해 제어된다. 다음 요구 사항을 하나라도 충족하면 식별할 수 있는 동작이다. (둘 다 아니면 구현 세부 사항이다.)  

+ 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 부작용을 초래하거나 또는 둘 다 하는 메서드다.  

+ 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다.  

+ 잘 설계된 코드는 식별할 수 있는 동작이 공개 API와 일치하고 구현 세부 사항이 비공개 API 뒤에 숨겨져 있는 코드다. 공개 API가 식별할 수 있는 동작 이상으로 커지면 코드는 구현 세부 사항을 유츌한다.  

+ 캡슐화는 코드를 불변성 위반으로부터 보호하는 행위다. 클라이언트는 구현 세부 사항을 사용해 코드의 불변성을 우회할 수 있기 때문에 세부 사항을 노출하면 캡슐화가 위반되는 경우가 종종 있다.  

+ 육각형 아키텍처는 상호 작용하는 애플리케이션의 집합이고 각 애플리케이션은 육각형으로 표시한다. 각 육각형은 도메인과 애플리케이션 서비스라는 두 계층으로 구성된다.  

+ 육각형 아키텍처는 다음과 같은 세 가지 관점을 강조한다.  

+ 도메인과 애플리케이션 서비스 계층 간의 영향 분리, 도메인 계층은 비즈니스 로직을 책임져야 하고, 애플리케이션 서비스는 도메인 계층과 외부 애플리케이션 간의 작업을 조정해야 한다.  

+ 애플리케이션 서비스 계층에서 도메인 계층으로의 단방향 의존성 흐름. 도메인 계층 내 클래스는 서로에게만 의존해야 하고, 애플리케이션 서비스 계층의 클래스에 의존해서는 안 된다.  

+ 외부 애플리케이션은 애플리케이션 서비스 계층이 유지하는 공통 인터페이스를 통해 연결된다. 아무도 도메인 계층에 직접 액세스할 수 없다.  

+ 육각형의 각 계층은 식별할 수 있는 동작을 나타내며 각각의 구현 세부 사항이 있다.  

+ 애플리케이션에는 시스템 내부 통신과 시스템 간 통신이라는 두 가지 통신 유형이 있다. 시스템 내부 통신은 애플리케이션 내 클래스 간의 통신이다. 시스템 간 통신은 애플리케이션이 외부 애플리케이션과 통신할 때를 말한다.  

+ 시스템 내 통신을 검증하고자 목을 사용하면 취약한 테스트로 이어진다. 따라서 시스템 간 통신(애플리케이션 경계를 넘는 통신)과 해당 통신의 부작용이 외부 환경에서 보일 때만 목을 사용하는 것이 타당하다.  

### 6. 단위 테스트 스타일
<br/>

#### 6.1. 단위 테스트이 세 가지 스타일
<br/>

##### 6.1.1. 출력 기반 테스트 정의
<br/>

+ 출력 기반 스타일  
테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 점검하는 방식의 테스트 스타일  

출력 기반 스타일은 전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다.  

출력 기반 단위 테스트 스타일은 함수형(functional)이라고도 한다. 이 이름은 부작용 없는 코드 선호를 강조하는 프로그래밍 방식인 함수형 프로그래밍(functional programming)에 뿌리를 두고 있다.  

##### 6.1.2. 상태 기반 스타일 정의
<br/>

+ 상태 기반 스타일  
작업이 완료된 후 시스템 상태를 확인하는 것  

이 테스트 스타일에서 상태라는 용어는 SUT나 협력자 중 하나, 또는 데이터베이스나 파일 시스템 등과 같은 프로세스 외부 의존성의 상태 등을 의미할 수 있다.  

##### 6.1.3. 통신 기반 스타일 정의
<br/>

+ 통신 기반 스타일  
목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증  

#### 6.2. 단위 테스트 스타일 비교
<br/>

##### 6.2.1. 회귀 방지와 피드백 속도 지표로 스타일 비교하기
<br/>

회귀 방지 지표는 특정 스타일에 따라 달라지지 않는다. 회귀 방지 지표는 다음 세 가지 특성으로 결정된다.  

+ 테스트 중에 실행되는 코드의 양
+ 코드 복잡도
+ 도메인 유의성  

보통 실행하는 코드가 많든 적든 원하는 대로 테스트를 작성할 수 있다. 어떤 스타일도 이 부분에서 도움이 되지 않느다. 코드 복잡도와 도메인 유의성 역시 마찬가지다. 통신 기반 스타일에는 예외가 하나 있다. 남용하면 작은 코드 조각을 검증하고 다른 것은 모두 목을 사용하는 등 피상적인 테스트가 될 수 있다. 하지만 이는 통신 기반 테스트의 결정적인 특징이 아니라 기술을 남용하는 극단적인 사례다.  

테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없다. 테스트가 프로세스 외부 의존성과 떨어져 단위 테스트 영역에 있는 한, 모든 스타일은 테스트 실행 속도가 거의 동일하다. 목은 런타임에 지연 시간이 생기는 편이므로 통신 기반 테스트가 약간 나쁠 수 있다. 그러나 이러한 테스트가 수만 개 수준이 아니라면 별로 차이는 없다.  

##### 6.2.2. 리팩터링 내성 지표로 스타일 비교하기
<br/>

리팩터링 내성 지표와 관련해서는 상황이 다르다. 리팩터링 내성은 리팩터링 중에 발생하는 거짓 양성(허위 경보) 수에 대한 척도다. 결국 거짓 양성은 식별할 수 있는 동작이 아니라 코드의 구현 세부 사항에 결합된 테스트의 결과다.  

출력 기반 테스트는 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수하다. 이러한 테스트가 구현 세부 사항에 결합하는 경우는 테스트 대상 메서드가 구현 세부 사항일 때뿐이다.  

상태 기반 테스트는 일반적으로 거짓 양성이 되기 쉽다. 이러한 테스트는 테스트 대상 메서드 외에도 클래스 상태와 함께 작동한다. 확률적으로 말하면, 테스트와 제품 코드 간의 결합도가 클수록 유출되는 구현 세부 사항에 테스트가 얽매일 가능성이 커진다. 상태 기반 테스트는 큰 API 노출 영역에 의존하므로, 구현 세부 사항과 결합할 가능성도 더 높다.  

통신 기반 테스트가 허위 경보에 가장 취약하다. 테스트 대역으로 상호 작용을 확인하는 테스트는 대부분 깨지기 쉽다. 이는 항상 스텁과 상호 작용하는 경우다. 이러한 상호 작용을 확인해서는 안 된다. 애플리케이션 경계를 넘는 상호 작용을 확인하고 해당 상호 작용의 부작용이 외부 환경에 보이는 경우에만 목이 괜찮다. 보다시피, 리팩터링 내성을 잘 지키려면 통신 기반 테스트를 사용할 때 더 신중해야 한다.  

그러나 피상적인 테스트가 통신 기반 테스트의 결정적인 특징이 아닌 것처럼, 불안정성도 통신 기반 테스트의 결정적인 특징이 아니다. 캡슐화를 잘 지키고 테스트를 식별할 수 있는 동작에만 결합하면 거짓 양성을 최소로 줄일 수 있다. 물론 단위 테스트 스타일에 따라 필요한 노력도 다르다.  

##### 6.2.3. 유지 보수성 지표로 스타일 비교하기
<br/>

마지막으로 유지 보수성 지표는 단위 테스트 스타일과 밀접한 관련이 있다. 그러나 리팩터링 내성과 달리 완화할 수 있는 방법이 많지 않다. 유지 보수성은 단위 테스트의 유지비를 측정하며, 다음 두 가지 특성으로 정의한다.  

+ 테스트를 이해하기 얼마나 어려운가(테스트 크기에 대한 함수)?
+ 테스트를 실행하기 얼마나 어려운가(테스트에 직접적으로 관련 있는 프로세스 외부 의존성 개수에 대한 함수)?  

테스트가 크면, 필요할 때 파악하기도 변경하기도 어려우므로 유지 보수가 쉽지 않다. 마찬가지로 하나 이상의 프로세스 외부 의존성(데이터베이스 등)과 직접 작동하는 테스트는 데이터베이스 서버 재부팅, 네트워크 연결 문제 해결 등과 같이 운영하는 데 시간이 필요하므로 유지 보수가 어렵다.  

###### 6.2.3.1. 출력 기반 테스트의 유지 보수성
<br/>

다른 두 가지 스타일과 비교하면, 출력 기반 테스트가 가장 유지 보수하기 용이하다. 출력 기반 테스트는 거의 항상 짧고 간결하므로 유지 보수가 쉽다. 이러한 이점은 메서드로 입력을 공급하는 것과 해당 출력을 검증하는 두 가지로 요약할 수 있다는 사실에서 비롯된다. 단 몇 줄로 이 두 가지를 수행할 수 있다.  

출력 기반 테스트의 기반 코드는 전역 상태나 내부 상태를 변경할 리 없으므로, 프로세스 외부 의존성을 다루지 않는다. 따라서 두 가지 유지 보수성 모두의 측면에서 출력 기반 테스트가 가장 좋다.  

###### 6.2.3.2. 상태 기반 테스트의 유지 보수성
<br/>

상태 기반 테스트는 일반적으로 출력 기반 테스트보다 유지 보수가 쉽지 않다. 상태 검증은 종종 출력 검증보다 더 많은 공간을 차지하기 때문이다.  

대부분 코드를 숨기고 테스트를 단축하는 헬퍼 메서드로 문제를 완화할 수 있지만, 이러한 메서드를 작성하고 유지하는 데 상당한 노력이 필요하다.  

상태 기반 테스트를 단축하는 또 다른 방법으로, 검증 대상 클래스의 동등 멤버를 정의할 수 있다. 또한 Fluent Assertions와 같은 검증문 라이브러리를 써서 테스트를 단순하게 할 수 있다.  

이 두 가지 기법(헬퍼 메서드 사용과 값 객체로 클래스 변환하기)은 가끔만 적용할 수 있다. 그리고 이러한 기법을 적용할 수 있더라도 상태 기반 테스트는 출력 기반 테스트보다 공간을 더 많이 차지하므로 유지 보수성이 떨어진다.  

###### 6.2.3.3. 통신 기반 테스트의 유지 보수성
<br/>

+ 목 사슬(mock chain)  
목이 다른 목을 반환하고, 그 다른 목은 또 다른 목을 반환하는 식으로 여러 계층이 있는 목이나 스텁  

통신 기반 테스트는 유지 보수성 지표에서 출력 기반 테스트와 상태 기반 테스트보다 점수가 낮다. 통신 기반 테스트에는 테스트 대역과 상호 작용 검증을 설정해야 하며, 이는 공간을 많이 차지한다. 목이 사슬 형태로 있을 때(다시 말해, 목 사슬(mock chain)) 테스트는 더 커지고 유지 보수하기가 어려워진다.  

##### 6.2.4. 스타일 비교하기: 결론
<br/>

<table>
	<thead>
		<tr>
			<th></th>
			<th>출력 기반</th>
			<th>상태 기반</th>
			<th>통신 기반</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>리팩터링 내성을 지키기 위해 필요한 노력</td>
			<td>낮음</td>
			<td>중간</td>
			<td>중간</td>
		</tr>
		<tr>
			<td>유지비</td>
			<td>낮음</td>
			<td>중간</td>
			<td>높음</td>
		</tr>
	</tbody>
</table>
<br/><br/>

출력 기반 테스트가 가장 결과가 좋다. 이 스타일은 구현 세부 사항과 거의 결합되지 않으므로 리팩터링 내성을 적절히 유지하고자 주의를 많이 기울일 필요가 없다. 이러한 테스트는 간결하고 프로세스 외부 의존성이 없기 때문에 유지 보수도 쉽다.  

상태 기반 테스트와 통신 기반 테스트는 두 지표 모두 좋지 않다. 유출된 구현 세부 사항에 결합할 가능성이 높고, 크기도 커서 유지비가 많이 든다.  

그러므로 항상 다른 것보다 출력 기반 테스트를 선호하라. 하지만 안타깝게도 말하기는 쉬워도 행하기는 어렵다. 출력 기반 스타일은 함수형으로 작성된 코드에만 적용할 수 있고, 대부분의 객체지향 언어에는 해당하지 않는다. 그래도 테스트를 출력 기반 스타일로 변경하는 기법이 있다.  

#### 6.3. 함수형 아키텍처 이해
<br/>

##### 6.3.1. 함수형 프로그래밍이란?
<br/>

출력 기반 단위 테스트 스타일은 함수형이라고도 한다. 기반 제품 코드를 함수형 프로그래밍을 이용해 순수 함수 방식으로 작성해야 하기 때문이다.  

+ 함수형 프로그래밍  
수학적 함수(mathematical function, pure function)를 사용한 프로그래밍  

수학점 함수는 숨은 입출력이 없는 함수(또는 메서드)다. 수학적 함수의 모든 입출력은 메서드 이름, 인수, 반환 타입으로 구성된 메서드 시그니처(method signature)에 명시해야 한다. 수학적 함수는 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성한다.  

수학에서의 함수는 첫 번째 집합의 각 요소에 대해 두 번째 집합에서 정확히 하나의 요소를 찾는 두 집합 사이의 관계다.  

입출력을 명시한 수학적 함수는 이에 따르는 테스트가 짧고 간결하며 이해하고 유지 보수하기 쉬우므로 테스트하기가 매우 쉽다. 출력 기반 테스트를 적용할 수 있는 메서드 유형은 수학적 함수뿐이다. 이는 유지 보수성이 뛰어나고 거짓 양성 빈도가 낮다.  

반면에 숨은 입출력은 코드를 테스트하기 힘들게 한다(가독성도 떨어짐). 숨은 입출력의 유형은 다음과 같다.  

+ 부작용  
메서드 시그니처에 표시되지 않은 출력이며, 따라서 숨어있다. 연산은 클래스 인스턴스의 상태를 변경하고 디스크의 파일을 업데이트하는 등 부작용을 발생시킨다.  

+ 예외  
메서드가 예외를 던지면, 프로그램 흐름에 메서드 시그니처에 설정된 계약을 우회하는 경로를 만든다. 호출된 예외는 호출 스택의 어느 곳에서도 발생할 수 있으므로, 메서드 시그니처가 전달하지 않는 출력을 추가한다.  

+ 내외부 상태에 대한 참조  
DateTime.Now와 같이 정적 속성을 사용해 현재 날짜와 시간을 가져오는 메서드가 있을 수 있다. 데이터베이스에서 데이터를 질의할 수 있고, 비공개 변경 가능 필드를 참조할 수도 있다. 이 모두 메서드 시그니처에 없는 실행 흐름에 대한 입력이며, 따라서 숨어있다.  

메서드가 수학적 함수인지 판별하는 가장 좋은 방법은 프로그램의 동작을 변경하지 않고 해당 메서드에 대한 호출을 반환 값으로 대체할 수 있는지 확인하는 것이다. 메서드 호출을 해당 값으로 바꾸는 것을 참조 투명성(referential transparency)이라고 한다.  

부작용은 숨은 출력의 가장 일반적인 유형이다.  

##### 6.3.2. 함수형 아키텍처란?
<br/>

물론 어떤 부작용도 일으키지 않는 애플리케이션을 만들 수는 없다. 이러한 애플리케이션은 비현실적이다.  

함수형 프로그래밍의 목표는 부작용을 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리하는 것이다. 이 두 가지 책임은 각각만 보더라도 충분히 복잡하다. 모두 고려하면 복잡도가 배가되고 장기적으로 코드의 유지 보수성을 방해한다. 함수형 아키텍처는 바로 이곳에 적용된다. 부작용을 비즈니스 연산 끝으로 몰아서 비즈니스 로직을 부작용과 분리한다.  

함수형 아키텍처는 부작용을 다루는 코드를 최소화하면서 순수 함수(불변) 방식으로 작성한 코드의 양을 극대화한다. '불변(immutable)'이란 변하지 않는 것을 의미한다. 일단 객체가 생성되면 그 상태는 바꿀 수 없다. 이는 생성 후 수정할 수 있는 변경 가능한(mutable) 객체와 대조적이다.  

다음 두 가지 코드 유형을 구분해서 로직과 부작용을 분리할 수 있다.  

+ 결정을 내리는 코드  
이 코드는 부작용이 필요 없기 때문에 수학적 함수를 사용해 작성할 수 있다.  

+ 해당 결정에 따라 작용하는 코드  
이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다.  

결정을 내리는 코드는 종종 함수형 코어(functional core, 불변 코어(immutable core)라고도 함)라고도 한다. 해당 결정에 따라 작용하는 코드는 가변 셸(mutable shell)이다.  

함수형 아키텍처에서 함수형 코어는 수학적 함수를 사용해 구현되며 애플리케이션에서 모든 결정을 내린다. 가변 셸은 함수형 코어에 입력 데이터를 제공하고 데이터베이스와 같은 프로세스 외부 의존성에 부작용을 적용해 그 결정을 해석한다.  

함수형 코어와 가변 셸은 다음과 같은 방식으로 협력한다.  

+ 가변 셸은 모든 입력을 수집한다.
+ 함수형 코어는 결정을 생성한다.
+ 셸은 결정을 부작용으로 변환한다.  

이 두 계층을 계속 잘 분리하려면, 가변 셸이 의사 결정을 추가하지 않게끔 결정을 나타내는 클래스에 정보가 충분히 있는지 확인해야 한다. 다시 말해, 가변 셸은 가능한 한 아무 말도 하지 않아야 한다. 목표는 출력 기반 테스트로 함수형 코어를 두루 다루고 가변 셸을 훨씬 더 적은 수의 통합 테스트에 맡기는 것이다.  

###### 6.3.2.1. 캡슐화와 불변성
<br/>

캡슐화와 같이, (일반적으로) 함수형 아키텍처와 (특히) 불변성은 단위 테스트와 같은 목표가 있다. 소프트웨어 프로젝트의 지속적인 가능하게 하는 것이다. 실제로 캡슐화 개념과 불변성 개념 사이에는 같은 연관성이 있다.  

캡슐화는 코드에 모순이 생기지 않도록 보호하는 행위다. 캡슐화는 다음을 통해 클래스 내부가 변질되지 않도록 보호한다.  

+ 데이터 수정이 가능한 API 노출 영역 축소
+ 나머지 API를 철저히 조사  

불변성은 다른 각도에서 존재하는 불변을 해결한다. 불변 클래스를 사용하면 변경할 수 없는 것을 처음부터 변형할 수 없으므로 상태 변질에 대해 걱정할 필요가 없다. 결과적으로 함수형 프로그래밍에서 캡슐화할 필요가 없으며, 인스턴스를 만들 때 클래스의 상태를 한 번만 확인하면 된다. 그 후에 이 인스턴스를 자유롭게 전달할 수 있다. 모든 데이터가 불변일 때 캡슐화가 되지 않아 생긴 문제는 모두 간단히 사라진다.  

##### 6.3.3. 함수형 아키텍처와 육각형 아키텍처 비교
<br/>

함수형 아키텍처와 육각형 아키텍처는 비슷한 점이 많다. 둘 다 관심사 분리라는 아이디어를 기반으로 한다. 그러나 분리를 둘러싼 구체적인 내용은 다양하다.  

육각형 아키텍처는 도메인 계층과 애플리케이션 서비스 계층을 구별한다. 도메인 계층은 비즈니스 로직에 책임이 있는 반면, 애플리케이션 서비스 계층은 데이터베이스나 SMTP 서비스와 같이 외부 애플리케이션과의 통신에 책임이 있다. 이는 결정과 실행을 분리하는 함수형 아키텍처와 매우 유사하다.  

또 다른 유사점은 의존성 간의 단방향 흐름이다. 육각형 아키텍처에서 도메인 계층 내 클래스는 서로에게만 의존해야 한다. 애플리케이션 서비스 계층의 클래스에 의존해서는 안 된다. 마찬가지로 함수형 아키텍처의 불변 코어는 가변 셸에 의존하지 않는다. 자급할 수 있고 외부 계층과 격리돼 작동할 수 있다. 이로 인해 함수형 아키텍처를 테스트하기 쉽다. 가변 셸에서 불변 코어를 완전히 떼어내 셸이 제공하는 입력을 단순한 값으로 모방할 수 있다.  

이 둘의 차이점은 부작용에 대한 처리에 있다. 함수형 아키텍처는 모든 부작용을 불변 코어에서 비즈니스 연산 가장자리로 밀어낸다. 이 가장자리는 가변 셸이 처리한다. 반면 육각형 아키텍처는 도메인 계층에 제한하는 한, 도메인 계층으로 인한 부작용도 문제없다. 육각형 아키텍처의 모든 수정 사항은 도메인 계층 내에 있어야 하며, 걔층의 경계를 넘어서는 안 된다. 예를 들어 도메인 클래스 인스턴스는 데이터베이스에 직접 저장할 수 없지만, 상태는 변경할 수 있다. 애플리케이션 서비스에서 이 변경 사항을 데이터베이스 적용한다.  

함수형 아키텍처는 육각형 아키텍처의 하위 집합이다. 극단적으로는 함수형 아키텍처를 육각형 아키텍처로 볼 수도 있다.  

#### 6.4. 함수형 아키텍처와 출력 기반 테스트로의 전환
<br/>

##### 6.4.1. 감사 시스템 소개
<br/>

샘플 프로젝트는 조직의 모든 방문자를 추적하는 감사 시스템이다. 이 시스템은 가장 최근 파일의 마지막 줄에 방문자의 이름과 방문 시간을 추가한다. 파일당 최대 항목 수에 도달하면 인덱스를 증가시켜 새 파일을 작성한다.  

```cs
public class AuditManager
{
	private readonly int _maxEntriesPerFile;
	private readonly string _directoryName;

	public AuditManager(int maxEntriesPerFile, string directoryName)
	{
		_maxEntriesPerFile = maxEntriesPerFile;
		_directoryName = directoryName;
	}

	public void AddRecord(string visitorName, DateTime timeOfVisit)
	{
		string[] filePaths = Directory.GetFiles(_directoryName);
		(int index, string path)[] sorted = SortByIndex(filePaths);

		string newRecord = visitorName + ';' + timeOfVisit;

		if (sorted.Length == 0)
		{
			string newFile = Path.Combine(_directoryName, "audit_1.txt");
			File.WriteAllText(newFile, newRecord);
			return;
		}

		(int currentFileIndex, string currentFilePath) = sorted.Last();
		List<string> lines = File.ReadAllLines(currentFilePath).ToList();

		if (lines.Count < _maxEntriesPerFile)
		{
			lines.Add(newRecord);
			string newContent = string.Join("\r\n", lines);
			File.WriteAllText(currentFilePath, newContent);
		}
		else
		{
			int newIndex = currentFileIndex + 1;
			string newName = $"audit_{newIndex}.txt";
			string newFile = Path.Combine(_directoryName, newName);
			File.WriteAllText(newFile, newRecord);
		}
	}
}
```

코드가 다소 많아 보일 수 있지만 꽤 간단하다. AuditManager는 애플리케이션의 주요 클래스다. 생성자는 파일당 최대 항목 수와 작업 디렉터리를 설정 매개변수로 받는다. 이 클래스에 공개 메서드는 AddRecord뿐이며, 감사 시스템의 모든 작업을 수행한다.  

+ 작업 디렉터리에서 전체 파일 목록을 검색한다.
+ 인덱스별로 정렬한다(모든 파일 이름은 audit&#95;{index}.txt와 같은 패턴을 따른다. 예: audit&#95;1.text).
+ 아직 감사 파일이 없으면 단일 레코드로 첫 번째 파일을 생성한다.
+ 감사 파일이 있으면 최신 파일을 가져와서 파일의 항목 수가 한계에 도달했는지에 따라 새 레코드를 추가하거나 새 파일을 생성한다.  

AuditManager 클래스는 파일 시스템과 밀접하게 연결돼 있어 그대로 테스트하기가 어렵다. 테스트 전에 파일을 올바른 위치에 배치하고, 테스트가 끝나면 해당 파일을 읽고 내용을 확인한 후 삭제해야 한다.  

노력을 더 들이면 유지비가 크게 증가하지만, 이렇게 하지 않고서는 테스트를 병렬 처리할 수 없을 것이다. 병목 지점은 파일 시스템이다. 이는 테스트가 실행 흐름을 방해할 수 있는 공유 의존성이다.  

또 파일 시스템은 테스트를 느리게 한다. 로컬 시스템과 빌드 서버 모두 작업 디렉터리가 있고 테스트할 수 있어야 하므로 유지 보수성도 저하된다.  

한편 파일 시스템에 직접 작동하는 테스트는 단위 테스트의 정의에 맞지 않는다. 단위 테스트의 두 번째와 세 번째 특성을 준수하지 않으므로, 통합 테스트 범주에 속한다.  

##### 6.4.2. 테스트를 파일 시스템에서 분리하기 위한 목 사용
<br/>

테스트가 밀접하게 결합된 문제는 일반적으로 파일 시스템을 목으로 처리해 해결한다. 파일의 모든 연산을 별도의 클래스(IFileSystem)로 도출하고 AuditManager에 생성자로 해당 클래스를 주입할 수 있다. 그런 다음 테스트는 이 클래스를 목으로 처리하고 감사 시스템이 파일에 수행하는 쓰기를 캡처한다.  

테스트는 파일 시스템을 목으로 처리해 감사 시스템이 파일에 수행하는 쓰기를 캡처할 수 있다.  

다음 예제에서는 파일 시스템이 AuditManager에 어떻게 주입되는지 보여준다.  

```cs
public interface IFileSystem
{
	string[] GetFiles(string directoryName);
	void WriteAllText(string filePath, string content);
	List<string> ReadAllLines(string filePath);
}

public class AuditManager
{
	private readonly int _maxEntriesPerFile;
	private readonly string _directoryName;
	private readonly IFileSystem _fileSystem;

	public AuditManager(int maxEntriesPerFile, string directoryName, IFileSystem fileSystem)
	{
		_maxEntriesPerFile = maxEntriesPerFile;
		_directoryName = directoryName;
		_fileSystem = fileSystem;
	}
}
```

다음은 AddRecord 메서드다.  

```cs
public void AddRecord(string visitorName, DateTime timeOfVisit)
{
	string[] filePaths = _fileSystem.GetFiles(_directoryName);
	(int index, string path)[] sorted = SortByIndex(filePaths);
	string newRecord = visitorName + ';' + timeOfVisit;

	if (sorted.Length == 0)
	{
		string newFile = Path.Combine(_directoryName, "audit_1.txt");
		_fileSystem.WriteAllText(
		newFile, newRecord);
		return;
	}

	(int currentFileIndex, string currentFilePath) = sorted.Last();
	List<string> lines = _fileSystem.ReadAllLines(currentFilePath);

	if (lines.Count < _maxEntriesPerFile)
	{
		lines.Add(newRecord);
		string newContent = string.Join("\r\n", lines);
		_fileSystem.WriteAllText(
		currentFilePath, newContent);
	}
	else
	{
		int newIndex = currentFileIndex + 1;
		string newName = $"audit_{newIndex}.txt";
		string newFile = Path.Combine(_directoryName, newName);
		_fileSystem.WriteAllText(newFile, newRecord);
	}
}
```

이제 AuditManager가 파일 시스템에서 분리되므로, 공유 의존성이 사라지고 테스트를 서로 독립적으로 실행할 수 있다. 다음은 그러한 테스트다.  

```cs
[Fact]
public void A_new_file_is_created_when_the_current_file_overflows()
{
	var fileSystemMock = new Mock<IFileSystem>();
	fileSystemMock.Setup(x => x.GetFiles("audits"))
				  .Returns(new string[] {
				 	@"audits\audit_1.txt",
					@"audits\audit_2.txt"
				  });

	fileSystemMock.Setup(x => x.ReadAllLines(@"audits\audit_2.txt"))
				  .Returns(new List<string> {
					"Peter; 2019-04-06T16:30:00",
					"Jane; 2019-04-06T16:40:00",
					"Jack; 2019-04-06T17:00:00"
				  });

	var sut = new AuditManager(3, "audits", fileSystemMock.Object);
	sut.AddRecord("Alice", DateTime.Parse("2019-04-06T18:00:00"));
	fileSystemMock.Verify(x => x.WriteAllText(@"audits\audit_3.txt", "Alice 2019-04-06T18:00:00"));
}
```

이 테스트는 현재 파일의 항목 수가 한계(이 예제에서는 세 개)에 도달했을 때, 감사 항목이 하나 있는 새 파일을 생성하는지 검증한다. 이는 목을 타당하게 사용하는 것이다. 애플리케이션은 최종 사용자가 볼 수 있는 파일을 생성한다(최종 사용자가 다른 프로그램(전용 소프트웨어 또는 단순한 notepad.exe)을 사용해 파일을 읽은 것으로 가정). 따라서 파일 시스템과의 통신과 이러한 통신의 부작용(파일 변경)은 애플리케이션의 식별할 수 있는 동작이다.  

이 구현은 초기 버전보다 개선됐다. 테스트는 더 이상 파일 시스템에 접근하지 않으므로 더 빨리 실행된다. 테스트를 만족시키려고 파일 시스템을 다룰 필요가 없으므로 유지비도 절감된다. 리팩터링을 해도 회귀 방지와 리팩터링 내성이 나빠지지 않았다.  

하지만 더 개선할 수 있다. 테스트는 복잡한 설정을 포함하며, 이는 유지비 측면에서 이상적이지 않다. 목 라이브러리가 최선을 다해 도움을 주지만, 작성된 테스트는 여전히 평이한 입출력에 의존하는 테스트만큼 읽기가 쉽지 않다.  

##### 6.4.3. 함수형 아키텍처로 리팩터링하기
<br/>

인터페이스 뒤로 부작용을 숨기고 해당 인터페이스를 AuditManager에 주입하는 대신, 부작용을 클래스 외부로 완전히 이동할 수 있다. 그러면 AuditManager는 파일에 수행할 작업을 둘러싼 결정만 책임지게 된다. 새로운 클래스인 Persister는 그 결정에 따라 파일 시스템에 업데이트를 적용한다.  

Persister와 AuditManager는 함수형 코어(불변 코어)에 해당한다. 다음 예제는 리팩터링 후의 AuditManager다.  

```cs
public class Persister
{
	public FileContent[] ReadDirectory(string directoryName)
	{
		return Directory.GetFiles(directoryName)
						.Select(x => new FileContent(Path.GetFileName(x), File.ReadAllLines(x)))
						.ToArray();
	}

	public void ApplyUpdate(string directoryName, FileUpdate update)
	{
		string filePath = Path.Combine(directoryName, update.FileName);
		File.WriteAllText(filePath, update.NewContent);
	}
}

public class FileContent
{
	public readonly string FileName;
	public readonly string[] Lines;

	public FileContent(string fileName, string[] lines)
	{
		FileName = fileName;
		Lines = lines;
	}
}

public class FileUpdate
{
	public readonly string FileName;
	public readonly string NewContent;

	public FileUpdate(string fileName, string newContent)
	{
		FileName = fileName;
		NewContent = newContent;
	}
}

public class AuditManager
{
	private readonly int _maxEntriesPerFile;

	public AuditManager(int maxEntriesPerFile)
	{
		_maxEntriesPerFile = maxEntriesPerFile;
	}

	public FileUpdate AddRecord(FileContent[] files, string visitorName, DateTime timeOfVisit)
	{
		(int index, FileContent file)[] sorted = SortByIndex(files);
		string newRecord = visitorName + ';' + timeOfVisit;

		if (sorted.Length == 0)
		{
			return new FileUpdate("audit_1.txt", newRecord);
		}

		(int currentFileIndex, FileContent currentFile) = sorted.Last();
		List<string> lines = currentFile.Lines.ToList();

		if (lines.Count < _maxEntriesPerFile)
		{
			lines.Add(newRecord);
			string newContent = string.Join("\r\n", lines);
			return new FileUpdate(currentFile.FileName, newContent);
		}
		else
		{
			int newIndex = currentFileIndex + 1;
			string newName = $"audit_{newIndex}.txt";
			return new FileUpdate(newName, newRecord);
		}
	}
}
```

AuditManager는 이제 작업 디렉터리 경로 대신 FileContent 배열을 받는다. 이 클래스는 결정을 내리기 위해 파일 시스템에 대해 알아야 할 모든 것을 포함한다.  

또한 작업 디렉터리의 파일을 변경하는 대신, 이제 AuditManager는 수행하려는 부작용에 대한 명령을 반환한다.  

이 클래스가 얼마나 간결한지 확인해보자. 작업 디렉터리에서 내용을 읽고 AuditManager에서 받은 업데이트 명령을 작업 디렉터리에 다시 수행하기만 하면 된다. 여기에는 분기가 없다(if문 없음). 따라서 모든 복잡도는 AuditManager 클래스에 있다. 이것이 비즈니스 로직과 부작용의 분리다.  

이렇게 분리를 유지하려면, FileContent와 FileUpdate의 인터페이스를 프레임워크에 내장된 파일 상호 작용 명령과 최대한 가깝게 둬야 한다. 파싱과 준비 모두 함수형 코어에서 수행하므로, 함수형 코어 외부의 코드는 간결하게 유지된다. 예를 들어, .NET에 파일 내용을 문자열 배열로 반환하는 내장 함수인 File.ReadAllLines()가 있지 않고 단일 문자열을 반환하는 File.ReadAllText()만 있으면, FileContent의 Lines 속성을 문자열로 바꾸고 AuditManager에서 파싱해야 한다.  

```cs
public class FileContent
{
	public readonly string FileName;
	public readonly string Text; // 이전에는 string[] Lines;
}
```

AuditManager와 Persister를 붙이려면, 다음 예제에서 보듯이 육각형 아키텍처 분류 체계상 애플리케이션 서비스라는 또 다른 클래스가 필요하다.  

```cs
public class ApplicationService
{
	private readonly string _directoryName;
	private readonly AuditManager _auditManager;
	private readonly Persister _persister;

	public ApplicationService(string directoryName, int maxEntriesPerFile)
	{
		_directoryName = directoryName;
		_auditManager = new AuditManager(maxEntriesPerFile);
		_persister = new Persister();
	}
	public void AddRecord(string visitorName, DateTime timeOfVisit)
	{
		FileContent[] files = _persister.ReadDirectory(_directoryName);
		FileUpdate update = _auditManager.AddRecord(files, visitorName, timeOfVisit);
		_persister.ApplyUpdate(_directoryName, update);
	}
}
```

함수형 코어와 가변 셸을 붙이면서 애플리케이션 서비스가 외부 클라이언트를 위한 시스템의 진입점을 제공한다. 이러한 구현으로 감사 시스템의 동작을 쉽게 확인할 수 있다. 이제 모든 테스트는 작업 디렉터리의 가상 상태를 제공하고 AuditManager가 내린 결정을 검증하는 것으로 단축했다.  

ApplicationService는 함수형 코어(AuditManager)와 가변 셸(Persister)을 붙이고, 외부 클라이언트를 위한 진입점을 제공한다. 육각형 아키텍처 분류법에서 ApplicationService와 Persister는 애플리케이션 서비스 계층에 해당하고, AuditManager는 도메인 모델에 속한다.  

```cs
[Fact]
public void A_new_file_is_created_when_the_current_file_overflows()
{
	var sut = new AuditManager(3);
	var files = new FileContent[] {
		new FileContent("audit_1.txt", new string[0]),
		new FileContent("audit_2.txt", new string[] {
			"Peter; 2019-04-06T16:30:00",
			"Jane; 2019-04-06T16:40:00",
			"Jack; 2019-04-06T17:00:00"
		})
	};

	FileUpdate update = sut.AddRecord(files, "Alice", DateTime.Parse("2019-04-06T18:00:00"));
	Assert.Equal("audit_3.txt", update.FileName);
	Assert.Equal("Alice;2019-04-06T18:00:00", update.NewContent);
}
```

이 테스트는 목을 사용한 테스트와 같이 초기 버전에 비해 빠른 피드백이 개선됐을 뿐만 아니라 유지 보수성 지표도 향상됐다. 더 이상 복잡한 목 설정이 필요 없고, 단순한 입출력만 필요하므로 테스트 가독성을 크게 향상시킨다.  

함수형 코어가 생성한 명령은 항상 값이거나 값 집합이다. 값은 내용이 일치하는 한, 두 인스턴스를 서로 바꿀 수 있다. 이 사실을 활용하면, FileUpdate를 값 객체로 전환해서 테스트 가독성을 더욱 향상시킬 수 있다. .NET에서 하려면, 클래스를 구조체(struct)로 변환하거나 동등 멤버를 따로 정의해야 한다. 그러면 참조 비교 대신 값 비교(C# 클래스의 기본 동작)를 할 수 있다. 값으로 비교하면 위의 예제의 두 검증문을 하나로 압축할 수 있다.  

```cs
Assert.Equal(new FileUpdate("audit_3.txt", "Alice;2019-04-06T18:00:00"), update);
```


또는 Fluent Assertions를 사용하면 다음과 같다.  

```cs
update.Should().Be(new FileUpdate("audit_3.txt", "Alice;2019-04-06T18:00:00"));
```

##### 6.4.4. 예상되는 추가 개발
<br/>


잠시 뒤로 물러나서 샘플 프로젝트에 있을 만한 추가 개발 사항들을 살펴보자. 감사 시스템은 매우 간단하고 다음 세 가지 분기만 있다.  

+ 작업 디렉터리가 비어있는 경우 새로운 파일 작성
+ 기존 파일에 새 레코드 추가
+ 현재 파일의 항목 수가 한도를 초과할 때 다른 파일 작성  

그리고 유스케이스는 감사 기록에 항목을 추가하는 것뿐이다. 특정 방문자에 대한 언급을 모두 삭제하는 등 다른 유스케이스가 있다면 어떨까? 시스템이 유효성 검사(예: 방문자 이름의 최대 길이)를 해야 한다면 어떨까?  

특정 방문자에 대한 언급을 모두 삭제하려면 여러 파일에 영향을 줄 수 있으므로, 새 메서드는 여러 개의 파일 명령을 반환해야 한다.  

```cs
public FileUpdate[] DeleteAllMentions(FileContent[] files, string visitorName)
```

또한 비즈니스 담당자가 작업 디렉터리에 빈 파일을 두지 않도록 요구할 수 있다. 삭제 항목이 감사 파일의 마지막 항목이면, 해당 파일도 같이 제거해야 한다. 이 요구 사항을 구현하려면, FileUpdate를 FileAction이라는 이름으로 바꾸고, ActionType 열거형 필드를 추가해서 업데이트인지 삭제인지를 나타낼 수 있다.  

함수형 아키텍처를 통해 오류 처리가 더욱 간단해지고 명확해진다. FileUpdate 클래스나 별도의 구성 요소로 메서드 시그니처에 오류를 포함할 수 있다.  

```cs
public (FileUpdate update, Error error) AddRecord(FileContent[] files, string visitorName, DateTime timeOfVisit)
```

그러면 애플리케이션 서비스에서 이 오류를 확인할 수 있다. 오류가 있으면 서비스는 업데이트 명령을 Persister에 넘기지 않고, 사용자에게 오류 메시지를 전달한다.  

#### 6.5. 함수형 아키텍처의 단점 이해하기
<br/>

##### 6.5.1. 함수형 아키텍처 적용 가능성
<br/>

감사 시스템은 결정을 내리기 전에 입력을 모두 미리 수집할 수 있으므로 함수형 아키텍처가 잘 작동했다. 그러나 종종 실행 흐름이 간단하지 않다. 의사 결정 절차의 중간 결과에 따라 프로세스 외부 의존성에서 추가 데이터를 질의할 수도 있다.  

예를 들어보자. 지난 24시간 동안 방문 횟수가 임계치를 초과하면 감사 시스템이 방문자의 접근 레벨을 확인해야 한다고 해보자. 그리고 방문자의 접근 레벨이 모두 데이터베이스에 저장돼 있다고 가정하자. 다음과 같이 IDatabase 인스턴스를 AuditManager에 전달할 수 있다.  

```cs
public FileUpdate AddRecord(FileContent[] files, string visitorName, DateTime timeOfVisit, IDatabase database)
```

이 인스턴스는 AddRecord() 메서드에 숨은 입력이 생겼다. 따라서 이 메서드는 수학적 함수가 될 수 없으며 더 이상 출력 기반 테스트를 적용할 수 없다.  

데이터베이스에 대한 의존성으로 인해 감사 관리자에 숨은 입력이 생겼다. 더 이상 순수 함수가 아니며, 전체 애플리케이션은 더 이상 함수형 아키텍처를 따르지 않는다.  

이러한 상황에는 두 가지 해결책이 있다.  

+ 애플리케이션 서비스 전면에서 디렉터리 내용과 더불어 방문자 접근 레벨을 수집할 수 있다.
+ AuditManager에서는 IsAccessLevelCheckRequired()와 같은 새로운 메서드를 둬야 한다. 애플리케이션 서비스에서 AddRecord() 전에 이 메서드를 호출하고, true를 반환하면 서비스는 데이터베이스에서 접근 레벨을 가져온 후 AddRecord()에 전달한다.  

두 방법 모두 단점은 있다. 첫 번째 방법은 성능이 저하된다. 접근 레벨이 필요 없는 경우에도 무조건 데이터베이스에 질의한다. 그러나 이 방법은 비즈니스 로직과 외부 시스템과의 통신을 완전히 계속 분리할 수 있다. 즉, 이전과 같이 모든 의사 결정이 AuditManager에 있다. 두 번째 방법은 성능 향상을 위해 분리를 다소 완화한다. 데이터베이스를 호출자에 대한 결정은 AuditManager가 아니라 애플리케이션 서비스로 넘어간다.  

이 두 가지 옵션과 달리, 도메인 모델(AuditManager)을 데이터베이스에 의존하는 것은 좋은 생각이 아니다.  

###### 6.5.1.1. 협력자의 값
<br/>

AuditManager의 AddRecord() 메서드는 메서드 시그니처에 없는 의존성(&#95;maxEntriesPerFile 필드)이 있다는 점을 눈치챘을 것이다. 감사 관리자는 이 필드를 참조해 기존 감사 파일에 추가하거나 새 감사 파일을 생성할지 결정한다.  

이 의존성이 메서드 인자에는 없을지라도 숨긴 것은 아니다. 클래스의 생성자 시그니처에 있을 수 있다. &#95;maxEntriesPerFile 필드는 불변이므로 클래스를 인스턴스할 때와 AddRecord()를 호출할 때 모두 동일하다. 즉, 해당 필드는 값이다.  

IDatabase 의존성은 &#95;maxEntriesPerFile과 같은 값이 아니라 협력자이므로 상황이 다르다.  

+ 가변(상태 수정 가능)
+ 아직 메모리에 있지 않은 데이터에 대한 프록시(공유 의존성)  

IDatabase 인스턴스는 두 번째 범주에 속하므로 협력자에 해당한다. 프로세스 외부 의존성에 대한 호출이 더 필요하므로 출력 기반 테스트를 사용할 수 없다.  

함수형 코어의 클래스는 협력자로 작동하면 안 되고, 작업의 결과인 값으로 작동해야 한다.  

##### 6.5.2. 성능 단점
<br/>

시스템 전체에 영향을 미치는 성능은 함수형 아키텍처의 흔한 논쟁이다. 문제가 되는 것은 테스트의 성능이 아니다. 출력 기반 테스트는 목을 사용한 테스트만큼 빠르게 작동한다. 이제 시스템은 프로세스 외부 의존성을 더 많이 호출하고, 그 결과로 성능이 떨어졌다. 감사 시스템의 초기 버전과 목이 있는 버전 모두 작업 디렉터리에서 모든 파일을 읽지는 않았다. 그러나 최종 버전은 읽고-결정하고-실행하기(read-decide-act) 방식을 따르도록 작업 디렉터리의 모든 파일을 읽었다.  

함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성(제품 코드와 테스트 코드 모두) 간의 절충이다. 성능 영향이 그다지 눈에 띄지 않는 일부 시스템에서는 함수형 아키텍처를 사용해 유지 보수성을 향상시키는 편이 낫다. 다른 경우라면, 반대로 선택해야 할 수도 있다. 두루 적용되는 해결책은 없다.  

##### 6.5.3. 코드베이스 크기 증가
<br/>

코드베이스의 크기도 마찬가지다. 함수형 아키텍처는 함수형 코어(불변 코어)와 가변 셸 사이를 명확하게 분리해야 한다. 궁극적으로 코드 복잡도가 낮아지고 유지 보수성이 향상되지만, 초기에 코딩이 더 필요하다.  

그러나 모든 프로젝트에 초기 투자가 타당할 만큼 복잡도가 높은 것은 아니다. 어떤 코드베이스는 너무 단순하거나 비즈니스 관점에서 그다지 중요하지 않다. 켤코 초기 투자로 성과를 내지 못하기 때문에 이러한 프로젝트에서 함수형 아키텍처를 사용하는 것은 별 의미가 없다. 항상 시스템의 복잡도와 중요성을 고려해 함수형 아키텍처를 전략적으로 적용하라.  

마지막으로, 함수형 방식에서 순수성에 많은 비용이 든다면 순수성을 따르지 말라. 대부분의 프로젝트에서는 모든 도메인 모델을 불변으로 할 수 없기 때문에 (적어도 C#이나 자바와 같은 객체지향 프로그래밍 언어를 사용할 때) 출력 기반 테스트에만 의존할 수 없다. 대부분의 경우 출력 기반 스타일과 상태 기반 스타일을 조합하게 되며, 통신 기반 스타일을 약간 섞어도 괜찮다.  

#### 6.6. 요약
<br/>

+ 출력 기반 테스트는 SUT에 입력을 주고 출력을 확인하는 테스트 스타일이다. 이 테스트 스타일은 숨은 입출력이 없다고 가정하고, SUT 작업의 결과는 반환하는 값뿐이다.

+ 상태 기반 테스트는 작업이 완료된 후의 시스템 상태를 확인한다.

+ 통신 기반 테스트는 목을 사용해서 테스트 대상 시스템과 협력자 간의 통신을 검증한다.

+ 단위 테스트의 고전파는 통신 기반 스타일보다 상태 기반 스타일을 선호한다. 런던파는 반대를 선호한다. 두 분파 모두 출력 기반 테스트를 사용한다.

+ 출력 기반 테스트가 테스트 품질이 가장 좋다. 이러한 테스트는 구현 세부 사항에 거의 결합되지 않으므로 리팩터링 내성이 있다. 또한 작고 간결하므로 유지 보수하기도 쉽다.

+ 상태 기반 테스트는 안정성을 위해 더 신중해야 한다. 단위 테스트를 하려면 비공개 상태를 노출하지 않도록 해야 한다. 상태 기반 테스트는 출력 기반 테스트보다 크기가 큰 편이므로 유지 보수가 쉽지 않다. 헬퍼 메서드와 값 객체를 사용해 유지 보수성 문제를 완화할 수도 있지만 제거할 수는 없다.

+ 통신 기반 테스트도 안정성을 위해 더 신중해야 한다. 애플리케이션 경계를 넘어서 외부 환경에 부작용이 보이는 통신만 확인해야 한다. 통신 기반 테스트의 유지 보수성은 출력 기반 테스트 및 상태 기반 테스트와 비교할 때 좋지 않다. 목은 공간을 많이 차지하는 경향이 있어서 테스트 가독성이 떨어진다.

+ 함수형 프로그래밍은 수학적 함수로 된 프로그래밍이다.

+ 수학적 함수는 숨은 입출력이 없는 함수(또는 메서드)다. 부작용과 예외가 숨은 출력에 해당한다. 내부 상태 또는 외부 상태에 대한 참조는 숨은 입력이다. 수학적 함수는 명시적이므로 테스트 용이성을 상당히 높인다.

+ 함수형 프로그래밍의 목표는 비즈니스 로직과 부작용을 분리하는 것이다.

+ 함수형 아키텍처는 부작용을 비즈니스 연산의 가장자리로 밀어내 분리를 이루는 데 도움이 된다. 이 방법으로, 부작용을 다루는 코드를 최소화하면서 순수 함수 방식으로 작성된 코드의 양을 최대화할 수 있다.

+ 함수형 아키텍처는 모든 코드를 함수형 코어와 가변 셸이라는 두 가지 범주로 나눈다. 가변 셸은 입력 데이터를 함수형 코어에 공급하고, 코어가 내린 결정을 부작용으로 변환한다.

+ 함수형 아키텍처와 육각형 아키텍처의 차이는 부작용의 처리에 있다. 함수형 아키텍처는 모든 부작용을 도메인 계층 밖으로 밀어낸다. 이와 반대로, 육각형 아키텍처는 도메인 계층에만 한정돼 있는 한은 도메인 계층에 의해 만들어진 부작용도 괜찮다. 극단적으로 함수형 아키텍처는 육각형 아키텍처다.

+ 함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성 사이의 절충이며, 함수형 아키텍처는 유지 보수성 향상을 위해 성능을 희생한다.

+ 모든 코드베이스를 함수형 아키텍처로 전환할 수는 없다. 함수형 아키텍처를 전략적으로 적용하라. 시스템의 복잡도와 중요성을 고려하라. 코드베이스가 단순하거나 그렇게 중요하지 않으면, 함수형 아키텍처에 필요한 초기 투자는 별 효과가 없다.  

### 7. 가치 있는 단위 테스트를 위한 리팩터링
<br/>

#### 7.1. 리팩터링할 코드 식별하기
<br/>

##### 7.1.1. 코드의 네 가지 유형
<br/>

모든 제품 코드는 2차원으로 분류할 수 있다.  

+ 복잡도 또는 도메인 유의성
+ 협력자 수  

코드 복잡도(code complexity)는 코드 내 의사 결정(분기) 지점 수로 정의한다. 이 숫자가 클수록 복잡도는 더 높아진다.  

도메인 유의성(domain significance)은 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미 있는지를 나타낸다. 일반적으로 도메인 계층의 모든 코드는 최종 사용자의 목표와 직접적인 연관성이 있으므로 도메인 유의성이 높다. 반면에 유틸리티 코드는 그런 연관성이 없다.  

복잡한 코드와 도메인 유의성을 갖는 코드가 단위 테스트에서 가장 이롭다. 해당 테스트가 회귀 방지에 뛰어나기 때문이다. 도메인 코드는 복잡할 필요가 없으며, 복잡한 코드는 도메인 유의성이 나타나지 않아도 테스트할 만하다. 이 두 요소는 서로 독립적이다. 예를 들어 주문 가격을 계산하는 메서드에 조건문이 없다면 순환 복잡도는 1이다. 그러나 이러한 메서드는 비즈니스에 중요한 기능이므로 테스트하는 것이 중요하다.  

두 번째 차원은 클래스 또는 메서드가 가진 협력자 수다. 협력자는 가변 의존성이거나 프로세스 외부 의존성(또는 둘 다)이다. 협력자가 많은 코드는 테스트 비용이 많이 든다. 테스트 크기에 따라 달라지는 유지 보수성 지표 때문이다. 협력자를 예상되는 조건으로 두고 상태나 상호 작용을 확인하게끔 코드를 작성해야 한다. 협력자가 많을수록 테스트도 커진다.  

협력자의 유형도 중요하다. 도메인 모델이라면 프로세스 외부 협력자를 사용하면 안 된다. 테스트에서 목 체계가 복잡하기 때문에 유지비가 더 든다. 또한 리팩터링 내성을 잘 지키려면 아주 신중하게 목을 사용해야 하는데, 애플리케이션 경계를 넘는 상호 작용을 검증하는 데만 사용해야 한다. 프로세스 외부 의존성을 가진 모든 통신은 도메인 계층 외부의 클래스에 위임하는 것이 좋다. 그러면 도메인 클래스는 프로세스 내부 의존성에서만 동작하게 된다.  

암시적 협력자와 명시적 협력자 모두 이 숫자에 해당한다. 테스트 대상 시스템(SUT)이 협력자를 인수로 받거나 정적 메서드를 통해 암시적으로 참조해도 상관없지만, 테스트에서 이 협력자를 설정해야 한다. 반대로 불변 의존성(값 또는 값 객체 등)은 해당하지 않는다. 불변 의존성은 설정과 검증이 훨씬 쉽다.  

코드 복잡도, 도메인 유의성, 협력자의 수의 조합으로 네 가지 코드 유형을 볼 수 있다.  

+ 도메인 모델과 알고리즘  
보통 복잡한 코드는 도메인 모델이지만, 100%는 아니다. 문제 도메인과 직접적으로 관련이 없는 복잡한 알고리즘이 있을 수 있다.  

+ 간단한 코드  
C#에서 이러한 코드의 예로 매개변수가 없는 생성자와 한 줄 속성 등이 있다. 협력자가 있는 경우가 거의 없고 복잡도나 도메인 유의성도 거의 없다.  

+ 컨트롤러  
이 코드는 복잡하거나 비즈니스에 중요한 작업을 하는 것이 아니라 도메인 클래스와 외부 애플리케이션 같은 다른 구성 요소의 작업을 조정한다.  

+ 지나치게 복잡한 코드  
이러한 코드는 두 가지 지표 모두 높다. 협력자가 많으며 복잡하거나 중요하다. 한 가지 예로 덩치가 큰 컨트롤러(복잡한 작업을 어디에도 위임하지 않고 모든 것을 스스로 하는 컨트롤러)가 있다.  

도메인 모델 및 알고리즘을 단위 테스트하면 노력 대비 가장 이롭다. 이러한 단위 테스트는 매우 가치 있고 저렴하다. 해당 코드가 복잡하거나 중요한 로직을 수행해서 테스트의 회귀 방지가 향상되기 때문에 가치 있다. 또한 코드에 협력자가 거의 없어서(이상적으로는 완전히 없음) 테스트 유지비를 낮추기 때문에 저렴하다.  

간단한 코드는 테스트할 필요가 전혀 없다. 이러한 테스트는 가치가 0에 가깝다. 컨트롤러의 경우, 포괄적인 통합 테스트의 일부로서 간단히 테스트해야 한다.  

가장 문제가 되는 코드 유형은 지나치게 복잡한 코드다. 단위 테스트가 어렵겠지만, 테스트 커버리지 없이 내버려두는 것은 너무 위험하다. 이러한 코드는 많은 사람이 단위 테스트로 어려움을 겪는 주요 원인 중 하나다. 때때로 실제 구현이 까다로울 수 있지만, 지나치게 복잡한 코드를 알고리즘과 컨트롤러라는 두 부분으로 나누는 것이 일반적이다.  

코드가 더 중요해지거나 복잡해질수록 협력자는 더 적어야 한다.  

지나치게 복잡한 코드를 피하고 도메인 모델과 알고리즘만 단위 테스트하는 것이 매우 가치 있고 유지 보수가 쉬운 테스트 스위트로 가는 길이다. 하지만 이 방법으로도 테스트 커버리지를 100% 달성할 수 없으며, 이를 목표로 해서도 안 된다. 목표는 각각의 테스트가 프로젝트를 가치를 높이는 테스트 스위트다. 다른 모든 테스트를 리팩터링하거나 제거하라. 테스트 스위트의 크기를 부풀리지 말라.  

좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다.  

###### 7.1.1.1. 순환 복잡도 계산법
<br/>

컴퓨터 과학에서 코드 복잡도를 설명하는 특별한 용어로 순환 복잡도(cyclomatic complexity)가 있다. 순환 복잡도는 주어진 프로그램 또는 메서드의 분기 수를 나타낸다. 이 지표는 다음과 같이 계산한다.  

1 + <분기점 수>  

따라서 제어 흐름문(예: if 문 또는 조건부 루프)이 없는 메서드에서는 순환 복잡도가 1 + 0 = 1이다.  

이 지표에는 또 다른 의미가 있다. 메서드에서 시작부터 끝으로 가는 데 독립적인 경로의 수 또는 100% 분기 커버리지를 얻는 데 필요한 테스트의 수로 생각해볼 수 있다.  

분기점 수는 관련된 가장 간단한 조건(predicate) 수로 계산한다. 예를 들어, IF 조건1 AND 조건2 THEN은 IF 조건 THEN IF 조건2 THEN과 같다. 따라서 복잡도는 1 + 2 = 3이다.  

##### 7.1.2. 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기
<br/>

지나치게 복잡한 코드를 쪼개려면, 험블 객체(Humble Object) 패턴을 써야 한다.  

코드가 프레임워크 의존성에 결합돼 있으면 테스트가 어렵다. 예를 들어 비동기 또는 멀티스레드 실행, 사용자 인터페이스, 프로세스 외부 의존성과의 통신 등이 있다.  

어려운 의존성과 결합된 코드는 테스트하기 어렵다. 테스트는 해당 의존성도 다뤄야 하기 때문에 유지비가 증가한다.  

테스트 대상 코드의 로직을 테스트하려면, 테스트가 가능한 부분을 추출해야 한다. 결과적으로 코드는 테스트 가능한 부분을 둘러싼 얇은 험블 래퍼(humble wrapper)가 된다. 이 험블 래퍼가 테스트하기 어려운 의존성과 새로 추출된 구성 요소를 붙이지만, 자체적인 로직이 거의 없거나 전혀 없으므로 테스트할 필요가 없다.  

험블 객체 패턴은 지나치게 복잡한 코드에서 로직을 추출해 코드를 테스트할 필요가 없도록 간단하게 만든다. 추출된 로직은 테스트하기 어려운 의존성에서 분리된 다른 클래스로 이동한다.  

사실 육각형 아키텍처와 함수형 아키텍처 모두 정확히 이 패턴을 구현한다. 육각형 아키텍처는 비즈니스 로직과 외부 의존성과의 통신을 분리한다. 이는 도메인 계층과 애플리케이션 서비스 계층이 각각 담당하는 것이다.  

함수형 아키텍처는 더 나아가 프로세스 외부 의존성뿐만 아니라 모든 협력자와의 커뮤니케이션에서 비즈니스 로직을 분리한다. 이는 함수형 아키텍처가 테스트를 용이하게 하는 것이다. 즉, 함수형 코어에는 아무런 협력자도 없다.  

험블 객체 패턴을 보는 또 다른 방법은 단일 책임 원칙(Single Responsibility principle)을 지키는 것이다. 이는 각 클래스가 단일한 책임만 가져야 한다는 원칙이다. 그러한 책임 중 하나로 늘 비즈니스 로직이 있는데, 이 패턴을 적용하면 비즈니스 로직을 거의 모든 것과 분리할 수 있다.  

특정 상황을 예로 들자면, 비즈니스 로직과 오케스트레이션(orchestration)을 분리하는 경우다. 코드의 깊이와 코드의 너비 관점에서 이 두 가지 책임을 생각해볼 수 있다. 코드가 깊거나(복잡하거나 중요한) 넓을(많은 협력자와 작동함) 수 있지만, 둘 다 가능하지는 않다.  

컨트롤러는 많은 의존성을 조정하지만 그 자체로 복잡하지 않다. 도메인 클래스는 그 반대다.  

이 분리가 얼마나 중요한지는 아무리 강조해도 지나치지 않다. 실제로 잘 알려진 많은 원칙과 패턴은 험블 객체 패턴의 형태로 설명할 수 있다. 험블 객체 패턴은 오케스트레이션을 수행하는 코드에서 복잡한 코드를 분리하도록 특별히 설계됐다.  

다른 예로 MVP(Model-View-Presenter)와 MVC(Model-View-Controller) 패턴이 있다. 이 두 패턴은 비즈니스 로직(모델 부분), UI 관심사(뷰) 그리고 모델과 뷰 사이의 조정(프리젠터 또는 컨트롤러)을 분리하는 데 도움이 된다. 프리젠터와 컨트롤러 구성 요소는 험블 객체로, 뷰와 모델을 붙인다.  

또 다른 예로 도메인 주도 설계(Domain-Driven Design)에 나오는 집계 패턴(Aggregate pattern)이 있다. 그 목표 중 하나는 클래스를 클러스터(집계)로 묶어서 클래스 간 연결을 줄이는 것이다. 클래스는 해당 클러스터 내부에 강결합돼 있지만, 클러스터 자체는 느슨하게 결합돼 있다. 이러한 구조는 코드베이스의 총 통신 수를 줄인다. 그 결과, 연결이 줄어들고 테스트 용이성이 향상된다.  

비즈니스 로직과 오케스트레이션을 계속 분리해야 하는 이뉴는 테스트 용이성이 좋아져서만이 아니다. 이렇게 분리하면 코드 복잡도를 해결할 수 있으며, (특히 장기적으로) 프로젝트 성장에도 중요한 역할을 한다. 개인적으로는 항상 테스트 가능한 설계가 어떻게 테스트를 용이하게 할 뿐만 아니라 유지 보수도 쉽게 해주는지를 흥미롭게 생각한다.  

#### 7.2. 가치 있는 단위 테스트를 위한 리팩터링하기
<br/>

##### 7.2.1. 고객 관리 시스템 소개
<br/>

이번 샘플 프로젝트는 사용자 등록을 처리하는 고객 관리 시스템(CRM, Customer Management System)이며, 모든 사용자가 데이터베이스에 저장된다. 현재 시스템은 사용자 이메일 변경이라는 단 하나의 유스케이스만 지원한다. 이 연산에는 세 가지 비즈니스 규칙이 있다.  

+ 사용자 이메일이 회사 도메인에 속한 경우 해당 사용자는 직원으로 표시된다. 그렇지 않으면 고객으로 간주한다.

+ 시스템은 회사의 직원 수를 추적해야 한다. 사용자 유형이 직원에서 고객으로, 또는 그 반대로 변경되면 이 숫자도 변경해야 한다.

+ 이메일이 변경되면 시스템은 메시지 버스로 메시지를 보내 외부 시스템에 알려야 한다.  

다음 예제가 CRM 시스템의 초기 구현이다.  

```cs
public class User
{
	public int UserId { get; private set; }
	public string Email { get; private set; }
	public UserType Type { get; private set; }

	public void ChangeEmail(int userId, string newEmail)
	{
		object[] data = Database.GetUserById(userId);
		UserId = userId;
		Email = (string)data[1];
		Type = (UserType)data[2];

		if (Email == newEmail)
			return;

		object[] companyData = Database.GetCompany();
		string companyDomainName = (string)companyData[0];
		int numberOfEmployees = (int)companyData[1];

		string emailDomain = newEmail.Split('@')[1];
		bool isEmailCorporate = emailDomain == companyDomainName;
		UserType newType = isEmailCorporate ? UserType.Employee : UserType.Customer;

		if (Type != newType)
		{
			int delta = newType == UserType.Employee ? 1 : -1;
			int newNumber = numberOfEmployees + delta;
			Database.SaveCompany(newNumber);
		}

		Email = newEmail;
		Type = newType;

		Database.SaveUser(this);
		MessageBus.SendEmailChangedMessage(UserId, newEmail);
	}
}

public enum UserType
{
	Customer = 1,
	Employee = 2
}
```

User 클래스는 사용자 이메일을 변경한다. 간결성을 위해 이메일 정확성이나 데이터베이스에서 사용자의 존재 여부를 확인하는 것과 같이 간단한 유효성 검사는 생략했다.  

코드 복잡도는 그리 높지 않다. ChangeEmail 메서드에는 사용자를 직원으로 식별할지 또는 고객으로 식별할지와 회사의 직원 수를 어떻게 업데이트할지 등 두 가지의 명시적 의사결정 지점만 포함돼 있다. 간단하지만 이러한 결정은 중요하다. 애플리케이션의 핵심 비즈니스 로직이므로, 이 클래스는 복잡도와 도메인 유의성 측면에서 점수가 높다.  

반면에 User 클래스에는 네 개의 의존성이 있으며, 그중 두 개는 명시적이고 나머지 두 개는 암시적이다. 명시적 의존성은 userId와 newEmail 인수다. 그러나 이 둘은 값이므로 클래스의 협력자 수에는 포함되지 않는다. 암시적인 것은 Database와 MessageBus이다. 이 둘은 프로세스 외부 협력자다. 앞에서 언급했듯이 도메인 유의성이 높은 코드에서 프로세스 외부 협력자는 사용하면 안 된다. 따라서 User 클래스는 협력자 측면에서도 점수가 높으므로 이 클래스는 지나치게 복잡한 코드로 분류된다.  

도메인 클래스가 스스로 데이터베이스를 검색하고 다시 저장하는 이러한 방식을 활성 레코드(Active Record) 패턴이라고 한다. 단순한 프로젝트나 단기 프로젝트에서는 잘 작동하지만 코드베이스가 커지면 확장하지 못하는 경우가 많다. 그 이유는 정확히 두 가지 책임, 즉 비즈니스 로직과 프로세스 외부 의존성과의 통신 사이에 분리가 없기 때문이다.  

##### 7.2.2. 1단계: 암시적 의존성을 명시적으로 만들기
<br/>

테스트 용이성을 개선하는 일반적인 방법은 암시적 의존성을 명시적으로 만드는 것이다. 즉, 데이터베이스와 메시지 버스에 대한 인터페이스를 두고, 이 인터페이스를 User에 주입한 후 테스트에서 목으로 처리한다. 이 방법은 도움이 되고, 감사 시스템에 목을 구현했을 때와 정확히 같다. 그러나 충분하지는 않다.  

도메인 모델이 프로세스 외부 의존성을 직접 참조하든 인터페이스를 통해 참조하든 상관없다. 해당 의존성은 여전히 프로세스 외부에 있다. 아직 메모리에 데이터가 없는 프록시 형태다. 이러한 클래스를 테스트하려면 복잡한 목 체계가 필요한데, 여기서 테스트 유지비가 증가한다. 그리고 목을 데이터베이스 의존성에 사용하면 테스트 취약성을 야기할 수 있다.  

결국 도메인 모델은 직접적으로든 간접적으로든 (인터페이스를 통해) 프로세스 외부 협력자에게 의존하지 않는 것이 훨씬 더 깔끔하다. 이것이 바로 육각형 아키텍처에서 바라는 바다. 도메인 모델은 외부 시스템과의 통신을 책임지지 않아야 한다.  

##### 7.2.3. 2단계: 애플리케이션 서비스 계층 도입
<br/>

도메인 모델이 외부 시스템과 직접 통신하는 문제를 극복하려면 다른 클래스인 험블 컨트롤러(humble controller, 육각형 아키텍처 분류상 애플리케이션 서비스)로 책임을 옮겨야 한다. 일반적으로 도메인 클래스는 다른 도메인 클래스나 단순 값과 같은 프로세스 내부 의존성에만 의존해야 한다. 이 애플리케이션 서비스의 첫 번째 버전을 보면 다음과 같다.  

```cs
public class UserController
{
	private readonly Database _database = new Database();
	private readonly MessageBus _messageBus = new MessageBus();

	public void ChangeEmail(int userId, string newEmail)
	{
		object[] data = _database.GetUserById(userId);
		string email = (string)data[1];
		UserType type = (UserType)data[2];
		var user = new User(userId, email, type);

		object[] companyData = _database.GetCompany();
		string companyDomainName = (string)companyData[0];
		int numberOfEmployees = (int)companyData[1];

		int newNumberOfEmployees = user.ChangeEmail(newEmail, companyDomainName, numberOfEmployees);

		_database.SaveCompany(newNumberOfEmployees);
		_database.SaveUser(user);
		_messageBus.SendEmailChangedMessage(userId, newEmail);
	}
}
```

괜찮은 첫 시도다. User 클래스로부터 프로세스 외부 의존성과의 작업을 줄이는 데 애플리케이션 서비스가 도움이 됐다. 그러나 이 구현에는 몇 가지 문제가 있다.  

+ 프로세스 외부 의존성(Database와 MessageBus)이 주입되지 않고 직접 인스턴스화된다. 이는 이 클래스를 위해 작성할 통합 테스트에서 문제가 될 것이다.  

+ 컨트롤러는 데이터베이스에서 받은 원시 데이터를 User 인스턴스로 재구성한다. 이는 복잡한 로직이므로 애플리케이션 서비스에 속하면 안 된다. 애플리케이션 서비스의 역할은 복잡도나 도메인 유의성의 로직이 아니라 오케스트레이션만 해당한다.  

+ 회사 데이터도 마찬가지다. 이 데이터의 다른 문제는 다음과 같다. User는 이제 업데이트된 직원 수를 반환하는데, 이 부분이 이상해 보인다. 회사 직원 수는 특정 사용자와 관련이 없다. 이 책임은 다른 곳에 있어야 한다.  

+ 컨트롤러는 새로운 이메일이 전과 다른지 여부와 관계없이 무조건 데이터를 수정해서 저장하고 메시지 버스에 알림을 보낸다.  

User 클래스는 더 이상 프로세스 외부 의존성과 통신할 필요가 없으므로 테스트하기가 매우 쉬워졌다. 실제로 프로세스 외부든 내부든 어떤 협력자도 없다. User의 ChangeEmail 메서드의 새로운 버전을 보면 다음과 같다.  

```cs
public int ChangeEmail(string newEmail, string companyDomainName, int numberOfEmployees)
{
	if (Email == newEmail)
		return numberOfEmployees;

	string emailDomain = newEmail.Split('@')[1];
	bool isEmailCorporate = emailDomain == companyDomainName;
	UserType newType = isEmailCorporate ? UserType.Employee : UserType.Customer;

	if (Type != newType)
	{
		int delta = newType == UserType.Employee ? 1 : -1;
		int newNumber = numberOfEmployees + delta;
		numberOfEmployees = newNumber;
	}

	Email = newEmail;
	Type = newType;

	return numberOfEmployees;
}
```

괜찮은 첫 시도다. User 클래스로부터 프로세스 외부 의존성과의 작업을 줄이는 데 애플리케이션 서비스가 도움이 됐다. 그러나 이 구현에는 몇 가지 문제가 있다.  

+ 프로세스 외부 의존송(Database와 MessageBus)이 주입되지 않고 직접 인스턴스화된다. 이는 이 클래스를 위해 작성할 통합 테스트에서 문제가 될 것이다.  

+ 컨트롤러는 데이터베이스에서 받은 원시 데이터를 User 인스턴스로 재구성한다. 이는 복잡한 로직이므로 애플리케이션 서비스에 속하면 안 된다. 애플리케이션 서비스의 역할은 복잡도나 도메인 유의성의 로직이 아니라 오케스트레이션만 해당한다.

+ 회사 데이터도 마찬가지다. 이 데이터의 다른 문제는 다음과 같다. User는 이제 업데이트된 직원 수를 반환하는데, 이 부분이 이상해 보인다. 회사 직원 수는 특정 사용자와 관련이 없다. 이 책임은 다른 곳에 있어야 한다.

+ 컨트롤러는 새로운 이메일이 전과 다른지 여부와 관계없이 무조건 데이터를 수정해서 저장하고 메시지 버스에 알림을 보낸다.  

User 클래스는 더 이상 프로세스 외부 의존성과 통신할 필요가 없으므로 테스트하기가 매우 쉬워졌다. 실제로 프로세스 외부든 내부든 어떤 협력자도 없다. User의 ChangeEmail 메서드의 새로운 버전을 보면 다음과 같다.  

```cs
public int ChangeEmail(string newEmail, string companyDomainName, int numberOfEmployees)
{
	if (Email == newEmail)
		return numberOfEmployees;

	string emailDomain = newEmail.Split('@')[1];
	bool isEmailCorporate = emailDomain == companyDomainName;
	UserType newType = isEmailCorporate ? UserType.Employee : UserType.Customer;

	if (Type != newType)
	{
		int delta = newType == UserType.Employee ? 1 : -1;
		int newNumber = numberOfEmployees + delta;
		numberOfEmployees = newNumber;
	}

	Email = newEmail;
	Type = newType;

	return numberOfEmployees;
}
```

##### 7.2.4. 3단계: 애플리케이션 서비스 복잡도 낮추기
<br/>

UserController가 컨트롤러 사분면에 확실히 있으려면 재구성 로직을 추출해야 한다. ORM(Object-Relational Mapping, 객체 관계 매핑) 라이브러리를 사용해 데이터베이스를 도메인 모델에 매핑하면, 재구성 로직을 옮기기에 적절한 위치가 될 수 있다. 모든 ORM 라이브러리는 데이터베이스 테이블을 도메인 클래스에 어떻게 매핑하는지(도메인 클래스 최상단의 특성이나 XML 파일 또는 플루언트 매핑 파일 등)를 지정할 수 있게 한다.  

ORM을 사용하지 않거나 사용할 수 없으면, 도메인 모델에 원시 데이터베이스 데이터로 도메인 클래스를 인스턴스화하는 팩토리 클래스를 작성하라. 이 팩토리 클래스는 별도 클래스가 될 수도 있고, 더 간단한 경우 기존 도메인 클래스의 정적 메서드가 될 수도 있다. 샘플 애플리케이션의 재구성 로직이 그다지 복잡하지 않지만 분리해두는 것이 좋기 때문에 다음 예제와 같이 별도의 UserFactory 클래스를 둔다.  

```cs
public class UserFactory
{
	public static User Create(object[] data)
	{
		Precondition.Requires(data.Length >= 3);

		int id = (int)data[0];
		string email = (string)data[1];
		UserType type = (UserType)data[2];

		return new User(id, email, type);
	}
}
```

이 코드는 이제 모든 협력자와 완전히 격리돼 있으므로 테스트가 쉬워졌다. 이 메서드에는 데이터 배열에 최소 세 개의 요소가 있어야 한다는 요구 사항에 대해 안전 장치가 있다. Percondition은 불 인수(boolean argument)가 false인 경우 예외를 발생시키는 간단한 사용자 정의 클래스다. 이 클래스를 쓰는 이유는 코드가 간결하고 조건을 반전시켰기 때문이다. (긍정문은 부정문보다 더 읽기 쉽다.) 이 예에서 data.length >= 3은 다음 구문보다 읽기 쉽다.  

```cs
if (data.Length < 3)
	throw new Exception();
```

이 재구성 로직은 다소 복잡하지만 도메인 유의성이 없다. 사용자 이메일을 변경하려는 클라이언트의 목표와 직접적인 관련이 없다.  

##### 7.2.4.1. 재구성 로직은 얼마나 복잡한가?
<br/>

UserFactory.Create() 메서드에 분기점이 단 하나 있다고 하면, 재구성 로직은 얼마나 복잡한가? 코드에서 사용하는 기본 라이브러리에는 숨은 분기점이 많을 수 있으므로 무언가 잘못될 가능성이 많다. 이는 정확히 UserFactory.Create() 메서드에 해당한다.  

인덱스로 배열 요소를 참조할 때(data[0]) 어떤 데이터 요소를 접근할지에 관해 .NET 프레임워크에 의한 내부 결정이 필요하다. object를 int나 string으로 변환할 때도 마찬가지다. .NET 프레임워크가 내부적으로 캐스팅 예외를 던질지 아니면 변환을 진행할지를 결정한다. 그러므로 의사 결정 지점이 없어도 숨은 분기로 인해 재구성 로직을 테스트해볼 만하다.  

##### 7.2.5. 4단계: 새 Company 클래스 소개
<br/>

컨트롤러 코드를 다시 한 번 살펴보자.  

User에서 업데이트된 직원 수를 반환하는 부분이 어색하다. 이는 책임을 잘못 뒀더는 신호이자 추상화가 없다는 신호다. 이 문제를 해결하려면, 다음 예제와 같이 회사 관련 로직과 데이터를 함께 묶는 또 다른 도메인 클래스인 Company를 만들어야 한다.  

```cs
public class Company
{
	public string DomainName { get; private set; }
	public int NumberOfEmployees { get; private set; }

	public void ChangeNumberOfEmployees(int delta)
	{
		Precondition.Requires(NumberOfEmployees + delta >= 0);
		NumberOfEmployees += delta;
	}

	public bool IsEmailCorporate(string email)
	{
		string emailDomain = email.Split('@')[1];
		return emailDomain == DomainName;
	}
}
```

이 클래스에는 ChangeNumberOfEmplyees()와 IsEmailCorporate()라는 두 가지 메서드가 있다. 이러한 메서드는 '묻지 말고 말하라(tell-don't-ask)'라는 원칙을 준수하는 데 도움이 된다. 이 원칙을 따르면 데이터와 해당 데이터에 대한 작업을 묶는다. User 인스턴스는 직원 수를 변경하거나 특정 이메일이 회사 이메일인지 여부를 파악하도록 회사에 말하며, 원시 데이터를 묻지 않고 모든 작업을 자체적으로 수행한다.  

UserFactory와 유사하게 Company 객체의 재구성을 담당하도록 하는 새 CompanyFactory 클래스도 있다. 컨트롤러는 이제 다음과 같다.  

```cs
public class UserController
{
	private readonly Database _database = new Database();
	private readonly MessageBus _messageBus = new MessageBus();

	public void ChangeEmail(int userId, string newEmail)
	{
		object[] userData = _database.GetUserById(userId);
		User user = UserFactory.Create(userData);

		object[] companyData = _database.GetCompany();
		Company company = CompanyFactory.Create(companyData);

		user.ChangeEmail(newEmail, company);

		_database.SaveCompany(company);
		_database.SaveUser(user);
		_messageBus.SendEmailChangedMessage(userId, newEmail);
	}
}
```

그리고 User 클래스는 다음과 같다.  

```cs
public class User
{
	public int UserId { get; private set; }
	public string Email { get; private set; }
	public UserType Type { get; private set; }

	public void ChangeEmail(string newEmail, Company company)
	{
		if (Email == newEmail)
			return;

		UserType newType = company.IsEmailCorporate(newEmail) ? UserType.Employee : UserType.Customer;

		if (Type != newType)
		{
			int delta = newType == UserType.Employee ? 1 : -1;
			company.ChangeNumberOfEmployees(delta);
		}

		Email = newEmail;
		Type = newType;
	}
}
```

잘못 둔 책임을 제거하니 User가 훨씬 더 깔끔해졌다. 회사 데이터를 처리하는 대신 Company 인스턴스를 받아, 이메일이 회사 이메일인지 결정하는 것과 회사의 직원 수를 변경하는 것, 이 두 가지 중요한 작업을 해당 인스턴스에 위임한다.  

이 구현과 함수형 아키텍처 간에 비슷한 점을 생각해보자. 감사 시스템의 함수형 코어도, CRM의 도메인 계층(User와 Company 클래스)도 프로세스 외부 의존성과 통신하지 않는다. 두 가지 구현 모두에서 애플리케이션 서비스 계층이 해당 통신을 담당한다. 파일 시스템이나 데이터베이스에서 원시 데이터를 가져온 다음, 해당 데이터를 상태가 없는 알고리즘이나 도메인 모델에 전달하고 결과를 다시 데이터 저장소에 저장한다.  

두 가지 구현의 차이는 부작용 처리에 있다. 함수형 코어는 어떠한 부작용도 일으키지 않는다. CRM의 도메인 모델은 부작용을 일으키지만, 이러한 모든 부작용은 변경된 사용자 이메일과 직원 수의 형태로 도메인 모델 내부에 남아있다. 컨트롤러가 User 객체와 Company 객체를 데이터베이스에 저장할 때만 부작용이 도메인 모델의 경계를 넘는다.  

마지막 순간까지 모든 부작용이 메모리에 남아있다는 사실로 인해 테스트 용이성이 크게 향상된다. 테스트가 프로세스 외부 의존성을 검사할 필요가 없고 통신 기반 테스트에 의존할 필요도 없다. 메모리에 있는 객체의 출력 기반 테스트와 상태 기반 테스트로 모든 검증을 수행할 수 있다.  

#### 7.3. 최적의 단위 테스트 커버리지 분석
<br/>

#### 7.5. 요약
<br/>

+ 코드 복잡도는 코드에서 의사 결정 지점 수에 따라 명시적으로(코드) 암시적으로(코드가 사용하는 라이브러리) 정의된다.

+ 도메인 유의성은 프로젝트의 문제 도메인에 대해 코드가 얼마나 중요한지를 보여준다. 복잡한 코드는 종종 도메인 유의성이 높고 그 반대의 경우도 있지만, 모든 경우에 100% 해당하지는 않는다.

+ 복잡한 코드와 도메인 유의성을 갖는 코드는 해당 테스트의 회귀 방지가 뛰어나기 때문에 단위 테스트에서 가장 이롭다.

+ 협력자가 많은 코드를 다루는 단위 테스트는 유지비가 많이 든다. 이러한 테스트는 협력자를 예상 상태로 만들고 나서 상호 작용을 확인하고자 공간을 많이 필요로 한다.

+ 모든 제품 코드는 복잡도 또는 도메인 유의성과 협력자 수에 따라 네 가지 유형의 코드로 분류할 수 있다.

+ 도메인 모델 및 알고리즘(복잡도 또는 도메인 유의성이 높음. 협력자가 거의 없음)은 단위 테스트에 대한 노력 대비 가장 이롭다.

+ 간단한 코드(복잡도와 도메인 유의성이 낮음. 협력자가 거의 없음)는 테스트할 가치가 전혀 없다.

+ 컨트롤러(복잡도와 도메인 유의성이 낮음. 협력자가 많음)는 통합 테스트를 통해 간단히 테스트해야 한다.

+ 지나치게 복잡한 코드(복잡도 또는 도메인 유의성이 높음. 협력자가 많음)는 컨트롤러와 복잡한 코드로 분할해야 한다.

+ 코드가 중요하거나 복잡할수록 협력자가 적어야 한다.

+ 험블 객체 패턴은 해당 코드에서 비즈니스 로직을 별도의 클래스로 추출해 복잡한 코드를 테스트할 수 있는 데 도움이 된다. 그 결과, 나머지 코드는 비즈니스 로직을 둘러싼 얇은 험블 래퍼, 즉 컨트롤러가 된다.

+ 육각형 아키텍처와 함수형 아키텍처는 험블 객체 패턴을 구현한다. 육각형 아키텍처는 비즈니스 로직과 프로세스 외부 의존성과의 통신을 분리하도록 한다. 함수형 아키텍처는 프로세스 외부 의존성뿐만 아니라 모든 협력자와의 통신과 비즈니스 로직을 분리한다.

+ 코드의 깊이와 너비의 관점에서 비즈니스 로직과 오케스트레이션 책임을 생각하라. 코드는 깊을 수도 있고(복잡하거나 중요함) 넓을 수도 있지만(협력자가 많음), 둘 다는 다니다.

+ 도메인 유의성이 있으면 전제 조건을 테스트하고, 그 외의 경우에는 테스트하지 않는다.

+ 비즈니스 로직과 오케스트레이션을 분리할 때는 다음과 같이 세 가지 중요한 특성이 있다.

+ 도메인 모델 테스트 유의성: 도메인 클래스 내 협력자 수와 유형에 대한 함수

+ 컨트롤러 단순성: 컨트롤러에 의사 결정 지점이 있는지에 따라 다름

+ 성능: 프로세스 외부 의존성에 대한 호출 수로 정의

+ 항상 세 가지 특성 중 최대 두 가지를 가질 수 있다.

+ 외부에 대한 모든 읽기와 쓰기를 비즈니스 연산 가장자리로 밀어내기  
컨트롤러를 단순하게 유지하고 도메인 모델 테스트 유의성을 지키지만, 성능이 저하된다.  

+ 도메인 모델에 프로세스 외부 의존성을 주입하기  
성능을 유지하고 컨트롤러를 단순하게 하지만, 도메인 모델의 테스트 유의성이 떨어진다.  

+ 의사 결정 프로세스 단계를 더 세분화하기  
성능과 도메인 모델 테스트 유의성을 지키지만, 컨트롤러의 단순함을 포기한다.  

+ 의사 결정 프로세스 단계를 더 세분화하는 것이 장단점을 고려할 때 가장 효과적인 절충이다. 다음 두 가지 패턴을 사용해 컨트롤러 복잡도 증가를 완화할 수 있다.

+ CanExecute/Execute 패턴은 각 Do() 메서드에 대해 CanDo()를 두고, CanDo()가 성공적으로 실행되는 것을 Do()의 전제 조건으로 한다. 이 패턴은 Do 전에 CanDo() 호출하지 않을 수 없기 때문에 컨트롤러의 의사 결정을 근본적으로 제거한다.

+ 도메인 이벤트는 도메인 모델의 중요한 변경 사항을 추적하고 해당 변경 사항을 프로세스 외부 의존성에 대한 호출로 변환한다. 이 패턴으로 컨트롤러에서 추적에 대한 책임이 없어진다.

+ 추상화할 것을 테스트하기보다는 추상화를 테스트하는 것이 더 쉽다. 도메인 이벤트는 프로세스 외부 의존성 호출 위의 추상화에 해당한다. 도메인 클래스의 변경은 데이터 저장소의 향후 수정에 대한 추상화에 해당한다.  

### 8. 통합 테스트를 하는 이유
<br/>

#### 8.8. 요약
<br/>

+ 통합 테스트는 단위 테스트가 아닌 테스트에 해당한다. 통합 테스트는 시스템이 프로세스 외부 의존성과 통합해 작동하는 방식을 검증한다.

+ 통합 테스트는 컨트롤러를 다루고, 단위 테스트는 알고리즘과 도메인 모델을 다룬다.

+ 통합 테스트는 회귀 방지와 리팩터링 내성이 우수하고, 단위 테스트는 유지 보수성과 피드백 속도가 우수하다.

+ 통합 테스트의 기준은 단위 테스트보다 높다. 통합 테스트에서 회귀 방지와 리팩터링 내성 지표에 대한 점수는 단위 테스트보다 유지 보수성과 피드백 속도가 떨어진만큼은 높아야 한다. 테스트 피라미드가 이러한 절충을 나타낸다. 대부분의 테스트는 빠르면서 비용이 낮아야 하고, 시스템이 전체적으로 올바른지 확인하는 통합 테스트는 속도가 느리고 비용이 많이 발생하므로 그 수가 적어야 한다.

+ 단위 테스트를 통해 가능한 한 많은 비즈니스 시나리오의 예외 상황을 확인하라. 통합 테스트를 사용해서 하나의 주요 흐름과 단위 테스트로 확인할 수 없는 얘외 상황을 다루도록 하라.

+ 테스트 피라미드의 모양은 프로젝트 복잡도에 따라 달라진다. 간단한 프로젝트는 도메인 모델에 코드가 거의 없으므로 단위 테스트와 통합 테스트의 개수가 동일하다. 아주 단순한 경우 단위 테스트가 없을 수도 있다.

+ 빠른 실패 원칙은 버그가 빠르게 나타날 수 있도록 하며 통합 테스트에서 할 수 있는 대안이다.

+ 관리 의존성은 애플리케이션을 통해서만 접근할 수 있는 프로세스 외부 의존성이다. 관리 의존성과의 상호 작용은 외부에서 관찰할 수 없다. 대표적인 예는 애플리케이션 데이터베이스다.

+ 비관리 의존성은 다른 애플리케이션이 접근할 수 있는 프로세스 외부 의존성이다. 비관리 의존성과의 상호 작용은 외부에서 관찰할 수 이씨다. 대표적인 예로 SMTP 서버나 메시지 버스 등이 있다.

+ 관리 의존성과의 통신은 구현 세부 사항이고, 비관리 의존성과의 통신은 식별할 수 있는 동작이다.

+ 통합 테스트에서 관리 의존성은 실제 인스턴스를 사용하라. 비관리 의존성은 톡으로 대체하라.

+ 때로는 관리 의존성과 비관리 의존성 모두의 특성을 나타내는 프로세스 외부 의존성이 있다. 전형적인 예로는 다른 애플리케이션이 접근할 수 있는 데이터베이스가 있다. 비관리 의존성의 식별 가능한 부분을 비관리 의존성으로 간주하고, 테스트에서 해당 부분을 목으로 대체하라. 나머지 부분을 관리 의존성으로 간주하고, 해당 부분과의 상호 작용 대신 최종 상태를 검증하라.

+ 통합 테스트에서 관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체하라.

+ 때때로 프로세스 외부 의존성은 관리 의존성과 비관리 의존성 모두의 속성을 나타낸다. 대표적인 예로 다른 애플리케이션이 접근할 수 있는 데이터베이스가 있다. 의존성 중 관찰할 수 있는 부분을 비관리 의존성으로 취급하라. 즉, 테스트에서 해당 부분을 목으로 대체하라. 나머지 의존성은 관리 의존성으로 취급하라. 상호 작용이 아닌 최종 상태를 검증하라.

+ 통합 테스트는 관리 의존성과 작동하는 모든 계층을 거쳐야 한다. 데이터베이스를 예로 들면, 입력 매개변수로 사용한 데이터와 별개로 해당 데이터베이스의 상태를 확인하는 것을 의미한다.

+ 구현이 하나뿐인 인터페이스는 추상화가 아니며 해당 인터페이스를 구현하는 클래스보다 결합도가 낮지 않다. 이러한 인터페이스에 대한 향후 구현을 예상하면 YAGNI 원칙을 위배한다.

+ 구현이 하나뿐인 인터페이스를 사용하기에 타당한 이유는 목을 사용하기 위한 것뿐이다. 비관리 의존성에만 사용하고, 관리 의존성은 구체 클래스를 사용하라.

+ 프로세스 내부 의존성에 대해 구현이 하나뿐인 인터페이스는 좋지 않다. 이러한 인터페이스는 목을 사용해 도메인 클래스 간의 상호 작용을 확인하게 되고, 테스트가 코드의 구현 세부 사항에 결합된다.

+ 도메인 모델을 코드베이스에 명시적이고 잘 알려진 위치에 둬라. 도메인 클래스와 컨트롤러 사이의 경계가 명확하면 단위 테스트와 통합 테스트를 좀 더 쉽게 구분할 수 있다.

+ 간접 계층이 너무 많으면 코드를 추론하기가 어려워진다. 간접 계층을 가능한 한 적게 하라. 대부분의 백엔드 시스템은 도메인 모델, 애플리케이션 서비스 계층(컨트롤러), 인프라 계층, 이 세 가지 계층만 있다.

+ 순환 의존성이 있으면 코드를 이해하려고 할 때 알아야 하는 부담이 커진다. 대표적인 예는 콜백(수신자가 발신자에게 작업 결과를 알리는 경우)이다. 값 객체를 도입해 순환을 없애고, 호출부에 주는 결과를 값 객체를 반환하라.

+ 테스트에 여러 실행 구절이 있는 것은 올바른 상태가 되기 어려운 프로세스 외부 의존성으로 작동하는 경우에만 타당하다. 단위 테스트는 프로세스 외부 의존성으로 수행되지 않기 때문에 여러 가지 실행을 해서는 안 된다. 다단계 테스트는 대부분 엔드 투 엔드 테스트 범주에 속한다.

+ 지원 로깅은 지원 부서나 시스템 관리자를 위한 것이며, 애플리케이션의 식별할 수 있는 동작이다. 전단 로깅은 개발자가 애플리케이션 내부에서 진행되는 작업을 이해하는 데 도움을 주며, 구현 세부 사항이다.

+ 지원 로깅은 비즈니스 요구 사항이므로 해당 요구 사항을 코드베이스에 명시적으로 반영하라. 비즈니스 에 필요한 모든 지원 로깅이 나열돼 있는 특별한 DomainLogger 클래스를 도입하라.

+ 지원 로깅을 프로세스 외부 의존성으로 작동하는 다른 기능처럼 취급하라. 도메인 이벤트를 사용해 도메인 모델의 변경 사항을 추적하라. 컨트롤러에서 도메인 이벤트를 DomainLogger 호출로 변환하라.

+ 진단 로깅을 테스트하지 말라. 지원 로깅과 달리 도메인 모델에서 직접 진단 로그를 남길 수도 있다.

+ 진단 로깅은 가끔 사용하라. 진단 로깅을 너무 많이 쓰면 코드를 복잡하게 하고 로그의 신호 대비 잡음 비율이 나빠진다. 이상적으로는 진단 로깅을 처리되지 않은 예외에 대해서만 사용해야 한다.

+ 항상 모든 의존성(로거 포함)을 생성자 또는 메서드 인수를 통해 명시적으로 주입하라.

### 9. 목 처리에 대한 모범 사례
<br/>

+ 시스템 끝에서 비관리 의존성과의 상호 작용을 검증하라. 컨트롤러와 비관리 의존성 사이의 타입 사슬에서 마지막 고리를 목으로 처리하라. 이로써 회귀 방지(통합 테스트로 검증된 코드가 더 많기 때문)와 리팩터링 내성(코드의 구현 세부 사항에서 목을 분리하기 때문)이 향상될 수 있다.

+ 스파이는 직접 작성한 목이다. 시스템 끝에 있는 클래스에 대해서는 스파이가 목보다 낫다. 검증 단계에서 코드를 재사용해 테스트 크기가 줄고 가독성이 개선된다.

+ 검증문을 작성할 때 제품 코드에 의존하지 말라. 테스트에서 별도의 리터럴과 상수 집합을 사용하라. 필요하면 리터럴과 상수를 복제하라. 테스트는 제품 코드와 독립적으로 검사점을 제공해야 한다. 그렇지 않으면, 이름만 바꿀 뿐 동어 반복 테스트(아무것도 검증 하지 않고 무의미한 검증문만 있는 테스트)를 만들 위험이 있다.

+ 모든 비관리 의존성에 하위 호환성이 동일한 수준으로 필요한 것은 아니다, 메시지의 정확한 구조가 중요하지 않고 메시지의 존재 여부와 전달하는 정보만 검증하면 시스템의 끝에서 비관리 의존성과의 상호 작용을 검증하라는 지침을 무시할 수 있다. 대표적인 예가 로깅이다.

+ 목은 비관리 의존성만을 위한 것이고 이러한 의존성을 처리하는 코드는 컨트롤러뿐이므로 통합 테스트에서 컨트롤러를 테스트할 때만 목을 적용해야 한다. 단위 테스트에서는 목을 사용하지 말라.

+ 테스트에서 사용된 목의 수는 관계가 없다. 목의 수는 비관리 의존성의 수에 따라 달라진다.

+ 목에 예상되는 호출이 있는지와 예상치 못한 호출이 없는지를 확인하라.

+ 보유 타입만 목으로 처리하라. 비관리 의존성에 접근하는 서드파티 라이브러리 위에 어댑터를 작성하라. 기본 타입 대신 해당 어댑터를 목을 처리하라.  

### 10. 데이터베이스 테스트
<br/>

#### 10.7. 요약
<br/>

+ 데이터베이스 스키마를 소스 코드와 같이 형상 관리 시스템에 저장하라. 테이블, 뷰, 인덱스, 저장 프로시저와 데이터베이스 구성 방식에 대한 청사진이 되는 기타 모든 항목 등이 데이터베이스 스키마에 해당한다.

+ 참조 데이터도 데이터베이스 스키마에 해당한다. 이는 애플리케이션 제대로 작동하도록 미리 채워져야 하는 데이터다. 참조 데이터와 일반 데이터를 구별하려면 애플리케이션에서 해당 데이터를 수정할 수 있는지 확인하면 된다. 수정할 수 있으면 일반 데이터고, 그렇지 않으면 참조 데이터다.

+ 개발자마다 데이터베이스 인스턴스를 별도로 두게 하라. 더 좋은 방법은 개발자 장비에 인스턴스를 호스팅하는 것인데, 이렇게 하면 테스트 실행 속도를 극대화할 수 있다.

+ 상태 기반 데이터베이스 배포 방식은 상태를 명시적으로 만들고 비교 도구가 마이그레이션을 암묵적으로 제어할 수 있도록 한다. 마이그레이션 기반 방식은 데이터베이스를 특정 상태에서 다른 상태로 전환하게끔 명시적 마이그레이션을 사용하도록 한다. 데이터베이스 상태가 명확하면 병합 충돌을 좀 더 쉽게 처리할 수 있는 데 반해, 명시적 마이그레이션은 데이터 모션 문제를 해결하는 데 도움이 된다.

+ 상태 기반 방식보다는 마이그레이션 기반 방식을 선호해라. 왜냐하면 데이터 모션 처리가 병합 충돌보다 훨씬 중요하기 때문이다. 마이그레이션을 통해 모든 수정 사항을 데이터베이스 스키마(참조 데이터 포함)에 적용하라.

+ 비즈니스 연산은 데이터를 원자적으로 업데이트해야 한다. 원자성을 얻으려면 데이터베이스 트랜잭션 메커니즘에 의존하라.

+ 가능하면 작업 단위 패턴을 사용하라. 작업 단위는 데이터베이스 트랜잭션에 의존하며, 비즈니스 연산 종료 시점까지 업데이트를 모두 지연시켜서 성능을 향상시킨다.

+ 테스트 구절마다 데이터베이스 트랜잭션이나 작업 단위를 재사용하지 말라. 준비, 실행, 검증 구절에 각각 고유의 트랜잭션이나 작업 단위가 있어야 한다.

+ 통합 테스트는 순차적으로 실행하라. 병렬 실행에는 상당한 노력이 필요하며, 보통 그럴 가치가 없다.

+ 테스트 시작 시점에 남은 데이터를 정리하라. 이 방식은 빠르고 일관성 없는 동작을 일으키지 않으며, 정리 단계를 실수로 건너뛰지 않는다. 이렇게 하면 별도의 종료 단계도 둘 필요가 없다.

+ SQLite와 같은 인메모리 데이터베이스는 사용하지 말라. 다른 업체의 데이터베이스로 테스트를 실행하면 보호 수준이 떨어진다. 테스트에서도 운영 환경과 같이 동일한 DBMS를 사용하라.

+ 필수가 아닌 부분을 비공개 메서드 또는 헬퍼 클래스로 추출해 테스트를 단축하라.

+ 준비 구절에서는 테스트 데이터 필터 대신 오브젝트 마더를 선택하라.

+ 실행 구절에서는 데코레이터 메서드를 작성하라.

+ 검증 구절에서는 플루언트 인터페이스를 도입하라.

+ 읽기 테스트 임계치는 쓰기 테스트 임계치보다 높아야 한다. 가장 복잡하거나 중요한 읽기 작업만 테스트하라. 나머지는 무시하라.

+ 리포지터리는 직접 테스트하지 말고 포괄적인 통합 테스트 스위트로 취급하라. 리포지터리 테스트는 회귀 방지에 대한 이득이 너무 적은 데 반해 유지비가 너무 높다.  

### 11. 단위 테스트 안티 패턴
<br/>

#### 11.8. 요약
<br/>

+ 단위 테스트를 가능하게 하고자 비공개 메서드를 노출하게 되면 테스트가 구현에 결합되고, 결국 리팩터링 내성이 떨어진다. 비공개 메서드를 직접 테스트하는 대신, 식별할 수 있는 동작으로서 간접적으로 테스트하라.

+ 비공개 메서드가 너무 복잡해서 공개 API로 테스트할 수 없다면, 추상화가 누락됐다는 뜻이다. 비공개 메서드를 공개로 하지 말고 해당 추상화를 별도 클래스로 추출하라.

+ 드물지만, 비공개 메서드가 클래스의 식별할 수 있는 동작에 속한 경우가 있다. 보통 클래스와 ORM 또는 팩토리 간의 비공개 계약을 구현하는 것이 여기에 해당한다.

+ 비공개였던 상태를 단위 테스트만을 위해 노출하지 말라. 테스트는 제품 코드와 같은 방식으로 테스트 대상 시스템과 상호 작용해야 한다. 어떤 특권도 가져서는 안 되기 때문이다.

+ 테스트를 작성할 때 특정 구현을 암시하지 말라. 블랙박스 관점에서 제품 코드를 검증하라. 또한 도메인 지식을 테스트에 유출하지 않도록 하라.

+ 코드 오염은 테스트에만 필요한 제품 코드를 추가하는 것이다. 이는 테스트 코드와 제품 코드가 혼재되게 하고 제품 코드의 유지비를 증가시키기 때문에 안티 패턴이다.

+ 기능을 지키려고 구체 클래스를 목으로 처리해야 하면, 이는 단일 책임 원칙을 위반하는 결과다. 해당 클래스를 두 가지 클래스, 즉 도메인 로직이 있는 클래스와 프로세스 외부 의존성과 통신하는 클래스로 분리하라.

+ 현재 시간을 앰비언트 컨텍스트로 하면 제품 코드가 오염되고 테스트하기가 더 어려워진다. 서비스나 일반 값의 명시적인 의존성으로 시간을 주입하라. 가능하면 항상 일반 값이 좋다.