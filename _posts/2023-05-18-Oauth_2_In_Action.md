---
title:  OAuth 2 In Action
categories:
- OAuth 2 In Action
feature_text: |
  ## OAuth 2 In Action
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---
<style>
	thead td { text-align: center; }
	td { border: 1px solid #444444; }
</style>

### 1. OAuth 2.0이 무엇이고, 왜 관심을 가져야 할까?
<br/>

#### 1.1. OAuth 2.0은 무엇인가?
<br/>

+ OAuth 2.0  
자신이 소유한 리소스에 소프트웨어 애플리케이션이 접근할 수 있도록 허용해줌으로써 접근 권한을 요청하고, 요청 결과로 전달받은 토큰을 이용해 애플리케이션이 해당 리소스에 접근하는 프로토콜  

+ OAuth 2.0 인가 프레임워크  
리소스 소유자를 대신해 HTTP 서비스와 리소스에 대한 접근 요청 승인을 조정하거나 리소스 소유자를 대신해 서드파티 애플리케이션에게 리소스에 대한 접근을 허용해주는 방식으로 HTTP 서비스에 대한 서드파티 애플리케이션의 접근을 가능하게 해준다.  

+ 리소스 소유자  
API에 대한 접근 권한을 갖고 있으며, 그것을 위임할 수 있다.  

+ 보호된 리소스  
리소스 소유자가 접근하는 구성 요소로 대부분의 경우 웹 API의 형태를 띤다.  

+ 클라이언트  
리소스 소유자를 대신해 보호된 리소스에 접근하는 소프트웨어 요소  

#### 1.3. 접근 권한 위임
<br/>

+ 인가 서버(AS, Authorization Server)  
특정 목적의 보안 자격 증명, 즉 OAuth 액세스 토큰을 클라이언트에게 발급하는 서버  

클라이언트는 액세스 토큰을 획득하기 위해 먼저 리소스 소유자가 인가 서버에 해당 클라이언트에게 권한을 위임하도록 요청한다. 그러면 리소스 소유자는 요청한 클라이언트를 인가할 것인지 여부를 인가 서버를 통해 선택한다. 클라이언트는 접근할 수 있는 리소스 범위와 수행할 수 있는 기능을 지정해 요청할 수 있으며, 리소스 소유자는 요청된 권한을 축소할 수도 있다. 일단 접근이 인가되면 클라이언트는 인가 서버에 액세스 토큰을 요청할 수 있다. 발급받은 액세스 토큰을 이용해 클라이언트는 보호된 리소스에 접근하기 위한 API를 호출할 수 있다.  

+ OAuth 수행 절차  
(1) 클라이언트가 인가를 요청  
(2) 리소스 소유자는 권한을 인가  
(3) 클라이언트가 인가 그랜트를 전달  
(4) 인가 서버는 액세스 토큰을 전달  
(5) 클라이언트가 액세스 토큰을 전달  
(6) 보호된 리소스는 리소스를 전달  

##### 1.3.3. 사용자 주도 보안과 사용자 선택
<br/>

OAuth 시스템은 주로 TOFU(Trust On First Use) 원칙을 따른다.  

TOFU 모델에서는 처음에 보안 결정을 위한 어떤 전후 사정이나 설정이 존재하지 않기 때문에 보안적인 결정이 런타임에 사용자에게 요구된다. 사용자의 결정 요구를 "새로운 애플리케이션에 연결하겠습니까?"처럼 단순하게 만들 수도 있지만, 더 많은 제어를 할 수 있도록 구현하는 것도 가능하다. 그리고 시스템은 이후를 위해 사용자의 결정을 기억한다. 다시 말해, 처음으로 권한 인가가 이뤄지면 이후의 처리를 위해 시스템이 사용자의 결정을 신뢰하도록 만들 수 있다.  

+ TOFU 모델을 사용해야 하는가?  
보안 결정 관리를 위한 TOFU 모델을 구현해야 할 필요는 없지만, 두 기술이 함께 사용되는 것은 매우 흔하게 볼 수 있다. 왜 그럴까? TOFU 모델은 사용자에게 보안 결정을 내리도록 요구하는 유연성과 그런 결정을 지속적으로 내리도록 요구하는 피로도 간에 적절한 균형을 유지한다. TOFU에서 "Trust" 부분이 없다면 사용자는 그런 권한 위임이 어떻게 이뤄졌는지 말하지 못할 것이다. 그리고 TOFU에서 "On First Use" 부분이 없다면 사용자는 끝없이 쏟아져 들어오는 접근 권한 요청에 빠르게 무감각해질 것이다. 이런 보안 시스템에 의한 피로도 증가로 인해 보안 시스템이 원래 의도한 것보다 더 안전하지 않은 결과를 초래한다.  

#### 1.4. OAuth 2.0이 아닌 것  
<br/>

OAuth는 HTTP 프로토콜과 독립적으로 정의되지 않는다. 왜냐하면 OAuth 2.0 Bearer 토큰은 메시지 시그니처를 제공하지 않기 때문에 HTTPS(HTTP over TLS)를 이용해야 한다. 따라서 민감한 비밀 정보를 전달하려면 OAuth는 TLS와 같은 안전한 전송 계층 메커니즘이 필요하다. OAuth 토큰 전달을 위한 표준으로 SASL(Simple Authentication and Security Layer)이 있으며, CoAP(Constrained Application Protocol)를 이용하는 새로운 시도가 이뤄지고 있다. 그리고 미래에는 TLS를 이용하지 않고도 OAuth를 이용하기 위한 노력이 이뤄질 것이다. 하지만 그런 경우에도 HTTPS 트랜잭션과 다른 프로토콜 및 시스템 간의 명확한 매핑이 필요하다.  

OAuth는 인증 프로토콜이 아니다. OAuth 트랜잭션 자체만으로 사용자가 누구인지 알 수 없다. OAuth는 본질적으로 다양한 서비스와 기능을 가능하게 하기 위해 사용될 수 있는 재료라고 할 수 있다. 또한 OAuth는 여러 곳에서 인증을 사용한다. 특히, 인가 서버가 리소스 소유자와 클라이언트 소프트웨어를 인증할 때 사용한다. 그렇다고 해서 그런 내재된 인증 자체만으로 OAuth가 인증 프로토콜이 되지는 않는다.  

OAuth는 기본적으로 사용자가 소프트웨어에 권한을 위임하는 것이지만, 사용자 간의 권한 위임 메커니즘은 정의하지 않는다. OAuth에서 리소스 소유자는 클라이언트를 통제하는 사람이라고 가정한다. 리소스 소유자가 다른 사람을 인가할 수 있게 하려면 OAuth만으로는 힘들다. 그런 형태의 권한 위임은 일반적이지 않으며, UMA(User Managed Access) 프로토콜은 OAuth를 이용해 사용자 간의 권한 위임이 가능한 시스템을 만든다.  

OAuth는 인가 절차 메커니즘을 정의하지 않는다. OAuth는 권한 위임이 이뤄졌다는 사실을 전달하기 위한 방법을 제공하지만, 권한 인가 자체의 내용을 정의하지는 않는다. 대신, 토큰과 그것의 범위 같은 OAuth의 구성 요소를 이용해 허용 가능한 작업이 어떤 것인지 서비스 API로 정의한다.  

OAuth는 토큰의 포맷을 정의하지 않는다. 실제로 OAuth 프로토콜은 토큰의 내용이 클라이언트 애플리케이션에게 완전히 불투명하다고 명확히 기술하고 있다. 이는 클라이언트 애플리케이션이 토큰을 구문 분석하고 처리해야 하는 WS-&#42;, SAML(Security Assertion Markup Language), 커버로스와 같은 이전의 프로토콜과 다른 점이다. 하지만 토큰을 발급하는 인가 서버와 토큰을 받아들이는 보호된 리소스는 여전히 그것을 이해할 필요가 있다. 그런 피룡성으로 인해 JWT(JSON Web Token)와 Token Introspection 프로토콜의 개발로 이어졌다. 즉, 토큰 자체는 여전히 클라이언트에게 불투명하지만, 상대방은 그것의 포맷을 이해할 수 있는 것이다.  

OAuth 2.0은 OAuth 1.0과 달리, 암호화 방법을 정의하지 않는다. OAuth 2.0 프로토콜은 OAuth에서 사용되는 새로운 암호화 메커니즘을 정의하지 않고 OAuth 외부에서 일반적인 목적으로 사용되는 암호화 메커니즘을 허용하도록 하고 있다. 그렇게 암호화 메커니즘을 의도적으로 누락시킴으로써 OAuth가 아닌 곳에서도 일반적인 목적의 암호화 메커니즘으로 사용할 수 있는 JOSE(JSON Object Signing and Encryption)와 같은 암호 메커니즘 스펙이 만들어져 왔다.  

OAuth 2.0은 단일 프로토콜이 아니다.  

OAuth는 인가 접근 시스템을 위한 권한 위임 프로토콜이다.  

#### 2.1. OAuth 2.0 프로토콜의 개요: 토큰 획득과 사용  
<br/>
본질적으로 OAuth 트랜잭션에는 2개의 중요한 단계가 있다. 그것은 토큰을 발급하고 발급된 토큰을 사용하는 것이다. 토큰은 클라이언트에게 위임된 접근 권한을 의미하며, OAuth 2.0의 모든 부분에서 중요한 역할을 담당한다. 각 단계의 세부 내용은 여러 가지 요소에 따라 달라질 수 있다. 표준 OAuth 트랜잭션은 다음과 같은 일련의 이벤트로 구성된다.  

+ 리소스 소유자는 클라이언트에게 자신을 대신해 작업을 수행하라고 말한다.
+ 클라이언트는 인가 서버의 리소스 소유자에게 인가를 요청한다.
+ 리소스 소유자는 클라이언트를 인가한다.
+ 클라이언트는 인가 서버로부터 토큰을 전달받는다.
+ 클라이언트는 보호된 리소스에 접근하기 위해 토큰을 사용한다.  

#### 2.2. OAuth 2.0 인가 그랜트  
<br/>

+ 인가 코드 그랜트  
리소스 소유자가 클라이언트에게 접근 권한을 위임했다는 것을 나태니기 우해 임시 자격 증명인 인가 코드를 사용  

+ 인가 코드 그랜트 수행 절차  
(1) 클라이언트는 사용자 에이전트를 인가 엔드 포인트로 리다이렉트시킨다.  
(2) 사용자 에이전트는 인가 엔드 포인트를 로드한다.  
(3) 리소스 소유자가 인가 서버에 인증을 수행한다.  
(4) 리소스 소유자가 클라이언트를 인가한다.  
(5) 인가 서버는 사용자 에이전트를 클라이언트로 리다이렉트시키면서 인가 코드를 전달한다.  
(6) 사용자 에이전트는 인가 코드로 클라이언트의 리다이렉트 URI를 로드한다.  
(7) 클라이언트는 인가 코드의 자신의 자격 증명 정보를 토큰 엔드 포인트에 전달한다.  
(8) 인가 서버는 액세스 토큰을 클라이언트에게 전달한다.  
(9) 클라이언트는 액세스 토큰을 보호된 리소스에 전달한다.  
(10) 보호된 리소스는 클라이언트에게 요청된 리소스를 전달한다.  

#### 2.3. OAuth의 구성원: 클라이언트, 인가 서버, 리소스 소유자 그리고 보호된 리소스 
<br/>

+ OAuth 클라이언트  
리소스 소유자를 대신해 보호된 리소스에 접근하고자 하는 소프트웨어로 가장 단순한 OAuth 시스템의 구성 요소이며, 인가 서버로부터 액세스 토큰을 획득하고 획득한 액세스 토큰을 이용해 보호된 리소스에 접근하는 역할을 담당  

+ 보호된 리소스  
HTTP 서버를 통해 접근하고, 접근을 위해서는 OAuth 토큰이 필요하며, 전달된 토큰의 유효성을 검사하고 요청을 어떻게 처리할지를 결정  

+ 리소스 소유자  
클라이언트에게 접근 권한을 위임할 권한을 소유(소프트웨어가 아님)  

+ OAuth 인가 서버  
HTTP 서버로 리소스 소유자와 클라이언트를 인증하고 리소스 소유자가 클라이언트에게 권한을 위임할 수 있는 메커니즘을 제공하는 OAuth 시스템의 핵심적인 구성원  

#### 2.4. OAuth의 구성 요소: 토큰, 범위 그리고 인가 그랜트 
<br/>

##### 2.4.1. 액세스 토큰  
<br/>

+ OAuth 액세스 토큰(Access Token)  
클라이언트에게 권한이 위임됐다는 것을 나타내기 위해 인가 서버가 클라이언트에게 발급  

##### 2.4.3. 리프레시 토큰  
<br/>

+ OAuth 리프레시 토큰(Refresh Token)  
인가 서버가 클라이언트에게 발급하고 리소스 소유자와는 관련없이 이를 이용해 새로운 액세스 토큰을 요청  

+ 리프레스 토큰 이용 절차  
(1) 클라이언트는 보호된 리소스에게 액세스 토큰으로 리소스를 요청  
(2) 보호된 리소스는 해당 액세스 토큰에 대해 에러 반환  
(3) 클라이언트는 인가 서버에게 리프레시 토큰을 전달
(4) 인가 서버는 클라이언트에게 새로운 액세스 토큰과 리프레시 토큰 반환  
(5) 클라이언트는 보호된 리소스에게 액세스 토큰으로 리소스를 요청  
(6) 보호된 리소스는 클라이언트에게 응답으로 리소스를 전달  

##### 2.4.4. 인가 그랜트  
<br/>

+ 인가 그랜트  
OAuth 프로토콜을 이용해 OAuth 클라이언트에게 보호된 리소스에 대한 접근 권한을 위임해주기 위한 방법이며, 클라이언트가 사용자를 인가 엔드 포인트로 이동시키고, 인가 코드를 전달받고 마지막으로 인가 코드를 토큰과 교환하는 과정 전체  

#### 2.5. OAuth의 구성원과 구성 요소 간의 상호 작용: 백 채널, 프런트 채널 그리고 엔드 포인트  
<br/>

+ 비HTTP 채널을 통한 OAuth  
OAuth는 HTTP에 대해서만 정의되지만, OAuth 프로세스의 다른 부분을 비HTTP 프로토콜로 이동하는 방법에 대해 정의한 스펙도 있다. 예를 들면, GSS-API(Generic Security Services Application Program Interface)와 CoAP(Constrained Application Protocol)상에서 OAuth 토큰을 이용하는 방법을 정의한 표준안이 그것이다. 그 표준안에서는 프로세스의 시작 부분은 여전히 HTTP를 이용하지만, 가능한 한 직접 HTTP 기반의 OAuth 구성 요소를 다른 프로토콜로 변환하려고 한다.  

##### 2.5.1. 백 채널 통신  
<br/>

+ 백 채널(Back-channel)  
리소스 소유자와 사용자 에이전트 범위 밖에서 일반적이 HTTP 요청과 응답으로 구성 요소 간의 통신  

백 채널 통신은 모두 일반적인 HTTP 메커니즘으로 이뤄진다. 즉, 헤더, 질의 파라미터, 질의 메서드 그리고 질의 요청 내용에 중요한 트랜잭션 정보가 포함된다. 일반적인 경우보다 좀 더 많은 HTTP 스택이 이용되는 특징이 있으며, 대부분의 간단한 웹 API에서는 클라이언트 개발자가 그 응답에 좀 더 주의를 기울일 수 있다.  

인가 서버는 클라이언트가 액세스 토큰과 리프레시 토큰을 요청하기 위해 사용하는 토큰 엔드 포인트를 제공한다. 클라이언트는 토큰 엔드 포인트를 직접 호출하며, 인가 서버가 분석하고 처리할 수 있는 인코딩된 폼의 파라미터로 형태로 요청 내용을 전달한다. 그러면 인가 서버는 JSON 객체 형식의 토큰을 응답으로 전달한다.  

클라이언트가 보호된 리소스에 접근할 때도 백 채널 통신으로 HTTP를 직접 호출한다. 이때 전달되는 내용은 전적으로 보호된 리소스에 다라 결정된다.  

백 채널 통신에서 클라이언트는 OAuth 토큰을 전달하고 보호된 리소스는 자신에게 전달된 토큰과 그것이 갖고 있는 권한을 이해할 수 있어야 한다.  

##### 2.5.2. 프런트 채널 통신  
<br/>

+ 프런트 채널(Front-channel) 통신  
중간의 웹 브라우저를 통해 두 시스템이 간접적으로 HTTP 통신을 하는 방법으로 웹 브라우저의 양쪽 세션을 분리하며, 그로 인해 서로 다른 보안 도메인 간의 작업을 가능하게 해준다.  

프런트 채널 통신은 웹 브라우저가 방문해야 하는 URL을 파라미터를 전달함으로써 이뤄진다. 그런 URL을 전달받은 쪽에서는 해당 URL을 파싱하고 함께 전달된 파라미터와 동일한 방법으로 웹 브라우저를 해당 URL로 리다이렉트한다.  

그렇게 중간의 웹 브라우저를 통해 두 통신 주체는 서로 간접적으로 통신한다. 각 프런트 채널 요청과 응답은 실제로 HTTP 요청과 응답 트랜잭션 쌍이라고 할 수 있다.  

프런트 채널을 통해 전달되는 모든 정보는 웹 브라우저가 접근 가능하다. 따라서 그 내용을 읽거나 질의가 전송되기 전에 질의 내용이 조작될 잠재적인 가능성이 존재한다. 이 점 때문에 OAuth 프로토콜은 프런트 채널을 통해 전달되는 정보의 종류를 제한하고 프런트 채널에서 사용된 어떤 정보도 단독으로 권한 위임 작업을 위해 사용될 수 없도록 한다. 인가 코드는 웹 브라우저가 직접 사용할 수 없지만, 백 채널에서 클라이언트의 자격 증명과 함께 제시돼야 한다. OpenID 커넥트와 같은 몇몇 프로토콜은 클라이언트나 인가 서버가 프런트 채널 메시지를 서명함으로써 보다 향상된 보안성을 제공한다.  

+ 만약 클라이언트가 웹 애플리케이션이 아니라면?  
웹 애플리케이션이나 네이티브 애플리케이션 모두 OAuth를 이용할 수 있지만, 인가 엔드 포인트로부터 정보를 전달받기 위해서는 모두 동일한 채널 메커니즘을 이용해야 한다. 프런트 채널은 항상 웹 브라우저와 HTTP 리다이렉트를 이용한다. 하지만 반드시 일반적인 웹 서브를 이용해야 하는 것은 아니다. 다행스럽게도 내부 웹 서버나 애플리케이션을 위한 특정 URI 체계 그리고 백엔드 서비스로부터의 푸시 알림과 같은 몇 가지 유용한 트릭을 사용하면 된다. 웹 브라우저가 URI를 호출할 수만 있다면 어쨋듯 동작하는 데 문제는 없다.  

### 3. 간단한 OAuth 클라이언트  
<br/>

#### 3.3. 보호된 리소스에 접근하기 위한 토큰 사용  
<br/>

##### 3.3.1. Bearer 토큰을 전달하는 방법  
<br/>

지금가지 언급한 OAuth 액세스 토큰은 Bearer 토큰으로서 누구나 그것을 갖고 있으면 보호된 리소스에 접근할 수 있다. OAuth Bearer 토큰의 사용법을 정의한 스펙에서는 세 가지 방법의 토큰 전달 방법을 설명하고 있다.  

+ HTTP Authentication 헤더를 이용하는 방법
+ 폼 인코딩된 요청 파라미터로 전달하는 방법
+ URL 인코딩된 질의 파라미터로 전달하는 방법  

다른 두 가지 방법은 한계가 있기 때문에 가능하면 Authentication 헤더를 이용하는 방법을 이용하도록 권장하고 있다. 질의 파라미터로 액세스 토큰을 전달할 때 액세스 토큰이 URL 질의에 포함되기 때문에 실수로 서버의 로그에 액세스 토큰 값이 유출될 수 있다. 폼 인코딩된 파라미터로 액세스 토큰을 전달하는 방법은 보호된 리소스의 입력 유형이 폼 인코딩된 파라미터로 제한되고 POST 전송만 사용할 수 있다. 만약, API가 이미 그렇게 사용하도록 정해졌다면, 질의 파라미터로 전달할 때 발생할 수 있는 동일한 보안 이슈가 발생하지 않으므로 문제되지 않는다.  

Authentication 헤더를 이용하는 방법은 세 가지 방법 중에서 가장 큰 유연성과 보안성을 제공하지만, 일부 클라이언트에서는 사용하기가 어려울 수 있다는 단점이 있다.  

#### 3.4. 액세스 토큰 갱신  
<br/>

#### 3.4.1. 지금 갖고 있는 토큰이 유효한 것일까?  
<br/>

OAuth 클라이언트는 어떻게 자신이 갖고 있는 액세스 토큰이 유효한지 아는 것일까? 유일한 방법은 그것을 사용해보고 무슨 일이 발생하는지 확인하는 것이다. 액세스 토큰이 만료될 것으로 예상하면 인가 서버는 응답 내용에 선택적인 필드인 expires&#95;in을 이용해 토큰의 예상 만료 시간에 대한 힌트를 제공해준다. 그 값은 액세스 토큰이 만들어진 시간부터 시작해 토큰이 더 이상 유효하지 않을 것으로 예상되는 시간을 초 단위로 나타낸 것이다. 제대로 작성된 클라이언트는 expires&#95;in 값에 주의를 기울이고 만료 시간이 지난 토큰이라면 폐기해 버린다.  

하지만 클라이언트는 만료 시간에 대한 정보만으로 토큰의 상태를 알기가 어렵다. 많은 OAuth 구현에 있어 리소스 소유자는 토큰이 만료되기 전에 폐기할 수 있다. 잘 설계된 OAuth 클라이언트는 언제든지 액세스 토큰이 작동을 멈출 수 있다고 예상하고, 그에 따른 올바른 대응을 할 수 있어야 한다.  

### 4. 간단한 OAuth 리소스 서버  
<br/>

#### 4.2. 액세스 토큰의 유효성 확인  
<br/>

##### 4.2.1. 데이터베이스를 공유해 사용해야 하는가?  
<br/>

OAuth 구현에서 데이터베이스를 공유해 사용하는 것은 일반적인 패턴이지만, 꼭 그렇게 할 필요는 없다. 토큰 인트로스펙션이라는 표준화된 웹 프로토콜이 있는데, 이를 사용하면 리소스 서버는 토큰의 상태를 런타임으로 체크할 수 있다. 이를 통해 리소스 서버는 더 많은 네트워크 트래픽이 필요하지만 클라이언트처럼 토큰 자체를 불명확한 것으로 취급할 수 있다. 또는 토큰 자체에 보호된 리소스가 직접 파싱하고 이해할 수 있는 정보를 포함시킬 수 있다. 그런 것 중 하나가 JWT(JSON Web Token)이며, 암호로 보호된 JSON 객체에 여러 정보를 저장해 전달한다.  

#### 4.3.4. 추가 접근 통제  
<br/>

OAuath를 이용해 보호된 리소스에 적용할 수 있는 접근 통제 방법으로 보호할 리소스의 패턴은 실제로 매우 다양할 것이다. 이 때문에 OAuth는 권한 부여 결정 프로세스 역할을 수행하는 대신, 토큰과 권한 범위를 통해 인가 정보를 전달하는 역할을 담당한다. 이런 접근 방식 덕분에 OAuth는 인터넷상의 매우 다양한 형태의 API에 적용될 수 있다.  

리소스 서버는 토큰과 권한 범위와 같은 토큰 안에 포함된 정보를 이용할 수 있으며, 그런 정보는 바탕으로 인가를 직접적으로 결정할 수 있다. 또한 리소스 서버는 API 호출을 제공할지 여부와 API 호출에 대해 무엇을 반환할지를 결정하기 위해 액세스 토큰과 다른 접근 통제 정보를 결합해볼 수도 있다. 예를 들어, 리소스 서버는 토큰과는 상관없이 특정 클라이언트와 사용자에 대해 정해진 시간에만 접근할 수 있도록 제한할 수 있다. 심지어 리소스 서버는 토큰을 입력값으로 해 외부 정책 엔진을 요청함으로써 보다 복잡한 이가 규칙을 조직 내에서 중앙 집중식으로 관리할 수도 있다.  

리소스 서버는 항상 액세스 토큰이 무엇을 의미하는지에 대한 최종 결정권을 갖는다. 리소스 서버 이외의 의사 결정 프로세스가 아무리 많다고 하더라도 결국 요청된 것에 대해 무엇을 하지 여부를 결정하는 것은 항상 전적으로 리소스 서버에 달려 있다.  

### 5. 간단한 OAuth 인가 서버  
<br/>

#### 5.2. 클라이언트 인가  
<br/>

##### 5.2.1. 인가 엔드 포인트  
<br/>

OAuth 스펙에서는 하나의 등록된 리다이렉트 URI에 에러 코드를 추가하는 방식으로 클라이언트에게 에러를 반환하기 위한 메커니즘을 정의하고 있지만, 이 경우에는 해당하지 않는다. 왜 그럴까? 전달된 클라이언트 ID나 리다이렉트 URI가 유효하지 않다면 그것은 악의적인 공격자가 사용자를 공격하고 있다는 표시라고 볼 수 있다. 만약, 그렇다면 인가 서버는 리다이렉트 URI의 내용을 전혀 통제하지 못할 것이다. 즉, 리다이렉트 URI가 피싱 페이지이거나 악성 코드를 감염시키는 페이지일 수도 있다. 인가 서버는 악의적인 클라이언트 애플리케이션으로부터 사용자를 완전히 보호할 수는 없다. 하지만 최소한 몇 가지 유형의 공격은 간단히 필터링해줄 수 있다.  

#### 5.6. 요약  
<br/>

+ 프런트 채널 및 백 채널 응답 통신을 처리하는 데에는 유사한 요청이나 응답이라고 할지라도 다른 기술이 필요하다.
+ 인가 코드 플로는 액세스 토큰을 만들기 위해 여러 단계에 걸친 데이터 추적이 필요하다.
+ 인가 서버를 공격할 수 있는 잠재적인 공격 포인트는 많이 있으며, 그것들을 모두 적절히 방어해야 한다.
+ 리프레시 토큰은 액세스 토큰과 함께 발급되며, 사용자 개입 없이 새로운 액세스 토큰을 발급받고자 할 때 사용한다.
+ 권한 범위는 액세스 토큰의 권한을 제한한다.  

### 6. 현실 세계의 OAuth 2.0  
<br/>

#### 6.1. 인가 그랜트 타입  
<br/>

##### 6.1.1. 암시적 그랜트 타입  
<br/>

인가 코드 플로의 중요한 특징은 서로 다른 구성 요소 간에 정보를 별도로 유지한다는 것이다. 따라서 웹 브라우저는 클라이언트만 알아야 하는 사항을 알지 못하며, 클라이언트는 웹 브라이줘의 상태 정보를 얻을 수 없다. 하지만 클라이언트가 웹 브라우저 내부에 있는 경우는 어떻게 될까?  

웹 브라우저 내부에서 실행되는 자바스크립트 애플리케이션이 그런 경우에 해당할 것이다. 그런 경우, 클라이언트는 웹 브라우저로부터 중요한 정보를 보호할 수 없고, 웹 브라우저는 클라이언트의 실행에 관련된 모든 것을 알 수 있다. 따라서 웹 브라우저를 통해 인증 코드를 클라이언트에게 전달하는 데 있어서 실질적인 이점이 없고, 클라이언트가 토큰에 대한 정보를 교환하도록 하기 위한 별도의 비밀 계층이 전혀 보호되지 않는다.  

암시적 그랜트 타입은 인가 엔드 포인트에서 토큰을 직접 전달해주기 때문에 토큰 전달을 위해 사용되는 추가 비밀 정보나 상호간의 통신을 필요로 하지 않는다. 따라서 암시적 그랜트 타입은 인가 서버와의 통신을 위해 프런트 채널만 사용한다. 이 플로는 웹 사이트에 삽입돼 어느 정도 제한되고, 보안 도메인 간에 공유되는 세션에 대한 인가를 수행해야 하는 자바스크립트 애플리케이션에게 상당히 유용하도고 할 수 있다. 암시적 그랜트에는 사용하기 전에 고려해야 하는 제한 사항이 있다. 첫 번째는 클라이언트 시크릿을 포함한 모든 것이 웹 브라우저에게 노출되기 때문에 클라이언트는 자신의 중요 정보를 보호할 현실적인 방법이 없다는 것이다. 암시적 그랜트 플로에서는 토큰 엔드 포인트는 사용하지 않고 인가 엔드 포인트만 사용하며, 클라이언트는 인가 엔드포인트에서 인증을 받지 않는다. 따라서 이 제한은 클라이언트의 기능에는 별다른 영향을 미치지 않을 것이다.  

하지만 클라이언트를 인증할 방법이 없으면 그랜트 타입에 대한 보안 프로파일에 영향을 미치게 되므로 신중하게 접근할 필요가 있다. 또한 암시적 플로로는 리프레시 토큰을 얻을 수 없다. 웹 브라우저에서 실행되는 애플리케이션은 그 생명주기가 짧고, 애플리케이션을 로드한 웹 브라우저 컨텍스트의 세션만큼만 유지되기 때문에 리프레스 토큰의 유용성은 매우 제한적이다. 더욱이 다른 그랜트 타입과 달리, 리소스 소유자가 웹 브라우저를 사용하고 있고, 필요한 경우 클라이언트를 재인가할 수 있다고 가정할 수 있다. 인가 서버는 여전히 TOFU(Trust On First Use) 원칙을 적용할 수 있어서 매끄러운 사용자 경험으로 재인증이 이뤄질 수 있다.  

클라이언트는 인가 코드 플로의 경우와 동일한 방법으로 인가 서버의 인가 엔드 포인트에 인가 요청을 보낼 수 있다. 다만, 다른 점은 response_type 파라미터의 값이 code가 아닌 token이 사용된다는 것이다. 이는 토큰과 교환할 때 사용되는 인가 코드 대신 토큰을 생성하도록 인가 서버에 알리기 위함이다.  

클라이언트는 이를 위해 전체 페이지를 리다이렉트시키거나 페이지 안에서 iframe를 이용할 수도 있다. 어떤 방법을 사용하는 웹 브라우저는 인가 서버의 인가 엔드 포인트에 요청을 보낸다. 리소스 소유자는 스스로 인증하고 인가 코드 플로와 동일한 방법으로 클라이언트를 인가한다. 하지만 인가 코드 플로의 경우와 달리, 인가 서버는 토큰을 즉시 생성해 URI 프래그맨트에 생성한 토큰을 붙여 전달한다. 기억해야 할 것은 이 과정이 프런트 채널로 수행되기 때문에 클라이언트에 대한 응답은 클라이언트의 리다이렉트 URI로 HTTP 리다이렉트되는 형태로 전달된다는 것이다.  

일반적으로 URI의 프레그먼트 부분은 서버로 다시 전달되지 않는다. 그것은 토큰 값은 웹 브라우저 내부에서만 사용할 수 있다는 의미가 된다. 하지만 웹 브라우저의 버전과 구현 방식에 따라 달라질 수도 있다.  

##### 6.1.2. 클라이언트 자격 증명 그랜트 타입  
<br/>

명시적인 리소스 소유자가 없거나 리소스 소유자와 클라이언트 소프트웨어를 구별하기 힘들 때는 어떻게 해야 할까? 이는 흔하게 접할 수 있는 상황으로, 백엔드 시스템이 있어서 그것들이 서로 직접 통신하며, 특정 사용자를 대신할 필요가 없을 수 있다. 이럴 때는 OAuth 2.0에 추가된 클라이언트 자격 증명 그랜트 타입을 이용하면 된다. 암시적 플로의 경우에는 클라이언트가 웹 브라우저에 밀어 넣어져 그 안에서 프런트 채널을 사용했다. 결과적으로 클라이언트는 백 채널을 사용하게 되고, 토큰 엔드 포인트에서 액세스 토큰을 얻기 위해 리소스 소유자의 역할을 한다.  

클라이언트는 인가 코드 그랜트 타입의 경우처럼 토큰 엔드 포인트에 토큰을 요청한다. 차이점은 grant_type 파라미터의 값으로 client_credentials를 사용하며, 토큰과 교환히기 위해 인가 코드나 암시적인 자격 증명을 사용하지 않는다는 것이다. 대신, 클라이언트는 직접 스스로 인증하고 인가 서버는 적절한 액세스 토큰을 발급한다. 또한 인가 코드 플로와 implicit 플로의 인가 엔드 포인트에서 사용되는 scope 파라미터와 유사하게 클라이언트는 토큰을 요청할 때 scope 파라미터를 이용해 특정 권한 범위를 요청할 수 있다.  

인가 서버로부터 전달되는 응답은 일반적인 OAuth 토큰 엔드 포인트의 응답과 같다. 즉, 토큰 정보를 포함하는 JSON 객체로 전달된다. 클라이언트 자격 증명 플로에서 클라이언트는 별도의 리소스 소유자 없이 언제든지 자기자신을 위해 새로운 토큰을 요청할 수 있다고 가정하기 때무네 리프레시 토큰이 필요 없다. 따라서 리프레시 토큰을 발급하지 않는다.  

클라이언트는 다른 플로의 경우와 동일한 방법으로 액세스 토큰을 이용하며, 보호된 리소스는 심지어 클라이언트가 토큰을 어떻게 획득했는지 알 필요가 없다. 토큰 자체는 권한을 사용자가 위임했는지 또는 클라이언트가 직접 요청했는지에 따라 액세스 권한이 다를 수 있지만, 그런 종류의 차이점은 권한 위임 방식을 구분할 수 있는 인가 정책 엔진으로 처리할 수 있다. 다시 말해, 리소스 서버에 동일하게 전달되는 것 같지만 그것을 다르게 처리할 수 있다.  

클라이언트 자격 증명 그랜트 타입에서는 사용자와의 직접적인 상호 작용이 없기 때문에 서비스에 직접 접근하는 신뢰할 수 있는 백엔드 시스템을 위한 것이다. 이점을 이용해 보호된 리소스는 요청을 처리할 때 요청한 클라이언트가 사용자와의 상호 작용이 있는 클라이언트인지 여부를 구분할 수 있다. 이를 위해 클라이언트 유형별로 각기 다른 권한 범위를 인가하는 방법을 일반적으로 사용하며, 인가 서버에 클라이언트를 등록하는 과정의 일부로서 관리된다.  

##### 6.1.3. 리소스 소유자 자격 증명 그랜트 타입  
<br/>

+ 리소스 소유자 자격 증명 그랜트 타입  
리소스 소유자가 인가 서버에 암호화되지 않은 사용자 이름과 비밀번호를 갖고 있다면 클라이언트는 사용자에게 해당 자격 증명 정보를 요구한 후, 그것을 액세스 토큰과 교환할 수 있다. 이와 같은 리소스 소유자 자격 증명 그랜트 타입은 비밀번호 플로라고도 한다. 리소스 소유자는 클라이언트와 직접 상호 작용하며, 인가 서버와는 상호 작용하지 않는다. 이 그랜트 타입은 토큰 엔드 포인트만 사용하며, 백 채널만 사용한다. 이 그랜트 타입은 안티패턴(antipattern)에 기반을 두고 있다.  

+ 안티패턴의 명문화  
왜 이런 패턴을 사용하면 안 되는지에 대해 생각해보자. 앞뒤로 리다이렉션을 처리하는 것보다는 확실히 프로그램이 간단해진다. 하지만 그런 단순함으로 인해 보안 위험이 크게 증가하고 유연성과 기능성이 떨어진다. 리소스 소유자의 자격 증명 정보가 암호화되지 않은 상태로 클라이언트에게 노출되고 클라이언트는 그것을 캐싱하거나 언제든지 사용할 수 있다. 클라이언트 자격 증명이 암호화되지 않고(TLS 암호화 연결을 통해 전달된다고 하더라도) 인가 서버에 전달되면 전달된 자격 증명을 검증해야 하고, 또 다른 잠재적인 연결을 통해 공격 포인트가 만들어진다. 사용자 경험에 영향을 미치지 않고 폐기하거나 순환시킬 수 있는 OAuth 토큰과 달리, 사용자의 이름과 비밀번호는 관리하거나 변경하는 것이 훨신 어려운 경향이 있다. 사용자의 자격 증명을 수집하고 재사용해야 한다는 요구 사항으로 인해 사용자를 인증하는 데 사용할 수 있는 자격 증명의 종류 또한 제한된다. 웹 브라우저를 통해 접근하는 인가 서버는 인증서나 연합된 신원과 같은 다양한 인증 기술과 사용자 경험을 사용할 수 있지만, 가장 효과적이고 안전한 방법 대다수는 리소스 소유자 자격 증명 그랜트 타입이 의존하는 자격 증명 재사용을 방지하도록 설계됐다. 따라서, 사용자 이름과 비밀번호 또는 그와 유사한 것을 이용한 인증을 효과적으로 제한한다. 결국 사용자에게 비밀번호를 요구하는 모든 애플리케이션에게 그것을 제공하도록 사용자를 학습시키게 된다. 따라서 인가 서버와 같은 신뢰할 수 있는 애플리케이션에게만 비밀번호를 제공하도록 사용자 교육을 해야 한다.  

그렇다면 OAuth는 왜 그렇게 좋지 않은 그랜트 타입을 명문화했을까? 만약, 사용할 수 있는 다른 옵션이 있었다면 그것은 매우 나쁜 생각이었겠지만, 실행 가능한 다른 옵션이 없다는 것이 문제다. 리소스 소유자 자격 증명 그랜트 타입은 클라이언트가 리소스 소유자의 사용자 이름과 비밀번호를 묻고, 그렇게 얻은 자격 증명은 모든 보호된 자원에 접근하기 위해 재사용된다. 사용자를 귀찮게 하지 않고 이를 수행하기 위해 클라이언트는 사용자 이름과 비밀번호를 저장해 놓고 나중에 필요할 때 그것을 재사용한다. 보호된 리소스는 요청이 올 때마다 사용자의 비밀번호를 매번 검증해야 하며, 민감한 정보에 대한 엄청난 공격 대상이 될 수 있다.  

리소스 소유자 자격 증명 그랜트 타입은 OAuth의 보다 안전한 다른 그랜트 타입을 사용하는 보다 현대적인 보안 아키텍처를 위한 발판 역할을 할 수 있다. 우선, 보호된 리소스는 사용자의 비밀번호를 더 이상 알 필요가 없으며, OAuth 토큰만으로 처리할 수 있다. 따라서 네트워크를 통해 사용자의 자격 증명 정보가 노출되거나 그것을 볼 수 있는 구성 숑소의 수가 제한된다. 둘째로, 선의의 클라이언트 애플리케이션은 더 이상 비밀번호를 저장하고 리소스 서버에 그것을 전달할 필요가 없다. 클라이언트는 자격 증명을 액세스 토큰과 교환하고 다양한 보호된 리소스에 접근하기 위해 액세스 토큰을 사용한다. 리프레시 토큰과 결합하면 사용자 경험은 이전과 동일하지만, 보안 프로필이 상당히 향상된다. 인가 코드 그랜드 타입을 사용하는 것이 더 좋긴 하지만, 보호된 리소스를 요청할 때마다 매번 사용자의 비밀번호를 재사용하는 것보다는 이 그랜트 타입을 사용하는 것이 경우에 따라서는 더 좋을 수 있다.  

이 그랜트 타입은 현실 세계에서는 되도록이면 사용하지 않는 것이 좋다. 이 그랜트 타입은 사용자 이름과 비밀번호를 직접 처리해야 하는 클라이언트를 연결하는 데에만 사용해야 하며, 가능하다면 최대한 인가 코드 그랜트를 사용해야 한다. 즉, 다른 선택지가 없는 이상, 이 그랜트 타입을 사용하면 안 된다.  

##### 6.1.4. 어설션 그랜트 타입  
<br/>

+ 어설션 그랜트(Assertion grant) 타입  
클라이언트가 토큰과 교환하는 과정에 어설션(assertion)이라는 일종의 인증된 문서로 구조화되고 암호로 보호된 항목을 사용하고 백 채널만 사용하며, 명시적으로 리소스 소유자가 관여하지 않는다.  

발급받은 토큰과 관련된 권한은 클라이언트에 의해만 결정되지 않고 전달된 어설션에 의해 결정된다. 어설션은 일반적으로 외부의 서드파티로부터 클라이언트로 전달되기 때문에 클라이언트는 어셜션 자체에 대한 내용은 알지 못할 수 있다.  

다른 백 채널 플로의 경우처럼 클라이언트는 인가 서버의 토큰 엔드 포인트로 HTTP POST 요청을 보낸다. 클라이언트는 늘 그렇듯 자기자신을 스스로 인증하며, 어설션을 파라미터로서 포함된다. 클라이언트가 어설션을 얻을 수 있는 방법은 매우 다양하며, 그것과 관련된 프로토콜이 많다. 사용자 클라이언트에게 어설션을 전달해줄 수도 있고, 설정 시스템이나 또 다른 비OAuth 프로토콜이 전달할 수도 있다.  

결국 액세스 토큰과 마찬가지로 클라이언트가 인가 서버에 어설션을 전달할 수만 있다면, 클라이언트가 어설션을 얻은 방법은 중요하지 않다.  

인가 서버는 전달된 어설션을 파싱하고 암호화 부분을 확인하며, 그서의 내용을 바탕으로 생성할 토큰의 종류를 판단한다. 어설션은 리소스 소유자의 ID나 허용된 권한 범위 셋과 같은 다양한 내용을 포함할 수 있다. 일반적으로 인가 서버는 어설션이 무엇을 의미하는지에 대한 규칙과 어설션을 허용할 것인지를 결정하기 위한 정책을 갖고 있다. 마지막에는 다른 토큰 엔드 포인트의 응답과 마찬가지로 액세스 토큰을 생성한다. 그러면 클라이언트는 발급받은 토큰을 이용해 보호된 리소스를 요청한다.  

이 그랜트 타입은 클라이언트가 토큰 엔드 포인트에 정보를 전달하면 인가 서버는 토큰을 직접 발급한다는 면에서 다른 백 채널만 사용하는 플로와 유사하다. 실제로는 기업과 같은 제한된 곳에서만 어설션을 볼 수 있을 것이다.  

##### 6.1.5. 올바른 그랜트 타입 선택  
<br/>

현재의 작업을 위해 어느 그랜트 타입이 가장 적합한지 결정하는 것은 쉬운 일이 아니다. 하지만 고맙게도 올바른 방향으로 갈 수 있는 몇 가지 기본적인 원칙이 있다.  

클라이언트가 리소스 소유자를 대신해 행동하는가? 그리고 사용자를 웹 브라우저 내의 웹 페이지로 이동시킬 수 있는가?  

그렇다면, 리다이렉트 기반의 플로인 인가 코드나 암시적 그랜트 타입 중 하나를 원할 것이다. 무엇을 선택할 것인가? 그것은 클라이언트에게 달려 있다.  

클라이언트가 웹 브라이저 내에서만 동작하는가? 서버에서 실행되는 애플리케이션과 웹 브라우저를 통해 사용자 인터페이스에 액세스하는 애플리케이션은 포함되지 않으며, 전적으로 웹 브라우저 자체 내부에서만 동작하는 애플리케이션만 해당된다. 그렇다면 특정 케이스에 최적화된 암시적 플로를 사용하는 것이 좋을 것이다. 그렇지 않은 경우에는, 애플리케이션이 웹 서버로부터 제공되거나 사용자의 컴퓨터에서 네이티브로 동작하는 것이므로 최고의 보안 속성과 유연성을 가진 인가 코드 플로를 사용하는 것이 좋다.  

클라이언트가 네이티브 애플리케이션인가? 이미 인가 코드 그랜트 타입에 대해 다뤘지만, 인가 코드 그랜트 타입 외에도 DynReg(Dynamic Registration)나 PKCE(Proof Key for Code Exchange)와 같은 특정 보안 확장을 사용하길 원할 것이다.  

클라이너트가 자신을 대신해 행동하는가? 그 범주에는 대용량 데이터 전송과 같이 단일 사용자에게 매핑되지 않은 API에 대한 접근이 포함된다. 그렇다면, 클라이언트 자격 증명 플로를 사용하는 것이 좋다. 어떤 사용자로 동작할지를 파라미터로 지정하는 API를 사용하는 경우에는 개별적인 동의 및 감사를 허용하느느 리다이렉트 기반의 플로를 사용하는 것이 좋다.  

클라이언트가 신뢰할 수 있는 서드파티의 지시 아래 있는가? 서드파티가 사용자를 대신할 수 있다는 것을 증명하는 무엇인가를 직접 제공할 수 있는가? 그렇다면, 어설션 플로 중 하나를 사용하는 편이 좋을 것이다. 어느 것을 사용할지는 인가 서버와 어설션을 발급하는 서드파티에 따라 달라질 수 있다.  

클라이언트는 사용자를 웹 브라우저에서 리다이렉트할 수 없는가? 사용자에게 알려줄 수 있는 간단한 자격 증명 세트를 갖고 있는가? 다른 선택지가 없는가? 그렇다면, 리소스 소유자 자격 증명 플로를 사용할 수 있으며, 그 한계를 잘 알아야 한다. 물론, 그것을 사용하는 것에 대해 경고를 받지 않았다고 말하면 안 된다.  

#### 6.2. 클라이언트 배포  
<br/>

OAuth 클라이언트는 다양한 형태와 스타일로 제작될 수 있다. 하지만 그렇게 다양하다고 하더라도 크게 세 가지로 분류할 수 있다. 그것은 웹 애플리케이션과 웹 브라우저 애플리케이션, 네이티브 애플리케이션이다. 각기 장단점을 갖고 있으며, 차례대로 살펴보자.  

##### 6.2.1. 웹 애플리케이션  
<br/>

OAuth 클라이언트의 가장 일반적인 형태는 웹 애플리케이션이다. 웹 애플리케이션은 원격지 서버에서 실행되며, 웹 브라우저를 통해 접근한다. 웹 서버에 애플리케이션 설정과 실행 상태가 저장되며, 웹 브라우저와 연결은 일반적으로 세션 쿠키로 이뤄진다.  

웹 애플리케이션은 프런트 채널과 백 채널 통신 모두를 수행할 수 있다. 사용자는 이미 웹 브라우저로 상호 작용하기 때문에 프런트 채널로 요청을 보내는 것은 웹 브라우저에 HTTP 리다리엑트 메시지를 보내는 것만큼 간단하다. 또한 프런트 채널로 전달되는 응답을 기다리는 것은 애플리케이션이 실행되는 애플리케이션이 이미 보낸 HTTP 요청을 기다리는 것만큼 간단하다. 백 채널 통신은 애플리케이션이 실행되는 웹 서버에서 HTTP 호출이 직접 만들어질 때 발생할 수 있다. 이와 같은 유연성으로 인해 웹 애플리케이션은 인가 코드 그랜트와 클라이언트 자격 증명 그랜트를 쉽게 사용할 수 있으며, 어설션 그랜트 플로의 경우는 가장 효과적으로 사용할 수 없다. 일반적으로 요청 URI의 프레그먼트 부분은 웹 브라우저에 의해 서버로 전달되지 않기 때문에 웹 애플리케이션에서는 대부분의 경우, 암시적 플로가 제대로 동작하지 않다.  

##### 6.2.2. 웹 브라우저 애플리케이션  
<br/>

웹 브라우저 애플리케이션은 전적으로 웹 브라우저에서 실행되며, 일반적으로 자바스크립트로 구현된다. 웹 서버가 애플리케이션 코드를 제공해야 하지만, 그것이 서버에서 실행되지는 않으며, 웹 서버는 애플리케이션의 런타임 상태를 관리하지 않는다. 애플리케이션에 관련된 모든 것은 사용자 컴퓨터의 웹 브라우저 내에서 이뤄진다.  

웹 브라우저 애플리케이션에서는 HTTP 리다이렉트 사용자를 다른 페이지로 이동시키는 것이 간단하기 때문에 프런트 채널을 쉽게 사용할 수 있다. 또한 클라이언트 소프트웨어를 웹 서버에서 로드해야 하기 때문에 프런트 채널을 통한 응답도 간단하다. 하지만 웹 브라우저 애플리케이션은 크로스-도메인 공격을 막기 위한 동일 출처 정책(Same-Origin Policy)과 그와 관련된 보안 요구 사항에 의해 제한을 받기 때문에 백 채널 통신은 좀 더 복잡하다고 할 수 있다. 결국 웹 브라우저 애플리케이션은 이와 같은 환경에 최적화된 암시적인 플로에 가장 잘 맞는다고 할 수 있다.  

##### 6.2.3. 네이티브 애플리케이션  
<br/>

네이티브 애플리케이션은 컴퓨터나 모바일 플랫폼과 같은 사용자 기기에서 직접 실행되며, 컴파일되거나 패키징돼 기기에 설치된다.  

네이티브 애플리케이션은 백 채널을 이용해 원격지 서버에 대한 HTTP 호출을 직접 수행한다. 웹 애플리케이션이나 웹 브라우저 클라이언트처럼 사용자가 웹 브라우저를 이용하는 것이 아니기 때문에 프런트 채널은 문제가 될 수 있다. 프런트 채널 요청을 만들기 위해 네이티브 애플리케이션은 시스템 웹 브라우저나 임베디드 웹 브라우저를 사용해 사용자와 인가 서버를 직접 연결할 수 있어야 한다. 프런트 채널 응답을 수신 대기하기 위해 네이티브 애플리케이션은 인가 서버가 리다이렉트할 수 있는 URI를 제공해야 한다.  

모바일 애플리케이션에서 커스텀 URI 스킴은 일반적이다. 네이티브 애플리케이션은 인가 코드 그랜트와 클라이언트 자격 증명 그랜트 또는 어설션 그랜트 플로를 쉽게 사용할 수 있다. 하지만 웹 브라우저 외부에 정보를 저장할 수 있기 때문에 암시적 그랜트 플로를 사용하는 것은 권장하지 않는다.  

##### 6.2.4. 클라이언트 시크릿 관리  
<br/>

클라이언트 시크릿(Client Secret)의 목적은 리소스 소유자가 인가한 권한을 확인하는 것이 아니라 인가 서버에서 클라이언트 소프트웨어 자체를 인증하는 것이다. 클라이언트 시크릿은 리소스 소유자나 웹 브라우저에서 사용할 수 없기 때문에 클라이언트 소프트웨어 애플리케이션을 고유하게 식별하는 데 사용될 수 있다. OAuth 1.0에서는 클라이언트의 종류와 상관없이 모든 클라이언트가 클라이언트 시크릿(OAuth 1.0 스펙에서는 그것을 comsumer key라고 불렀다)을 가졌다. 웹 애플리케이션의 경우에는 웹 브라우저와 사용자와 분리돼 클라이언트 시크릿을 설정할 수 있지만, 네이티브 애플리케이션과 웹 브라우저 애플리케이션의 경우에는 그렇지 않다.  

문제는 클라이언트 복사본 모두에 동일하게 설정되는 설정 시간 시크릿(configuration time secrets)과 각각의 클라이언트 인스턴스마다 다르게 갖는 런타임 시크릿(runtime secrets)을 구별해야 하는 것이다. 클라이언트 시크릿은 설정 시간 시크릿이다. 왜냐하면 설정 시간 시크릿이 클라이언트 소프트웨어 자체를 나타내고 클라이언트 소프트웨어 내부에 그 값이 설정되기 때문이다. 액세스 토큰과 리프레시 토큰 그리고 인가 코드는 모두 실행 시에 배포돼 클라이언트 소프트웨어에 저장되기 때문에 런타임 시크릿이다. 런타임 시크릿은 또한 안전하게 저장되고 적절히 보호돼야 하지만, 쉽게 폐기되고 순환될 수 있도록 설계됐다. 반대로 설정 시간 시크릿은 일반적으로 자주 변경되지 않는다.  

OAuth 2.0에서는 클라이언트 시크릿에 대한 이분법적인 요구 사항을 해결하기 위해 모든 클라이언트가 클라이언트 시크릿을 가져야 한다는 제약 사항을 없앴다. 따라서 설정 시간 시크릿의 보유 여부에 따라 공개 클라이언트(public clients)와 기밀 클라이언트(confidential clients)로 구분된다.  

공개 클라이언트는 그 이름이 나타내는 바와 같이 설정 시간 시크릿, 즉 클라이언트 시크릿을 가질 수 없다. 왜냐하면 클라이언트가 다운로드돼 웹 브라우저 내에서 실행되거나 사용자의 기기에 네이티브 애플리케이션으로 실행될 때 클라이언트를 위한 코드가 사용자에게 어떤 식으로든 노출될 수 있기 때문이다. 따라서 대부분은 웹 브라우저 애플리케이션과 네이티브 애플리케이션은 공개 클라이언트라고 할 수 있으며, 클라이언트 복사본은 모두 동일하고 각각 많은 인스턴스를 가질 수 있다. 애플리케이션 사용자는 애플리케이션 인스턴스에서 클라이언트 ID와 클라이언트 ID를 공유하더라도 클라이언트 ID가 비밀값이 아니기 때문에 문제가 되지는 않는다. 클라이언트 ID를 복사해 마치 해당 클라이언트인 것처럼 행세하려고 하더라도 리다이렉트 URI를 이용해야 하고, 다른 방법으로 바인딩해야만 한다. 공개 클라이언트가 추가 클라이언트 시크릿을 이용하도록 한다고 하더라도 그것 또한 클라이언트 ID와 함께 추출될 수 있기 때문에 바람직하지는 않다.  

잠재적인 공격 대응 방안은 PKCE(Proof Key for Code Exchange) 형태의 인가 코드 플로를 이용하는 것이다. PKCE 프로토콜 확장을 사용하면 클라이언트는 인가 코드를 이용하는 것보다 좀 더 밀접하게 바인딩할 수 있지만, 클라이언트 시크릿이나 그와 유사한 것을 사용하지는 않는다.  

기밀 클라이언트는 설정 시간 시크릿을 가질 수 있다. 기밀 클라이언트 소프트웨어 인스턴스는 각기 다른 클라이언트 ID나 시크릿과 같은 설정 내용을 갖는다. 또한 사용자가 그것을 추출하는 것이 쉽지 않다. 웹 애플리케이션은 가장 일반적인 기밀 클라이언트이며, 단일 OAuth 클라이언트로서 웹 서버에서 동작하고 여러 리소스 소유자를 처리할 수 있다. 클라이언트 ID는 웹 브라우저를 통해 노출되고 수집될 수 있지만, 클라이언트 시크릿은 백 채널로만 전달되며 절대로 직접 노출되지 않는다.  

### 7. 일반적인 클라이언트 보안 취약점  
<br/>

#### 7.2. 클라이언트에 대한 CSRF 공격  
<br/>

+ 상태 파라미터  
클라이언트가 요청과 콜백 사이의 상태를 유지하기 위해 사용하는 구조가 정해지지 않은 값으로서 인가 서버는 유저 에이전트를 클라이언트로 다시 리다이렉트시킬 때는 이 값을 함께 전달한다. CSRF(Cross-Site Request Forgery) 공격을 방지하기 위해서는 이 값을 사용해야 한다.  

+ CSRF  
악의적인 애플리케이션이 현재 사용자가 인증된 웹 사이트로 사용자의 웹 브라우저가 요청을 보내게 함으로써 원하지 않는 작업이 이뤄지도록 만드는 것으로 웹 브라우저가 요청을 만들고(쿠키를 이용해) 그로 인해 특정 작업이 수행되며 어떤 특정 작업을 수행할 수 있는 사이트에 사용자가 로그인하면 공격자는 사용자의 웹 브라우저가 그런 작업 중 하나를 요청하도록 만들어 해당 작업이 로그인한 사용자 권한으로 실행되는 것이다. 일반적으로 공격자는 사용자 몰래 웹 브라우저가 특정 작업 URI를 호출하게 만들기 위해 악의적인 HTML 코드나 자바스크립트 코드를 이메일이나 웹 사이트에 삽입한다. CSRF 공격을 막기 위한 가장 일반적이고 효과적인 방법은 각각의 HTTP 요청에 예측할 수 없는 값을 추가하는 것이다. 즉, OAuth 클라이언트가 예측하기 힘든 상태 파라미터 값을 만들고, 인가 서버에 요청을 보낼 때 그것을 함께 보내는 것이다. 그러면 인가 서버는 리다이렉트 URI의 파라미터로 자신에게 전달된 상태 파라미터 값을 그대로 전달한다. 그렇게 리다이렉트 URI가 호출되면 클라이언트는 상태값을 확인한다. 만약, 자신이 인가 서버에 보낸 값과 다르거나 없다면 클라이언트는 더 이상 OAuth 플로를 수행하지 않으면 된다. 이렇게 함으로써 공격자가 자신의 인가 코드를 클라이언트에 삽입하는 것을 방지할 수 있다.  

#### 7.4 리다이렉트 URI 등록  
<br/>

##### 7.4.1. 레퍼러를 통한 인가 코드 탈취  
<br/>

+ HTTP 레퍼러  
하나의 웹 페이지에서 다른 웹 페이지로 이동될 때 웹 브라우저(일반적으로 HTTP 클라이언트)가 HTTP 헤더에 추가하는 필드

+ 레퍼러 전송 정책  
공격자가 이용하는 URI는 반드시 https URI여야 한다. 실제로, HTTP RFC(RFC 2616)의 15.1.3 절(Encoding Seesitive Information in URI's)에서는 다음과 같이 기술하고 있다. 레퍼러 페이지가 보안 프로토콜로 전달됐다면 클라이언트는(보안되지 않은) HTTP 요청으로는 Referer 헤더 필드를 포함시키면 안 된다.  

#### 7.6. 토큰 탈취  
<br/>

OAuth를 대상으로 한 공격자의 최종 목표는 액세스 토큰을 탈취하는 것이다. 액세스 토큰이 있으면 공격자는 이전에는 절대로 수행할 수 없었던 모든 종류의 작업을 수행할 수 있다. 가장 일반적인 방법은 요청 헤더에 Bearer 토큰을 전달(Authentication: Bearer aceess_token_value)하는 방법이다. RFC 6750에서는 Bearer 토큰을 전달하는 그 외의 두 가지 방법을 정의하고 있다. 그것 중 하나는 URI 질의 파라미터를 이용하는 것이다. 이 방법은 매우 단순하다는 장점이 있지만, 보호된 리소스에 접근하기 위해 이 방법으로 액세스 토큰을 전달하는 것은 많은 단점을 갖고 있다.  

+ 액세스 토큰은 URI의 일부로 인식돼 access.log 파일에 기록된다.
+ 사람들은 공개된 포럼(예를 들면, Stackoverflow)에서 답변을 검색하기 위해 데이터를 복사해 붙여 넣는 행위를 아무런 거리낌없이 하는 경향이 있다.
+ 이렇게 되면 결국 HTTP 기록이나 접근 URL을 통해 포럼에 액세스 토큰이 붙여 넣기될 가능성이 있다.
+ 레퍼러에는 전체 URL에 포함되기 때문에 레퍼러를 이용한 공격으로 액세스 토큰은 유출될 위험이 있다.  

이는 표준 Authorization 헤더를 사용하면 URL에 액세스 토큰이 포함되지 않기 때문에 이와 같은 문제를 피할 수 있다.  

+ Authorization Server Mix-Up  
2016년 1월 OAuth 워킹 그룹의 메일링 리스트에 보안 권고문이 게시됐다. 그것은 트리어 대학(University of Trier)과 보훔 루르 대학(Ruhr-University Bochum)의 연구원들이 개별적으로 발견한 Authorization Server Mix-Up에 대한 내용이었다. 하나 이상의 인가 서버에서 발급된 여러 개의 클라이언트 ID를 갖고 있는 OAuth 클라이언트를 속여 클라이언트가 하나의 서버에서 또 다른 악의적인 서버로 시크릿(클라이언트 시크릿과 인가 코드)을 전달하도록 속일 수 있다는 내용이다. 해당 공격에 대한 자세한 사항은 온라인을 통해 확인 가능하다(http://arxiv.org/abs/1601.01229와 http://arxiv.org/pdf/1508.04324.pdf). 임시적인 대응 방안으로 사용할 수 있는 것이, 클라이언트는 인가 서버에 redirect_uri를 등록할 때 서버마다 각기 다른 값으로 등록하는 것이다. 이렇게 하면 콜백과 쳥을 혼동하지 않고 구별해 처리할 수 있다.  

### 8. 일반적인 보호된 리소스 보안 취약점  
<br/>

#### 8.1. 보호된 리소스의 보안 취약점  
<br/>

보호된 리소스는 다양한 측면에서 취약할 수 있다. 가장 확실한 것은 액세스 토큰이 유출돼 공격자가 보호된 리소스에 대한 데이터를 획득할 수 있다는 것이다. 보호된 리소스와 관련된 또 다른 보안 이슈는 엔드 포인트가 XSS(Cross-Site Scripting) 공격에 취약할 수 있다는 것이다. 실제로, 리소스 서버가 URI 파라미터로 액세스 토큰을 이용할 수 있도록 지원한다면 공격자는 XSS 공격이 포함된 가짜 URI를 만든 후 사회 공학 기법으로 해당 링크를 클릭하도록 속일 수 있다.  

+ XSS(Cross-Site Scripting)  
접근 통제를 우회하기 위해 정상적이고 신뢰할 수 있는 웹 사이트에 악의적인 스크립트를 삽입하는 공격으로 공격자가 마치 인가된 사용자인 것처럼 속이거나 웹 브라우저에서 악의적인 코드가 실행되로록 만들어 데이터를 탈취하려는 자신의 목적을 달성한다.  

+ 로제타 플래시(Rosetta Flash) 공격  
2014년 구글의 보안 엔지니어인 Michele Spagnuolo가 발견했으며, 취약한 JSONP 엔드 포인트를 갖고 있는 서버를 공격할 수 있는 기술로서, 어도비 플레이어가 공격자가 지정한 플래시 애플릿을 취약한 공격 대상 서버의 것이라고 믿게 만든다. 대부분의 웹 브라우저에서 이 공격을 못하게 하려면 X-Content-Type-Options: nosniff HTTP 헤더를 전달하거나 콜백 앞에 /&#42;&#42;/을 추가하는 것이다.  

### 9. 일반적인 인가 서버 보안 취약점  
<br/>

#### 9.2. 세션 가로채기  
<br/>

클라이언트가 인가 코드 그랜트 플로에서 액세스 토큰을 얻으려면 인가 서버로부터 인가 코드를 전달받는 중간 단계를 거쳐야 한다. 인가 코드는 요청 파라미터로 전달된 URI로 리다이렉트(302 리다이렉트)돼 전달된다. 리다이렉트로 인해 웹 브라우저는 클라이언트에게 요청을 보내며, 이때 인가 코드가 포함된다.  

인가 코드 값은 일회용 자격 증명 정보로 사용되며, 리소스 소유자가 요청을 인가했다는 것을 의미한다. 인가 코드는 인가 서버를 떠나서 사용자의 에이전트를 통과하기 때문에 웹 브라우저 히스토리에 계속 유지된다는 것에 주목할 필요가 있다.  

다음과 같은 시나리오를 가정해보자. 웹 서버가 있고, 그것을 사이트 A라고 하자. 사이트 A는 OAuth 클라이언트로서 몇 가지 REST API를 호출한다. 리소스 소유자는 공용 컴퓨터로 도서관이나 그 밖의 몇 군데에서 사이트 A에 접근한다. 사이트 A는 OAuth 토큰을 얻기 위해 인가 코드 그랜트를 이용한다. 이는 인가 서버에 대한 로그인 필요하다는 것을 의미한다. 해당 사이트를 이용하는 동안 결과적으로 인가 코드가 웹 브라우저 히스토리에 남게 될 것이다. 리소스 소유자는 작업을 마친 다음에 거의 대부분 사이트 A에서 로그아웃하고 심지어 인가 서버에서도 로그아웃이 되겠지만, 그들이 사용하는 웹 브라우저 히스토리는 깔끔하게 삭제되지 않는다.  

이때 사이트 A를 이용하는 공격자 또한 그 컴퓨터를 사용할 수 있다. 공격자는 자기자신의 자격 증명으로 로그인을 하겠지만, 앞서 컴퓨터를 사용한 리소스 소유자의 세션이 웹 브라우저 히스토리를 저장돼 있기 때문에 그것과 사이트 A로의 리다이렉트를 이용해 인가 코드를 삽입할 수 있다. 그러면 공격자가 자기자신의 자격 증명으로 로그인을 했음에도 불구하고 원래 리소스 소유자의 리소스에 접근할 수 있게 된다.  

OAuth 핵심 스펙의 4.1.3절에서는 이와 같은 문제를 해결하기 위한 해결책을 제시하고 있다.  

클라이언트는 인가 코드를 절대로 한 번 이상 사용하면 된다. 인가 코드가 한 번 이상 사용되더라도 인가 서버는 그것을 거절해야 하며, (가능할 때) 해당 인가 코드를 기반으로 이전에 발급된 모든 토큰을 폐기해야만 한다.  

인가 코드 그랜트 타입에서 보안을 위해 필요한 또 다른 조치는 인가 코드를 인증된 클라이언트의 client_id에 바인딩시키는 것이다.  

이는 RFC 6749의 4.1.3절의 또 다른 권고 사항을 위한 처리라고 할 수 있다.  

인가 코드가 인증된 기밀 클라이언트에 발급됐는지 확인한다. 만약, 클라이언트가 공개 클라이언트라면 인가 코드를 요청한 클라이언트의 "client_id"를 확인한다.  

+ 리다이렉트: 320 or 307?  
2016년 1월, OAuth 워킹 그룹의 메일링 리스트에 HTTP 307에 대한 웹 브라우저 동작을 활용한 공격을 설명하는 보안 권고문이 포스팅 됐다. 그 공격 방법은 트리어 대학의 연구원이 발견했다. 해당 공격은 OAuth 표준에서는 프런트 채널 통신을 위한 어떤 HTTP 리다이렉트 코드도 허용하며, 어떤 것을 사용할지는 구현자의 선택에 달려 있다는 것을 기반으로 하고 있다. 실제로 웹 브라우저는 모든 리다이렉트를 동일하게 처리하지 않으며, 그중에서도 307 리다이렉트가 OAuth에서 악용돼 사용자의 자격 증명 정보가 유출될 수 있다는 내용이었다.  

#### 9.3. 리다이렉트 URI 조작  
<br/>

해당 공격은 공격이 가능하기 위한 조건으로 인증 서버에서 수행되는 유효성 검증 알고리즘과 관련해 몇 가지를 가정한다. OAuth 스펙에서는 리다이렉트 URI에 대한 검증 방법을 전적으로 인가 서버에 맡긴다. 인가 서버는 요청으로 전달된 리다이렉트 URI에 대해 등록된 리다이렉트 URI로 세 가지 방법으로 확인한다. 즉, 완전히 일치하는지, 하위 디렉터리를 허용하는지 그리고 하위 도메인을 허용하는지에 대해 확인한다. 그러면 각각의 확인 방법이 어떻게 이뤄지는지 살펴보자.  

완전히 일치하는지 확인하는 알고리즘은 말 그대로, 전달된 리다이렉트 URI 파라미터와 해당 클라이언트를 위해 등록된 리다이렉트 URI를 문자열 비교하는 것이다. 비교해 일치하지 않으면 에러가 출력된다.  

하위 디렉터리 허용에 대한 확인 알고리즘은 URI의 시작 부분이 등록된 리다이렉트 URI와 일치하고 URI의 나머지 부분이 추가돼 잇는 형태라면 해당 리다이렉트 URI가 유효하다고 판단한다. 또한 리다이렉트 URI의 호스트와 포트 번호는 등록된 콜백  URL과 정학히 일치해야 하며, 리다이렉트 URI는 등록된 콜백 URI의 하위 디렉터리를 포함할 수 있다.  

하위 도메인 허용에 대한 확인 알고리즘은 리다이렉트 URI의 호스트 부분에 좀 더 유연성을 제공한다. 즉, 전달된 리다이렉트 URI의 도메인이 등록된 리다이렉트 URI의 하위 도메인이라면 해당 리다이렉트 URI는 유효하다고 판단한다.  

또 다른 확인 알고리즘은 하위 디렉터리 허용과 하위 도메인 허용을 결합한 것이다. 이 방법은 도메인과 리다이렉트 URI 모두에 유연성을 제공해준다.  

경우에 따라서는 와일드 카드 문자나 또 다른 구문 표현에 의해 확인 작업이 제한되지만, 효과는 동일하다. 즉, 하나의 등록된 값에 대해 여러 개의 서로 다른 요청값이 매칭될 수 있다.  

이제 깔끔하게 정리해보면, 유일하고 일관성 있는 안전한 방법은 리다이렉트 URI가 완전히 일치하는지 확인하는 것이다. 다른 방법은 클라이언트 개발자가 자신들의 애플리케이션 개발에 있어서 원하는 유연성을 제공하지만, 악용될 수 있다.  

+ 은닉 리다이렉트  
2014년 보안 연구원 왕징은 오픈 리다이렉트 공격을 은닉 리다이렉트(Covert Redirect)라고 명명했다. 그것은 악의적인 사용자가 OAuth 클라이언트에서 OAuth 2.0 인가 서버에 전달하는 요청을 가로챈 다음, 리다이렉트 URI 파라미터의 내용을 변경해 악의적인 위치로 리다이렉트되게 만드는 것이다. 결국 인가 서버가 전달하는 중요 정보를 탈취하는 것이다. RFC 6819(OAuth 2.0 Threat Modal)에서 공식적으로 이 위협을 설명하고 있고, RFC 문서의 5.2.3.5절에서 다음과 같이 대응하도록 권고하고 있다. 인가 서버는 모든 클라이언트가 리다이렉트 URI를 등록하도록 요구해야 하며, 등록되는 리다이렉트 URI (RFC6749)에 정의된 Full URI여야 한다.  

### 10. 일반적인 OAuth 토큰 보안 취약점  
<br/>

#### 10.1. Bearer 토큰  
<br/>

기술적인 관점에서 보면, Bearer 토큰은 웹 브라우저 쿠키와 매우 유사하다고 생각할 수 있다. 기본적으로 웹 브라우저 쿠키와 동일한 점은 같다.  

+ 평문으로 된 문자열을 사용
+ 시크릿이나 시그니처를 포함하지 않음
+ 보안 모델에 있어서 TLS는 기본  

차이점은 다음과 같다.  

+ 웹 브라우저에서는 쿠키를 오래 전부터 사용해왔지만 OAuth 클라이언트에서는 그렇지 않다.
+ 웹 브라우저에서는 동일 근원 정책을 강제하기 때문에 어느 한 도메인을 위한 쿠키가 다른 도메인으로 전달되지 않는다. 하지만 OAuth 클라이언트의 경우에는 그렇지 않다(이것이 문제의 근원이 될 수 있다).  

#### 10.2. Bearer 토큰 사용에 있어서의 위험과 고려 사항  
<br/>

Bearer 토큰은 웹 브라우저의 세션 쿠키와 유사한 특징을 갖고 있다. 불행하게도, 그러한 유사성을 제대로 이해하지 못하는 데서 모든 보안 관련 문제가 발생한다. 공격자가 액세스 토큰을 탈취할 수 있으면 공격자는 탈취한 토큰이 갖고 있는 권한 범위의 모든 리소스에 접근할 수 있게 된다. Bearer 토큰을 갖고 있는 클라이언트는 암호화 키와 같은 추가 보안 요소를 갖고 있다고 증명하지 않아도 된다. 토큰 탈취 외에도, 토큰 기반의 다른 프로토콜에서도 공통적으로 발생할 수 있는 OAuth의 Bearer 토큰과 관련된 보안 위협은 다음과 같다.  

+ 토큰 위조  
공격자는 자신만의 가짜 토큰을 만들거나 기존의 유효한 토큰을 변조해 리소스 서버가 클라이언트에게 접근 권한을 인가하게 만들 수 있다.  

+ 토큰 재사용  
공격자는 이미 과거에 사용돼 유효 기간이 만료된 토큰을 이용하려고 시도한다. 그런 경우, 리소스 서버는 어떤 유효한 데이터도 반환을 해주면 안 되고, 대신 에러를 반환해야 한다.  

+ 토큰 리다이렉트  
공격자는 특정 리소스 서버를 위해 만들어진 토큰을 이용해 다른 리소스 서버에 접근하려고 시도한다. 그 경우, 공격 대상 리소스 서버는 공격자가 사용한 토큰이 유효한 것이라고 잘못 판단하는 경우다. 즉, 공격자가 특정 리소스 서버를 위한 액세스 토큰을 합법적으로 취득한 후, 그 토큰을 이용해 다른 리소스 서버에 접근하려고 시도하는 것이다.  

+ 토큰 유출  
토큰에는 시스템에 대한 민감한 정보가 포함될 수 있고, 공격자는 다른 방법으로는 획득할 수 없는 정보를 토큰을 통해 획득할 수 있다.  

#### 10.3. 토큰 보호 방법
<br/>

Bearer 토큰으로서 전달되는 액세스 토큰은 안전하지 않은 채널로는 절대로 전달돼서는 안 된다. OAuth 스펙에 따르면, 액세스 토큰은 SSL/TLS와 같은 종단간의 기밀성을 보장하는 방법으로 전송돼야 한다.  

+ TLS(Transport Layer Security)  
컴퓨터 네트워크상의 통신 보안을 제공하는 암호화 프로토콜로 서로 간에 직접 연결된 두 당사자 간의 전송을 보호하고, 전송되는 데이터를 대칭 암호화로 보호하기 때문에 비공개 연결이며, 전송되는 각각의 메시지는 메시지 인증 코드를 사용해 무결성을 제공하기 때문에 연결이 안정적이다.  

이는 일반적으로 공개키 암호화 기술을 사용한 인증서를 기반으로 이뤄진다. 특히, 인터넷상에서 연결을 요청한 애플리케이션은 해당 연결 요청을 받은 애플리케이션의 인증서를 확인한다. 일부 제한된 환경에서는 연결을 요청하는 애플리케이션의 인증서 또한 검증될 수 있지만, 그런 TLS 연결의 상호 인증은 상당히 제한적이고 드문 일이다. OAuth Bearer 토큰은 안전한 전송 수단으로서, TLS를 사용하지 않는다면 안전하게 사용될 수 없다는 것을 기억해야 한다.  

##### 10.3.1. 클라이언트에서 탈취  
<br/>

클라이언트에게 Bearer 액세스 토큰은 투명하고 그것을 위해 어떤 암호화 작업도 요구되지 않는다. 따라서 공격자가 Bearer 액세스 토큰을 획득하면 해당 토큰의 권한 범위에 속하는 모든 리소스에 접근할 수 있게 된다.  

대응책으로서 클라이언트에게 적용할 수 있는 것은 작업에 필요한 최소한의 권한 범위만 토큰에 부여하는 것이다. 이처럼 "최소 권한 부여"와 같은 접근 방식을 사용하면 토큰이 탈취되더라도 그것으로 할 수 있는 것이 제한된다. 사용자 경험에 미치는 영향을 최소화하기 위해 클라이언트는 인가 요청 과정에서는 적절한 모든 권한 범위를 요청한 후, 리프레시 토큰으로 제한된 권한 범위의 액세스 토큰을 가져와서 리소스를 직접 요청한다.  

가능하다면, 저장돼 관리되는 토큰에 대한 공격을 최소화하기 위해 토큰을 메모리에 일시적으로 유지하는 것도 유용한 방법이라고 할 수 있다. 그렇게 하면 공격자가 클라이언트의 데이터베이스에 접근할 수 있다고 하더라도 액세스 토큰에 관한 어떤 정보도 얻을 수 없을 것이다. 모든 유형의 클라이언트에 이 방법을 항상 사용할 수 있는 것은 아니다. 하지만 토큰을 안전하게 저장하고 다른 애플리케이션 및 일반 사용자의 눈을 피하는 것은 모든 OAuth 클라이언트 애플리케이션이 수행해야 하는 일이다.  

##### 10.3.2. 인가 서버에서 탈취  
<br/>

공격자가 인가 서버의 데이터베이스에 접근할 수 있거나 데이터베이스에 대한 SQL 인젝션 공격을 수행할 수 있다면, 여러 리소스 소유자의 보안이 침해될 수 있다. 이와 같은 이슈는 인가 서버가 액세스 토큰을 관리하고 여러 클라이언트에게 액세스 토큰을 발급하며, 여러 보호된 자원이 이용하는 중심부 역할을 하기 때문에 발생한다. 인가 서버는 대부분의 구현에 있어서 액세스 토큰을 데이터베이스에 저장한다. 보호된 리소스는 클라이언트로부터 전달된 요청을 검증한다. 검증은 다양한 방법으로 수행될 수 있지만, 일반적으로 전달된 토큰과 일치하는 것이 있는지 데이터베이스에 질의하는 방법이 사용된다.  

효과적인 예방책 중 하나로서 인가 서버는 액세스 토큰 자체의 텍스트 대신 액세스 토큰의 해시 값(예를 들면, SHA-256)을 저장할 수도 있다. 그렇게 하면 공격자가 모든 액세스 토큰을 저장하고 있는 데이터베이스 전체를 탈취할 수 있다고 하더라도 그것으로 할 수 있는 것은 없다. 사용자의 비밀번호를 저장할 때는 해시에 솔트를 추가하는 것을 권장하지만, 액세스 토큰 값은 이미 자체적으로 오프라인 사전 공격을 어렵게 할 수 있는 합리적인 수준의 엔트로피를 가지도록 만들어져야 하기 때문에 추가 솔트가 요구되지 않는다.  

또한 엑세스 토큰 유출과 관련된 위험을 최소화하기 위해 액세스 토큰의 유효 기간을 짧게 유지하는 것도 좋은 방법이 될 수 있다. 그렇게 하면 토큰이 침해되더라도 그것의 유효 기간이 제한돼 공격자에게 유용하지 않게 된다. 클라이언트가 리소스에 대한 더 긴 기간의 접근을 필요로 한다면 인가 서버는 클라이언트에게 리프레시 토큰을 발급하면 된다. 리프레시 토큰은 클라이언트와 인가 서버 사이에 전달되고, 보호된 리소스에는 전달되지 않기 때문에 유효 기간이 긴 토큰에 대한 공격 문제를 상당히 제한할 수 있다. 토큰의 "짧은" 유효 기간을 구성하는 것은 전적으로 보호할 대상 애플리케이션에 의존적이지만, 일반적으로 말해, API 사용에 있어서 필요한 평균 기간보다 유효 기간이 길지 않아야 한다.  

궁극적으로, 인가 서버에서 수행할 수 있는 가장 좋은 방법 중 하나는 전반적인 보안 감사와 로깅이다. 토큰이 발급되고 소비되고 폐기될 때마다 그것의 세부 내용(클라이언트, 리소스 소유자, 권한 범위, 리소스, 시간 등)에 의심스러운 행위가 있는지 지켜봐야 한다. 결론적으로 액세스 토큰 값의 유출을 방지하기 위해 모든 로그가 유지돼야 한다.  

##### 10.3.3. 보호된 리소스에서 탈취  
<br/>

보호된 리소스는 종종 니가 서버와 유사한 방법으로 액세스 토큰을 처리하기 때문에 동일한 수준으로 보안을 처리해야 한다. 네트워크상으로는 인가 서버보다 보호된 리소스가 더 많기 때문에 더 많은 직접적인 주의가 필요할 수 있다. 결국 Bearer 토큰을 사용한다면 악의적인 보호된 리소스가 다른 보호된 리소스를 위해 액세스 토큰을 재사용하는 것을 막을 수 없다. 액세스 토큰은 시스템 로그상에서, 특히 분석을 위해 인입되는 모든 HTTP 트래픽 캡처에서 우연히 유출될 수 있다. 따라서 로그에 포함되지 않도록 토큰 값을 제거해야 한다.  

리소스 엔드 포인트는 토큰의 권한 범위를 제한하고 데이터 수집 최소화 원칙과 특정 작업을 수행하기 위해 필요한 최소한의 권한 범위만 요청하도록 설계돼야 한다. 토큰과 관련된 권한 범위를 요청하는 것이 클라이언트일지라도 보호된 리소스 설계자는 기능을 위한 가장 구체적인 권한 범위만 가진 토큰을 요구하도록 설계해야 한다. 이를 위해 클라이언트가 자신의 작업을 수행하는 데 필요한 것보다 더 많은 기능을 요청할 필요가 없도록 애플리케이션의 리소스를 논리적으로 나눈다.  

리소스 서버는 또한 토큰을 적절히 검증해야 하고, 어떤 강력한 권한을 가진 특별한 목적의 액세스 토큰을 사용하지 않아야 한다. 보호된 리소스가 토큰의 현재 상태를 캐시하는 것은 일반적이지만, 토큰 인트로스펙션과 같은 프로토콜을 사용할 때는 캐시의 장단점을 항상 고려해야 한다. 공격자가 보호된 리소스에서 유효한 토큰을 낚을 수 없도록 사용 빈도를 제한하거나 기타 다른 기술을 이용해 API를 보호하는 것 도한 좋은 생각이다.  

액세스 토큰을 메모리에 일시적으로 저장하면 리소스 서버의 데이터 저장소에 대한 공격인 경우에는 도움이 된다. 공격자가 백엔드 시스템에서 유효한 액세스 토큰을 찾기가 더욱 어려워지기 때문이다. 물론, 공격자가 백엔드 시스템에 접근할 수 있으면 리소스로 보호되는 데이터에는 접근할 수 있는 가능성이 크기 때문에 항상 비용과 그에 따른 효과의 균형이 필요하다.  

#### 10.4. 인가 코드  
<br/>

##### 10.4.1. Proof Key for Code Exchange(PKCE)  
<br/>

PKCE 스펙은 인가 요청과 그에 따른 토큰 요청을 안전하게 바인딩함으로써 인가 코드 탈취 공격을 방어하도록 만들어졌다. PKCE의 동작 방식은 단순하다.  

+ 클라이언트는 code&#95;verifier라는 것을 만들어 기록한다.
+ 그 다음 클라이언트는 code&#95;verifier를 기반으로 code&#95;challenge를 계산한다. 이때 code&#95;verifier를 그대로 사용하거나, code&#95;verifier의 SHA-256 해시 값을 사용할 수 있지만, 해시 값을 사용하면 검증 자체에 대한 공격은 방어할 수 있으므로 해시 값을 사용하는 경우가 대부분이다.  
+ 클라이언트는 code&#95;challenge와 선택적으로 code&#95;challenge&#95;method(평문이나 SHA-256 해시의 키워드)를 일반적인 인가 요청 파라미터와 함께 인가 서버에 전달한다.
+ 인가 서버는 다른 경우와 동일하게 응답하지만, code&#95;challenge와 code&#95;challenge(존재한다면)를 기록해둔다. 이것은 인가 서버가 발급하는 인가 코드와 관련이 있다.
+ 클라이언트가 인가 코드를 받으면 앞서 만들어둔 code&#95;verifier를 포함해 토큰 요청을 전달한다.
+ 서버는 전달받은 code&#95;verifier로 code&#95;challenge를 계산해 앞서받은 code&#95;challenge와 일치하는지 확인한다. 만약, 일치하지 않으면 에러를 반환하고 트랜잭션은 일반적인 경우와 동일하게 수행된다.  

클라이언트와 인가 서버가 PKCE를 지원하도록 변경하는 것은 매우 간단하다. PKCE의 장점 중 하나(보안적인 이점을 제외하고)는 클라이언트와 인가 서버가 실제 서비스되고 있다고 하더라도 서비스 중단 없이 추가할 수 있다는 것이다.  

### 11. OAuth 토큰  
<br/>

#### 11.1. OAuth 토큰이 무엇인가?  
<br/>

OAuth에서는 토큰의 내용에 대한 언급이 전혀 없다. OAuth 클라이언트는 토큰 자체의 내용에 대해서는 전혀 알 필요가 없다. 클라이언트는 토큰을 인가 서버로부터 어떻게 발급받고, 발급받은 토큰을 리소스 서버에 어떻게 사용해야 하는지만 알면 된다. 하지만 인가 서버와 리소스 서버는 토큰에 대해 알아야 한다. 인가 서버는 토큰을 어떻게 만들어 클라이언트에게 전달해야 하는지 알아야 하고, 리소스 서버는 클라이언트로부터 전달된 토큰을 어떻게 식별하고 검증해야 하는지 알아야 한다.  

그렇다면 왜 OAuth 핵심 스펙에서는 토큰에 대해 구체적으로 정의하지 않았을까? 그것은 토큰을 구체적으로 정의하지 않으면 OAuth를 특성이나 위험 환경 그리고 요구 사항이 각기 다른 다양한 곳에 적용해 사용할 수 있기 때문이다. OAuth 토큰은 유효 기간이 만료되거나 폐기될 수 있으며, 유효 기간을 무기한으로 해 사용하거나 환경에 따라 다양한 조합을 사용할 수도 있다. 또한 토큰은 시스템의 특정 사용자나 모든 사용자를 나타내거나 아무런 사용자도 나타내지 않을 수 있다. 토큰은 내부 구조를 가지거나 임의의 값으로 만들어질 수도 있다. 또는 토큰의 내용을 암호화해 보호할 수도 있고, 여러 가지 형태를 조합할 수도 있다. OAuth의 유연성과 모듈성으로 인해 토큰의 포맷이 명확해야 하고, 시스템상의 모든 구성 요소가 그것을 알아야 하는 WS-&#42;, SAML, Kerberos와 같은 보다 포괄적인 보안 프로토콜에는 적용하기 어려울 수 있다.  

토큰을 만들고 검증하는 데에는 몇 가지 일반적인 기술이 있다. 각각의 기술은 다양한 환경에 따라 장단점을 갖게 된다.  

인가 서버가 토큰을 만들면 그것을 공유된 디스크상의 데이터베이스에 저장된다. 보호된 리소스는 클라이언트로부터 토큰을 전달받으면 동일한 데이터베이스에 해당 토큰 값이 있는지 확인해 토큰이 정상적인 것인지 판단한다. 그런 경우, 토큰에는 어떤 정보도 없고 대신 데이터를 조회하기 위한 단순한 핸들 역할을 한다. 이는 액세스 토큰을 만들고 관리하는 매우 유효하고 일반적인 방법이며, 많은 양의 엔트로피를 제공하면서 토큰 자체를 작게 유지할 수 있다는 장점이 있다.  

인가 서버와 보호된 리소스가 데이터베이스를 공유하는 것이 항상 실용적인 것은 아니다. 특히, 하나의 인가 서버가 여러 개의 서로 다른 보호된 리소스를 보호하고 있을 때 그렇다. 그렇다면 어떻게 해야 할까? 이에 대한 대안으로 두 가지를 살펴본다.  

#### 11.2. 구조화된 토큰: JSON Web Token  
<br/>

공유해 사용하는 데이터베이스에서 토큰을 찾는 것 대신 토큰 안에 필요한 정보를 담아 만들면 어떨까? 그렇게 하면 인가 서버는 인가 서버는 어떤 네트워크 API 호출 없이도 토큰 자체 만으로 보호된 리소스와 간접적으로 통신할 수 있게 된다.  

즉, 토큰의 유효 기간이나 발급받은 사용자 정보와 같이 보호된 리소스가 필요로 하는 어떤 정보든 인가 서버는 토큰에 담으면 된다. 필요한 정보가 담긴 토큰은 클라이언트에게 전달되지만, 모든 OAuth 2.0 시스템에서는 토큰의 구조가 불명확한 상태로 유지되기 때문에 클라이언트는 토큰이 내용을 알지 못한다. 일단 클라이언트가 토큰을 얻기 되면 랜덤 값으로 만들어진 토큰을 이용했을 때처럼 츨라이언트는 토큰을 보호된 리소스에 전닿하면 된다. 이때 보호된 리소스는 자신에게 전달된 토큰의 내용을 알아얗 한다. 그래서 토큰을 파싱해 그 안에 담긴 정보를 보고 접근을 허용할 것인지 여부를 판단한다.  

##### 11.2.1. JWT의 구조  
<br/>

이와 같은 종류의 토큰을 만들기 위해서는 전달하 정보를 구조화하고 직렬화하는 방법이 필요하다. JSON 웹 토큰 포맷 또는 JWT는 토큰으로 전달해야 하는 정보를 간단히 구조화하는 방법을 제공한다. 핵심은 전달한 정보를 JSON 객체 형식으로 표현하는 것이다.  

각 부분은 랜덤한 값이 아니며, Base64URL 인코딩 방식으로 인코딩된 JSON 객체다.  

헤더는 항상 JSON 객체고, 토큰의 나머지 부분에 대한 정보를 설명하는 데 사용된다. typ 헤더는 토큰의 나머지 부분을 처리하는 애플리케이션에게 두 번째 섹션인 페이로드가 무엇인지를 알려준다. 물론 이와 같은 구조를 저장하는 데 다른 포맷을 사용할 수 있지만, 일반적으로 JWT가 가장 많이 사용되고 OAuth 토큰으로서의 목적에도 가장 잘 맞는다. alg 헤더의 값이 none이면 해당 토큰이 서명되지 않았다는 것을 나타낸다.  

두 번째 섹션의 토큰 자체의 페이로드 부분이며, 헤더와 동일하게 Base64URL 인코딩 방식으로 직렬화된 JSON 객체다. JWT에서 페이로드는 어떤 형태의 JSON 객체든지 가능하다.  

##### 11.2.2. JWT 클레임  
<br/>

일반적인 데이터 구조체와는 달리, JWT는 다양한 애플리케이션에서 사용할 수 있는 클레임 셋을 제공한다. JWT에는 어떤 JSON 데이터든 포함할 수 있다. 그럼에도 불구하고 JWT 클레임은 일반적인 작업을 위해 사용된다. 물론 모든 JWT 클레임은 선택적으로 사용할 수 있지만, 특정 서비스에서는 자체적인 요구 사항으로 특정 클레임을 사용하도록 정의할 수도 있다.  

+ iss  
(issuer) 토큰 발급자. 누가 토큰을 만들었는지를 나타내며, 많은 경우 인가 서버의 URL이 이 클레임의 값으로 설정된다. 이 클레임은 단일 문자열이다.  

+ sub  
(subject) 토큰의 대상. 누구를 위한 토큰인지를 나타내며, 많은 경우 리소스 소유자를 위한 고유한 식별자가 이 클레임의 값으로 설정된다. 대부분의 경우, 이 클레임 값은 토큰 발급자의 범위 내에서만 고유하기만 하면 된다. 이 클레임은 단일 문자열값이다.  

+ aud  
(audience) 토큰 수신자. 누구에게 토큰이 전달되는 것인지를 나타내며, 많은 경우 보호된 리소스의 URL 또는 토큰을 전달받을 수 있는 보호된 리소스들의 URL이 이 클레임의 값으로 설정된다. 이 클레임은 문자열 배열 또는 하나의 값만 설정해야 하는 경우에는 문자열값이다.  

+ exp  
(expiration) 토큰의 만료 시간. 언제 토큰이 만료되었는지를 나타낸다. 이 클레임은 유닉스 에폭(GMT 시간 기준으로 1970년 1월 1일 자정부터의 경과 시간을 초로 환산한 정수값) 시간값이다.  

+ nbf  
토큰의 not-before 타임. 토큰이 유효해지기 전에 발급되는 경우, 언제 토큰이 유효해지기 시작하는지를 나타낸다. 이 클레임은 유닉스 에폭(GMT 시간 기준으로 1970년 1월 1일 자정부터의 경과 시간을 초로 환산한 정수값) 시간값이다.  

+ iat  
(issued-at) 토큰이 발급된 시간. 토큰이 언제 생성되었는지를 나타내며 일반적으로 토큰 발급자가 토큰을 생성한 시점의 시스템 시간이 설정된다. 이 클레임은 유닉스 에폭(GMT 시간 기준으로 1970년 1월 1일 자정부터의 경과 시간을 초로 환산한 정수값) 시간값이다.  

+ jti  
(unique identifier) 토큰 식별자. 토큰 발급자가 생성한 토큰의 고유한 식별자값이며 값이 충돌되는 것을 방지하기 위해 암호학적인 랜덤 값이 주로 이용된다. 공격자가 알기 힘든 임의의 엔트로피를 구조화된 토큰에 추가함으로써 토큰 값을 유추하거나 토큰 재사용을 방지하는 데 유용하게 사용될 수 있다.  

특정 애플리케이션에 필요한 필드를 추가하는 것도 가능하다.  

JWT 스펙에서는 JWT 구현과의 충돌을 피하기 위한 몇 가지 가이드가 있지만, 유효한 JSON 문자열이라면 필드의 이름으로 사용할 수 있다. 이는 JSON 객체에서도 마찬가지다. JWT 스펙의 가이드는 JWT가 다양한 클레임을 정의되고, 그것이 서로 다른 의미로 사용되는 보안 도메인들 사이에서 사용될 때 유용하다.  

#### 11.3. 암호화를 통한 토큰 보호: JOSE  
<br/>

+ JOSE(JSON Object Signing and Encryption)  
서명을 위한 JWS(JSON Web Signature)와 암호화를 위한 JWE(JSON Web Encryption)를 제공하며, 기본적인 데이터 모델로써 JSON을 이용한 키 저장 포맷인 JWK(JSON Web Key)를 제공한다.  

+ CBOR(Concise Binary Object Representation)  
사람이 읽을 수 없는 형태의 바이너리 포맷  

+ COSE(CBOR Object Signing and Encryption)  
CBOR 데이터 직렬화를 기반으로 기본적인 데이터 모델은 JSON을 기반으로 하고 JSON으로 표현되는 것이면 모두 CBOR로 쉽게 변환할 수 있다.  

#### 11.4. 온라인으로 토큰의 정보를 조회: 토큰 인트로스펙션  
<br/>

토큰 자체에 토큰에 관한 정보를 포함시키는 것은 단점이 있다. 토큰에 모든 요구된 클레임과 토큰을 보호하기 위해 필요한 암호화 구조를 포함시키면 토큰 자체가 상당히 커질 수 있다. 더욱이 보호된 리소스가 토큰 자체에 포함된 정보만 의지한다면 일단 생성되고 발급돼 사용되고 있는 토큰을 폐기시키는 것은 매우 어려워질 수 있다.  

##### 11.4.1. 인트로스펙션 프로토콜  
<br/>

OAuth 토큰 인트로스펙션 프로토콜은 보호된 리소스가 인가 서버에 토큰의 상태에 대한 질의를 적극적으로 수행하기 위한 메커니즘을 정의하고 있다. 인가 서버가 토큰을 발급하기 때문에 인가 서버는 토큰이 나타내는 권한 위임에 대한 세부적인 관련 정보를 알 수 있다.  

OAuth 토큰 인트로스펙션 프로토콜은 OAuth 프로토콜을 간단히 확장한 것이다. 인가 서버는 클라이언트에게 토큰을 발급하고, 클라이언트는 그 토큰을 보호된 리소스에 전달하고, 보호된 리소스는 전달된 토큰을 인가 서버를 통해 조회한다.  

인트로스펙션은 요청은 인가 서버의 인트로스펙션 엔드 포인트로 전달되는 인코딩된 폼 기반의 HTTP 요청이다. 즉, 보호된 리소스는 인가 서버에 "누군가 나에게 토큰을 전달해줬는데, 그것이 유효한 것인가요?"라고 물어본다. 보호된 리소스는 그런 요청을 하는 동안 인증을 수행하기 때문에 인가 서버는 누가 그런 질문을 한 것인지 알 수 있고, 누가 질문했는지에 따라 전달하는 응답이 달라질 수 있다. 인트로스펙션 스펙은 보호된 리소스가 자기자신에 대한 인증을 어떻게 수행하는지에 대해서는 기술하지 않는다.  

##### 11.4.4. 인트로스펙션과 JWT의 결합  
<br/>

인트로스펙션과 JWT를 함께 사용하면 큰 효과를 얻을 수 있다.  

이와 같은 접근 방식은 보호된 리소스가 다양한 인가 서버로부터 액세스 토큰을 받아들이도록 설정됐을 때 특히 유용하게 사용될 수 있다. 보호된 리소스는 JWT를 파싱해 토큰을 발급한 인가 서버를 알아낸 후, 토큰 인트로스펙션으로 토큰을 발급한 인가 서버로부터 토큰에 대한 추가 정보를 얻을 수 있다.  

###### 11.4.4.1. 토큰의 상태  
<br/>

OAuth 클라이언트는 언제든지 새로운 토큰을 가져올 준비가 돼야 하기 때문에 클라이언트에게는 토큰이 누군가에 의해 폐기됐는지 여부는 중요하지 않다. 에러 응답의 내용이 토큰 폐기든, 토큰 만료든, 유효하지 않은 토큰이든 클라이언트의 응답은 항상 동일하기 때문에 OAuth 프로토콜은 에러 응답을 따로 구별하지 않는다.  

하지만 보호된 리소스에게는 토큰이 폐기된 것인지, 아닌지를 아는 것이 매우 중요하다. 왜냐하면 폐기된 토큰을 받아들이면 거대한 보안 구멍이 생길 수 있기 때문이다. 거대한 보안 구멍은 일반적으로 나쁜 것으로 간주된다. 만약, 보호된 리소스가 로컬 데이터베이스를 검색하거나 실시간으로 인트로스펙션과 같은 질의를 수행한다면 토큰이 폐기된 것인지 쉽고 빠르게 알아낼 수 있다. 하지만 JWT를 사용한다면 어떨까?  

JWT는 표면상으로는 독립적이기 때문에 상태가 없는 것으로 간주된다. 외부 신호를 이용하지 않고는 보호된 리소스에게 토큰이 폐기됐다는 것을 나타낼 수 있는 방법이 없다. 인증서 기반의 공개키 구조(PKI)에서도 동일한 문제가 발생한다. 즉, 인증서의 모든 시그니처가 일치해 유효하다고 판단되는 경우 해당 인증서의 폐기를 알아내기 힘들다. OAuth에서는 토큰 인트로스펙션으로 그런 문제를 해결하듯이 인증서의 경우에는 인증서 폐기 리스트와 OCSI(Online Certificate Status Protocol)을 이용해 문제를 해결한다.  

#### 11.5. 토큰 폐기로 토큰의 라이프사이클 관리  
<br/>

OAuth 토큰은 일반적으로 예측 가능한 라이프사이클을 갖는다. 즉, 인가 서버는 토큰을 생성하고, 생성된 토큰은 클라이언트가 사용하고, 보호된 리소스는 그것을 검증한다. 토큰은 인가 서버의 리소스 소유자(또는 관리자)에 의해 자체적으로 만료되거나 폐기된다. OAuth의 핵심 스펙에서는 우리가 지금까지 살펴본 다양한 토큰 획득 방법과 사용 방법을 정의하고 있다. 리프레시 트큰을 사용하면 클라이언트는 무효화된 토큰을 대체할 수 있는 새로운 액세스 토큰을 요청할 수 있다.  

OAuth 토큰 폐기 스펙이 따로 있다. 해당 스펙에서는 발생하는 이벤트에 대한 응답으로서 클라이언트가 능동적으로 토큰의 라이프사이클을 관리할 수 있는 방법을 제시한다. 예를 들면, 클라이언트가 사용자의 기기에서 제거되는 네이티브 애플리케이션이거나 사용자가 클라이언트 프로비저닝을 해제할 수 있도록 사용자 인터페이스를 제공할 수 있다. 심지어는 클라이언트 소프트웨어가 의심스러운 행위를 감지해 권한이 부여된 보호된 리소스의 피해를 제한하려고 할 수도 있다. 발생하는 이벤트가 무엇이든, 토큰 폐기 스펙에서는 클라이언트가 인가 서버에 신호를 보내 발급된 토큰이 더 이상 사용되지 않도록 만든다.  

##### 11.5.1. 토큰 폐기 프로토콜  
<br/>

OAuth 토큰 폐기는 클라이언트가 간단히 "내가 갖고 있는 토큰을 제거해주세요"라고 인가 서버에 말할 수 있는 간단한 프로토콜이다. 클라이언트는 폐기를 요청할 토큰과 폼 인코딩된 HTTP POST 요청 파라미터를 폐기 엔드 포인트라는 특별한 엔드 포인트로 보낸다.  

클라이언트는 토큰 엔드 포인트에 요청할 때와 동일한 자격 증명 정보를 이용해 인증을 수행한다. 인가 서버는 전달된 토큰을 찾아본다. 만약, 찾았다면 그서을 데이터 저장소에서 삭제한 후, OK 응답을 전달한다.  

이것이 전부다. 그리고 클라이언트는 해당 토큰의 사본을 제거한다.  

인가 서버가 토큰을 찾지 못했거나 클라이언트가 토큰 폐기를 요청할 권한을 갖고 있지 않은 경우에도 인가 서버는 OK 응답을 전달한다. 이 경우에는 왜 에러를 반환하지 않는 것일까? 에러를 반환한다면 클라이언트에게 의도치 않은 토큰에 대한 정보를 제공한다. 예를 들어, 다른 클라이언트의 토믄을 폐기하려고 하는 클라이언트에게 HTTP 403 에러를 반환한다고 가정해보자. 그런 경우, 다른 클라이언트에 대한 서비스 거부 공격이 열릴 수 있기 때문에 해당 토큰이 폐기되지 않도록 할 것이다. 하지만 해당 토큰이 어떤 식으로 획득했든 그것이 유효하고 다른 곳에서도 사용될 수 있다는 것을 클라이언트에게 말하고 싶지 않을 것이다. 그런 정보 유출을 차단하기 위해 항상 해당 토큰이 폐기된 것처럼 응답하는 것이다. 정상적으로 동작하는 클라이언트에게는 이와 같은 응답으로 인한 기능상의 차이가 발생하지 않으며, 의도하지 않은 어떤 것도 악의적인 클라이언트에게 노출하지 않을 수 있다. 물론, 클라이언트 인증에 있어서는 토큰 엔드포인트의 경우와 마찬가지로 여전히 적절한 응답이 반환된다.  

### 12. 클라이언트 동적 등록  
<br/>

OAuth에서 인가 서버는 클라이언트를 클라이언트 식별자로 식별한다. 즉, OAuth 클라이언트로서 동작하는 소프트웨어에 고유한 식별자가 할당된다. OAuth 플로에서는 클라이언트 ID가 인가를 요청하는 단계에서 인가 서버에 전달된다. 인가 서버는 클라이언트 ID를 기반으로 어느 리다이렉트 URI를 허용할 것인지, 허용할 권한 범위는 무엇인지 그리고 사용자에게 어떤 정보를 출력해줘야 하는지를 결정할 수 있다. 클라이언트 ID는 또한 토큰 엔드포인트에 전달되며, 클라이언트 시크릿과 결합해 OAuth의 권한 위임 프로세스 수행 기간 동안 클라이언트를 인증하는 데 이용된다.  

클라이언트 식별자는 리소스 소유자를 나타내는 식별자는 계정과는 구별된다. OAuth에서는 리소스 소유자의 명의를 사용하는 것이 아니기 때문에 이러한 구별은 중요하다. 사실 OAuth 프로토콜은 소프트웨어가 리소스 소유자를 대신해 동작하는 것이 전부라고 할 수 있다. 그런데 클라이언트는 어떻게 식별자를 얻고 서버는 어떻게 해당 식별자를 유효한 리다이렉트 URI 셋이나 권한 범위와 같은 메타데이터와 연관지을 수 있을까?  

#### 12.1. 서버가 클라이언트를 식별하는 방법  
<br/>

클라이언트 ID가 정적으로 설정되는 방식의 단점은, 보호된 리소스에 접근하기 위한 API을 이용하는 클라이언트 소프트웨어의 모든 인스턴스는 해당 API를 보호하는 인가 서ㅕ버의 모든 인스턴스에 연결돼야 한다는 것이다. 이는 인가 서버가 하나의 API를 독립적으로 보호하도록 설정된 경우처럼 클라이언트와 인가 서버 간의 연결이 명확하고, 상대적으로 관계에 대한 변화가 없을 때는 합리적이라고 볼 수 있다.  

하지만 클라이언트가 서로 다른 여러 서버에서 제공하는 API에 접근하도록 구현한다면 어떻게 해야 할까? 또는 어떤 클라이언트 소프트웨어의 인스턴스가 많이 있고, 그것들이 각각 동일한 인가 서버와 통신을 해야 한다면 어떻게 해야 할까? 이는 클라이언트가 네이티브 애플리케이션일 때의 경우라고 할 수 있다. 각 클라이언트 인스턴스는 인가 서버와 통신하기 위해 클라이언트 식별자가 있어야 한다. 
그리고 클라리언트 시크릿을 어떻게 처리해야 할까? 동일한 시크릿을 복사해 공개하는 방법이 있다.  

즉, 시크릿을 공개해 클라이언트를 공개 클라이언트로 만드는 것이다. 이는 OAuth 표준에서 명시적으로 허용되는 방법이다. 하지만 공개 클라이언트는 인가 코드와 토큰 탈취 그리고 악의적인 소프트웨어에 의한 클라이언트 위조와 같은 모든 종류의 공격에 노출된다. 경우에 따라서는 그런 위험을 수용할 수 있지만, 대부분의 경우 그렇지 않기 때문에 각 인스턴스마다 별도의 클라이언트 시크릿을 갖도록 만든다.  

어떤 경우든 수동으로 등록하는 것으로는 해결되지 않는다.  

#### 12.2. 실시간으로 클라이언트 등록  
<br/>

OAuth Dynamic Client Registration 프로토콜은 클라이언트가 스스로 인가 서버에 자기자신과 관련된 정보를 알릴 수 있는 방법을 제공한다. 그러면 인가 서버는 클라이언트가 이후의 모든 OAuth 트랜재션에서 사용할 수 있고, 클라이언트 시크릿과 연결해 사용할 수 있는 고유한 클라이언트 ID를 클라이언트에게 전달한다. 이 프로토콜은 클라이언트 소프트웨어가 스스로 사용하거나 클라이언트 개발자 대신 빌드 배포 시스템의 일부분으로 사용될 수도 있다.  

##### 12.2.1. 동작 방식  
<br/>

동적 클라이언트 등록 프로토콜은 인가 서버의 클라이언트 등록 엔드 포인트에 대한 간단한 HTTP 요청과 그에 대한 응답으로 수행된다. 인가 서버의 클라이언트 등록 엔드 포인트는 클라이언트의 정보 메타 데이터를 담고 있는 JSON 데이터를 전달하는 HTTP POST 요청을 기다린다. 클라이언트 등록 요청을 OAuth 토큰으로 보호할 수도 있지만, 여기서는 토큰 없이 등록하는 과정을 보여줄 것이다.  

메타 데이터에는 클라이언트의 이름, 리다이렉트 URI, 권한 범위 그리고 클라이언트의 기능과 관련된 다양한 내용이 포함될 수 있다. 하지만 메타 데이터에는 클라이언트 ID와 클라이언트 시크릿이 포함되지 않는다. 대신 그 두 정보는 항상 인가 서버가 관리한다. 클라이언트 ID를 위조하거나 충돌되는 것을 막고, 보안 레벨이 약한 클라이언트 시크릿이 선택되는 것을 막기 위함이다. 인가 서버는 전달된 메타 데이터에 대해 항상 기본적인 체크를 수행한다. 일반적으로 OAuth에서 인가 서버는 유효성에 대한 결정을 내리고 요청한 클라이언트가 어떤 클라이언트인지를 판단한다.  

등록 요청에 문제가 없으면 인가 서버는 새로운 클라이언트 ID와 클라이언트 시크릿을 생성한다. 그리고 해당 클라이언트의 메타 데이터와 함께 클라이언트로 전달한다. 클라이언트 요청 시 전달하는 값들은 모두 인가 서버에 전달되지만, 그중에서 어느 것이 클라이언트 등록과 관련된 것인지 최종적으로 판단하는 것은 인가 서버며, 인가 서버는 자신에게 전달된 값을 자유롭게 무시하거나 거부할 수 있다. 클라이언트의 등록 결과는 JSON 객체로 클라이언트에게 전달된다.  

##### 12.2.2. 왜 동적 등록을 사용하는가?  
<br/>

동적 등록을 사용해야 하는 데에는 몇 가지 이유가 있다. 원래 OAuth는 웹 서비스를 제공하는 기업의 경우처럼 단일 위치의 API를 중심으로 돌아갔다. 그런 API를 사용하기 위해서는 특별한 클라이언트가 필요하며, 클라이언트는 단일 API 제공자하고만 통신하면 된다. 따라서 클라이언트 개발자가 그런 API에 자신들이 클라이언트를 등록하려고 애쓰는 것은 자연스러운 일이다. 왜냐하면 해당 API 제공자가 하나만 있기 때문이다.  

하지만 이와 같은 가정이 성립하지 않는 두 가지의 예외 케이스를 이미 봤다. 특정 API를 제공자가 두 명 이상이거나 동일한 API의 새로운 인스턴스를 자유롭게 사용할 수 있다면 어떻게 될까? 예를 들어, OpenID 커넥트는 표준화된 관리 API를 제공하고 SCIM(System for Cross-domain identity Management) 프로토콜은 표준화된 관리 API를 제공한다. 둘은 모두 OAuth에 의해 보호되며, 서로 다른 여러 공급자가 있을 수 있다. 비록 클라이언트 소프트웨어가 어떤 도메인상에서 동작하든 그 표준 API를 사용할 수는 있지만, 그런 환경에서는 클라이언트 ID를 관리하는 것이 불가능하다는 것을 알고 있다. 간단히 말해, 새로운 클라이언트를 작성하거나 이 프로토콜 생태계를 위한 새로운 서버를 배포하는 것은 악몽과 같을 것이다.  

심지어 인가 서버가 하나라고 하더라도 클라이언트의 인스턴스가 많다면 어떻게 될까? 특히, 모바일 플랫폼에서 동작하는 네이티브 애플리케이션의 경우에는 치명적이라고 할 수 있다. 왜냐하면 네이티브 클라이언트 소프트웨어의 모든 사본은 동일한 클라이언트 ID와 시크릿을 갖게 되기 때문이다. 동적 등록 방법을 이요하면 클라이언트의 각 인스턴스는 인가 서버에 자기자신을 등록할 수 있다. 그러면 각 인스턴스는 고유한 클라이언트 ID을 받게 되고, 중요한 점은 자체 클라이언트 시크릿을 통해 사용자를 보호할 수 있다는 것이다.  

이메일 클라이언트와 서버 간의 상호 작용과 같은 것이 동적 등록의 주요 사례라고 할 수 있다. 현재는 SASL-GSSAPI(Simple Authentication and Security Layer-Generic Security Application Program Interface)와 같은 확장을 이용하면 OAuth로 IMAP(Internet Message Access Protocol) 이메일 서비스에 접근하는 것이 가능하다. 동적 등록을 사용하지 않는다면 각각의 메일 클라이언트는 모두 OAuth 접근을 허용하는 모든 가능한 이메일 제공자에 사전 등록을 해야만 한다. 또한 이메일 클라이언트가 일단 설치되면 사용자는 그것을 수정하거나 설정할 수 없기 때문에 소프트웨어가 배포되기 전에 개발자에 의해 사전 등록이 완료돼야 한다. 사전 등록을 위해서는 모든 메일 클라이언트에 대해 알아야 하는 인가 서버와 모든 서버를 알아야 하는 메일 클라이언트 간의 엄청나게 많은 조합이 필요하다. 하지만 동적 클라이언트 등록을 사용하면 모든 메일 클라이언트의 인스턴스는 연동이 필요한 모든 인가서버의 인스턴스에 자기자신을 등록할 수 있다.  

###### 12.2.2.1. 화이트 리스트, 블랙 리스트 그리고 그레이 리스트  
<br/>

인가 서버에 대한 동적 등록을 허용하는 것이 위험해 보일 수도 있을 것이다. 결국 어떤 소프트웨어든 등록을 해 토큰을 요청할 수 있게 만들고 싶은가? 사실, 대부분의 경우 원하는 것이 바로 그것일 것이다. 상호 운용성은 그 자체의 특성상 요청하지 않은 요청과 잘 구분되지 않는다.  

중요한 점은, 인가 서버에 등록한 클라이언트라고 해서 해당 인가 서버가 보호하는 리소스에 접근할 수 있는 권한이 부여되지는 않는다. 따라서 리소스 소유자는 여전히 클라이언트에게 어떤 형태로든 접근 권한을 위임할 필요가 있다. 이 점 때문에 OAuth가 다른 보안 프로토콜과 구별된다. 다른 보안 프로토콜은 등록 이벤트에 리소스에 대한 덥근 권한이 수반되고, 따라서 등록 프로세스에 대한 엄격한 보호가 필요하다. 인가 서버의 관리자가 검사하고 신뢰할 수 있는 권한에 의해 정적으로 등록된 클라이언트의 경우에 인가 서버는 리소스 소유자의 동의 절차를 생략하고 싶을 수 있다. 그런 신뢰할 수 있는 클라이언트를 화이트 리스트로 관리한다면 인가 서버는 사용자 개입 없이 자연스럽게 권한을 부여할 수 있을 것이다. OAuth 프로토콜에서는 리소스 소유자가 권한 위임에 동의하면 리소스 소유자는 인가 엔드 포인트로 리다이렉트되고, 인가 서버는 프런트 채널로 전달된 접근 요청을 읽는다. 이때 리소스 소유자에게 클라이언트를 신뢰할 것인지 묻지 않고 해당 클라이언트가 이미 인가됐다는 정책적인 결정을 내려 인가 요청 결과를 즉시 리턴할 수 있다.  

반대로, 안가 서버는 클라이언트의 특정 속성에 대한 등록이나 인가 요청을 허용하지 않는 것으로 결정할 수도 있다. 허용하지 않는 속성으로는 이미 알려진 악의적인 소프트웨어에 대한 리다이렉트 URI나 사용자를 의도적으로 혼란스럽게 만들기 위한 이름 또는 악의적인 다른 유형의 탐지 가능한 속성이 해당된다. 그런 속성값들을 블랙 리스트로 관리하면, 인가 서버는 클라이언트가 그런 값들은 사용하지 못하도록 차단할 수 있다.  

그 외의 것은 모두 그레이 리소트로 관리해 그것을 바탕으로 리소스 소유자는 최종적인 권한 위임 결정을 수행한다. 동적으로 등록된 클라이언트가 블랙 리스트에는 포함돼 있지 않지만, 화이트 리스트에도 포함돼 있지 않다면 그것은 자동으로 그레이 리스트에 등록된다. 그렇게 등록된 클라이언트는 정적으로 등록된 클라이언트와는 달리, 특정 권한 범위를 요청하거나 특정 그랜트 타입을 사용하지 못하도록 제한되지만, 일반적인 OAuth 클라이언트와 동일하게 동작한다. 인가 서버는 이와 같은 방법을 통해 보안성을 손상시키지 않으면서 확정성과 유연성을 향상시킬 수 있다. 충분히 오랜 기간 동안 많은 사용자에 의해 문제 없이 사용된 동적으로 등록된 클라이언트는 화이트 리스트에 등록될 수 있고, 악의적인 클라이언트라고 판단된 클라이언트는 등록이 취소되고 그것의 주요 속성값은 블랙리스트에 등록된다.  

#### 12.3. 클라이언트 메타 데이터  
<br/>

+ 클라이언트 메타 데이터  
등록된 클라이언트와 관련된 속성 정보  

+ 클라이언트가 서버로 전달  
클라이언트는 요청된 속성 값들을 인가 서버로 전달한다. 그렇게 전달된 속성 값들은 인가 서버에 설정된 것과 호한되지 않을 수 있다.  

+ 서버가 클라이언트에게 반환  
인가 서버가 등록된 속성값을 클라이언트에게 전달한다. 인가 서버는 클라이언트의 요청된 속성을 교체하거나 보강하거나 제가할 수 있다. 일반적으로 인가 서버는 클라이언트의 요청된 속성을 존중하려고 하지만, 최종적인 결정은 항상 인가 서버에 의해 이뤄진다. 어떤 경우든 인가 서버는 항상 실제 등록된 속성값을 클라이언트에게 전달해야 한다. 클라이언트는 원하지 않는 등록 결과에 대해 좀 더 타당한 값으로 변경해 등록을 요청하거나 인가 서버와의 통신을 거부하는 것과 같은 대응을 할 수는 있지만, 바람직한 방법은 아니다.  

##### 12.3.1. 핵심적인 클라이언트 메타 데이터 필드 이름 테이블  
<br/>

동적 클라이언트 등록 프로토콜은 공통 클라이언트 데이터 이름과 그것의 확장에 대해 정의하고 있다. OAuth 클라이언트에 일반적으로 적용되는 몇 가지 OpenID 커넥트 관련 확장을 표에 포함시켰다.  

<table>
	<thead>
		<tr>
			<th>이벤트 타입</th>
			<th colspan="2">용도</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>redirect_uris</td>
			<td colspan="2">리다리엑트 기반의 OAuth 그랜트에서 사용되는 authorization&#95;code와 implicit와 같은 URI 문자열 배열</td>
		</tr>
		<tr>
			<td>token&#95;endpoint&#95;auth&#95;method</td>
			<td colspan="2">클라이언트가 토큰 엔드 포인트에 인증하는 방법</td>
		</tr>
		<tr>
			<td></td>
			<td>none</td>
			<td>클라이언트가 토큰 엔드포인트를 사용하지 않거나 사용하더라도 공개 클라이언트가 아니라면 클라이언트는 토큰 엔드 포인트에 인증하지 않는다.</td>
		</tr>
		<tr>
			<td></td>
			<td>client&#95;secret&#95;basic</td>
			<td>클라이언트는 HTTP BASIC으로 자신의 클라이언트 시크릿을 전달한다. 이는 클라이언트가 클라이언트 시크릿을 발급받은 상태에서 특별히 인증 방법을 지정하지 않았을 때 디폴트로 사용된다.</td>
		</tr>
		<tr>
			<td></td>
			<td>client&#95;secret&#95;post</td>
			<td>클라이언트는 자신의 클라이언트 시크릿을 HTTP 폼 파라미터로 전달한다.</td>
		</tr>
		<tr>
			<td></td>
			<td>client&#95;secret&#95;jwt</td>
			<td>클라이언트는 자신의 개인키로 서명한 JWT를 만든다. 공개키는 인가 서버에 등록돼야 한다.</td>
		</tr>
		<tr>
			<td>grant&#95;types</td>
			<td colspan="2">클라이언트가 토큰을 얻기 위해 사용하는 그랜트 타입. 여기에 정의된 값은 토큰 엔드 포인트에서 grant&#95;type 파라미터로 사용되는 것과 동일한 것이다.</td>
		</tr>
		<tr>
			<td></td>
			<td>authorization&#95;code</td>
			<td>클라이언트가 리소스 소유자를 인가 엔드 포인트로 보내서 인가 코드를 얻고 그것을 토큰 엔드 포인트에 전달하는 인가 코드 그랜트, response&#95;type으로 "code"가 사용돼야 한다.</td>
		</tr>
		<tr>
			<td></td>
			<td>implicit</td>
			<td>클라이언트가 리소스 소유자를 인가 엔드 포인트로 보내 토큰을 직접 획득하는 암시적 그랜트, response&#95;type으로 "token"이 사용돼야 한다.</td>
		</tr>
		<tr>
			<td></td>
			<td>password</td>
			<td>클라이언트가 리소스 소유자에게 자신의 이름과 비밀번호를 입력하도록 만들고, 토큰 엔드 포인트에서 그것을 토큰과 교환하는 리소스 소유자가 비밀번호 그랜트</td>
		</tr>
		<tr>
			<td></td>
			<td>client&#95;credentials</td>
			<td>클라이언트가 토큰을 얻기 위해 자신의 자격 증명을 이용하는 클라이언트 자격 증명 그랜트</td>
		</tr>
		<tr>
			<td></td>
			<td>refresh&#95;token</td>
			<td>클라이언트가 리소스 소유자의 개입 없이 새로운 액세스 토큰을 얻기 위해 리프레시 토큰을 사용하는 리프레시 토큰 그랜트</td>
		</tr>
		<tr>
			<td></td>
			<td>urn:ietf:params:oauth: grant-type:jwt-bearer</td>
			<td>클라이언트가 토큰을 얻기 위해 특정 클레잉ㅁ을 지정한 JWT를 전달하는 JWT 어설션 그랜트</td>
		</tr>
		<tr>
			<td></td>
			<td>urn:ietf:params:oauth: grant-type:saml2-'bearer</td>
			<td>클라이언트가 토큰을 얻기 위해 특정 클레임을 지정한 SAML 문서를 전달하는 SAML(Security Assertion Markup Language) 어설션 그랜트</td>
		</tr>
		<tr>
			<td>response&#95;types</td>
			<td colspan="2">인가 엔드 포인트에서 사용할 클라이언트의 응답 타입. 이 값은 response&#95;type 파라미터에 사용되는 것과 동일하다.</td>
		</tr>
		<tr>
			<td></td>
			<td>code</td>
			<td>토큰을 얻기 위해 토큰 엔드 포인트에 전달돼야 하는 인가 코드를 반환하는 인가 코드 응답 타입</td>
		</tr>
		<tr>
			<td></td>
			<td>token</td>
			<td>리다이렉트 URI에 토큰을 직접 반환하는 암시적 응답 타입</td>
		</tr>
		<tr>
			<td>client&#95;name</td>
			<td colspan="2">사람이 읽을 수 있는 형태의 클라이언트이 이름</td>
		</tr>
		<tr>
			<td>client&#95;uri</td>
			<td colspan="2">사람이 읽을 수 있는 형태의 클라이언트이 URI</td>
		</tr>
		<tr>
			<td>logo&#95;uri</td>
			<td>클라이언트를 위한 로고 URI. 인가 서버는 이 URL을 이용해 사용자에게 클라이언트의 로고를 출력해줄 수 있지만, 이미지 URL을 사용하면 사용자에 대한 보안과 프라이버시 이슈가 있을 수 있다는 것을 고려해야 한다.</td>
		</tr>
		<tr>
			<td>scope</td>
			<td>클라이언트가 토큰을 요청할 때 사용하는 권한 범위 리스트. OAuth 프로토콜의 경우처럼 각 권한 문자열이 공백 문자로 구분된다.</td>
		</tr>
		<tr>
			<td>contacts</td>
			<td>클라이언트 담당자에게 연락할 수 있는 방법에 대한 리스트. 일반적으로는 이메일 주소지만, 전화번호나 인스턴트 메신저 주소 또는 기타 다른 연락 메커니즘으로 구성된다.</td>
		</tr>
		<tr>
			<td>tos&#95;uri</td>
			<td>사람이 읽을 수 있는 형태로 클라이언트를 위한 서비스 이용 약관의 리스트를 담고 있는 URI. 클라이언트에게 권한을 인가할 때 리소스 소유자가 수락하는 계약 관계를 설명한다.</td>
		</tr>
		<tr>
			<td>policy&#95;uri</td>
			<td>사람이 읽을 수 있는 형태로 클라이언트를 위한 프라이버시 정책을 담고 있는 URI. 이 정책은 클라이언트를 배포한 조직이 인증된 API 호출을 통해 액세스한 데이터를 비롯해 리소스 소유자의 개인 데이터를 수집, 사용, 보유 및 공개하는 방법을 설명한다.</td>
		</tr>
		<tr>
			<td>jwks&#95;uri</td>
			<td>클라아언트를 위한 공개키를 포함하는 JSON Web Key Set을 가리키는 URI로서 인가 서버가 접근 가능한 곳이다. 이 필드는 jwks 필드와 함께 사용될 수 없다. 클라이언트가 키를 순환해 사용할 수 있기 때문에 jwks&#95;uri가 더 많이 사용된다.</td>
		</tr>
		<tr>
			<td>jwks</td>
			<td>클라이언트를 위한 공개키를 포함하는 JSON Web Key Set: 문서(JSON 객체). 이 필드는 jwks&#95;uri 필드와 함께 사용될 수 없다. 클라이언트가 키를 순환해 사용할 수 있기 때문에 jwks&#95;uri가 더 많이 사용된다.</td>
		</tr>
		<tr>
			<td>software&#95;id</td>
			<td>클라이언트가 동작하는 소프트웨어를 위한 고유한 식별자. 이 식별자는 클라이언트 소프트웨어의 모든 인스턴스에서 동일한 것이다.</td>
		</tr>
		<tr>
			<td>software&#95;version</td>
			<td>software&#95;id 필드가 가리키는 클라이언트 소프트웨어를 위한 버전 식별자. 버전 문자열은 인가 서버에는 불투명하며, 특정 포맷이 사용되지 않는다.</td>
		</tr>
	</tbody>
</table>
<br/><br/>

##### 12.3.2. 사람이 읽을 수 있는 클라이언트 메타 데이터의 국제화  
<br/>

등록 요청과 응답에 전달되는 다양한 클라이언트 정보 가운데 몇 가지는 인가 페이지에서 리소스 소유자에게 전달되기 위한 용도나 인가 서버가 사용자에게 제공하는 페이지에 출력하는 용도로 사용된다. 그것은 사용자에게 직접 출력되는 문자열이거나 상요자가 클릭할 수 있는 URL일 수도 있다. 하지만 클라이언트가 하나 이상의 언어가 지역에서 사용될 수 있다면 그것이 지원하는 각 언어에 대해 사람이 읽을 수 있는 형태의 값을 가질 수 있다. 그런 경우, 클라이언트는 각 언어에 대해 개별적으로 등록을 수행해야 할까?  

다행스럽게도 동적 클라이언트 등록 프로토콜은 동시에 여러 개의 언어로 값을 표현하기 위한 시스템(OpenID 커넥트에서 차용한)을 갖고 있다.  

다른 언어나 스크립트를 나타내기 위해 클라이언트는 필드의 이름에 &#35; 문자와 언어 태그를 붙여 전달한다.  

인가 서버는 사용자와의 상호 작용에 있어서 최대한 구체적인 방법을 사용해야 한다.  

##### 12.3.3. 소프트웨어 명세서  
<br/>

동적 등록 요청을 위해 클라이언트가 전달하는 모든 메타 데이터 값은 스스로 확인된 값으로 간주돼야 한다. 그런 환경에서는 클라이언트가 잘못된 클라이언트 이름이나 다른 누군가의 도메인에 있는 URI을 리다이렉트 URI로 잘못 전달하는 것을 막을 수 없다.  

만약, 인가 서버가 자신에게 전달되는 클라이언트 메타 데이터가 신뢰된 곳으로부터 전달된 것인지 검증할 수 있도록 전달할 수 있는 방법이 있다면 어떻게 될까? 그런 메커니즘을 갖고 있으면 인가 서버는 클라이언트의 특정 메타 데이터 속성을 제재할 수 있으며, 메타 데이터가 유효하다고 확신할 수 있다. OAuth 동적 등록 프로토콜은 그런 메커니즘을 제공하며, 그것을 소프트웨어 명세서라고 한다.  

간단히 말해, 소프트웨어 명세서는 등록 엔드 포인트에 대한 요청에서 발견되는 페이로드 클라이언트 메타 데이터를 포함하는 서명된 JWT라고 할 수 있다. 모든 인가 서버에 클라이언트 소프트웨어의 인스턴스 모두를 수동으로 등록하는 대신, 클라이언트 개발자는 자신의 클라이언트 메타 데이터의 일부를 미리 등록할 수 있다. 미리 등록되는 내용은 시간이 흘러도 좀처럼 바뀌지 않고, 신뢰된 제삼자에 의해 서명된 소프트웨어 명세서를 발급받는다. 그러면 이후부터 클라이언트 소프트웨어는 소프트웨어 명세서와 등록에 필요한 추가 메타 데이터를 이용해 인가 서버에 대한 등록을 수행한다.  

클라이언트가 전달하는 등록 요청에는 소프트웨어 명세서에 포함되지 않은 추가 필드가 포함될 수 있다.  

인가 서버는 소프트웨어 명세서를 파싱하고, 그것의 시그니처를 검증해 신뢰된 기관으로부터 발급받은 것인지 여부를 판단한다. 검증이 통과되면 소프트웨어 명세서 안의 클레임이 서명되지 않은 JSON 객체의 것보다 우선시된다.  

소프트웨어 명세서 OAuth에서 일반적으로 사용되는 자기 검증보다 높은 신뢰 수준을 제공한다. 또한 중앙의 발급 기관(또는 여러 기관)을 여러 인가 서버가 신뢰할 수 있게 돼 다른 클라이언트에 대한 소프트웨어 명세서 발급도 가능해진다. 더욱이 인가 서버는 소프트웨어 명세서상의 정보를 기준으로 소프트웨어의 여러 인스턴스를 논리적으로 그룹화할 수 있다. 각각의 소프트웨어 인스턴스가 각기 고유한 클라이언트 ID와 클라이언트 시크릿을 받게 되더라도 서버 관리자는 일부 인스턴스의 악의적인 행위가 발생했을 때 해당 소프트웨어의 모든 인스턴스를 한 번에 비활성화시키거나 해지시킬 수 있다.  

### 13. OAuth 2.0에서의 사용자 인증  
<br/>

#### 13.1. OAuth 2.0이 인증 프로토콜이 아닌 이유  
<br/>

+ 인증  
현재 사용자가 누구인지 그리고 현재 사용자가 애플리케이션을 사용하고 있는지 여부를 애플리케이션에게 알려주는 것으로 일반적으로 자격 증명(사용자 이름과 비밀번호와 같은)을 애플리케이션에 제공함으로써 사용자가 현재 주장하는 자신임을 알리는 보안 아키텍처의 일부분이라고 할 수 있다.  

OAuth 2.0은 자체적으로 사용자에 대해 어떤 것도 알려주지 않을 뿐만 아니라 사용자가 자신의 존재를 어떻게 증명했는지 또는 존재했는지에 대해서도 알려주지 않는다. OAuth 2.0 클라이언트는 토큰을 요청해 토큰을 획득하고, 결국 그 토큰을 이용해 API에 접근한다. 하지만 누가 해당 클라이언트를 인가했는지 또는 인가되는 과정에 사용자가 있었는지에 대해서는 전혀 알지 못한다. 사실, OAuth 2.0은 사용자가 상호 작용해 더 이상 애플리케이션에게 권한을 인가할 수 없을 때 애플리케이션이 액세스 토큰을 얻기 위해 주로 사용된다.  

#### 13.2. OAuth를 인증 프로토콜로 매핑  
<br/>

그렇다면 OAuth를 기반으로 어떻게 인증 프로토콜을 구축할 수 있을까? 먼저, 서로 다른 OAuth 2.0 구성 요소를 인증 트랜잭션의 적절한 부분으로 매핑시켜야 한다.  

OAuth 2.0 트랜잭션에서 리소스 소유자는 인가 서버의 토큰을 이용해 보호된 리소스에 접근할 수 있도록 클라이언트에게 접근 권한을 인가한다. 인증 트랜잭션에서 사용자는 식별 제공자(Idp, Identity Provider)를 이용해 신뢰 당사자(RP, Relying Party)에 로그인한다. 이를 염두에 두고, 인증 프로토콜을 설계할 때 공통적인 접근 방법은 신뢰 당사자를 보호된 리소스로 매핑하는 것이다. 결국 신뢰 당사자가 인증 프로토콜에 의해 보호되는 구성 요소일까?  

OAuth 2.0 위에 신원 확인 프로토콜을 배치하는 것이 합리적인 것 같지만, 보안 경계가 잘 정리되지 않는다. OAuth 2.0에서 클라이언트와 리소스 소유자는 함께 동작한다. 즉, 클라이언트는 리소스 소유자를 대신해 동작을 수행한다. 인가 서버와 보호된 리소스 또한 함께 동작한다. 인가 서버는 토큰을 만들고 보호된 리소스는 그것을 받아들인다. 다시 말하면, 사용자/클라이언트와 인가 서버/보호된 리소스 사이에 보안 및 신뢰 경계가 있고, OAuth 2.0은 그 경계를 가로지르는 데 사용되는 프로토콜이다. 각 구성 요소를 매핑시킬 때 경계는 IdP와 보호된 리소스 사이가 된다. 그렇게 되면 보호된 리소스가 사용자와 직접 상호 작용하게 돼 보안 경계가 부자연스럽게 교차된다. 하지만 OAuth 2.0에서는 일반적으로 리소스 소유자는 보호된 리소스와 상호 작용하지 않는다. 클라이언트 애플리케이션이 API를 이용해 보호된 리소스에 접근한다.  

따라서 보안 경계가 제대로 유지되는 다른 방법을 찾을 필요가 있다. OAuth 2.0 클라이언트는 어쨌든 리소스 소유자인 사용자와 상호 작용하는 구성 요소이므로 구성 요소이므로 OAuth 2.0 클라이언트를 RP로 매핑시켜보자.  

또한 인가 서버와 보호된 리소스를 하나의 구성 요소인 IdP로 묶을 수 있다. 리소스 공유자가 클라이언트에게 접근 권한을 위임하게 만들 예정이지만, 위임되는 접근 권한의 대상은 리소스 자체의 식별 정보가 된다. 다시 말하면, RP에게 지금 당장 누가 있는지를 알아낼 수 있는 구너한을 위임한다는 것이다. 이것이 여기서 구축하려는 인증 트랜잭션의 핵심이다.  

인가 프로토콜 위에 인증 프로토콜을 구축하는 것이 다소 직관적이지 않게 보일 수는 있지만, OAuth 2.0의 보안 위임 모델을 활용하면 시스템을 연결하기 위한 강력한 수단이 될 수 있다는 것을 볼 수 있을 것이다. 더 나아가. OAuth 2.0 시스템의 모든 구성 요소를 인증 프로토콜의 구성 요소로 깔끔히 매핑시킬 수 있다. OAuth 2.0을 확장해 인가 서버와 보호된 리소스에서 오는 정보가 사용자와 사용자의 인증 컨텍스트를 전달한다면 클라이언트에게 사용자를 안전하게 로그인하는 데 필요한 모든 것을 제공할 수 있다.  

이제 익숙한 OAuth 2.0으로 만든 인증 프로토콜을 갖게 됐다. 새로운 프로토콜에 대해 작업할 것이기 때문에 다른 이름이 필요하다. 클라이언트는 이제 신뢰 당사자 또는 RP로 불리는 것이다. 인가 서버와 보호된 리소스는 개념적으로 식별 제공자 또는 IdP로 결합시켰다. 토큰을 발행하고 사용자의 신원 정보를 제공하는 두 가지 기능은 별도의 서버를 두어서 처리하도록 할 수 있지만, RP가 고려된다면 하나의 기능으로 동작할 수 있다. 또한 액세스 토큰뿐만 아니라 ID 토큰이라는 것을 추가해 인증 이벤트 자체에 대한 정보를 전달할 것이다.  

이제 RP는 사용자가 누구인지 그리고 그들이 어떻게 로그인됐는지 알아낼 수 있다. 하지만 여기서 왜 2개의 토큰을 이용하는 것일까? 인가 서버로부터 받은 토큰에 사용자에 대한 정보를 직접 제공하거나 OAuth로 보호되는 리소스로 호출할 수 있는 사용자 정보 API를 제공할 수도 있다.  

#### 13.3. OAuth 2.0 인증 방법  
<br/>

OAuth의 권한 위임 프로세스가 동작하기 위해서는 여러 가지 형태의 인증이 요구된다. 즉, 리소스 소유자는 인가 서버의 인가 엔드 포인트에 대해 인증하고, 클라이언트는 토큰 엔드 포인트에서 인가 서버에 인증하고, 설정에 따라 그 외 다른 형태의 인증이 있을 수 있다. 인가 프로토콜 위에 인증 프로토콜을 구축하면 인가 프로토콜 자체는 인증 프로토콜에 의존하게 되는데, 그것이 다소 복잡하다고 생각될 수 있다.  

이상하게 보일 수 있지만, 그렇게 하면 사용자가 인가 서버에서 인증한다는 사실을 활용할 수 있고, OAuth 2.0 프로토콜을 통해 사용자의 자격 증명이 클라이언트 애플리케이션(RP)에 전달되는 지점이 없다는 것을 활용할 수 있다. 각 구성 요소가 필요로 하는 정보를 제한함으로서 트랜잭션을 보다 안전하고 좀처럼 실패하지 않게 만들 수 있으며, 보안 도메인 전체에서 제대로 종작하게 만들 수 있다. 사용자는 클라이언트가 그러하듯 단일 구성 요소에 직접 인증을 수행해야 하며, 다른 사용자로 가장하지 않아야 한다.  

이처럼 인가 프로토콜 위에 인증 프로토콜을 구축하는 또 다른 이점은 사용자 동의가 실시간으로 수행될 수 있다는 것이다. 사용자가 자신들의 신원 종보를 어느 애플리케이션에게 공개할지를 결정하게 함으로써 OAuth 2.0 기반의 신원 확인 프로토콜은 보안 도메인을 인터넷으로 확장할 수 있다. 모든 사용자가 시스템에 로그인할 수 있는지 여부를 미리 결정하는 방식이 아닌 각 개별 사용자가 자신들이 선택한 곳에 로그인할 것인지를 결정한다. 이는 OAuth 2.0의 TOFU(Trust On First Use) 모델에 부합된다.  

또한 사용자는 자신들의 신원 정보와 함께 다른 보호된 API에 대한 권한을 위임할 수 있다. 한 번의 호출만으로 애플리케이션은 사용자의 로그인 여부와 애플리케이션이 사용자에게 요청해야 하는 내용을 알 수 있다. 서비스가 이미 OAuth 2.0으로 보호된 API를 제공하고 있다면, 인증 서비스도 함께 제공하도록 하는 것이 그렇게 부담되는 작업은 아니다. 서비스가 식별 기능을 제공하는 것은 오늘날의 웹 API 중심의 세계에서 유용하다는 것이 입증됐다.  

#### 13.4. 인증을 위해 OAuth 2.0을 사용하는 데 있어서의 일반적인 함정  
<br/>

##### 13.4.1. 인증의 증거로서의 액세스 토큰  
<br/>

리소스 소유자는 일반적으로 액세스 토큰이 발급되기에 앞서 인가 엔드 포인트에 인증을 해야 하기 때문에 액세스 토큰이 있으면 그것이 인증을 수행한 증거로 간주하기도 한다. 하지만 토큰 자체는 인증과 관련된 어떤 정보도 전달하지 않으며, 실제로 인증이 수행됐는지 여부를 나타내지 않는다. 또한 토큰이 유효 기간이 긴 세션(그래서 탈취될 가능성이 있는)에서 발행된 것일 수도 있고, 개인과 상관없는 권한 범위를 위해 자동으로 발급된 것일 수도 있다. 토큰은 클라이언트 자격 증명이나 어설션 또는 리프레시 토큰과 같은 사용자와의 상호 작용을 요구하지 않는 OAuth 2.0 그랜트 타입으로 클라이언트에게 직접 발급될 수도 있다. 또한 클라이언트가 액세스 토큰이 발급되는 곳을 신중하게 확인하지 않으며, 다른 클라이언트에 임의의 토큰을 발급하는 것이 가능해질 수 있다.  

토큰을 어떻게 얻었든 클라이언트는 액세스 토큰으로서 사용자나 그들의 인증 상태에 대해 어떤 것도 말할 수 없다. 이는 클라이언트가 OAuth 2.0 액세스 토큰의 의도된 수신 대상자가 아니라는 사실 때문이다. 클라이언트가 토큰에서 어떤 사용자 정보를 추출할 필요가 있을 수 있지만, OAuth 2.0에서는 액세스 토큰이 클라이언트에게 그 내용이 불투명하도록 설계됐다. 클라이언트는 액세스 토큰을 전달하고 보호된 리소스는 그것을 받아들이도록 돼 있다.  

클라이언트가 해석하고 이해할 수 있는 형태의 토큰 포맷을 정의할 수도 있다. 그런 토큰에는 클라이언트가 읽고 검증할 수 있는 사용자 관련 정보와 인증 관련 정보를 포함할 수 있다. 하지만 일반적인 OAuth 2.0에서는 액세스 토큰을 특정한 포맷이나 구조를 정의하지 않으며, 기존의 배포된 OAuth 시스템들은 각자 자체적인 토큰 포맷을 사용한다. 또한 액세스 토큰의 수명이 토큰 내부에 기술된 인증 이벤트보다 길어질 가능성이 높다. 토큰은 보호된 리소스에 전달되기 때문에 그중 일부는 식별과 관련이 없을 수 있고, 보호된 리소스가 사용자의 로그인 이벤트에 대한 민감한 정보를 아는 것이 잠재적으로 문제가 될 수 있다. 이와 같은 한계를 극복하기 위해 OpenID 커넥트와 페이스북 커넥트의 Signed Response와 같은 프로토콜에서는 클라이언트에게 인증 정보를 직접 전달하기 위해 액세스 토큰과 더불어 또 하나의 토큰을 추가로 제공한다. 즉, 액세스 토큰은 기존의 OAuth와 동일하게 클라이언트에게 불토명하게 만들고, 인증 토큰은 클라이언트가 제대로 해석할 수 있도록 정의해 만든다.  

##### 13.4.2. 인증의 증거로서의 보호된 API에 대한 접근  
<br/>

클라이언트가 토큰의 내용을 모르더라도 클라이언트는 항상 그것을 보호된 리소스에 전달할 수 있다. 만약, 클라이언트에게 누가 토큰을 발급한 것인지 알려주는 보호된 리소스를 정의하면 어떻게 될까? 액세스 토큰을 사용자 속성 정보와 교환할 수 있다면 유효한 액세스 토큰을 소유하고 있다는 것만으로 사용자가 인증됐음을 증명하는 데 충분하다고 생각할 가능성이 있다.  

이는 인가 서버에서 인증되는 사용자의 컨텍스트 내에서 새로 만들어진 액세스 토큰인 경우에만 해당하는 내용이다. 하지만 OAuth 에서는 다른 방법으로도 액세스 토큰을 얻을 수 있다. 사용자 없이 리프레시 토큰과 어설션을 이용해 액세스 토큰을 얻을 수도 있고, 경우에 따라서는 사용자 인증 없이 접근 권한을 얻을 수도 있다.  

더욱이 액세스 토큰은 일반적으로 사용자가 로그아웃한 이후에도 사용된다. 일반적으로 보호된 리소스는 사용자가 있는지 여부를 토큰만으로 알 수 있는 위치에 있지 않다. OAuth 2.0 프로토콜의 속성상 사용자는 클라이언트와 보호된 리소스 사이의 연결에 위치하지 않기 때문이다. 많은 대규모 OAuth 2.0 생태계에서 사용자는 보호된 리소스에 인증할 수 있는 수단을 절대 갖지 않는다. 보호된 리소스가 원래 어떤 사용자가 토큰을 인가했는지 말할 수 있을지 모르지만, 사용자의 현재 상태에 대해서는 일반적으로 말하지 못한다.  

인가 이벤트와 보호된 리소스에 대한 토큰 사용 간의 시간 간격이 큰 경우에 특히 문제가 발생할 수 있다. OAuth 2.0은 사용자가 현재 없을 때 클라이언트나 인가 서버 모두에서 제대로 동작할 수 있지만, 인증 프로토콜의 대부분이 사용자가 있는지 여부를 확인하기 위한 것이기 때문에 클라이언트는 기능 중인 액세스 토큰의 존재 여부에 의존해 사용자가 있는지를 결정할 수 없다. 클라이언트는 토큰이 상대적으로 최신의 것이라는 것을 알 때만 사용자 정보를 확인함으로써 문제를 해결할 수 있다. 액세스 토큰만 있으면 사용자 API에 접근할 수 있기 때문에 액세스 토큰이 있다고 해서 사용자가 현재 있다고 가정하면 안 된다.  

##### 13.4.3. 액세스 토큰 삽입  
<br/>

클라이언트가 토큰 엔드 포인트로 요청을 보내 전달받는 것 외의 소스에서 액세스 토큰을 받아들인다면 또 다른 위협이 발생한다. 이는 특히 URL 해시의 파라미터로 클라이언트에게 직접 토큰이 전달되는 암시적 플로르 사용하는 경우, 문제가 된다. 공격자는 다른 애플리케이션을 통해 또는 중간에 가로채 유효한 토큰을 확보할 수 있으며, 토큰을 요청하고 대기 중인 RP에 그것을 전달할 수 있다. 이는 클라이언트가 실제 리소스 소유자의 것이 아닌 다른 리소스에 접근하도록 속일 수 있기 때문에 OAuth 2.0에서 충분히 문제가 될 수 있다. 인증 프로토콜에서는 공격자가 토큰을 복사해 다른 애플리케이션에 로그인할 수 있기 때문에 보다 엄청난 문제가 초래될 수 있다.  

애플리케이션의 구성 요소 간에 액세스 토큰을 "공유"하기 위해 액세스 토큰이 전달될 때도 문제가 발생할 수 있다. 이는 액세스 토큰이 외부의 구성 요소에 의해 애플리케이션에 주입될 가능성이 있고, 애플리케이션 외부로 유출될 수 있는 길이 열리기 때문에 문제가 된다. 클라이언트 애플리케이션이 액세스 토큰을 검증하지 않는다면 유효한 토큰과 공격자의 토큰을 구분할 수 잇는 방법이 없다.  

이는 암시적 플로 대신 인가 코드 플로를 사용하면 해결할 수 있다. 즉, 클라이언트는 인가 서버의 토큰 엔드 포인트에서 전달된 토큰만 받아들이면 된다. state 파라미터를 사용하면 클라이언트는 공격자가 추측할 수 없는 값을 제공할 수 있다. 토큰이 전달될 때 state 파라미터가 없거나 state 파라미터의 값이 틀리면 클라이언트는 토큰이 유효하지 않다고 판단해 거부할 수 있다.  

##### 13.4.4. 수신자 제한의 결여  
<br/>

대부분의 OAuth 2.0 API는 반환되는 정보에 대해 수신자를 제한하는 어떤 메커니즘도 제공하지 않는다. 즉, 클라이언트가 액세스 토큰이 자신에게 발급된 것인지, 다른 클라이언트를 위해 발급된 것인지 여부를 말할 수 있는 방법이 없다. 네이티브 클라이언트에게 다른 클라이언트의 (유효한) 토큰을 전달해 네이티브 클라이언트가 사용자 API를 호출하게 만드는 것이 가능하다. 보호된 리소스는 API를 호출하는 클라이언트의 식별 정보를 모르기 때문에 토큰에 대한 검증만 수행할 수 있고, 결국 유효한 사용자 정보를 반환하게 될 것이다. 하지만 반환되는 정보는 원래 다른 클라이언트가 사용하기 위한 정보였을 수 있다. 그리고 심지어 사용자는 해당 네이티브 클라이언트를 인가하지 않는다.  

이 문제는 클라이언트가 인식하고 자체적으로 검증할 수 있는 식별자를 인증 정보와 함께 클라이언트에게 전달함으로써 대응할 수 있다. 이를 통해 클라이언트는 자기자신에 대한 인증과 다른 애플리케이션에 대한 인증을 구별할 수 있다. 또한 OAuth 2.0이 처리되는 동안 클라이언트에게 인증 정보를 OAuth 2.0으로 보호된 API와 같은 부가적인 메커니즘을 통하지 않고 직접 전달하면 클라이언트로 신뢰되지 않은 정보가 삽입돼 전달되는 것을 막을 수 있다.  

##### 13.4.5. 잘못된 사용자 정보 삽입  
<br/>

공격자가 클라이언트로부터의 호출 중 하나를 가로채거나 선택할 수 있다면 클라이언트 모르게 반환되는 사용자 정보의 내용을 변경할 수 있다. 예를 들면, 사용자 정보 API의 반환값이나 클라이언트로 전달되는 토큰의 내용을 바꿀 수 있다. 이를 통해 공격자는 사용자의 식별 정보를 교체할 수 있고, 순진한 클라이언트에서 다른 사용자로 가장할 수 있다.  

이 공격을 막으려면 클라이언트로 전달되는 인증 정보를 암호화로 보호하고 검증하면 된다. 클라이언트와 인가 서버 사이의 모든 통신은 TLS로 보호돼야 하고, 클라이언트는 서버에 접속할 때 서버의 인증서를 검증해야 한다. 추가로, 서버는 사용자 장보나 토큰(또는 둘 모두)을 서명할 수 있고, 클라이언트는 그것을 검증할 수 있다. 추가 시그니처를 통해 네트워크가 탈취된다고 하더라도 사용자 정보가 변조되거나 삽입되는 것을 막을 수 있다.  

##### 13.4.6. 식별 제공자마다 다른 프로토콜 사용  
<br/>

OAuth 2.0 기반 식별 API의 가장 큰 문제점 중 하나는 식별 제공자가 표준적인 OAuth를 기반으로 하더라도 각기 다르게 식별 API를 구현한다는 것이다. 예를 들면, 사용자의 고유 식별자를 어느 한 식별 제공자에서는 user_id 필드에서 찾을 수 있다면, 다른 식별 제공자에서는 sub 필드에서 찾을 수도 있다. 해당 필드들은 모두 의미적으로 동일한 것이지만, 각기 다른 별도의 코드 처리가 필요하다. 각 식별 제공자에서 수행되는 인가는 동일한 방법으로 이뤄지지만, 인증 정보의 전달은 다를 수 있다.  

이 문제는 여기에서 논의된 인증 정보 전달을 위한 메커니즘이 OAuth 2.0의 범위를 벗어나기 때문에 발생한다. OAuth 2.0은 토큰의 포맷을 정의하지 않고, 액세스 토큰을 위한 공통적인 권한 범위를 저의하지 않고 보호된 리소스가 액세스 토큰을 검증하는 방법을 설명하지 않는다. 따라서 OAuth 표준 위에 구축된 표준 인증 프로토콜을 이용하면 문제가 해결될 수 있으므로 식별 정보가 어디서 전달되든 동일한 방법으로 전송된다. 그렇다면 그런 표준이 있을까?  

#### 13.5. OpenID 커넥트: OAuth 2.0 기반의 인증과 식별 표준  
<br/>

+ OpenID 커넥트  
2014년 2월에 OpenID 재단에서 공개한 오픈 표준으로서 OAuth 2.0으로 사용자 인증을 수행하기 위한 상호 운용 방식을 정의한다.  

오픈 표준인 OpenID 커넥트를 구현할 때는 라이선스나 지적 재산권에 대한 어떤 고려도 하지 않아도 된다. 프로토콜이 상호 운용 가능하게 설계됐기 때문에 OpenID 클라이언트 애플리케이션은 각각의 식별 제공자를 위해 각기 다른 프로토콜을 구현하지 않고 하나의 프로토콜로 많은 식별 제공자와 대화할 수 있다.  

OpenID 커넥트는 OAuth 2.0 위에 직접 구축되며, OAuth 2.0과 호환된다. 많은 경우, API를 보호하기 위한 일반적인 OAuth 기반 위에 배포된다. OAuth 2.0뿐만 아니라 OpenID 커넥트도 정보를 암호화하고 서명해 보낼 때 JOSE를 이용한다. JOSE를 이용하는 OAuth 2.0과 OpenID 커넥트 간의 차이는 상대적으로 작기 때문에 이미 완전한 호환의 길에 접어들었다고 할 수 있다. 반면, OpenID 커넥트는 OAuth 2.0에 몇 가지 중요한 구성 요소를 추가함으로써 많은 위험을 피할 수 있도록 관리한다.  

##### 13.5.1. ID 토큰  
<br/>

OpenID 커넥트의 ID 토큰은 서명된 JWT로서 일반적인 OAuth 액세스 토큰과 함께 클라이언트 애플리케이션에게 전달된다. 액세스 토큰과 달리, ID 토큰은 RP로 보내져 그것의 내용이 파싱된다.  

ID 토큰에도 인증 세션에 대한 클레임이 포함된다. 즉, 사용자 식별자(sub)와 토큰을 발급한 이슈 제공자를 위한 식별자(iss) 그리고 생성된 토큰을 발급받는 클라이언트 식별자(aud) 클레임이 포함된다. 또한 ID 토큰은 토큰 자체의 유효 시간 윈도우(exp와 iat 클레임으로)에 대한 정보뿐만 아니라 클라이언트에게 전달되는 인증 컨텍스트에 대한 추가 정보를 포함한다. ID 토큰은 표준 JWT 클레임뿐만 아니라 OpenID 커넥트 프로토콜을 위해 확장된 클레임도 포함될 수도 있다.  

<table>
	<thead>
		<tr>
			<th>클레임 이름</th>
			<th>설명</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>iss</td>
			<td>(issuer) 토큰 발급자: IdP의 URL
		</tr>
		<tr>
			<td>sub</td>
			<td>(subject) 토큰 대상. idP에서 사용자에 대한 안정적이고 고유한 식별자. 일반적으로 프로그램이 인식 가능한 문자열이며, 사용자 이름으로 사용되면 안 된다.</td>
		</tr>
		<tr>
			<td>aud</td>
			<td>(audience) 토큰 수신자: RP의 클라이언트 ID를 포함해야 한다.</td>
		</tr>
		<tr>
			<td>exp</td>
			<td>(expiration) 토큰의 만료 시간. 모든 ID 토큰이 만료되며, 일반적으로 매우 빨리 만료된다.</td>
		</tr>
		<tr>
			<td>iat</td>
			<td>토큰이 발급된 시간</td>
		</tr>
		<tr>
			<td>auth&#95;time</td>
			<td>사용자가 IdP에 인증한 시간</td>
		</tr>
		<tr>
			<td>nonce</td>
			<td>인증이 요청될 때 RP가 전달하는 문자열. 재전송 공격을 막기 위해 state 파라미터처럼 사용된다.</td>
		</tr>
		<tr>
			<td>acr</td>
			<td>(authentication context reference) 인증 컨텍스트 레퍼런스. 사용자가 IdP에서 수행할 인증의 전반적인 범주을 가리킨다.</td>
		</tr>
		<tr>
			<td>amr</td>
			<td>(authentication method reference) 인증 방법 레퍼런스. 사용자가 IdP에서 수행한 인증 방법을 가리킨다.</td>
		</tr>
		<tr>
			<td>axp</td>
			<td>(authorized party) 토큰으로 인가된 대상. 이 클레임이 사용된다면 RP의 클라이언트 ID가 포함돼야 한다.</td>
		</tr>
		<tr>
			<td>at&#95;hast</td>
			<td>액세스 토큰의 해시 값</td>
		</tr>
		<tr>
			<td>c&#95;hash</td>
			<td>인가 코드의 해시 값</td>
		</tr>
	</tbody>
</table>
<br/><br/>

ID 토큰은 토큰 엔드 포인트의 응답 데이터 내의 id&#95;token 멤버로 액세스 토큰과 함께 전달된다. 두 토큰은 각각 의도된 사용자와 사용 목적이 다르다. 토큰이 하나 추가돼 기능을 확장하는 것이기 때문에 액세스 토큰은 기존 OAuth과 동일하게 클라이언트에게 불투명한 구조로 남을 수 있고, 반면 ID 토큰은 그 내용을 해석할 수 있다. 또한 두 토큰은 각기 다른 라이프사이클을 가지며, ID 토큰 유효 기간이 보다 빨리 만료된다. ID 토큰은 하나의 인증 이벤트만 나타내며, 다른 외부 서비스로는 절대 전달되지 않는다. 하지만 액세스 토큰은 사용자가 떠난 이후에도 보호된 리소스에 접속하는 데 사용될 수 있다. 액세스 토큰을 사용해 처음에 누가 클라이언트를 인가했는지 물어볼 수는 있지만, 그렇다고 해서 사용자가 여전히 있다고 말하는 용도로는 사용할 수 없다.  

마지막으로, ID 토큰 자체가 식별 제공자의 키로 서명되기 때문에 토큰이 전달될 때 사용된 TLS 전송 보호 외에도 내부의 클레임 보호를 위한 계층이 하나 더 추가된다. 인가 서버가 ID 토큰을 서명하므로 인가 코드(c&#95;hash), 액세스 토큰(at&#95;hash)과는 분리된 독립적인 시그니처를 제공할 수 있다. 클라이언트는 여전히 인가 코드와 액세스 코드의 구조는 알지 못하지만, 그것의 해시 값을 검증함으로써 전반적인 삽입 공격을 방지할 수 있다.  

서명된 JWT를 검증할 때와 동일한 방법으로 ID 토큰을 검증함으로써 클라이언트는 많은 수의 일반적인 공격으로부터 자신을 보호할 수 있다.  

(1) ID 토큰을 파싱해 그것이 유효한 JWT인지 확인한다.  
+ "." 문자를 기준으로 문자열 섹션을 나눈다.
+ 각 섹션을 Base64URL 디코딩한다.
+ 처음 두 섹션(헤더와 페이로드)을 JSON 객체로 파싱한다.  
(2) 공개된 IdP의 공개키로 토큰의 시그니처를 검증한다.  
(3) ID 토큰이 신뢰할 수 있는 IdP가 발급한 것인지 확인한다.  
(4) 클라이언트 자신의 식별자가 ID 토큰의 수신자 리스트에 있는지 확인한다.  
(5) 만료 시간과 issued-at, not-before 타임스탬프 값이 현재 시간을 고려해 적절한지 확인한다.  
(6) nonce 값이 있다면 자신이 전달한 것과 동일한지 확인한다.  
(7) 인가 코드나 액세스 토큰의 해시 값이 있다면 그것을 검증한다.  

각 검증 단계는 기계적이며, 어떤 조건을 결정하는 것이기 때문에 최소한의 코딩 작업만 필요로 한다. OpenID 커넥트의 일부 고급 모드에서는 ID 토큰을 암호화할 수 있어서 파싱과 검증 프로세스가 약간 변경되지만, 그 결과는 동일하다.  

##### 13.5.4. OAuth 2.0과의 호환성  
<br/>

이처럼 강력한 인증 기능을 제공함에도 불구하고 OpenID 커넥트는 설계적으로 여전히 OAuth 2.0과 호환된다. 사실, 서비스가 완벽하게 지원할 준비가 잘돼 있는 것이다.  

OpenID 커넥트 클라이언트를 제대로 개발할 수 있도록 OpenID 커넥트 워킹 그룹에서는 인가 코드 플로를 이용하는 기본적인 OpenID 커넥트 클라이언트 개발을 위한 문서와 암시적 OpenID 커넥트 클라이언트 개발을 위한 문서를 제공하고 있다. 그 문서들은 개발자에게 기본적인 OAuth 2.0 클라이언트를 개발하는 방법과 OpenID 커넥트의 기능을 사용하기 위해 필요한 구성 요소를 추가하는 방법을 제공한다.  

##### 13.5.5. 고급 기능  
<br/>

OpenID 커넥트의 핵심적인 스펙이 매우 간단하다고 하더라도 모든 사용 시나리오가 OpenID 커넥트의 기본적인 메커니즘에 의해 제대로 해결될 수 있는 것은 아니다. 따라서 OpenID 커넥트는 다양한 사용 시나리오를 지원하기 위해 표준 OAuth가 정의하는 것 외에도 다양한 추가 옵션을 정의하고 있다.  

OpenID 커넥트 클라이언트는 OAuth의 전통적인 방식인 클라이언트 시크릿을 공유하는 방식 대신, 서명된 JWT를 이용해 인증을 수행할 수 있다. 그때 JWT는 클라이언트가 자신의 공개키를 서버에 등록해 놓았다면 클라이언트의 비대칭 비밀키로 서명되거나 클라이언트 시크릿을 대칭키로 사용해 서명할 수도 있다. 이 방법을 사용하면 클라이언트가 네트워크로 비밀번호를 전달하지 않아도 되기 때문에 보다 높은 수준의 보안을 제공할 수 있다.  

이와 유사하게, OpenID 커넥트 클라이언트는 폼 파라미터를 이용하는 대신 서명된 JWT를 이용해 인가 엔드 포인트에 요청을 보낼 수도 잇다. 요청 객체를 서명하는 데 사용된 키가 서버에 등록돼 있기만 하면 서버는 자신에게 전달된 요청 객체의 내용을 검증할 수 있고, 웹 브라우저가 전달되는 내용을 변조하지 않았다고 확신할 수 있다.  

OpenID 커넥트 서버는 클라이언트로 전달되는 데이터를 서명하거나 암호화해 JWT 형태로 만들 수 있다. ID 토큰은 서버에서 서명할 뿐만 아니라 암호화를 할 수도 있다. 이런 보호 기능을 사용하면 클라이언트는 TLS 연결을 통해 얻을 수 있는 보장뿐만 아니라 전달되는 데이터가 변조되지 않았다는 것을 확신할 수 있다.  

OAuth 2.0 엔드 포인트에 대한 확장으로 여러 가지 파라미터가 추가됐다. OpenID 커넥트 클라이언트는 인가 서버에 OAuth 2.0의 경우 보다 세부적인 요청을 전달할 수 있다. 그것은 표현력이 좋은 JSON 페이로드 형식으로 요청 객체를 만들어 전달하기 때문이다. 그렇게 전달하는 요청에는 특정 식별자와 일치하는 사용자만 로그인되도록 요청하는 것처럼 세부적인 사용자 클레임 정보가 포함될 수 있다.  

OpenID 커넥트는 서버(또는 다른 서드파티)가 로그인 프로세스를 시작시킬 수 있는 방법을 제공한다. 기존의 모든 OAuth 2.0 트랜잭션은 클라이언트 애플리케이션에 의해 시작되지만, 이 기능을 사용하면 클라이언트는 특정 IdP에 대한 로그인 프로세스를 시작하라는 신호를 받을 수 있다.  

OpenID 커넥트는 몇 가지 정보(ID 토큰)가 프런트 채널로 전달되고 그 밖의 정보(액세스 토큰)는 백 채널로 전달되는 하이브리드 플로와 같은 몇 가지 다른 토큰 획득 방법을 정의한다. 그런 플로를 기존 OAuth 2.0 플로의 단순한 조합이라고 생각하면 안 되고, 다른 애플리케이션을 위한 새로운 기능이라고 생각해야 한다.  

마지막으로, OpenID 커넥트는 RP와 IdP 사이 또는 여러 RP 간의 세션 관리를 위한 세션을 제공한다. OAuth 2.0에는 인가를 위임하는 시점과 별개로 사용자가 존재한다는 개념이 없기 때문에 연합된 인증의 사이클을 처리하기 위한 확장 기능이 필요하다. 만약, 사용자가 어느 한 RP에서 로그아웃한다면 다른 곳에서도 동일하게 로그아웃되길 원할 것이고, RP는 IdP에게 이를 알릴 수 있어야 한다. 그리고 다른 RP는 로그아웃이 발생했다는 것을 IdP로부터 수신해얗 한다면 그에 따른 적절한 처리를 수행할 수 있어야 한다.  

OpenID 커넥트는 OAuth 2.0과의 호환성에 영향을 미치지 않으면서 이와 같은 확장 기능을 모두 제공한다.  

### 14. OAuth 2.0을 이용하는 프로토콜과 프로파일  
<br/>

#### 14.1. UMA  
<br/>

+ UMA(User Managed Access)  
OAuth 2.0 위에 구축되는 프로토콜로서 리소스 소유자가 제어하는 소프트웨어나 다른 사용자가 제어하게 되는 스프트웨어에 대한 인가 서버를 사용함으로써 리소스 소유자가 자신의 리소스에 대한 풍분한 접근 통제를 할 수 있게 해준다.  

OAuth 2.0을 기반으로 UMA 프로토콜을 사용하면 두 가지 주유 기능을 구현할 수 있다. 그것은 사용자 간의 위임과 하나의 리소스 서버에 대해 여러 개의 인가 서버를 처리하는 것이다.  

다시 말하면, OAuth 2.0은 리소스 소유자가 클라이언트 소프트웨어에 리소스 소유자처럼 행동할 수 있도록 권한을 인가하지만, UMA는 리소스 소유자가 다른 사용자의 클라이언트처럼 행동할 수 있도록 인가하지만, UMA는 리소스 소유자가 다른 사용자의 클라이언트 소프트웨어에 다른 사용자의 권한을 인가해주는 것이다. 쉽게 말하면, OAuth는 앨리스와 앨리스 간의 공유(앨리스가 클라이언트를 실행시키기 때문)를 가능하게 하는 것이고, UMA는 앨리스와 밥 간의 공유를 가능하게 하는 것이다. UMA는 또한 앨리스가 자기자신의 인가 서버를 가져와 리소스 서버에 알려줄 수도 있다. 그러면 밥의 클라이언트는 앨리스의 인가 서버를 발견해 앨리스의 리소스에 대한 접근을 시도할 수 있다.  

UMA는 전통적인 OAuth의 역할 간의 관계를 변경하고 새로운 역할을 정의(Rpq, Request Party)함으로써 이와 같은 트릭을 관리한다. 리소스 소유자는 인가 서버와 리소스 서버 간의 관계를 관리하고 리소스에 대한 서드 파티의 접근 정책을 설정한다. 요청자의 제어하에 있는 클라이언트는 리소스 소요자가 설정한 요구 사항을 충족시키기 위해 자신과 요청자에 대한 정보를 전달함으로써 액세스 토큰을 요청할 수 있다. 리소스 소유자는 클라이언트와 전혀 상호 작용하지 않고, 대신 요청자에게 접근 권한을 인가한다.  

UMA는 OAuth보다 확실히 복잡하지만, 그것은 더 복잡한 문제를 해결하기 위해 그렇게 된 것이다. UMA의 보호 API 절반은 리소스 소유자의 제어 아래 있지만, UMA의 인가 API 절반은 요청자의 제어 아래 있다. 각 구성 요소마다 UMA에서 역할을 수행하는 부분들이 있다.  

##### 14.1.1. UMA가 중요한 이유  
<br/>

UMA가 어떻게 동작하는지에 대해 자세히 알아보기에 앞서 왜 UMA에 관심을 가져야 하는지 알아보자. 사용자 간의 공유 관리와 인가 서버의 사용자 제어를 가능하게 해주는 UMA의 기능은 오늘날 인터넷 보안 환경의 다른 프로토콜과 차별화되는 점이다.  

이로 인해 UMA는 많은 구성 요소가 복잡하게 돌아가 다양한 단계를 갖는 프로토콜이 됐지만, 다른 기술로는 해결할 수 없는 문제를 해결하는 강력한 프로토콜이 됐다.  

설정을 통해 리소스 소유자는 요청자의 리소스 접근을 허용할 수 있다. 심지어는 요청이 발생한 시점에 리소스 소요자가 부재하더라도 접근을 허용하는 것이 가능하다. 클라이언트가 어떤 식으로든 리소스의 정책에서 요구하는 것을 만족시킬 수 있다면, 요청 당사자 대신 토큰을 얻을 수 있다. 이 토큰은 다른 OAuth 액세스 토큰과 마찬가지로 리소스 서버에서 사용할 수 있다. 다른 점이라면, 리소스 서버는 리소스 소유자에게 요청자와 클라이언트에 이르는 전체적인 권한 위임 체인을 볼 수 있으며, 그것을 바탕으로 권한 인가 여부를 결정하는 것이다.  

UMA는 서로를 모두 알고 있는 정적인 환경에서도 잘 동작하지만, 인가된 구성 요소의 지시에 따라 실시간으로 구성 요소가 추가될 수도 있다. 리소스 소유자가 자신의 인가 서버를 가져올 수 있게 허용함으로써 UMA는 진정한 사용자 중심의 정보 환경을 구성한다. 사용자는 어느 서비스가 자신을 대신할 것인지, 사용자나 소프트웨어와 같은 구성 요소 중 어떤 것이 자신의 데이터에 접근할 수 있는지를 결정할 권한을 갖는다.  

또한 UMA 인가 서버에서 보호하는 리소스에 대한 레퍼런스를 리소스 서버가 등록하는 방법을 정의한다. 그러한 것들을 리소스 셋이라 부르며, 보호된 리소스의 묶음으로 표현한다. 그리고 정책에 추가되고 클라이언트가 접근한다. 리소스 셋 등록 프로토콜은 동적 클라이언트 등록 프로토콜과 비슷하다. 흥미롭게도, 동적 클라이언트 등록은 인가 서버에 새로운 클라이언트를 실시간으로 알리는 문제가 바로 발생할 때 그 원인 중 일부를 추적할 수도 있다.  

OAuth는 사용자가 실시간으로 결정하도록 함으로써 수용 가능한 보안 정책의 경계를 밀어 넣지만, UMA는 해당 생태계 내부에서 시작된 보안 경계를 밀어 넣는다. 정책에 의해 허용되는 것은 기술로 가능한 것보다 항상 뒤처지지만, UMA의 기능은 강력한 힘을 발휘하며, 어떤 종류의 보안이 가능한지에 대한 대화를 앞당기기 시작하고 있다.  

##### 14.1.2. UMA 프로토콜의 동작 방식  
<br/>

(1) 리소스 소유자는 인가 서버에 리소스 서버를 알린다. 이 과정이 어떻게 이뤄지는지에 대한 것은 UMA 프로토콜 스펙의 범위를 벗어나지만, 이에 대한 몇 가지 선행 조건이 있다. 매우 긴밀하게 연결된 UMA 생태계에서 리소스 소유자는 인가 서버 목록에서 인가 서버를 선택할 수 있을 것이다. 반면, 인터넷과 같이 보다 광범위하게 분산된 공간에서 리소스 소유자는 자신의 WebFinger ID를 보호된 리소스에 전달해 마치 식별 서버 발견의 경우처럼 그들 개인의 인가 서버를 발견할 수 있게 한다. 어쨌든, 리소스 서버는 발급자 URL로 불리는 인가 서버를 위한 URL을 얻게 된다.  

(2) 리소스 서버는 인가 서버의 설정을 발견하고 OAuth 클라이언트를 등록한다. UMA는 시스템상의 다른 구성 요소가 인가 서버에 대한 중요 정보를 발견할 수 있게 해주는 서비스 발견 프로토콜을 제공한다. OpenID 커넥트처럼 UMA도 시스템상의 다른 구성 요소가 인가 서버에 대한 중요 정보를 발견할 수 있게 해주는 서비스 발견 프로토콜을 제공한다. 발견 정보는 인가 서버의 발견자 URL을 기반으로 만든 URL에 추가해 만든 URL에 호스팅되며, 그 내용은 UMA 인가 서버에 대한 정보를 갖고 있는 JSON 문서로 이뤄진다.  

JSON 문서에는 OAuth 트랜잭션을 위한 인가 엔드 포인트와 토큰 엔드 포인트와 같은 정보뿐만 아니라 (이후에 사용될) 리소스 셋을 어디에 등록해야 하는 지 등과 같이 UMA에 특화된 정보도 함께 포함된다. OAuth와 OpenID 커넥트와 마찬가지로 UMA도 프로토콜 전반에 걸쳐 HTTP 트랜잭션을 보호하기 위한 TLS를 요구한다.  

그 다음 리소스 서버는 동적 클라이언트 등록을 이용해 자기자신을 OAuth 클라이언트로 등록하거나 일종의 정적인 방법으로 등록을 수행한다. 궁극적으로 이는 다른 OAuth 클라이언트의 경우와 매우 유사하며, UMA에 특화된 유일한 측면이라고 한다면 리소스 서버가 uma&#95;protection이라는 특별한 권한 범위를 가진 토큰을 얻을 수 있어야 한다는 것이다. 그 토큰을 다음 단계에서 인가 서버의 특별한 기능에 접근하는 데 사용된다.  

(3) 리소스 소유자는 리소스 서버를 인가한다. 리소스 서버는 이제 OAuth 클라이언트로 동작하기 때문에 다른 OAuth 클라이언트의 경우처럼 리소스 소유자로부터 인가돼야 한다. OAuth와 마찬가지로 리소스 서버가 적절한 권한을 가진 액세스 토큰을 얻는 방법은 여러 가지지만, 리소스 소유자를 대신해 직접 수행되는 작업이기 때문에 인가 코드 플로처럼 상호 작용을 통해 액세스 토큰을 얻는 것이 일반적이다.  

이 과정에서 리소스 서버가 얻는 액세스 토큰을 Protection API Token 또는 PAT라고 한다. PAT는 최소한 uma&#95;protection 권한 범위를 가져야 하지만, 관련된 다른 권한 범위를 함께 가질 수도 있다. 리소스 서버는 PAT를 이용해 보호된 리소스를 관리하고 승인 티켓을 요청하며, 토큰을 조회한다. 이와 같은 작업을 보호(Protection) API라고 하며, 인가 서버는 이를 제공한다.  

이 시점에서 보호된 리소스가 이제는 OAuth 클라이언트로 동작하고 인가 서버는 자신의 보호 API를 통해 보호된 리소스로 동작한다는 사실을 깨닫는 것이 중요하며, 동시에 혼란을 준다. OAuth 생태계의 각 구성 요소는 다른 시간에는 다른 소프트웨어로 조각으로 그에 맞는 역할을 수행할 수 있기 때문에 그렇게 불합리하다고 볼 수는 없다.  

(4) 리소스 서버는 자신의 리소스 셋을 인가 서버에 등록한다. 인가 서버는 이제 리소스 서버가 리소스 소유자 대신 보호하고 있는 리소스에 대해 알아야 한다. 리소스 서버는 동적 클라이언트 등록 프로토콜과 유사한 프로토콜로 리소스 셋을 등록한다. 리소스 서버는 보호하고자 하는 각 리소스 셋에 대한 자세한 정보를 PAT를 사용해 리소스 셋 등록 URI로 HTTP POST 메시지를 전달한다.  

전달하는 메시지에는 출력 이름과 아이콘, 리소스 셋과 관련된 가장 중요한 OAuth 권한 범위 정보가 포함된다. 인가 서버는 리소스 셋에 고유한 식별자를 할당해 리소스 소유자가 리소스 셋과 관련된 정책을 관리할 수 있는 URL과 함께 리소스 서버에 전달한다.  

Location 헤더로는 RESTful API 패턴을 사용해 리소스 셋 등록 자체를 관리하기 위한 URL을 전달한다. 리소스 서버는 HTTP POST와 GET, POST, DELETE를 사용해 각각의 리소스 셋을 읽고, 업데이트하고, 제거할 수 있다.  

(5) 리소스 소유자는 리소스 셋과 관련된 정책을 인가 서버에 설정한다. 리소스 셋이 등록됐지만, 그것에 접근하는 방법에 대해서는 아무도 말하지 않았다. 클라이언트가 리소스 셋에 대한 접근을 요청하기 전에 리소스 소유자는 누가 리소스에 접근할 수 있는지 그리고 어떤 상황에서 접근할 수 있는지를 가리키는 리소스에 대한 정책을 설정해야 한다. 정책을 작성하고 설정하는 방법은 거의 끝이 없기 때문에 그런 정책 설정에 대한 것은 UMA의 범위를 완전히 벗어난다. 일반적으로는 리소스에 접근할 수 있는 기간이나 사용자의 식별자 또는 접근할 수 있는 횟수가 설정에 포함된다.  

정책 함목 각각은 각 리소스 셋 권한 범위의 하위 집합에도 연결될 수 있어서 리소스 소유자가 자신의 공유 의도를 잘 표현할 수 있게 해준다.  

결국 요청자와 그들의 클라이언트는 설정된 정책의 요구 사항을 충족시키는 클레임 셋을 제시할 수 있게 된다. 중요한 점은, 정책이 설정되지 않은 리소스 셋은 적절한 정책이 설정될 때까지는 접근할 수 없는  것으로 간주돼야 한다. 그렇게 함으로써 순진한 인가 서버가 해당 리소스에 대한 요청을 실수로 허용하는 것을 방지할 수 있다. 그렇다면 결국 어떤 클레임도 요구하지 않는 리소스가 있다면 정책적인 요구 사항이 없기 때문에 제약 없이 토큰을 얻을 수 있는 것이 아닐까?  

일단 정책이 설정되고 나면 리소스 소유자는 작업을 종료하게 되고, 요청자는 그때부터 UMA 프로세스를 타게 된다. 인가 서버에는 리소스 소유자가 자신의 리소스에 요청자가 접근하려고 할 때 해당 자원에 대한 접근을 허용해줄 수 있는 고급 런타임 정책 엔진이 있을 수 있다. 하지만 여기서는 그것의 동작 방식에 대해서는 다루지 않을 것이다.  

(6) 요청자는 클라이언트에게 리소스 서버에 접근하라고 지시한다. 이 단계는 리소스 소유자가 클라이언트에게 자기 대신 뭔가에 접근하도록 지시한다는 측면에서 일반적인 OAuth 트랜잭션의 시작과 유사하다고 할 수 있다. OAuth의 경우처럼, 클라이언트가 보호된 리소스의 URL을 알아내거나 보호된 API에 접근하기 위해 무엇이 필요한지를 알아내는 방법은 UMA 스펙의 범위를 벗어난다. 하지만 OAuth와 달리, 요청자는 클라이언트 애플리케이션에게 다른 누군가가 제어하는 리소스에 접근하도록 지시하며, 클라이언트는 그것과 관련된 인가 서버가 어디에 있는지 모를 수도 있다.  

(7) 클라이언트가 보호된 리소스를 요청한다. 클라이언트는 접근하려는 자원에 대한 충분한 권한 없이 접근 요청을 시작한다. 일반적으로 이와 같은 요청은 액세스 토큰 없이 이뤄질 것이다.  

서로 다른 권한 패턴에 대해 OAuth를 사용하면 액세스 토큰으로 리소스 소유자를 위한 식별자 도는 그것과 관련된 권한 범위 같은 추가 컨텍스트를 제공할 수 있기 때문에 다양한 형태의 API를 보호할 수 있다. 이를 통해 보호된 리소스는 액세스 토큰에 연관된 데이터에 따라 서로 다른 정보를 제공한다. 즉, 동일한 하나의 URL에서 서로 다른 사용의 정보를 제공하거나 토큰과 연관된 권한 범위와 해당 토큰을 인가한 사용자에 따라 서로 다른 정보를 제공할 수 있다. OpenID 커넥트에서는 OAuth의 이와 같은 특징 덕분에 클라이언트에게 사용자의 식별자를 미리 노출하지 않고도 엔드포인트를 서버상의 모든 식별자를 제공하는 단일 URL로 사용할 수 있다. UMA에서 리소스 서버는 클라이언트가 어느 리소스 셋에 접근하려고 하는지 초기 HTTP 요청에서 파악할 수 있어야 하며, 따라서 어떤 리소스 소유자와 인가 서버에 대한 요청인지 확인해야 한다. 어떤 리소스 소유자와 인가 서버에 대한 요청인지 확인해야 한다. 어떤 결정을 내리는 데 도움이 되는 액세스 토큰이 없기 때문에 오직 URL과 헤더 그리고 HTTP 요청의 나머지 부분만 확인할 수밖에 없다. 이와 같은 제약 사항으로 인해 URL과 기타 HTTP 정보를 기반으로 리소스를 구분하는 데 사용되는 API의 유형을 효과적으로 제한한다.  

(8) 리소스 서버는 요청된 접근을 나타내기 위해 인가 서버에 권한 티켓을 요청하고 그것을 클라이언트에게 전달한다. 리소스 서버는 어느 리소스 셋에 접근하려고 하는 것인지를 일단 알게 되면, 해당 리소스 셋과 연관된 인가 서버가 무엇인지를 알게 된다. 그러면 리소스 서버는 접근 요청을 표현하기 위한 권한 티켓 요청 HTTP POST 메시지를 인가 서버의 권한 티켓 등록 엔드 포인트에 전달한다. 이 요청에는 리소스 셋 식별자와 해당 리소스 셋에 접근하기 위해 리소스 서버가 필요하다고 생각하는 권한 범위 셋이 포함되며, PAT에 의해 권한이 부여된다. 전달되는 요청에 포함되는 권한 범위는 해당 리소스 셋의 서브 셋이 될 수도 있기 때문에 리소스 서버는 잠재적으로 클라이언트의 접근을 자신이 원하는 대로 제한할 수 있다. 클라이언트는 명시적으로 요청한 것보다 더 많은 작업을 수행할 수도 있는데, 리소스 서버는 그것을 미리 추측할 수 있는 방법이 없기 때문이다.  

인가 서버는 PAT가 처음 리소스 셋을 등록한 리소스 서버와 동일한 리소스 서버를 나타내는지, 요청된 권한 범위가 해당 리소스 셋에서 모두 사용 가능한 것인지 확인한다. 확인 작업을 수행한 후, 이낙 서버는 권한 티켓을 단순한 JSON 문자열 형태로 생성해 리소스 서버에 발급한다.  

리소스 서버는 클라이언트가 UMA 프로세스를 통해 인가 서버와 상호 작용하도록 처리하기 때문에 권한 티켓에 대한 참조를 유지하거나 관리할 필요가 없다. 인가 서버는 필요 시 자동으로 해당 티켓을 만료시키거나 폐지시킨다.  

(9) 리소스 서버는 클라이언트에게 티켓과 인가 서버 정보를 전달한다. 일단 티켓을 얻으면 리소스 서버는 최종적으로 클라이언트의 요청에 응답을 할 수 있게 된다. 즉, WWW-Authentication: UMA 헤더를 이용해 클라이언트에게 티켓과 해당 리소스를 보호하는 인가 서버의 발급자 URL을 전달한다.  

클라이언트에게 전달되는 응답에서 UMA 프로토콜 스펙에 따라 결정되는 부분은 단지 헤더 부분뿐이며, 나머지 부분인 상태 코드, 응답 내용, 다른 헤더의 내용 등은 보호된 리소스가 결정한다. 이런 식으로 리소스 서버는 클라이언트에게 어떻게 하면 더 높은 수준의 접근 권한을 얻을 수 있는지에 대한 정보뿐만 아니라 다양한 공개 정보를 제공한다. 또는 클라이언트가 접근 요청과 함께 전달한 액세스 토큰이 요청한 작업에 필요한 모든 권한 셋을 갖고 있지 않다면 리소스 서버는 클라이언트에게 필요한 접근 권한 수준을 높이라고 알려줌과 동시에 클라이언트가 갖고 있는 접근 권한 수준에 적합한 콘텐츠만 제공해줄 수 있다.  

(10) 클라이언트는 인가 서버의 설정을 발견하고 그것을 등록한다. 리소스 서버의 경우처럼 클라이언트도 인가 서버가 어디에 있는지, 다음 단계에서 인가 서버와 어떻게 상호 작용해야 하는지를 알아내야 한다. 그리고 해당 작업이 병렬적으로 이뤄지기 때문에 여기서 자세히 설명하지는 않을 것이다. 그 과정이 끝나면 클라이언트는 보호된 리소스가 사용하는 것과는 자체적인 다른 자격 증명 셋을 갖게 되며, 그것을 이용해 인가 서버와 상호 작용한다.  

토큰을 얻기 위해 토큰이 필요한가?  
UMA 1.0 번에서 클라이언트는 인가 액세스 토큰(AAT)이라는 OAuth 액세스 토큰이 추가로 필요하다. 이 토큰의 목적은 요청자를 클라이언트와 인가 서버에 바인딩시키기 위한 것이며, PAT도 거의 동일한 방법으로 동작한다. 하지만 RqP는 이후에 상호 작용하는 방식으로 클레임을 전달해야 할 수도 있기 때문에 바인딩이 반드시 필요한 것은 아니다. 또한 AAT를 인가하기 위해 RqP는 인가 서버에 로그인해 클라이언트에게 uma&#95;authorization이라는 특별한 권한 범위를 가진 토큰을 인가할 수 있어야 한다. 하지만 RqP는 인가 서버와의 관계를 맺는 것을 보장받을 수 없고, 리소스 소유자만 보장을 받을 수 있기 때문에 RqP가 정상적인 OAuth 트랜잭션을 수행할 수 있다고 기대하기는 어렵다. 이와 같은 이유 때문에 UMA 프로토콜의 향후 버전에서는 AAT가 없을 것으로 보인다. 즉, RqP의 동의를 표현하고 수행하기 위해 다른 메커니즘을 이용할 것으로 보인다.  

(11) 클라이언트는 액세스 토큰을 얻기 위해 티켓을 인가 서버에 전달한다. 이 과정은 클라이언트가 인가 코드 그랜트 타입에서 인가 코드를 인가 서버에 전달하는 것과 유사하다. 하지만 리소스 서버로부터 받은 티켓을 임시 자격 증명으로 사용한다. 클라이언트는 티켓을 HTTP POST의 파라미터로 인가 서버에 전달한다.  

인가 서버는 전달된 티켓을 검사해 그것이 어느 리소스 셋과 연관된 것인지 알아낸다. 리소스 셋을 알아낸 다음에 인가 서버는 해당 리소스 셋과 관련된 정책이 무엇인지 판단해 클라이언트가 액세스 토큰을 얻기 위해 어떤 클레임을 전달해야 하는지 알아낸다. 인가 서버는 정책 이행과 관련된 클레임이 부족하다고 판단하면 클라이언트에게 에러 응답을 전달한다. 에러 응답에는 인가 서버가 요청자와 클라이언트의 접근을 허용하기 위해 필요한 클레임이 무엇인지에 대한 정보가 포함된다.  

(12) 클라이언트는 필요한 클레임을 인가 서버에 전달한다. 이 단계에서 클라이언트는 인가 서버가 요구하는 것을 얻기 위해 몇 가지 다른 작업을 수행할 수도 있다. 필요한 클레임을 수집하는 프로세스의 세부 사항은 다양한 상황과 환경을 고려할 수 있도록 하기 위해 UMA 프로토콜이 의도적으로 모호하게 남겨두었다.  

클라이언트가 필요한 클레임을 이미 갖고 있고, 그것이 인가 서버가 검증할 수 있는 형태라면, 토큰을 위한 다른 요청에 그것을 직접 전달할 수 있다.  

이 방법은 클라이언트가 자신에 대한 클레임이나 클라이언트 소프트웨어를 배포한 조직에 대한 클레임을 전달할 때 잘 동작한다. 권한을 가진 구성 요소가 그와 같은 클레임을 서명하면 인가 서버는 그것을 직접 검증하고 확인할 수 있다. 만약, 클라이언트가 요청자에 대한 정보를 전달하는 방식을 사용한다면 그것을 별로 도움이 되지 않을 것이다. 왜냐하면 요청자와 클라이언트 사이의 관계가 정의되지 않기 때문이다. 그것은 심지어 클라이언트와 인가 서버 사이에 강력한 신뢰 관계가 있다고 하더라도 마찬가지다.  

클라이언트가 요청자에게 식별자와 같은 클레임을 전달하도록 요청해야 한다면, 클라이언트는 요청자를 인가 서버의 클레임 수집 엔드 포인트로 리다이렉트시킨다. 이제 클라이언트 ID와 티켓 값 그리고 클레임 수집이 완료된 이후에 리다이렉트를 위한 URL을 포함해 전달한다.  

엔드 포인트에서 요청자는 인가 서버와 직접 상호 작용해 요구된 클레임을 제공한다. 이 과정 또한 UMA 스펙에서 구체적으로 정의하고 있지 않다. 하지만 여기서는 요청자가 자신의 OpenID 커넥트 계정을 이용해 인가 서버에 로그인할 것이다. UMA 인가 서버는 이제 OpenID 커넥트의 RP로서 행동해 정책 요청을 이행하는 데 사용할 수 있는 요청자의 식별 정보에 인가 서버가 접근할 수 있게 한다.  

인가 서버가 클레임 수집 과정을 만족하면 이후의 프로세스를 계속 진행하라는 것을 나타내기 위해 요청자를 다시 클라이언트로 리다이렉트시킨다.  

이 과정은 일반적인 OAuth의 인가 엔드 포인트의 경우처럼 클라이언트와 인가 서버 간의 프런트 채널을 이용한다. 하지만 여기서 사용되는 리다이렉트 URI은 인가 코드 그랜트 타입이나 암시적 그랜트 타입에서 사용되는 것과는 다르다.  

클레임을 전달하기 위해 어떤 방법이 사용되든 인가 서버는 전달된 클레임을 티켓과 연관시킨다. 클라이언트는 토큰을 얻기 위해 여전히 전달해야 한다.  

(13) 클라이언트는 토큰을 얻기 위해 티켓을 다시 전달한다. 이번에는 리소스 셋에 대한 정책을 만족시키는 클레임 셋과 연관된 티켓이기 때문에 제대로 동작할 것이다. 또한 정책은 권한 범위 셋과 매핑되기 때문에 인가 서버는 토큰의 최종적인 접근 권한을 판단할 수 있다. 인가 서버는 마치 OAuth의 토큰 엔드 포인트처럼 클라이언트에게 JSON 형태의 토큰을 발급한다.  

결국 클라이언트는 액세스 토큰을 갖게 되고, 그것을 이용해 리소스를 다시 요청할 수 있다. OAuth의 경우처럼 클라이언트는 토큰 자체 의 내용과 포맷은 알지 못한다.  

(14) 클라이언트는 리소스 서버에 액세스 토큰을 전달한다. 클라이언트는 다시 한 번 보호된 리소스를 요청한다. 하지만 이번에는 인가 서버에서 전달받은 토큰을 이용한다.  

클라이언트의 요청은 OAuth의 표준 Bearer 토큰 요청과 동일하며, UMA에서는 요청 방법을 따로 정의하고 있지는 않다. 지금까지는 클라이언트가 몇 가지 특별한 작업을 수행해야 했지만, 이제는 다른 OAuth 클라이언트처럼 동작하면 된다.  

(15) 보호된 리소스는 토큰이 적합한 것인지 판단한다. 이제 보호된 리소스는 클라이언트로부터 토큰을 전달받았으므로 리소스 서버는 해당 토큰이 클라이언트가 하고자 하는 작업에 적합한 것인지 알아내야 한다. 하지만 UMA 프로토콜 설계에서 리소스 서버는 인가 서버와 분리되기 때문에 토큰 정보를 로컬에서 검사하는 것에 의지할 수는 없다.  

UMA는 네트워크 기반의 프로토콜이고, 인가 서버는 네트워크 질의에 응답하기 위한 온라인 상태일 것이기 때문에 이 단계에서는 토큰 인트로스펙션을 사용하는 것이 보다 일반적이다. 리소스 서버로부터의 요청은 클라이언트 자격 증명 대신 PAT를 사용해 요청을 인가한다는 점만이 다르다. 하지만 UMA는 인트로스펙션 응답 데이터 구조체를 토큰을 발행하기 위해 필요한 권한에 대한 자세한 정보를 담고 있는 권한 객체로 확장하기 때문에 서버로부터 응답 데이터는 약간 다르다.  

인가 서버의 정책 엔진 설정에 따라 토큰 자체가 여러 리소스 셋과 권한 셋에 적합할 수도 있다. 리소스 서버는 토큰이 현재의 요청을 수행하기 위해 필요한 권한을 제대로 갖고 있는지 여부를 판단해야 한다. OAuth와 마찬가지로 토큰이 충분한 권한을 갖고 있는지 여루블 판단하는 것은 전적으로 리소스 서버에 달려 있다. 만약, 토큰이 올바른 권한을 갖고 있지 않다면 리소스 서버는 권한 티켓을 등록하고 그것을 다시 클라이언트에게 전달하는 과정을 다시 시작한다. 따라서 클라이언트는 새로운 토큰을 가져오는 작업을 수행한다.  

(16) 최종적으로, 클라이언트가 요청한 리소스가 클라이언테에게 전달된다. OAuth의 경우처럼, 일단 전달된 토큰이 적합하다고 판단되면 API에 대한 응답으로 리소스가 전달된다.  

요청한 것이 HTTP 응답으로 전달될 수 있으며, 클라이언트가 추가 접근을 원할 때 그것을 할 수 있다는 것을 나타내기 위해 또 다른 WWW-Authentication: UMA 헤더가 응답에 포함될 수도 있다.  

지금까지의 전체 과정에서 리소스 소유의 자격 증명과 요청자의 자격 증명은 리소스 서버나 클라이언트에 전혀 노출되지 않았다. 또한 민감한 개인적인 정보 또한 전혀 노출되지 않았다. 요청자는 리소스 소유자가 설정한 정책을 수행하는 데 필요한 최소한의 것만 증명하면 된다.  

### 15. 그 외 토큰들  
<br/>

Bearer 토큰을 많이 사용하는 이유는 단순함뿐만 아니라 표준 스펙에서 정의하는 유일한 토큰 유형이기 때문이다.  

#### 15.1. 왜 Bearer 이외의 토큰이 필요할까?  
<br/>

많은 경우, 토큰이 아닌, 즉 네트워크로 토큰을 전달하지 않고 클라이언트가 어떤 비밀 정보를 소유하고 있다고 증명하는 방식을 필요로 한다. 그렇게 하면 공격자가 네트워크를 캡처할 수 있다고 토큰을 재사용하는 공격을 수행할 수 없게 된다.  

#### 15.2. PoP 토큰  
<br/>

IETF(Internet Engineering Task Force)의 OAuth 워킹 그룹은 PoP(Proof of Possession)라는 새로운 형태의 토큰을 정의하기 위한 작업을 해왔다. 토큰 자체가 비밀 정보를 의미하는 Bearer 토큰과 달리, PoP 토큰은 토큰과 키라는 두 가지로 구성된다. PoP 토큰을 갖고 있는 클라이언트는 토큰 자체뿐만 아니라 키를 소유하고 있다는 것을 증명할 수 있어야 한다. 토큰은 요청과 함께 네트워크로 전송되지만, 키는 그렇지 않다.  

토큰 부분은 여러 가지 면에서 Bearer 토큰과 유사하다. 클라이언트는 토큰이 보호된 리소스에 대한 접근 권한을 위임한다는 것 외에 토큰 자체나 그 안에 무엇이 포함돼 있는지 알지 못하거나 상관하지 않는다. 클라이언트는 다른 경우와 마찬가지로 토큰 부분을 그대로 전달한다.  

토큰의 키 부분은 HTTP 요청으로 전달되는 암호화 시그니처를 만드는 데 사용된다. 클라이언트는 보호된 리소스에 전달하기 전에 HTTP요청의 일부분을 서명해 전달하는데, 그 때 사용되는 것이 토큰의 키 부분이다. 키를 인코딩하기 위해 OAuth의 PoP 시스템은 JOSE(JSON Object Signing and Encrption) 스펙의 일부분이 JWK(JSON Web Key) 인코딩을 이용한다. JWK는 대칭키 및 비대칭키 유형뿐만 아니라 시간 경과에 따른 암호화 기민성을 제공한다. PoP 처리 과정에는 Bearer 토큰의 경우처럼 몇 가지 선택 사항이 있다. 첫 번째는 토큰을 얻어야 한다는 것이다. 그 다음에는 그 토큰을 이용한다.  

##### 15.2.1. PoP 토큰 요청과 발급  
<br/>

PoP 토큰을 발급하기 위해 인가 서버는 토큰과 연결시킬 키를 알아야 한다. 클라이언트의 유형과 전체적인 배포 환경에 따라 클라이언트가 키를 제공할 수도 있고, 서버가 생성할 수도 있다.  

<table>
	<thead>
		<tr>
			<th rowspan="2">키 유형</th>
			<th colspan="2">제공 주체</th>
		</tr>
		<tr>
			<th>클라이언트</th>
			<th>서버</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>대칭키</td>
			<td>클라이언트가 보안적으로 약한 키를 선택할 수 있기 때문에 이는 좋은 방법은 아니지만, 클라이언트가 진짜로 안전한 공유 키를 생성할 수 있는 메커니즘이나 신뢰 플랫폼 모듈을 사용한다면 가능하다.</td>
			<td>제약이 있는 클라이언트나 안전한 키를 만들 수 없는 클라이언트를 위해 좋은 방법이다.</td>
		</tr>
		<tr>
			<td>비대칭키</td>
			<td>안전한 키를 만들 수 있고, 클라이언트의 비밀키를 노출하지 않는 클라이언트라면 좋은 방법이다. 클라이언트는 자신의 공개키만 등록하고 서버는 자신의 공개키만 전달한다.</td>
			<td>안전한 키를 만들 수 없는 클라이언트라면 좋은 방법이다. 서버가 키 쌍을 생성해 반환한다.</td>
		</tr>
	</tbody>
</table>
<br/><br/>

#### 15.4. TLS 토큰 바인딩  
<br/>

토큰 바인딩은 HTTP와 같은 애플리케이션 계층의 프로토콜과 OAuth와 같은 HTTP 상위에서 실행되는 프로토콜 내부에서 TLS의 정보를 사용할 수 있게 해주는 방법이다. 이 정보는 동일한 구성 요소들이 필요에 따라 이야기하는 것을 확인하기 위해 여러 계층에 걸쳐 비교될 수 있다.  

HTTPS에 대한 토큰 바인딩은 비교적 간단하다. HTTP 클라이언트가 HTTP 서버와의 TLS 연결을 만들 때 클라이언트는 HTTP 헤더에 공개키(토큰-바인딩 식별자)를 포함시키고 자신이 그것과 연관된 비밀키를 갖고 있다는 것을 증명한다. 서버가 토큰을 발급할 때 해당 토큰은 토큰-바인딩 식별자에 바인딩된다. 그리고 이후에 클라이언트가 서버에 연결할 때 클라이언트는 그 식별자를 비밀키로 서명해 TLS 헤더로 전달한다. 그려면 서버는 시그니처를 검증할 수 있고, 바운드 토큰을 전달한 클라이언트가 원래의 임시 키 쌍을 제공한 클라이언트가 맞는지 확인한다. 원래 토큰 바인딩은 모든 상호 작용이 하나의 채널에서 발생하기 때문에 사용벙이 매우 단순한 웹 브라우저 쿠키와 같은 것에 사용하려고 고안됐던 것이다.  

토큰 바인딩을 위해서는 TLS 계층에 대한 접근이 필요하며, TLS 터미네이터(아파치 HTTPD 리버스 프락시와 같은)가 사용할 때는 사용하기가 어려운 경향이 있다. 또한 TLS 트랜잭션에서 사용되는 인증서의 식별자가 두 통신 주체에서 검증되고 확인되는 TLS의 상호 인증과는 다르다. 하지만 토큰 바인딩을 통해 애플리케이션은 TLS 시스템에서 이미 사용 가능한 정보를 직접 이용해 보안을 강화할 수 있다. 토큰 바인딩 기능은 TLS 미들웨어 라이브러리에 내장돼 있기 때문에 모든 애플리케이션에서 투명하게 사용할 수 있을 것이다.  

OAuth 시스템에서 이는 리소스 소유자의 웹 브라우저와 클라이언트 또는 인가 서버 간의 연결을 관리하는 데 매우 효과적이다. 또한 클라이언트와 인가 서버 사이에 전달되는 리프레시 토큰의 경우에도 잘 동작한다. 하지만 액세스 토큰의 경우에는 문제가 될 수 있다. 토큰을 발급하는 HTTP 서버(인가 서버)와 토큰을 수신하는 HTTP 서버(보호된 리소스)가 동일한 서버가 아닌 다른 서버일 수 있기 때문에 클라이언트는 각기 다른 TLS 연결을 수행해야 한다. 웹 클라이언트와 토큰 인트로스펙션을 이용한다고 가정했을 때 모든 구성 요소 간의 가능한 연결 수를 계산해보면 5개 이상의 각기 다른 TLS 채널이 필요하다.  

+ 리소스 소유자의 웹 브라우저와 인가 서버의 인가 엔드 포인트 간의 연결
+ 리소스 소유자의 웹 브라우저와 클라이언트 간의 연결
+ 클라이언트와 인가 서버의 토큰 엔드 포인트 간의 연결
+ 클라이언트와 보호된 리소스 간의 연결
+ 보호된 리소스와 인가 서버의 인트로스펙션 엔드 포인트 간의 연결  

간단한 토큰-바인딩 설정하에서 각 채널에서는 서로 다른 토큰-바인딩 식별자를 수신하게 될 것이다. 토큰-바인딩 프로토콜은 클라이언트가 하나의 연결 식별자를 다른 연결을 위해 전달하도록 해 2개의 개별적인 연결을 의식적으로 묶도록 처리한다.  

본질적으로, 클라이언트가 OAuth 토큰을 얻기 위해 인가 서버에 요청할 때 보호된 자원에 연결하기 위한 토큰-바인딩 식별자가 포함된다. 인가 서버는 발급되는 토큰을 클라이언트와 인가 서버 사이의 연결을 위해 사용된 식별자 대신 요청 시 전달된 식별자에 바인딩된다. 나중에 클라이언트가 토큰으로 보호된 리소스를 호출할 때 보호된 리소스는 TLS 연결에 사용된 식별자가 토큰과 연관된 것인지 검증한다.  

이 방식은 클라이언트가 인가 서버와 보호된 리소스 간의 매핑을 적극적으로 관리하는 것을 요구하는데, 많은 OAuth 클라이언트는 잘못된 보호된 리소스로 토큰이 전달되는 것을 피하기 위해 이 요구 사항을 수행한다. 토큰 바인딩은 Bearer 토큰과 PoP 토큰 모두에서 사용될 수 있으며, 토큰과 연관된 토큰 키와 토큰 자체의 소유 등을 확인하는 계층이 추가된다.