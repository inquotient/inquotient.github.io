---
title: 웹 어플리케이션 구조
categories:
- Spring
feature_text: |
  ## 웹 어플리케이션 구조
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---
<style>
	thead td { text-align: center; }
	td { border: 1px solid #444444; }
</style>

웹 어플플리케이션을 개발할 때 사용하는 설계 구조에 대한 주제는 책 한 권으로는 다 쓸 수 없는 내용이지만, DBMS와 연동되는 웹 어플리케이션을 개발할 때 전형적으로 사용하는 구조가 존재한다.  

### 1. 서비스-DAO 구조
<br/>
웹 어플리케이션을 개발할 때 가장 많이 사용되는 구조는 컨트롤러-서비스-DAO로 이어지는 구성이다. 이 구조는 이해가 쉽기 때문에 도메인의 복잡도에 상관없이 널리 사용되고 있다. 서비스-DAO로 구성되는 웹 어플리케이션의 각 구성 요소 간의 관계를 표현한 것으로, 각 구성 요소는 다음의 역할을 수행한다.  

+ 모델  
데이터베이스 테이블과 관련된 클래스가 위치한다. CRUD의 기본 단위로 사용되며, 서비스-DAO 간 데이터를 주고 받기 위한 객체로도 사용된다.
+ DAO  
Data Access Object의 약자로, 데이터베이스 테이블에 대한 CRUD 기능을 정의한다. 데이터 입력이나 수정, 조회 시 데이터 타입으로 모델을 사용한다.
+ 서비스  
컨트롤러를 통해서 전달받은 사용자의 요청을 구한다. DB 연산이 필요한 경우 DAO를 이용한다.
+ 컨트롤러  
사용자의 웹 요청을 받아 서비스나 DAO에 전달하고, 결과를 뷰에 전달한다.  

스프링 기반 어플리케이션에서 컨트롤러, 서비스, DAO는 각각 스프링 빈으로 등록되며, DI를 이용해서 의존 대상을 조립한다.  

#### 1.1. DAO 인터페이스의 정의
<br/>
DAO는 Data Access Object의 약자로 데이터 접근에 필요한 메서드를 정의한다. 보통 SQL의 CRUD에 해당하는 insert, select, update, delete 메서드를 정의한다. insert()와 delete()는 단순한 인터페이스를 갖는다.  

select는 필요한 기능에 따라 다양한 메서드가 존재할 수 있다. 예를 들어, PK를 이용한 검색과 조건을 이용한 검색이 필요할 경우 다음과 같은 메서드를 사용할 수 있다.  

검색조건타입을 어떻게 정의하느냐는 검색 조건과 사용하는 기술에 따라 달라질 것이다.  

DAO 클래스는 검색조건이 가진 값에 따라 알맞은 쿼리를 실행하도록 구현한다.  

조건에 따라 쿼리를 생성하기 위해 별도의 클래스 타입을 만들어 사용하는 것을 고려할 수 있다. MyBatis를 사용한다면, 동적SQL(&#60;if&#62;, &#60;choose&#62;, &#60;when&#62; 등)을 사용해서 검색조건에 따라 where 절을 다르게 구성할 수도 있을 것이다. 스프링 데이터 JPA를 사용한다면 별도의 클래스 타입을 따로 구현하지 않고 스프링 데이터 JPA가 제공하는 Specification 타입을 사용할 수도 있을 것이다.  

##### 1.1.1. DAO 인터페이스의 크기
<br/>
DAO 인터페이스는 조회 기준이 되는 테이블마다 1개를 작성하는 것이 일반적이다.  

만약 여러 테이블을 조인해서 조회하는 메서드는 어떤 DAO 인터페이스에 위치시켜야 할까? 정답이 따로 있진 않지만, 다음의 세 가지 정도 접근법이 있을 것이다.  

+ 두 DAO에서 읽어와 프로그램에서 객체를 조립한다.
+ 주 테이블에 해당하는 DAO에 메서드를 추가한다.
+ 조인 결과를 위한 별도 DAO 인터페이스를 작성한다.  

세 번째 방법의 경우 특정 테이블을 기분으로 실행되는 조인이 아니라 통계처럼 여러 테이블을 조인해서 종합적인 결과를 추출하는 쿼리를 만들어야 할 때 사용한다.  

세 가지 방법 중 무엇이 좋다라고 단정지을 순 없다.  

#### 1.2. 서비스의 구현
<br/>
서비스는 사용자 기능을 정의한다.  

서비스 구현 클래스는 보통 DAO를 이용해서 기능을 완성한다.  

일반적으로 서비스의 메서드는 트랜잭션 단위가 되므로, &#64;Transactional 애노테이션이나 스키마 기반의 트랜잭션 설정을 이용해서 메서드가 트랜잭션 범위 내에서 실행되도록 한다.  

##### 1.2.1. 서비스의 크기
<br/>
서비스 인터페이스를 정의할 때 고민해 볼 문제는 인터페이스가 제공할 메서드에 대한 것이다.  

서비스 구현 클래스가 구현하는 메서드의 개수가 많아지면, 필요한 의존 객체를 참조하기 위한 필드 개수도 증가하게 된다. 또한, 서로 관련 없는 기능이 한 클래스에 구현되므로 코드를 복잡하게 만들 가능성이 높고 코드 길이도 증가하게 된다. 이는 전반적으로 코드를 관리하기 어렵게 만드는 경향이 있기 때문에 , 한 인터페이스에 메서드를 몰아 넣기 보다는 구분되는 기능별로 인터페이스를 분리하는 방법이 좋다.  

객체 지향의 주요 원칙 중에 SOLID라 불리는 다섯 가지 원칙이 있다. 이 중 인터페이스의 크기에 대한 원칙으로 SRP(Single Resposibility Principle)와 ISP(Interface Segregation Principle)를 들 수 있는데, 이 두 원칙에 따르면 여러 메서드를 하나의 서비스 인터페이스에 두는 것 보다 각각의 구분되는 기능을 위한 인터페이스를 따로 작성하도록 제안하고 있다.  

##### 1.2.2. 서비스의 메서드 파라미터 타입
<br/>
서비스 메서드의 파라미터가 모델 타입과 일치하지 않으면, 모델 타입을 사용하는 대신 서비스 메서드를 위한 별도 요청 타입을 작성하는 것이 좋다.  

##### 1.2.3. 조회 기능과 서비스
<br/>
조회 기능을 위한 서비스의 구현 코드는 DAO의 메서드를 호출하고 끝나는 경우가 많다.  

DAO에 단순 위임만 하고 끝나는 서비스를 작성하는 것은 사실상 필요 없는 인터페이스를 만드는 것이다.  

서비스에서 DAO의 조회 메서드를 호출하는 것 외에 추가적인 로직을 구현하지 않는다면, 서비스를 따로 정의할 필요 없이 데이터가 필요한 곳에서 DAO에 직접 접근할 수도 있을 것이다. 예를 들어, 컨트롤러에서 서비스를 거치지 않고 조회한 결과를 뷰에 전달하도록 구현할 수 있을 것이다.  

### 2. 어플리케이션-도메인-영속성 구조
<br/>
어플리케이션-도메인-영속성 구조는 DDD(Domain-Driven-Design)를 비롯해 도메인 모델을 중심으로 설계할 때 사용하는 구조이다. 꼭 DDD를 따르지 않더라도 어플리케이션-도메인-영속성 구조를 사용하면 복잡한 업무를 다루는 웹 어클리케이션을 개발할 때 객체 지향의 장점을 잘 살릴 수 있게 된다. 어플리케이션-도메인-영속성으로 구성된 어플리케이션의 전형적인 구조에서 각 요소는 다음과 같은 역할을 한다.  

<table>
	<thead>
		<tr>
			<td>영역</td>
			<td>구성 요소</td>
			<td>역할</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td rowspan="2">도메인 영역</td>
			<td>엔티티</td>
			<td>핵심 도메인 모델로서 구분되는 식별값을 가지며, 도메인 로직을 실행한다. 엔티티 외에 값(Value) 객체 등이 존재한다.</td>
		</tr>
		<tr>
			<td>리파지터리</td>
			<td>엔티티 객체를 보관하고 제공하는 기능을 정의한다.</td>
		</tr>
		<tr>
			<td>영속성 영역</td>
			<td>리파지터리 구현</td>
			<td>도메인 영역의 리파지터리 인터페이스의 구현을 제공한다. 보통 JPA나 하이버네이트와 같은 ORM 기술을 이용해서 구현한다.</td>
		</tr>
		<tr>
			<td>어플리케이션 영역</td>
			<td>어플리케이션 서비스</td>
			<td>도메인 영역의 리파지터리와 엔티티를 이용해서 클라이언트가 요청한 기능을 실행한다.</td>
		</tr>
	</tbody>
</table>
<br/><br/>

위의 내용은 매우 간략하게 각 영역을 설명한 것으로, 실제 DDD에는 더 많은 구성 요소가 존재한다.  

#### 2.1. 도메인 구성
<br/>
도메인 영역은 다음의 두 가지 종류의 구성 요소를 갖는다.  

+ 도메인 모델  
엔티티, 값 객체 등 도메인 모델을 표현하는 객체를 제공한다. 이들 객체들은 모델을 표현하는데 필요한 프로퍼티(예, 직원 엔티티의 경우 사번, 이름 등)를 포함한다. 엔티티와 DTO의 중요한 차이점은 엔티티는 도메인 기능을 함께 제공하는데 반해 DTO는 단순히 영역 간의 주고 받는 데이터를 담는 구조체라는 것이다.  

+ 엔티티/객체 관리  
리파지터리는 엔티티 객체의 생명주기를 관리한다. 리파지터리에 엔티티 객체를 보관하고, 리파지터리로부터 엔티티를 검색하고, 리파지터리를 통해 엔티티를 제거한다. 도메인 영역에서 리파지터리는 엔티티 관리를 위한 인터페이스만 제공하며, 실제 구현은 영속성 영역에서 다루게 된다.  

리파지터리는 엔티티를 보관하기 위한 용도로 사용된다. 어플리케이션 서비스는 엔티티 객체가 필요할 때 리파지터리를 통해 엔티티 객체를 찾으며, 리파지터리 인터페이스는 엔티티 객체를 보관, 검색, 삭제하기 위한 메서드를 정의한다.  

#### 2.2. 영속성 구현
<br/>
리파지터리의 실제 구현은 영속성 영역에 위치한다.  

영속성 영역을 구현할 때 다양한 기술을 사용할 수 있지만, 구현의 편리함 때문에 ORM 기술을 만힝 사용하는 편이다. 주요 ORM 기술로는 JPA와 하이버네이트가 있다. 이 중 스프링 데이터 JPA 모듈을 사용하면 구현해야 할 코드의 양이 상당히 줄어들기 때문에, 하이버네이트를 직접 사용하기 보다는 코드에서는 JPA를 이용하고 JPA의 프로바이더로 하이버네이트를 사용하는 것을 고려할 수 있다.  

JPA를 이용해서 영속성을 구현할 경우 도메인 영역의 엔티티나 다른 모델 클래스에 JPA 애노테이션을 적용하게 된다. 예를 들어, &#64;Entity, &#64;Table, &#64;Column 등 매핑 설정을 위한 애노테이션을 적용하게 된다.  

얼밀하게 따지면, 도메인 영역의 코드에서 영속성 영역의 코드에 대한 의존을 갖지 않도록 해서 영속성 영역을 다른 기술로 구현하더라도 모메인 코드가 영향을 받지 않도록 해야겠지만, 실제로 영속성 관련 기술을 변경하는 경우는 거의 없다. 따라서, 도메인 영역의 코드에 애노테이션과 같은 설정 정보가 일부 포함되더라도 실용적인 측면에서 문제되지 않는다.  

스프링 데이터 JPA를 사용하게 되면, 도메인 영역의 리파지터리 인터페이스를 구현할 때 Repository 인터페이스를 상속 받아 정의하면 된다. 리파지터리의 일부 기능을 직접 구현해야 한다면, 해당 구현 클래스를 영속성 영역에 위치시킨다.  

#### 2.3. 어플리케이션 서비스 구현
<br/>
어플리케이션 영역은 시스템이 제공하는 기능을 구현한다. 어플리케이션은 클라이언트의 요청을 받아, 도메인 영역의 구성 요소를 이용해서 요청을 처리하고, 그 결과를 리턴한다. 어플리케이션 영역에 위치한 서비스 구현 코드는 대부분 다음과 같은 구성을 갖는다.  

+ 도메인 영역의 리파지터리에서 엔티티를 구한다.
+ 엔티티의 기능을 실행한다.
+ 결과를 리턴한다.  

어플리케이션 서비스는 스프링 빈으로 등록하며, 어플리케이션의 서비스 메서드는 트랜잭션 단위가 된다.  

어플리케이션 서비스의 메서드는 요청을 처리하는데 필요한 입력값을 파라미터로 갖는다.  

서비스를 실행하는데 필요한 데이터가 많다면, 데이터를 담은 클래스를 만들어 메서드의 파라미터 타입으로 사용할 수 있을 것이다.  

#### 2.4. 컨트롤러와 뷰 그리고 도메인 객체 접근
<br/>
클라이언트는 크게 다음의 두 가지 종류의 기능을 서버에 요청한다.  

+ 상태를 변화시키는 기능 : 예를 들어, 암호를 변경한다거나 새로운 회원을 등록하는 등의 기능
+ 데이터를 조회하는 기능 : 예를 들어, 회원 정보를 화면에 보여준다거나, 회원 목록을 조회하는 등의 기능  

이 두 기능 중에서 상태를 변화시키는 기능은 어플리케이션 서비스에서 제공한다.  

그런데, 상태 조회 요청을 처리하는 경우에는 다양한 방식으로 접근할 수 있다. 첫 번째 방식은 컨트롤러에서 직접 리파지터리의 기능을 이용하는 것이다.  

그런데, 첫 번째 방식은 주의해야 할 점이 있다. 엔티티 클래스가 지연 로딩 방식의 1:1 연관 필드를 갖고 있다고 해보자.  

뷰를 구현하는 JSP 코드는 지연 로딩 프로퍼티를 출력할 수 있다.  

컨트롤러에서 상태 조회 메서드만 트랜잭션 범위에서 실행된다고 할 경우, 뷰 코드는 트랜잭션 범위 밖에서 실행된다. 그런데, JPA에서 지연 로딩 방식의 연관 객체는 트랜잭션 범위 내에서만 읽어올 수 있다. 따라서, 트랜재겨션 범위 밖에서 지연 로딩 프로퍼티에 접근할 경우, 익셉션이 발생하게 된다.  

모든 연관에서 지연 로딩을 사용하지 않으면 위 문제가 해결되지만, 대신 연관된 모든 객체를 DB에서 바로 로딩하기 때문에 조회 성능에 문제가 발생할 수 있다. 이런 이유로, 지연 로딩을 사용할 경우 뷰 실행 과정에서 문제가 발생하지 않도록 다음의 두 방법 중 하나를 사용한다.  

+ OSIV 패턴을 사용
+ 뷰에서 필요한 데이터를 트랜잭션 범위 내에서만 로딩  

첫 번째 방법은 OSIV(Open Session In View)라는 패턴을 사용하는 것이다. OSIV 패턴은 서블릿 필터를 이용해서 웹 요청이 시작될 때 JPA 세션을 시작하고, 웹 요청 처리가 끝나면 세션을 종료한다. 이 OSIV 필터를 사용하면 JPA 세션 범위에서 JSP를 실행하기 때문에, JSP 코드에서 지연 로딩 대상 프로퍼티에 접근하더라도 DB로부터 알맞게 대상 객체를 로딩할 수 있게 된다.  

스프링은 JPA를 위한 OSIV 필터를 제공하고 있으며, 이 필터는 다음과 같이 설정할 수 있다.  

```xml
<filter>
	<filter-name>openEntityManagerFilter</filter-name>
	<filter-class>
		org.springframework.orm.jpa.support.OpenEntityManagerViewFilter
	</filter-class>
	<init-param>
		<param-name>entityManagerFactoryBeanName</param-name>
		<param-value>entityManagerFactory</param-value>
	</init-param>
</filter>

<filter-mapping>
	<filter-name>openEntityManagerFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
```

OpenEntityManagerInViewFilter를 사용할 때 주의할 점은, OpenEntityManagerInViewFilter가 EntityManagerFactory 객체를 검색할 때 사용하는 스프링 컨테이너는 DispatcherServlet이 사용하는 컨테이너가 아닌 서블릿 컨텍스트를 위한 컨테이너라는 점이다. 즉, ContextLoaderListener를 이용해서 생성한 스프링 컨테이너에서 EntityManagerFactory를 검색한다. 따라서, 스프링 컨테이너를 설정할 때에는 다음과 같이 DispatcherServlet에서는 웹 MVC 관련 설정만 하고, 나머지 EntityManagerFactory를 포함한 어플리케이션과 관련된 설정은 ContextLoaderListener를 이용하는 방법을 사용해야 한다.  

```xml
<web-app...>
	<listener>
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<!-- EntityManagerFactory를 포함한 설정 -->
		<param-value>classpath:/jpa.xml, classpath:/application</param-value>
	</context-param>

	<!-- 스프링 MVC 관련 설정 -->
	<servlet>
		<servlet-name>dispatcher</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>
				/WEB-INF/spring-mvc.xml
			</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>dispatcher3</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>

	...

	<!-- OpenEntityManagerInViewFilter는 ContextLoaderListener가 생성한 스프링 컨테이너에서 EntityManagerFactory를 검색 -->
	<filter>
		<filter-name>openEntityManagerFilter</filter-name>
		<filter-class>
			org.springframework.orm.jpa.support.OpenEntityManagerInView
		</filter-class>
		<init-param>
			<param-name>entityManagerFactoryBeanName</param-name>
			<param-value>entityManagerFactory</param-value>
		</init-param>
	</filter>

	<filter-mapping>
		<filter-name>openEntityManagerFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
</web-app>
```

OSIV 패턴을 사용하면 구현을 편하게 할 수 있는 장점이 있지만, OSIV 패턴을 사용하는 것에 대한 호불호가 존재한다. OSIV 패턴을 사용하면 지연 로딩을 사용하면서도 JSP와 같은 뷰 영역의 코드에서 지연 로딩 대상 객체를 로딩할 수 있기 때문에, 개발자 입장에서는 지연 로딩을 비교적 자유롭게 사용할 수 있다. 하지만, 어플리케이션 서비스의 메서드가 트랜잭션의 적정 범위인데, 트랜잭션 범위가 뷰 영역까지 확장된다. 즉, 뷰 영역에서 도메인 객체의 상태를 변경할 수 있기 때문에, 개발자가 생각하는 트랜잭션 범위 밖에서 (즉, 어플리케이션 서비스 영역 밖인 뷰 코드에서) DB 상태를 변경하는 상황이 발생할 수 있다. 이런 이유로 OSIV 팬터을 선호하지 않는 프로그래머도 있다.  

OSIV 패턴 외에 지연 로딩으로 인해 발생하는 세션 문제를 해소하기 위한 또 다른 방법은 뷰에서 사용할 데이터를 미리 로딩한 뒤에 뷰에 전달하는 것이다. 예를 들어, 다음과 같이 뷰에서 필요한 데이터를 모두 로딩하는 클래스를 만들어 사용할 수 있다. Hibernate.initialize()는 JPA 프로바이더로 하이버네이트를 선택했을 때 사용할 수 있다. initialize()는 메서드에 전달한 객체를 DB에서 로딩하는 기능을 제공한다.  

지연 로딩 대상 연관을 미리 읽어오는 또 다른 방법은 뷰에서 필요한 데이터만 제공하는 별도 객체를 사용하는 것이다. 예를 들어, 도메인 객체를 커맨드 객체로 변환해서 폼에 전달하기 위해 스프링의 &#60;form:input&#62; 등의 태그를 사용해서 폼에 값을 쉽게 출력할 수 있게 된다.
