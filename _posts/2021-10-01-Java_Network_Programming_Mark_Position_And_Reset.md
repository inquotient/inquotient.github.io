---
title:  위치의 표시와 재설정
categories:
- Java Network Programming
feature_text: |
  ## 위치의 표시와 재설정
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---

InputStream은 일반적으로 잘 사용되지 않는 다음 세 가지 메소드를 제공한다. 이 메소드를 사용하여 프로그램은 스트림의 우치를 표시(mark)하거나 이미 읽은 데이터를 다시 읽을 수 있다.  

+ public void mark(int readAheadLimit)
+ public void reset() throws IOException
+ public boolean markSupported()  

데이터를 다시 읽기 위해, 먼저 mark() 메소드를 사용하여 스트림의 현재 위치를 표시힌다. 그리고 나중에 필요한 시점에서 reset() 메소드를 호출하여 표시된 위치로 스트림을 재설정한다. 그다음에 읽기를 시도하면 표시된 위치에서 읽은 데이터가 반환된다. 물론 스트림의 위치 재설정이 항상 성공하는 것은 아니다. 표시된 위치로부터 읽을 수 있는 바이트 수와 여전히 재설정 가능한지 여부는 mark() 메소드 호출 시 제공한 readAheadLimit 인자에 의해 결정된다. 표시된 위치로부터 너무 많이 읽은 후에 재설정을 시도하면 IOException이 발생한다. 게다가 스트림은 동시에 하나의 위치만 표시할 수 있다. 두 번째 위치를 표시하면 첫 번째 위치는 사라진다.  

스트림 위치의 표시와 재설정은 일반적으로 표시된 위치에서부터 읽은 모든 데이터를 내부 버퍼에 저장하는 방식으로 구현된다. 그러나 모든 입력 스트림이 이 기능을 지원하는 것은 아니다. 이 기능을 사용하기 전에 markSupported() 메소드를 사용하여 지원 유무를 확인해야 한다. 이 기능을 지원하지 않는 입력 스트림에 mark() 메소드를 호출하면 아무런 일도 발생하지 않지만 reset() 메소드는 IOException을 발생시킨다.  

위의 메소드는 매우 엉성하가 설계되어 있다. 실제로는 표시와 재설정을 지원하는 스트림보다 그렇지 않은 스트림이 더 많다. 대부분의 서브클래스에서 사용할 수 없는 기능을 추상화된 슈퍼클래스에 추가하는 것은 좋은 방법이 아니다. 이러한 메소드의 경우, 각각을 인터페이스에 포함시켜 그런 기능을 클래스가 제공하도록 구현하는 평이 더 좋을 것이다. 물론 이와 같은 방식으로는 입력 스트림의 타입을 알지 못하는 경우, 위에서 말한 메소드를 실행할 수 없는 문제가 발생할 수 있다. 그러나 실제로는 모든 스트림이 표시와 재설정을 지원하는 것은 아니므로 어쨌든 이런 문제는 피할 수 없다. markSupported() 같은 메소드로 스트림이 해당 기능을 제공하는지 검사하는 것은 객체지향적이지 않은 해결 방법이다. 객체지향적 접근이라면 markSupported() 같은 기능을 인터페이스와 클래스를 타입 시스템에 내장하여 컴파일하는 동안에 검사할 수 있어야 한다.  

java.io 내에서 스트림 위치의 표시를 항상 지원하는 유일한 입력 스트림 클래스는 BufferedInputStream과 ByteArrayInputStream이다. 그러나 TelnetInputStream 같은 다른 입력 스트림이 스트림 위치의 표시를 지원하기 위해서는 먼저 버퍼 입력 스트림과의 연결이 필요하다.
