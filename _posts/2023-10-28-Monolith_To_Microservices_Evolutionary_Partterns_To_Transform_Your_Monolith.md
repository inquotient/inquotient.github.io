---
title: Monolith to Microservices Evolutionary Patterns to Transform Your Monolith
categories:
- Microservice
feature_text: |
  ## Monolith to Microservices: Evolutionary Patterns to Transform Your Monolith
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---
<style>
	thead td { text-align: center; }
	td { border: 1px solid #444444; }
	.align-center { text-align: center; }
</style>

### 1. 더도 덜도 아닌 딱 마이크로 서비스  
<br/>

#### 1.1. 마이크로서비스란 무엇인가?  
<br/>

+ 마이크로서비스(Microservice)  
비즈니스 도메인을 중심으로 모델링된 독립적으로 배포 가능한 서비스  

마이크로서비스 아키텍처는 여러 협업 마이크로 서비스를 기반으로 한다.  

서비스 경계가 어떻게 형성되어야 하는지에 대해서는 의견이 분분하며, 독립적인 배포가 핵심이긴 하지만, 마이크로서비스도 SOA(서비스 지향 아키텍처, Service-Oriented Architecture)의 한 유형이다. 마이크로서비스는 또한 기술에 중립적이라는 장점도 있다.  

기술 관점에서 마이크로서비스는 하나 이상의 네트워크 종단점을 통해 캡슐화하는 비즈니스 기능을 외부에 공개한다. 마이크로서비스는 이런 네트워크를 통해 서로 통신하게 되며, 분산 시스템이라는 형태를 구성한다. 또한 잘 정의된 인터페이스를 통해, 데이터 저장소와 인출 기능을 캡슐화하고 데이터를 외부에 공개한다. 따라서 데이터베이스는 서비스 경계 내부에 숨겨져 있다.  

##### 1.1.1. 독립적인 배포 가능성  
<br/>

+ 독립적인 배포 가능성(Independent deployability)  
다른 서비스를 활용하지 않고서 마이크로서비스에 변경을 가하는 방식으로 서비스 환경에 배포할 수 있다는 개념  

독립적인 배포를 위해서는, 서비스가 느슨하게 결합되어 있음(loosely coupled)을 보증할 필요가 있다. 즉 다른 서비스를 변경하지 않고도 특정 서비스를 변경할 수 있는 능력을 갖출 필요가 있다. 이는 서비스 간에 명시적이고 잘 정의되며 안정적인 계약이 필요함을 의미한다. 몇몇 구현 선택은 이를 어렵게 만들며, 일례로 데이터베이스 공유가 특히 문제다. 인터페이스가 안정적인 느슨하게 결합된 서비스가 필요하다면, 먼저 서비스 경계를 찾도록 우리의 생각부터 바꿔야 한다.  

##### 1.1.2. 비즈니스 도메인을 중심으로 하는 모델링  
<br/>

프로세스 경계를 넘어서는 변경에는 비용이 많이 든다. 기능을 출시하기 위해 두 서비스를 변경하고 이 두 변경사항의 배포를 조정할 필요가 있는 경우, 단일 서비스(또는 마찬가지로 모놀리스) 내에서 동일한 변경을 수행하는 것보다 더 많은 작업이 필요하다. 따라서 교차 서비스(cross-service) 변경을 최소로 줄이게끔 보증하는 방법을 찾고자 한다.  

##### 1.1.3. 데이터 소유권 문제  
<br/>

마이크로서비스는 데이터베이스를 공유해서는 안 된다는 생각 때문에 매우 곤란해 하는 사람들을 종종 보곤 한다. 어떤 서비스에서 다른 서비스가 보유한 데이터에 접근하고 싶다면 데이터를 보유한 서비스를 찾아서 해당 데이터를 요청해야 마땅하다. 해당 서비스는 외부에 무엇을 공유하고 무엇을 숨길지를 결정할 수 있다. 또한 임의의 이유로 변경될 수 있는 내부 구현 세부사항으로부터 좀 더 안정적인 공개 계약으로 서비스를 매핑함으로써, 안정적인 서비스 인터페이스를 보장한다. 독립적인 배포 가능성(independent deployability)을 원한다면 서비스 간에 안정적인 인터페이스가 필수다. 만일 특정 서비스에서 외부에 공개하는 인터페이스가 계속 변경된다면, 이를 사용하는 다른 서비스도 변경해야 하는 연쇄 효과가 일어난다.  

정말로 필요한 경우가 아니라면 데이터베이스는 공유하지 말자. 피할 수 있는 모든 방법을 강구해야 한다. 독립적인 배포 가능성을 원한다면, 데이터베이스 공유는 최악의 선택 중 하나다.  

데이터와 행동(behavior)을 캡슐화하면 비즈니스 기능의 응집력이 높아진다. 서비스를 뒷받침하는 데이터베이스를 숨기는 방법 또한 결합도를 줄인다.  

다뤄야 할 데이터베이스가 대규모인 경우, 특히 기존 모놀리스 시스템을 사용할 때는 문제 해결이 어려울 수도 있다.  

##### 1.1.4. 마이크로서비스의 장점  
<br/>

배포의 독립적인 특성으로 인해 시스템의 확장성과 견고성을 개선할 수 있으며, 다양한 기술을 짝맞출 수 있다. 서비스의 병렬 개발 작업이 가능하므로, 개발자들은 서로 방해받지 않고 각자 문제 해결에 몰입할 수 있다. 또한 개발자가 시스템에서 자신이 맡은 부분에만 전념할 수 있으므로 시스템의 한 부분에만 집중할 수 있다. 또한 프로세스 격리를 통해 다양한 기술 선택이 가능하므로, 여러 프로그래밍 언어, 프로그래밍 스타일, 배포 플랫폼, 데이터베이스 등을 병용해 올바른 조합을 찾을 수도 있다.  

무엇보다도 마이크로서비스 아키텍처는 유연성을 제공한다. 문제를 향후 어떻게 해결할지에 대해 더 많은 선택지를 열어준다.  

그러나 이런 장점 중 어떤 것도 공짜로는 얻지 못한다는 사실에 유의해야 한다. 시스템 분해에 접근할 수 있는 방법은 여러 가지가 있으며, 달성하려는 목표에 따라 다양한 시스템 분해 방법으로 나뉠 것이다. 따라서 마이크로서비스 아키텍처에서 추구하려는 목표가 무엇인지부터 파악해야 한다.  

##### 1.1.5. 마이크로서비스가 야기하는 문제점  
<br/>

네트워크를 거치는 컴퓨터 간의 통신은 즉각적이지 않다(이는 분명히 물리학과 관련이 있다). 이는 특히 로컬 프로세스 내 작업에서 볼 수 있는 대기 시간과 비교해 훨씬 더 긴 대기 시간을 걱정해야 한다는 의미다. 이런 대기 시간이 제각각이라서 시스템 동작을 예측하기 어렵게 만들 때 상황은 더욱 악화된다. 또한 패킷이 손실되거나 네트워크 케이블이 끊어지는 경우처럼 종종 네트워크가 문제를 일으키는 상황도 해결해야 한다.  

이런 장애물로 인해, 트랜잭션 같은 단일 프로세스 모놀리스로 해결 가능한 비교적 단순한 활동은 훨씬 더 어려워진다. 이는 실제로도 매우 어렵기 때문에, 시스템이 복잡해지면 다른 종류의 기술(불행히도 너무나도 많은 절충안이 존재한다)을 도입하는 대가로 트랜잭션과 안전성을 포기해야 할 것이다.  

네트워크 호출이 (종종) 실패할 수 있고 (언젠가는) 실패할 것이라는 사실이 문제가 되는 까닭은 요청하게 될 서비스가 어떤 이유로든 오프라인 상태가 되거나 이상한 행동을 시작할 수 있기 때문이다. 설상가상으로, 여러 컴퓨터에 데이터가 나뉜 상황에서 일관성 있는 데이터 뷰를 얻는 방법도 찾기 시작해야 한다.  

물론, 마이크로서비스에 친화적인 엄청나게 많은 기술을 고려해볼 수 있다. 이런 신기술은 자칫 잘못 사용되면, 과실의 대가로 높은 비용을 치르게 된다. 솔직히, 마이크로서비스는 그 모든 장점을 빼면 정말 끔찍한 발상이다.  

'모놀리스'로 분류한 거의 모든 시스템도 사실상 분산 시스템이라는 점에 주목해야 한다. 단일 프로세스 애플리케이션은 다른 컴퓨터에서 실행되는 데이터베이스에서 데이터를 읽고 웹 브라우저에 데이터를 표시한다. 이렇게 하려면 최소한 컴퓨터 3대가 필요하며 네트워크를 통해 컴퓨터 간 통신이 가능해야 한다. 마이크로서비스 아키텍처에 비해 모놀리스 시스템은 배포되는 규모 면에서 차이가 난다. 더 많은 네트워크로 통신하는 컴퓨터를 더 많이 투입할수록, 분산 시스템과 관련된 심각한 문제에 부딪힐 가능성이 높아진다. 이런 문제들이 처음에는 나타나지 않을지도 모르지만, 이후에 시스템이 커지면 이와 같은 문제들로 인해 큰 타격을 입을 가능성이 있다.  

##### 1.1.6. 사용자 인터페이스  
<br/>

순수하게 서버 쪽에 마이크로서비스를 수용하는 과정에 집중하느라, UI는 단일 모놀리스 계층으로 남겨두는 경우가 많다. 새로운 기능을 더 신속하게 배포할 수 있는 아키텍처를 원한다면, UI를 모놀리스 덩어리로 남겨 두는 결정은 큰 실수가 될 수 있다. UI 분해 역시 검토할 수 있으며, 검토해야 마땅하다.  

##### 1.1.7. 기술  
<br/>

영롱하고 새로운 마이크로서비스 아키텍처와 함께 할 신기술을 움켜쥐려는 유혹이 강하게 들겠지만, 절대로 그 유혹에 빠져서는 안 된다. 새로운 기술을 채택하는 데는 비용도 들고 다소 격변이 일게 된다. 바라건데, 그만한 가치가 있을 것이지만(물론 올바른 기술을 선택했다면!) 마이크로서비스 아키텍처를 처음 도입할 때는 충분히 겪어봐야 한다.  

마이크로서비스 아키텍처를 올바르게 발전시키고 관리하는 방법을 개발하려면 분산 시스템과 관련된 수많은 문제와 씨름해야 하며, 아마도 이는 전에 한 번도 직면하게 못한 문제일 것이다. 이런 문제에 부딪힌다면, 먼저 익숙한 기술 스택을 활용해 문제를 이해하고 나서, 그다음에 찾아낸 문제를 해결하기 위해 기술 변경을 고려하는 방식이 훨씬 더 유용할 것이다.  

이미 언급한 바와 같이, 마이크로서비스는 기본적으로 기술에 중립적이다. 여러분의 서비스가 네트워크를 통해 서로 통신할 수 있는 한, 네트워크를 제외한 나머지는 무엇이든 선택할 수 있다. 이는 목적에 맞춰 원하는 기술 스택을 짜맞추게 만드는 엄청난 장점이 된다.  

쿠버네티스, 도커, 컨테이너, 퍼블릭 클라우드 등을 사용할 필요는 없다. 고(Go)나 러스트(Rust)같은 프로그래밍 언어로 코딩할 필요도 없다. 실제로 마이크로서비스 아키텍처에 관한 한 프로그래밍 언어 선택은 그다지 중요하지 않다. 더욱이 라이브러리나 프레임워크를 지원하는 풍부한 생태계를 확보했다는 특성이 언어 선택의 판단 기준은 될 수 없다. PHP에 가장 익숙하다면 PHP로 서비스를 구축하면 된다! 불행한 일이지만, 특정 도구를 사용하는 사람들에게는 경멸에 가까울 수 있는, 일부 기술 스택에 대한 우월의식이 너무 팽배해 있다. 스스로 문젯거리가 되어서는 안 된다! 각자 자신에게 가장 알맞은 접근 방식을 선택하고 문제를 만날 경우 바로 해결할 수 있도록 시스템을 변경하자.  

##### 1.1.8. 규모  
<br/>

마이크로서비스 관점에서 '규모'에 가장 근접하다고 생각한 정의는 마이크로서비스 전문가 크리스 리처드슨(Chris Richardson)이 말한 "마이크로서비스의 목표는 '가능한 한 작은 인터페이스를 유지'하는 것"이라는 발언이다.  

나는 사람들에게 규모에 대한 걱정을 떨치라고 충고한다. 처음 시작할 때는 2가지 사항에 집중하자. 첫째, 우리는 얼머나 많은 마이크로서비스를 다룰 수 있는가? 서비스가 많아질수록 시스템의 복잡성이 증가할 것이고 이에 대처하기 위해 새로운 기술을 배워야 할 것이다. 이런 이유로 나는 마이크로서비스 아키텍처로 가는 점진적인 마이그레이션을 강력히 옹호한다. 둘째, 이 모든 것이 끔찍하게 결합된 혼돈 상황이 되지 않으면서 마이크로서비스를 최대한 활용하기 위해 경계를 정의하는 방법은 무엇일까?  

#### 1.1.9. 소유권  
<br/>

비즈니스 도메인을 중심으로 모델링된 마이크로서비스에서, IT 산출물(독립적으로 배포 가능한 마이크로서비스)과 비즈니스 도메인은 나란히 움직인다. '비즈니스'와 'IT' 사이의 격차를 좁히는 기술 회사로 전환을 고려할 때 이런 개념은 큰 반항을 불러일으킨다. 전통적인 IT 조직에서 소프트웨어 개발이라는 행위는 실제로 요구사항을 정의하고 고객과 연결된 비즈니스와는 완전히 분리된 부분에서 처리된다.  

이보다는, 진정한 기술 조직이란 조직적이며 분리된 기존의 사일로를 완전히 결합한 형태다. 제품 소유자는 이제 배포 팀으로서 직접 작업하며, 배포 팀을 임의 기술 그룹으로 묶는 대신 고객 중심의 제품 라인에 맞춰 정렬한다. 중앙 집중화된 IT 기능을 표준으로 삼는 대신, 중앙 IT 기능을 이용해 이와 같은 고객 중심 배포 팀을 지원할 수 있다.  

모든 조직이 이렇게 변화하지는 않았지만, 마이크로서비스 아키텍처를 통해 이런 변화는 훨씬 더 쉬워진다. 배포 팀이 제품 라인을 중심으로 나란히 정렬되기를 원하고, 서비스가 비즈니스 도메인을 중심으로 정렬된다면, 제품을 지향하는 배포 팀에 소유권을 명확하게 할당하는 작업은 훨씬 더 수월해진다. 여러 팀에서 공유되는 서비스를 축소하는 것은 배포 경합(delivery contention)을 최소화하기 위한 핵심이다. 즉 비즈니스 도메인 지향 마이크로서비스 아키텍처를 통해 조직적인 구조에서 이런 변화는 훨씬 더 손쉽다.  

#### 1.2. 모놀리스  
<br/>

+ 모놀리스: 배포 단위(unit of deployment)
+ 모놀리스의 유형: 단일 프로세스 시스템, 분산 모놀리스 시스템, 외부 블랙박스 시스템  

##### 1.2.1. 단일 프로세스 모놀리스  
<br/>

견고성 또는 확장성을 이유로 이 프로세스의 인스턴스가 여러 개 있을지도 모르지만 기본적으로 모든 코드는 단일 프로세스로 묶어 포장된다. 실제로 이런 단일 프로세스 시스템은 데이터를 거의 항상 데이터베이스에서 읽거나 데이터베이스에 저장하기 때문에, 단순하면서도 독자적인 분산 시스템일 수 있다.  

이와 같은 단일 프로세스 모놀리스는 아마도 사람들이 어려움을 겪고 있는 대다수 모놀리스 시스템을 대표하므로 계속 다루게 될 유형이다.  

###### 1.2.1.1. 모듈식 모놀리스  
<br/>

+ 모듈식 모놀리스(modular monolith)  
단일 프로세스 모놀리스의 하위 집합으로 단일 프로세스는 별도 모듈로 구성되어 있으며 각 모듈은 독립적으로 동작할 수 있지만, 배포를 위해서는 여전히 결합이 필요  

많은 조직에서 모듈식 모놀리스는 탁월한 선택이 될 수 있다. 모듈 경계가 잘 정의되어 있으므로 병렬 작업을 많이 수행할 수 있지만 배포 고려사항은 훨씬 더 단순해지기 때문에, 분산 마이크로서비스 아키텍처에서 발생하늠 문제를 피할 수 있다. 쇼피파이(Shopify)는 모듈식 모놀리스 기술을 마이크로서비스 분해의 대안으로 사용한 조직의 훌륭한 예며, 모듈식 모놀리스가 정말 제대로 동작하는 듯이 보인다.  

모듈식 모놀리스의 문제 중 하나는 코드 수준에서 지원하는 분해 능력이 데이터베이스 부분에는 부족하므로 향후 모놀리스를 끌어내고 싶을 경우에 중대한 문제에 직면한다는 사실이다. 근본적으로, 기존의 모놀리스에 이와 같은 변경을 가하는 방식은 심지어 코드는 그대로 남겨 두더라도 여전히 매우 어렵다.  

##### 1.2.2. 분산 모놀리스  
<br/>

+ 분산 모놀리스(distributed monolith)  
여러 서비스로 구성되는 시스템이지만 어떤 이유로든 전체 시스템을 함께 배포해야만 하는 시스템  

분산 모놀리스는 SOA의 정의를 제대로 충족할지도 모르지만 대부분은 SOA의 약속을 이행하는 데 실패한다. 분산 모놀리스는 분산 시스템의 모든 단점에다가 단일 프로세스 모놀리스의 단점까지 포함하며, 양쪽의 장점을 충분히 발휘하지 못한다. 업무에서 분산 모놀리스를 다뤄야 했던 경험이 마이크로서비스 아키텍처에 대한 나의 관심을 증폭시켰다.  

분산 모놀리스는 전형적으로 정보 은닉이나 비즈니스 기능의 응집력 같은 개념이 희박한 환경에서 등장한다. 또한, 서비스 경계 지점에서 변경이 발생하기에 결합도가 매우 높은 아키텍처를 만들어내며, 지역적인 범위에서 나쁜 의도가 없는 듯한 변경사항이 외부까지 영향을 미쳐 시스템의 다른 부분을 망가뜨린다.  

##### 1.2.3. 외부 블랙박스 시스템  
<br/>

마이그레이션 노력의 일환으로 '분해'하기를 원하는 몇몇 외부 소프트웨어를 모놀리스로 간주할 수도 있다. 이런 소프트웨어로는 급여 시스템, CRM 시스템, HR 시스템 등을 들 수 있다. 이 소프트웨어 시스템의 공통점은 다른 사람들이 개발했기에 우리에게는 코드를 변경할 역량이 없다는 점이다. 이 시스템은 자체 인프라에 배포한 상용 소프트웨어이거나 사용 중인 SaaS(Software-as-a-Service) 제품일 수도 있다.  

##### 1.2.4. 모놀리스의 문제점  
<br/>

단일 프로세스 모놀리스나 분산 모놀리스 등은 종종 결합도, 특히 구현과 배포 결합도와 같은 결합도의 위험에 더 취약하다.  

같은 장소에 일하는 사람들이 점점 많아질수록, 저마다 각자의 길을 가게 된다. 동일한 코드를 변경하기 원하는 다양한 개발자, 각 기능을 각기 다른 시점에 밀어넣고 싶어 하는 (또는 배포를 지연하고 싶어하는) 팀들이 많다. 누가 무엇을 소유하며 누가 의사결정을 하는지에 대한 혼란도 존재한다. 다수의 연구결과에서 '혼란스러운 소유권의 경계선'이라는 문제를 보여준다. 이 문제를 배포 경합(delivery contention)이라고 부른다.  

모놀리스를 사용한다고 해서 반드시 배포 경합 문제에 직면하는 것은 아니며, 마찬가지로 마이크로서비스 아키텍처를 사용한다고 해서 문제를 피할 수 있는 것도 아니다. 그러나 마이크로서비스 아키텍처는 소유권의 경계선을 중심으로 더 구체적인 경계를 제공하므로 이 문제를 줄이기 위한 유연성이 훨씬 더 뛰어나다.  

##### 1.2.5. 모놀리스의 장점  
<br/>

하지만 단일 프로세스 모놀리스에는 장점도 많다. 훨씬 간단한 배포 토폴로지로 분산 시스템과 관련된 많은 위험을 피할 수도 있다. 단일 프로세스 모놀리스는 훨씬 더 간단한 개발자 워크플로우를 만들어낸다. 또한 모니터링, 문제 해결, 전 구간 테스트와 같은 활동도 크게 단순화할 수 있다.  

모놀리스는 또한 모놀리스 자체 내에서 코드 재사용을 단순하게 만든다. 분산 시스템 내에서 코드 재사용을 원하면, 코드를 복사할지, 라이브러리를 분해할지, 공유 기능을 서비스로 분리할지 등을 결정해야 한다. 모놀리스를 사용하면 우리의 선택이 훨씬 더 간단해진다. 사람들은 이 같은 단순함을 좋아한다. 다시 말해, 필요한 모든 코드가 있으므로 이를 사용하기만 하면 된다!  

안타깝게도 사람들은 모놀리스를 피해야 할 뭔가로, 본질적으로 문제가 되는 것으로 바라보게 되었다. 모놀리스 아키텍처는 선택이며 그 자체로 유효하다. 모든 상황에서 모놀리스가 올바른 선택이 아닐 수도 있고, 혹은 마이크로서비스를 뛰어넘을지도 모르지만, 그럼에도 모놀리스 또한 선택사항이다. 소프트웨어 배포를 위한 실현 가능한 선택지로서 모놀리스를 고의적으로 폄하하는 함정에 빠지면, 우리 스스로나 우리 소프트웨어 사용자가 올바르게 작업을 수행하지 못할 위험에 직면하게 된다.  

#### 1.3. 결합도와 응집력  
<br/>

+ 결합도(coupling)  
한 가지를 바꾸면 다른 것도 바꿀 필요가 있는 방식  

+ 응집력(cohesion)  
관련된 코드를 그룹으로 묶는 방식  

모놀리스의 문제점은 결합도와 응집력이 너무나 자주 반대로 움직이는 것이다. 응집력이 있는 코드를 함께 변경이 가능하게 유지하는 대신, 우리는 관련 없는 모든 유형의 코드를 가져와서 한데 붙여 놓는다. 마찬가지로, 느슨한 결합은 실제로 존재하지 않는다. 즉 코드에서 한 행은 충분히 쉽게 변경할 수 있을지도 모르지만, 모놀리스와 나머지 부분에 잠재적인 영향을 미치지 않으면서 해당 변경사항을 배포할 수는 없으며, 전체 시스템을 확실히 재배포해야 한다.  

또한 우리의 목표는 최대한 독립적인 배포 가능성의 개념을 수용하는 것이다. 즉 특정 서비스를 변경한 다음에 이와 무관한 다른 어떤 서비스도 변경하지 않고서도 해당 변경사항만 운영 환경에 배포하기를 원하기 때문에 시스템 안정성은 중요하다. 이렇게 작동하려면 우리가 의존하는 서비스들이 안전성을 갖춰야 하며, 우리에게 의존하는 서비스들에도 안정적인 계약을 제공해야 한다.  

##### 1.3.1. 응집력  
<br/>

+ 응집력  
함께 바뀌고 함께 머무는 코드  

##### 1.3.2. 결합도  
<br/>

+ 정보 은닉(Information Hiding)  
자주 변경되는 코드부를 정적인 코드부와 분리하는 것  

모듈 경계가 안정되기를 원하며 더 자주 변경될 것으로 예상되는 모듈 구현 부분을 숨겨야 한다. 즉 모듈 호환성이 유지되는 동안에는 내부 변경을 안전하게 수행할 수 있다.  

모듈(또는 마이크로서비스) 경계에서 가능한 한 적게 외부로 노출하는 접근 방식이 선호되는 편이다. 모듈 인터페이스의 일부가 되면, 이를 철회하기란 어렵다. 그러나 만일 지금 숨기면 언제든지 나중에 공유하기로 결정할 수 있다.  

객체 지향 소프트웨어의 개념으로서 캡슐화(encapsulation)는 정보 은닉과 관련이 있지만 받아들이는 이의 정의에 따라 둘은 정확하게 동일하지 않을 수도 있다. 객체 지향 프로그래밍에서 캡슐화는 하나 이상의 항목을 컨테이너로 묶는 것을 의미하게 되었다. 싶드와 해당 필드에서 작동하는 메소드를 모두 포함하는 클래스를 생각해보라. 그런 다음 클래스 정의에서 가시성을 사용해 구현의 일부를 숨길 수 있다.  

###### 1.3.2.1. 구현 결합도  
<br/>

구현 결합도에서는 B 구현 방식에 따라 A가 B에 결합되며, B 구현이 변경될 때 A 또한 변경된다.  

여기서 구현 세부사항을 종종 개발자가 임의로 선택한다는 문제가 있다. 문제를 해결하는 방법은 여러 가지다. 우리는 그중 하나를 선택하지만 마음이 바뀔지도 모른다. 우리가 마음을 바꾸려고 할 때, 우리는 이것이 컨슈머를 망가뜨리지 않기를 원한다(독립적인 배포 가능성을 기억하는가?).  

구현 결합도의 고전적이고 일반적인 예는 데이터베이스를 공유하는 형태로 나타난다.  

잘 정의된 서비스 인터페이스 뒤에 데이터베이스를 숨기면 서비스가 노출 대상의 범위를 제한하고 데이터 표현 방식을 변경할 수 있다.  

서비스 인터페이스를 정의할 때는, '외부에서 내부로'라는 사고 방식도 유용하다. 먼저 서비스 컨슈머의 입장에서 생각해 서비스 인터페이스를 설계한 다음, 해당 서비스 계약을 구현한다. 대안으로 사용하는 접근법(유감스럽게도 내가 관찰한 바에 따르면 너무 흔하다)은 이와 반대다. 서비스를 담당하는 팀은 데이터 모델이나 다른 내부 구현 세부사항을 가져와서 외부 세상에 이를 공개하려 한다.  

'외부에서 내부로'라는 사고 방식으로 여러분은 먼저 "서비스 컨슈머가 무엇을 원하는가?"라고 물어야 한다. 고객이 필요한 것이 무엇인지를 스스로 자문하라는 의미가 아니다. 여러분의 서비스를 호출할 사람들에게 직접 물으라는 의미다.  

마이크로서비스가 공개하는 서비스 인터페이스는 사용자 인터페이스처럼 취급하자. 서비스를 호출하는 사람들과 협력해 인터페이스 설계를 구체화하기 위해 '외부에서 내부로' 사고방식을 활용하자.  

외부 세계와 맺은 서비스 계약을 사용자 인터페이스라고 생각하자. 사용자 인터페이스를 설계할 때, 사용자에게 원하는 바를 물어보고 사용자와 함께 이 설계를 반복하자. 동일한 방식으로 서비스 계약을 구체화해야 마땅하다. 이는 또한 컨슈머가 사용하기 쉬운 서비스를 제공한다면 장점 이외에도 외부 계약과 내부 구현을 분리하는 과정에도 도움이 된다.  

###### 1.3.2.2. 시간적 결합도  
<br/>

+ 시간적 결합도(temporal coupling)  
주로 분산 환경에서 동기식 호출의 주요 도전과제 중 하나인 실행 시간에 발생하는 문제로 메시지가 전송되는 시점과 메시지가 처리되는 방식이 시간과 관련되어 있는 경우 존재  

창고 → 주문 → 고객  

연산을 수행하기 위해 동기식 호출을 사용하는 세 가지 서비스는 시간적으로 결합되어 있다고 말할 수 있다.  

여기서 주문에 대해 필요한 정보를 가져오기 위해 창고 서비스에서 다운스트림 주문 서비스로 향하는 동기식 HTTP 호출을 볼 수 있다. 요청을 충족하기 위해 주문 서비스는 계속해서 동기식 HTTP 호출을 통해 고객 서비스에서 정보를 가져와야 한다. 이와 같은 전체 연산을 완료하려면 창고, 주문, 고객 서비스가 모두 작동하고 네트워크로 연결돼야 한다. 3가지 서비스는 모두 시간적으로 결합되어 있다.  

이 문제는 다양한 방법으로 해소할 수 있다. 먼저 캐싱 사용을 고려하자. 주문 서비스가 고객 서비스에서 필요한 정보를 캐시하면 주문 서비스는 몇몇 경우에 다운스트림 서비스와 시간적 결합도를 피할 수 있을 것이다. 또한 요청을 보내기 위해 메시지 브로커 같은 서비스르사용하는 비동기 전송을 고려할 수도 있다. 메시지 브로커가 메시지를 다운스트림 서비스로 보내 놓으면 다운스트림 서비스가 여유가 생긴 시점에 해당 메시지를 처리한다.  

###### 1.3.2.3. 배포 결합도  
<br/>

정적으로 링크된 여러 모듈로 구성된 단일 프로세스를 생각해보자. 모듈 중 한 곳에서 코드 한 줄이 변경되었으며 해당 변경사항을 배포하기를 원한다. 이렇게 하려면, 심지어 변경되지 않은 모듈을 포함해 전체 모놀리스를 배포해야 한다. 모든 것이 반드시 함께 배포되어야 하므로 배포 결합도(deployment coupling)가 존재한다.  

+ 릴리스 기차(release train)  
실행 시간 의존성이 있는 컴포넌트나 여러 팀을 가로질러 릴리스를 조율하는 기법으로, 고정되고 안정적인 일정에 맞춰 모든 릴리스가 일어나는 특성이 있다.  

정적으로 링크된 프로세스의 예와 같이 배포 결합도가 강제될지도 모르지만, 릴리스 기차(release train)와 같이 관행에 따른 선택의 문제가 될 수도 있다. 릴리스 기차를 사용하면 일반적으로 반복 일정 형태로 사전에 계획된 릴리스 일정을 미리 작성해 놓는다. 릴리스 시점에 마지막 릴리스 기차 배포 이후의 모든 변경사항이 배포된다. 일부 사람들에게는 릴리스 기차가 유용한 기술일 수도 있지만, 궁극적인 목표라기보다는 적절한 맞춤식 릴리스 기술로 전환하는 과도기 단계 정도로 보는 편이 훨씬 낫다.  

배포에는 위험이 따른다 배포와 관련된 위험을 줄이는 방법은 여러 가지가 있는데, 그중 하나는 변경할 필요가 있는 사항만 바꾸는 것이다. 더 큰 프로세스를 독립적으로 배포 가능한 마이크로서비스로 분해해 배포 결합도를 줄일 수 있다면, 배포 범위를 줄임으로써 개별 배포의 위험을 낮출 수도 있다.  

릴리스 규모가 작을수록 위험 부담도 줄어든다. 잘못될 것이 적기 때문이다. 변경을 줄였기 때문에 뭔가가 잘못되어도 문제를 찾아내 해결하기가 쉬워진다. 릴리스 규모를 줄이는 방법을 찾는 것은 지속적인 배포의 핵심이며, 빠른 피드백과 맞춤식 릴리스 방법의 중요성을 뒷받침한다. 릴리스 범위가 작을수록 출시도 쉽고, 안전하며, 빠른 피드백을 얻을 수 있다.  

당연한 이야기지만, 배포 결합도를 줄이는 데는 마이크로서비스가 필요하지 않다. 얼랭(Erlang)같은 런타임은 새로운 버전의 모듈을 실행 중인 프로세스로 재시작 없이 배포하게 만들어준다. 궁극적으로 대부분의 경우에 우리가 매일 사용하는 기술 스택만으로 이렇게 할 수 있을지도 모른다.  

###### 1.3.2.4. 도메인 결합도  
<br/>

기본적으로 여러 독립적인 서비스로 구성된 시스템은 참가자 간에 상호작용이 있어야만 동작한다. 마이크로서비스 아키텍처에서 도메인 결합도(domain coupling)는 결과며, 서비스 간의 상호작용은 실제 도메인에서 일어나는 상호작용을 모델링한다. 주문하려면 고객의 쇼핑 바구니에 어떤 물품이 있는지 알아야 한다. 제품 배송을 원하면 제품을 어디로 배송할지 알아야 한다. 마이크로서비스 아키텍처에서, 분명히 이 정보는 다른 서비스에 포함될 것이다.  

구체적인 예를 들어보자. 물품을 보관하는 창고가 있다. 고객이 CD를 주문하면, 창고에서 일하는 작업자들은 어떤 물품을 선택하고 포장해야 할지, 물품을 어디로 보내야 할지를 알아야 한다. 따라서 주문에 대한 정보는 창고 작업자들과 공유해야 한다.  

주문 처리 서비스는 주문의 모든 세부사항을 창고 서비스로 전송한 다음, 물품을 포장하도록 만든다. 이와 같은 작업의 일부로서, 창고 서비스는 고객 ID를 사용해 별도로 분리된 고객 서비스에서 고객에 대한 정보를 가져오므로, 우리는 물품을 발송할 때 고객에게 통지하는 방법을 알고 있다.  

이 상황에서 우리는 전체 주문을 창고와 공유하고 있는데, 이는 합리적이지 않을지도 모른다. 창고는 포장할 대상 물품과 배송지에 대한 정보만 필요하기 때문이다. 물품 가격이 얼마인지는 알 필요가 없다(포장에 송장을 포함해야 하는 경우, 미리 만들어둔 PDF를 전달할 수도 있다). 또한 매우 광범위한 공유를 위해 접근 제어가 필요한 정보에 문제가 생길 수도 있다. 만일 전체 주문을 공유할 경우, 전혀 무관한 서비스에 신용카드 세부정보를 노출할 수도 있다.  

이보다는 '창고' 서비스가 요구하는 정보만 포함한 '물품 선택 명령'이라는 새로운 도메인 개념을 생각할 수도 있다. 이는 정보 은닉의 또 다른 예다.  

필요할 경우, 창고 서비스가 고객에 대해 알아야 할 필요성조차 없애는 방식으로, 결합도를 더욱 줄일 수도 있다. 이때 '물품 선택 명령'을 통해 모든 적절한 세부정보를 제공할 수 있다.  

이런 접근 방식이 작동하려면 특정 시점에서 주문 처리가 고객 서비스에 접근해 물품 선택 명령을 먼저 생성해야 하지만, 주문 처리는 여러 가지 이유 때문에 고객 정보에 접근할 필요가 있으므로 이는 큰 문제가 되지 않는다. 이와 같이 물품 선택 명령을 '보내는' 과정은 주문 처리에서 창고 서비스로 API 호출이 수행된다는 사실을 의미한다.  

대안으로, 주문 처리에서 창고가 소비하도록(consume) 이벤트를 발생시키는 방식도 가능하다. 창고가 소비하는 이벤트를 발생시키는 방식으로, 종속성을 효과적으로 뒤집을 수 있다. 우리는 주문 전송 과정을 보증하기 위해, (창고 서비스에 의존하는) 주문 처리 서비스로부터 (주문 처리 서비스에서 오는 이벤트를 수신하는) 창고 서비스로 초점을 이동한다. 2가지 접근법 모두 고유한 장점이 있으며, 우리의 선택은 아마도 주문 처리 로직과 창고 서비스에서 캡슐화된 기능 간의 상호작용에 대한 이해에 달려 있을 것이다. 이에 관해서는 도메인 모델링에서 도움을 얻을 수 있다.  

기본적으로, 창고 서비스가 작업을 수행하려면 주문에 대한 몇 가지 정보가 필요하다. 이런 수준의 도메인 결합도를 피할 수는 없다. 그러나 우리가 공유하려는 개념이 무엇인지, 또 그 개념을 어떻게 공유해야 하는지를 신중하게 생각한다면 결합도 수준을 줄이려는 목표를 달성할 수 있다.  

#### 1.4. 더도 덜도 아닌 딱 도메인 주도 설계  
<br/>

프로그램 자체가 운영될 실제 세계를 우리 프로그램이 더 잘 표현하기를 원하는 욕구는 새롭지 않다. 시뮬라(Simula) 같은 객체 지향 프로그래밍 언어는 실제 도메인을 모델링할 수 있게 개발되었다. 그러나 이런 개념이 실제로 형태를 갖추려면 프로그램 언어 기능을 넘어서는 뭔가가 필요하다.  

##### 1.4.1. 집계  
<br/>

도메인 주도 설계에서 집계(aggregate)는 다소 혼란스러운 개념이며, 다양한 정의가 존재한다. 집계는 단순히 임의의 객체 모음일까? 데이터베이스에서 꺼내야 하는 가장 작은 단위는 무엇일까? 집계는 실제 도메인 개념의 표현으로 간주하는 모델로 사용되어 왔다. 주문, 송장, 재고 물품 등과 같은 요소로 생각해보자. 집계는 일반적으로 수명주기가 있으므로 상태 머신(state machine)으로 구현할 수 있다. 우리는 집계를 독립된 단위로 취급하기를 원한다. 우리는 집계의 상태 전이를 처리하는 코드를 상태 자체와 함께 그룹으로 묶기를 원한다.  

집계와 마이크로서비스를 생각해보면, 단일 마이크로서비스는 하나 이상의 다양한 집계의 수명주기와 데이터 저장소를 처리할 것이다. 다른 서비스의 기능이 이와 같은 집계 중 하나를 변경하려는 경우, 해당 집계의 변경을 직접 요청하거나, 집계 자체를 시스템의 다른 구성 요소에 반응시켜서 시스템 자체의 상태 전환을 개시해야 한다.  

여기서 이해해야 할 핵심은 외부 시스템이 집계 내의 상태 전이를 요청하면 집계가 거절할 수 있다는 사실이다. 이상적으로는 불법적인 상태 전환이 불가능한 방식으로 집계를 구현하고자 한다.  

집계는 다른 집계와 관련이 있을 수도 있다. 하나 이상의 주문과 관련된 고객 집계가 있다. 우리는 고객과 주문을 별도의 집계로 모델링하기로 결정했으며, 각각 다른 서비스에서 처리할 수 있다.  

시스템을 집계로 분해하는 방법은 많으며, 몇몇 선택은 아주 주관적이다. 시간이 지나면, 성능상의 이유 또는 구현의 편의를 위해 집계를 재구성하기로 결정할 수도 있다. 하지만 나는 처음 시작할 때는, 구현 문제를 부차적인 것으로 생각하고, 처음에는 다른 요소가 작동할 때가지 시스템 사용자의 멘탈 모델(mental model)을 초기 설계에 대한 지침으로 삼는다. 비개발자 동료의 도움을 받아 이런 도메인 모델을 구성하는 데 도움이 되는 협업 방식의 일환인 이벤트 스토밍(Event Storming)이 있다.  

##### 1.4.2. 경계 컨텍스트  
<br/>

+ 경계 컨텍스트(bounded context)  
일반적으로 조직 내부의 더 큰 조직적인 경계(organizational boundary)  

해당 경계 내에서 명시적인 책임이 수행돼야 한다. 이 개념은 다소 혼란스럽기에, 구체적인 예를 하나 살펴보겠다.  

창고는 주문 배송 관리(그리고 반품 관리), 새로운 재고 수취, 지게차 트럭들의 분주한 이동 등이 일어나는 활동의 중심이다. 재무 부서는 아마 별로 재미가 없는 곳이겠지만, 조직에서는 여전히 급여 처리, 선적 비용 지불 등 중요한 기능을 수행한다.  

경계 컨텍스트는 구현 세부사항을 숨긴다. 여기에는 내부적인 고려사항이 있다. 예를 들어, 어떤 종류의 지게차가 쓰이는지는 창고 직원 이외의 다른 사람에게는 거의 관심을 끌지 못한다. 이런 내부적인 고려사항은 외부 세계로부터 숨겨져 있어야 마땅하다. 다른 사람들이 알 필요도 없으며 신경을 써서도 안 된다.  

구현 관점에서 경계 컨텍스트는 집계(aggregate)를 하나 이상 포함한다. 일부 집계들은 경계 컨텍스트 외부로 공개될 수도 있으며, 또 다른 집계들은 내부적으로 숨겨져 있을지도 모른다. 집계와 마찬가지로, 경계 컨텍스트는 다른 경계 컨텍스트들과 서로 관계가 있을 수도 있다. 서비스에 매핑될 때 이런 종속성은 서비스 간 종속성이 된다.  

##### 1.4.3. 집계와 경계 컨텍스트를 마이크로서비스에 매핑  
<br/>

집계와 경계 컨텍스트는 외부의 더 넓은 시스템과 상호작용하기 위해 잘 정의된 인터페이스로서 응집력의 단위를 제공한다. 집계는 우리 시스템에서 단일 도메인 개념에 중점을 둔 독자적인 상태 시스템으로, 관련된 집계의 집합을 표현하는 경계 컨텍스트와 함께 여기서도 더 넓은 세계에 대한 명시적 인터페이스를 제공한다.  

따라서 집계와 경계 컨텍스트 모두 서비스 경계(service boundary)로 작동할 수 있다. 처음에 이미 언급했듯이, 시작하자마자 여러분은 서비스의 수를 줄이고 싶을 것이다. 결과적으로, 아마도 전체 경계 컨텍스트를 포괄하는 서비스를 대상으로 삼아야 마땅할 것이다. 경험을 통해 얻은 확신을 바탕으로, 이런 서비스를 더 작은 서비스로 분해하기로 결정하게 되면, 집계 경계(aggregate boundary)를 중심으로 분할하는 방법을 모색하자.  

심지어 나중에 전체 경계 컨텍스트를 모델링하는 서비스를 더 작은 서비스로 분할하기로 결정한 경우에도 컨슈머에게 더 조밀한 수준의 API를 제공하는 방식으로 이와 같은 결정을 여전히 외부 세계에 숨길 수 있는 기법이 존재한다. 서비스를 더 작은 부분으로 분해하는 결정은 구현(implementation) 결정이 될 가능성이 높으므로, 가능하다면 숨기는 편이 나을지도 모른다!  

#### 1.5. 정리  
<br/>

마이크로서비스는 비즈니스 도메인을 중심으로 모델링한 독자적으로 배포가 가능한 서비스다. 마이크로서비스는 네트워크를 통해 서로 통신한다. 우리는 도메인 주도 설계와 함께 정보 은닉 원칙을 사용해 독립적으로 작업하기 쉽도록 경계가 안정적인 서비스를 만들며, 다양한 형태의 결합도를 줄이기 위해 최선을 다한다.  

### 2. 마이그레이션 계획하기  
<br/>

#### 2.1. 목표 이해하기  
<br/>

마이크로서비스는 목표가 아니다. 마이크로서비스로는 '승리'하지 못한다. 마이크로서비스는 아키텍처 채택은 합리적인 의사결정에 기반한 의도적인 결정이어야 한다. 현재 기존 시스템 아키텍처로는 이룰 수 없는 뭔가를 달성하기 위해, 마이크로서비스 아키텍처로 마이그레이션하는 전략을 고려해야 한다.  

성취하고자 하는 목표를 다루지 않은 상태로, 어떤 옵션을 선택할지에 대한 의사결정 과정을 어떻게 알릴 텐가? 마이크로서비스를 도입해서 달성하려는 목표는 시간을 들여 집중할 곳과 노력을 투입하기 위해 우선순위를 정하는 방식에 크게 영향을 미칠 것이다.  

이를 통해, 선택 과정 중에 과중한 부담을 겪는 분석 마비의 희생자가 되는 상황을 피할 수 있다. 또한 "마이크로서비스가 넷플릭스에 적합하다면, 우리에게도 좋다."라고 단순하게 가정한다면, 화물 숭배 신앙에 빠질 위험도 있다.  

마이크로서비스를 사용하는 이유에 대한 관점이 명확하지 않은 문제는 다양한 형태로 나타난다. 직접적으로는, 더 많은 인력이나 자금을 추가 투입하기 위한 면에서, 또는 전환 작업의 우선순위 변경 또는 기능 추가 면에서 상당한 투자가 필요할 수 있다. 전환의 결실을 보는 데까지 시간이 걸릴 수 있다는 사실 때문에 문제는 더욱 복잡해진다. 때로 사람들이 일 년 이상 전환작업을 진행하면서도 막상 자신이 처음에 왜 그 일을 시작했는지 기억조차 못 하는 상황으로 이어진다. 단순히 매몰 비용 오류라는 문제가 아니라, 실상 사람들은 자신이 작업을 수행하는 이유를 알지 못한다.  

이와 함께 사람들로부터 마이크로서비스 아키텍처로의 전환 시 투자 수익률(ROI)을 공유해달라는 요청을 받는다. 심지어 마이크로서비스를 고려해야 하는 이유를 뒷받침하는 확실한 정보와 숫자를 원하는 이들도 있다. 이에 대한 자세한 연구가 거의 존재하지 않는다는 현실과는 별개로, 심지어 연구 결과가 존재하더라도, 사람마다 각자 처한 상화잉 다르기 때문에 특정 사례를 연구해서 나온 결론은 다른 사례에서 거의 활요이 불가능하다.  

그렇다면 여기서 시사하는 바는 무엇이겠는가? 글쎄, 이는 쉽지 않다. 개발, 기술, 아키텍처 선택의 효용성에 대한 더 나은 연구를 할 수 있고, 또한 해야 마땅하다고 확신한다. 이미 데브옵스 상태 보고서(http://bit.ly/2ojVq5o) 같은 몇몇 연구 결과가 나왔지만, 아키텍처는 간략하게 짚고 넘어가버린다. 이런 엄격한 연구 대신에, 우리는 의사결정 과장에 더 비판적인 사고를 적용하기 위해 노력해야 하며, 동시에 실험을 위해 마음의 창을 더 크게 열어야 한다.  

달성하고자 하는 목표를 명확하게 이해하자. 기대하는 수익이 무엇인지를 적절히 평가하지 않으면 ROI를 계산할 수 없다. 독단적인 접근 방식을 고수하지 말고, 성취하기를 희망하는 결과에 집중할 필요가 있다. 심지어 낡고 고루한 예전의 접근 방식으로 돌아갈지라도, 우리가 필요한 것을 얻는 가장 좋은 방법에 대해 현명하게 생각할 필요가 있다.  

#### 2.1.1. 3가지 핵심 질문  
<br/>

마이크로서비스 아키텍처 채택을 고려하는 회사와 일할 때 나는 다음과 같은 질문을 던진다.  

+ 무엇을 성취하기를 바라는가?  
이 질문에 대한 답은 비즈니스가 달성하려는 목표에 연계된 일련의 결과여야 하며, 시스템의 최종 사용자에게 혜택을 기술하는 방식으로 표현할 수 있다.  

+ 마이크로서비스 사용에 대한 대안을 고려했는가?  
나중에 살펴보겠지만, 때로는 마이크로서비스가 제공하는 몇 가지 이점을 달성하기 위한 다른 방법도 존재한다. 이와 같은 대안을 살펴봤는가? 그렇지 않다면, 살펴보지 않은 이유는 무엇인가? 훨씬 수월하면서도 훨씬 따분한 기술을 사용해, 여러분이 요구하는 바를 성취할 수 있는 경우도 제법 많다.  

+ 전환이 작동하고 있는 어떻게 알 수 있나?  
전환에 착수하기로 결정한 경우, 올바른 방향으로 가고 있는지를 알 수 있는 방법은 무엇일까?  

#### 2.2. 왜 마이크로서비스를 선택하려 하는가?  
<br/>

##### 2.2.1. 팀 자율성 향상  
<br/>

자율 팀을 만드는 이점을 입증한 조직들은 많았다. 이들 조직은 조직 내 그룹을 작게 유지하며, 긴밀한 유대 관계를 구축하고, 관료 절차에 얽매이지 않고 협업함으로써, 그렇지 않은 조직에 비해 더 효과적으로 성장하고 확장해왔다. 소규모 비즈니스 부서가 성공하려면, 자율 부서로 작업할 수 있는 권한과 책임이 부여되어야 한다.  

자율성은 더 작은 규모에서도 작동한다. 나와 함께 일하는 대다수 현대적인 조직은 때론 아마존의 '피자 두 판의 법칙' 또는 스포티파이(Spitify) 모델과 같은 여러 기업의 모델을 모방하는 등 조직 내에서 더 많은 자율적 팀을 만들고자 노력한다.  

제대로만 작동한다면, 팀 자율성은 구성원에게 힘을 실어주고 성장시키며, 더 빠른 업무 처리를 돕는다. 팀이 마이크로서비스를 소유하고 해당 서비스를 완전히 제어할 수 있으면, 더 큰 조직내애서 발휘할 수 있는 자율성의 범위 또한 증가한다.  

###### 2.2.1.1. 대안은 없을까?  
<br/>

자율성(책임 분배)은 여러 방식으로 풀어낼 수 있다. 더 많은 책임을 팀에 부여하겠다고 아키텍처를 전환할 필요까진 없다. 그러나 본질적으로 자율성이란 팀에 어떤 책임을 부여할 수 있는지 파악하는 과정이며 여러 방식으로 풀어낼 수 있다. 코드 기반의 일부에 대한 소유권을 다른 팀에 부여하는 것은 하나의 해답이 될 수 있다(모듈식 모놀리스는 여전히 이 과정에 도움이 될 수 있다). 이는 또한 기능적인 배경에서 코드 기반의 일부를 결정할 권한이 있는 사람들을 식별함으로써 수행될 수도 있다(예: 디스플레이 광고를 가장 잘 아는 라이언이 이에 대해 책임을 진다. 제인은 쿼리 성능 조율을 가장 잘 알기 때문에 해당 분야에 제인을 제일 먼저 투입해야 한다).  

자율성이 향상되면, 남이 도와줄 때까지 기다릴 필요가 없다. 따라서 컴퓨터 또는 환경을 프로비저닝하기 위한 셀프 서비스 접근 방식은 큰 도움이 되며, 중앙 운영 팀 또한 일상적인 활동 과정에서 티켓을 처리할 필요가 없어진다.  

##### 2.2.2. 시장 출시 시간 단축  
<br/>

개별 마이크로서비스에 대해 변경하고, 조정된 릴리스를 기다릴 필요 없이 이러한 변경사항을 배포함으로써, 고객에게 더 신속하게 기능을 제공할 수 있게 된다. 더 많은 사람이 미리 문제를 겪게 해서 더 큰 문제가 일어나지 않게 막는 것도 중요한 요소이다.  

###### 2.2.2.1. 대안은 없을까?  
<br/>

소프트웨어를 더 빨리 출시하는 방법을 고려할 때 작용하는 변수는 매우 많다. 일종의 제작 경로(path-to-production) 모델링 연습을 수행할 것을 추천하는데, 이 과정에서 가장 큰 방해 요인은 우리가 생각하는 바와 다르다는 사실을 깨우치기도 하기 때문이다.  

소프트웨어 출시와 관련된 모든 단계를 생각해보자. 각 단계별 소요 시간(경과 시간과 일이 몰리는 시간 모두)을 확인하고, 그 과정에서 고충이 발생하는 지점에 주목하자. 이 과정을 모두 거치고 나면 마이크로서비스가 해결책이 될 수도 있다는 사실을 잘 알게 될 테지만, 병렬로 시도해볼 수 있는 다른 많은 방법도 찾게 될 것이다.  

##### 2.2.3. 부하를 다루기 위한 비용 효율적인 확장  
<br/>

프로세스는 개별 마이크로서비스로 분리해서 독립적으로 확장할 수 있다. 이는 비용 효율적으로 확장할 수 있다는 의미이기도 하다. 지금 당장은 부하를 다루는 과정에서 병목으로 작용하는 프로세스 부분에만 초점을 맞춰 확장할 필요가 있다. 또한 그러고 나서 부하가 적은 마이크로서비스는 축소할 수 있으며, 심지어 필요하지 않을 때는 서비스를 꺼도 무방하다. SaaS 제품을 구축하는 많은 회사가 마이크로서비스 아키텍처를 채택해 운영 비용을 더욱 효과적으로 통제할 수 있는 이유가 바로 여기에 있다.  

###### 2.2.3.1. 대안은 없을까?  
<br/>

여기에는 고려해야 할 수많은 대안이 있으며, 대부분은 마이크로서비스 지향 접근 방식보다 실험하기가 더 쉽다. 시작 과정에서 성능이 더 좋은 컴퓨터를 확보할 수 있으며, 퍼블릭 클라우드 또는 다른 유형의 가상화 플랫폼을 사용하는 경우 간단히 더 큰 자원을 프로비저닝해 여기서 프로세스를 실행할 수 있다. 이와 같은 '수직' 확장에는 분명히 한계가 있지만, 빠른 단기 개선을 추구한다면 무조건적으로 수직 확장을 무시해서는 안 된다.  

기본적으로 여러 사본(copy)을 실행하는 기존 모놀리스의 전통적인 수평 확장이 효과가 더 뛰어나다는 사실은 쉽게 증명할 수 있다. 로드 밸런서 또는 큐와 같은 부하 분배 매커니즘 뒤에 모놀리스의 여러 사본을 실행하면 더 많은 부하를 간단하게 처리할 수 있지만 사용하는 기술에 따라 병목 현상이 데이터베이스에 있는 경우에는 이런 확장 매커니즘은 도움이 안 될 수도 있다. 시도하기 쉬운 방식인 수평 확장은 마이크로서비스를 고려하기에 앞서 적합성을 신속하게 평가할 수 있으며, 완전한 마이크로서비스 아키텍처보다 단점도 훨씬 더 적기 때문에 시도해봐야 한다.  

현재 사용 중인 기술의 경우, 부하를 더 잘 처리할 수 있는 대안 기술로 대체할 수도 있다. 그러나 이는 일반적으로 쉽게 수행할 만큼 사소한 작업이 아니다. 기존 프로그램을 새로운 유형의 데이터베이스나 프로그래밍 언어로 이식하는 작업을 고려해보자. 마이크로서비스로의 전환을 통해 실제로 마이크로서비스 내에서만 사용되는 기술을 변경하고 나머지는 그대로 두어 변경의 영향을 줄일 수 있기 때문에, 이식 작업이 사실상 더 쉬워질 것이다.  

##### 2.2.4. 견고성 향상  
<br/>

단일 테넌트 소프트웨어에서 다중 테넌트 SaaS 애플리케이션으로의 이동은 시스템 중단의 영향이 훨씬 더 광범위해질 수 있음을 의미한다. 오늘날 소프트웨어의 중요성은 물론이고 소프트웨어 가용성에 대한 고객의 기대치도 높아졌다. 애플리케이션을 독립적이고 개별적으로 배포 가능한 프로세스로 분해함으로써, 애플리케이션의 견고성을 향상시킬 수 있는 다양한 메커니즘을 가속화할 수 있다.  

마이크로서비스를 사용하면 기능이 분해되기 때문에 더욱 견고한 아키텍처를 구현할 수 있다. 즉 기능의 한 영역에 미치는 영향으로 인해 전체 시스템을 중단할 필요가 없다. 또한 견고성을 가장 많이 요구하는 애플리케이션의 특정 부분에 시간과 에너지를 집중함으로써 시스템의 중요한 부분이 계속 작동하게 만들 수 있다.  

+ 견고성(robustness)  
예상되는 변화에 반응할 수 있는 시스템을 갖추는 능력  

+ 회복탄력성(resilience)  
예기치 못한 상황에 적응할 수 있는 조직을 구성하고 조직이 모든 잠재적 문제를 예상할 수 없다는 사실에 스스로 대비하는 과정으로서, 여기에는 카오스 엔지니어링(chaos engineering)과 같은 기법을 통해 '실험하는 문화(culture of experimentation)'를 만드는 것도 포함될 수 있다.  

여기서 중요한 고려사항은 마이크로서비스가 반드시 견고성을 무상으로 제공하지는 않는다는 사실이다. 그보다는 네트워크 분할, 서비스 중단 등을 더 잘 견딜 수 있는 방식으로, 시스템을 설계할 수 있는 기회를 열어 놓는다. 여러 개별 프로세스와 개별 컴퓨터에 기능을 분산시키는 것만으로는 견고성 향상을 보장할 수 없다. 정반대로, 장애가 발생하는 지점만 늘어날 뿐이다.  

###### 2.2.4.1. 대안은 없을까?  
<br/>

아마도 로드 밸런서 또는 큐 같은 부하 분배 메커니즘 뒤에 모놀리스의 여러 사본을 실행하는 방식으로 시스템에 중복성을 추가한다. 또한 모놀리스 인스턴스를 여러 장애 평면에 분산시켜(예를 들면 모든 서버를 동일 렉 또는 동일 데이터 센터에 배치하지 않는 등) 애플리케이션의 견고성을 더욱 향상시킬 수 있다.  

좀 더 안정적인 하드웨어와 소프트웨어에 대해 투자한다면, 현존하는 시스템 중단 원인을 철저히 조사하는 것만큼의 이익을 거둘 수 있다. 만약 애플리케이션의 견고성이 실수를 결코 저지르지 않으리라는 인간에만 의존하려 한다면, 위험한 상황에 빠지게 된다.  

##### 2.2.5. 개발자 수 늘리기  
<br/>

경계를 명확하게 긋고 마이크로서비스가 상호 결합도를 제한하게 초점을 맞춘 아키텍처를 통해 우리는 독립적으로 작업 가능한 코드를 만들어낸다. 따라서 배포 경합(delivery contention)을 줄임으로써 개발자 수를 늘리기를 원한다.  

문제에 집중하는 개발자 수를 성공적으로 늘리려면, 팀 간에 상당한 수준의 자율성이 필요하다. 단순히 마이크로서비스만으로는 충분하지 않을 것이다. 팀을 서비스 소유권에 맞춰 어떻게 정돈할지, 그리고 팀 간에 어떤 조정이 필요한지 생각해야 할 것이다. 또한 작업을 제대로 분할함으로써, 수많은 서비스 사이에서 변경사항 조정이 필요하지 않게 만들어야 할 것이다.  

###### 2.2.5.1. 대안은 없을까?  
<br/>

마이크로서비스는 그 자체로 독립적으로 작업할 수 있는, 결합도가 약한 기능의 조각이므로 규모가 더 큰 팀에 적합하다. 대안으로 모듈식 모놀리스 구현을 고려할 수도 있다. 즉 다양한 팀이 각각 모듈을 소유하고 다른 모듈과 연동하는 인터페이스가 안정적으로 유지되기만 한다면, 격리된 상태에서 계속 자신의 모듈을 변경할 수 있다.  

그러나 이 방법은 다소 제한적이다. 여전히 여러 팀 간에 경합이 발생한다. 아직 소프트웨어는 하나로 묶여서 배포되기 때문에 여러 이해당사자 사이에 조율이 필요하다.  

##### 2.2.6. 신기술 수용  
<br/>

모놀리스는 일반적으로 기술 선택을 제한한다. 통상적으로 백엔드에는 하나의 프로그래밍 관례를 사용하는 하나의 프로그래밍 언어만 적용된다. 또한 배포 플랫폼도 하나, 운영체제도 하나, 데이터베이스 유형도 하나만 쓰게 고정되어 있다. 그러나 마이크로서비스 아키텍처를 사용하면 각 서비스마다 선택지가 다양해질 수 있다.  

서비스 경계에서 기술 변화를 분리함으로써 우리는 격리된 상태에서 새로운 기술의 장점을 이해할 수 있고, 이런 기술이 문제로 판명될 경우에 미치는 영향을 제한할 수 있다.  

성숙도가 높은 마이크로서비스 조직은 지원하는 기술 스택 수를 제한하지만, 사용 중인 기술이 천편일률적일 경우는 드물다. 신기술을 안전한 방법으로 시도할 수 있는 유연성을 통해 조직은 경쟁 우위를 접할 수 있다. 고객에게 더 나은 결과를 제공하는 동시에 개발자는 새로운 기술에 숙달하게 되어 행복감을 느낄 수 있기 때문이다.  

###### 2.2.6.1. 대안은 없을까?  
<br/>

소프트웨어를 단일 프로세스로 계속 출시하는 경우, 도입 가능한 기술에는 제한이 있다. 물론 동일한 실행 환경에서도 새로운 언어를 안전하게 채택할 수 있다. 예를 들어 JVM은 동일한 실행 프로세스 내부에서 여러 언어로 작성된 코드를 적절히 호스팅할 수 있다. 그러나 새로운 유형의 데이터베이스는 더욱 문제가 되는데, 점진적인 마이그레이션을 가능하게 만들기 위해 이전의 모놀리스 데이터 모델을 분해하기 때문에 새로운 데이터베이스 기술로 완전하고 즉각적으로 전환하지 않는 이상, 복잡하고 위험하다.  

+ 불타는 플랫폼(burning platform)  
일반적으로 수명 종료로 간주되는 기술을 나타내는 데 사용한다. 해당 기술에 대한 지원을 받기가 너무 어렵거나 비용이 많이 들며, 관련 경험이 있는 직원을 고용하기가 너무 어려울 수도 있다. 대다수 조직에서 불타는 플랫폼으로 여기는 기술의 일반적인 예는 코볼(COBOL) 메인프레임 애플리케이션이다.  

현재 기술 스택이 '불타는 플랫폼'으로 간주되는 경우, 제대로 지원되는 최신 기술 스택으로 교체하는 방법 이외에 다른 선택지가 없을지도 모른다. 물론 기존 모놀리스를 새로운 모놀리스로 점진적으로 대체하는 것은 누구도 막을 수 없으며, 교살자 무화과(Strangler Fig) 패턴 등은 이런 상황에서 제대로 작동할 수 있다.  
  
마이크로서비스 마이그레이션에서 가장 자주 언급되는 목표 중 하나로, 애초에 형편없는 목표이다. 기본적으로 재사용은 사람들이 원하는 직접적인 결과가 아니다. 재사용은 사람들이 희망하는 다른 혜택으로 이어질 것이다. 우리는 재사용을 통해 기능을 더 신속하게 제공하거나 비용을 절감할 수 있기를 원한다. 그러나 재사용이 간접적으로 제공하는 신속한 기능 제공이나 비용 절감이 진짜 목표인 경우, 재사용 대신 진짜 목표를 추적하지 않으면 잘못된 것을 최적화하면서 끝나버린다.  

이 말이 무슨 뜻인지 이해하기 위해, 재사용이 목표로 선택되는 일반적인 이유 하나를 자세히 살펴보겠다. 우리는 기능을 더 빨리 제공하고 싶어 한다. 기존 코드 재사용에 대한 개발 프로세스를 최적화함으로써 많은 코드를 작성하지 않아도 되고, 작업이 줄었으니 소프트웨어를 더 신속하게 출시할 수 있다고 생각한다. 그렇지 않은가? 그러나 간단한 예를 들어보자. 고객 서비스 팀은 고객 송장 용도로 PDF 서식을 만들어야 한다. 시스템의 다른 부분에서는 이미 PDF 생성 작업을 처리한다. 즉 우리는 고객에게 배송될 주문을 위한 포장 전표를 만들고, 공급 업체에 주문 요청을 보내기 위해 인쇄용 PDF를 창고에서 만든다.  

재사용 목표에 따라, 우리 팀은 기존 PDF 생성 기능을 사용하라고 지시를 받을 수도 있다. 그러나 이 기능은 현 조직 내 타 부서 팀이 관리 중이다. 따라서 이제 이 기능 지원을 위해 필요한 변경을 수행하려면 그들과 협력해야 한다. 이는 그 팀에게 우리를 위해 일해달라고 요구해야 한다거나, 아니면 우리가 직접 변경해서 풀 요청(pull request)을 제출해야(회사 개발 업무가 이런 식으로 작동한다고 가정) 한다는 의미다. 어느 쪽이든 우리는 조직 내 다른 부문과 협력해서 변경 작업을 수행해야 한다.  

우리는 시간을 들여 다른 사람들과 협력해 변경을 이끌어내고, 결국 변경사항을 배포할 수 있었다. 그러나 우리는 독자적인 코드르 직접 작성하는 방법으로도 기존 코드를 수정하는 방법보다 훨씬 더 빠르게 고객에게 기능을 출시하도록 일을 풀어갈 수 있음을 깨달았다. 실제 목표가 시장 출시 시기 단축이라면 그렇게 하는 것이 더 올바른 선택일 수 있다. 그러나 시장 출시 시기를 더 단축할 목적으로 재사용을 위해 프로세스를 최적화한다면 작업 진행이 느려지는 결과를 낳을지도 모른다.  

복잡한 시스템에서 재사용 결과를 측정하기란 어렵고, 앞서 개괄한 것처럼 재사용은 일반적으로 다른 뭔가를 달성하기 위해 수행하는 작업이다. 그보다는 실제 목표에 집중하는 데 노력을 쏟고, 재사용이 항상 정답은 아닐 수도 있다는 사실을 인식하자.  

#### 2.3. 마이크로서비스는 어떤 경우에 나쁜 선택일까?  
<br/>

##### 2.3.1. 불분명한 도메인  
<br/>

서비스 경계를 잘못 잡으면 많은 비용이 들 수도 있다. 이로 인해 잦은 서비스 변경이나 과도하게 결합된 구성 요소가 발생할 수 있으며, 단일 모놀리스 시스템을 사용하는 경우보다 더 나빠질 수도 있다.  

도메인이 낯선 경우, 너무 조기에 시스템을 마이크로 서비스로 분해하면 높은 비용이 발생할 수 있다. 기존 코드 기반을 마이크로서비스로 분해하는 방식이 처음부터 마이크로서비스를 시도하는 방식보다 여러 가지 면에서 훨씬 더 수월하다.  

아직 도메인을 완전히 파악하지 못했다고 생각한다면, 시스템 분해에 몰두하기보다는 도메인부터 해결하는 쪽이 바람직할 것이다. (도메인 모델링을 수행해야 하는 또 다른 이유가 있다!)  

##### 2.3.2. 스타트업  
<br/>

마이크로서비스는 최소한 제품/시장 적합성의 기초를 확립해왔고 이제는 수익성을 높일 목적으로 (또는 쉽게 달성하기 위해) 확장에 나서는 '수직 확장(scale-up)'을 위한 훌륭한 선택지가 될 수 있다.  

수직 확장까지 갈 길이 먼 스타트업은 고객과 맞아 떨어지는 적합성을 찾기 위해 다양한 아이디어를 실험하곤 한다. 이로 인해 영역을 탐색할 때 제품의 원래 비전에 큰 변화가 생기고, 결과적으로 제품 도메인에도 큰 변화가 일어날 수 있다.  

진짜 스타트업은 자금이 제한적인 소규모 조직일 가능성이 높으며, 제품을 위해 올바른 적합성을 찾는 과정에 관심을 집중할 필요가 있다. 마이크로서비스는 일단 스타트업이 고객 기반에 적합하다고 판명한 문제를 주로 해결한다. 다시 말해, 마이크로서비스는 스타트업으로 초기에 성공하고 난 뒤에 발생할 수 있는 다양한 문제를 해결하는 훌륭한 방법이다. 처음에는 성공에 집중해야 한다! 초기 아이디어가 나쁘다면, 마이크로서비스로 구축했는지 아닌지 여부는 전혀 중요하지 않다.  

완전히 새로운 미개발 시스템에서 시작하는 것보다 기존의 '재개발 가능한' 시스템을 분해하는 편이 훨씬 더 쉽다. 여러분은 이런 재개발 가능한 시스템으로 더 많은 일을 해야 한다. 여러분에게는 검사할 수 있는 코드가 있으며, 시스템을 사용하고 유지 관리하는 사람들과 대화할 기회도 있다. 또한 여러분은 바람직한 모습이 무엇인지도 이미 안다. 즉 여러분에게는 변경 가능하며 동작 중인 시스템이 있으므로, 언제 실수를 저질렀을지, 또는 언제 의사결정 과정에서 너무 공격적이었을지를 쉽게 알 수 있다.  

여러분에게는 실제로 동작 중인 시스템도 있다. 도한 그 시스템이 어떻게 운영되며, 운영 환경에서 어떻게 동작하는지도 이해한다. 예를 들어 마이크로서비스로 분해하면 일부 고약한 성능 문제가 발생할 수 있지만, 재개발 가능한 시스템에서는 잠재적으로 성능에 영향을 미치는 변경을 수행하기에 앞서 정상적인 기준을 수립할 수 있다.  

"스타트업은 마이크로서비스를 절대로 도입하지 말라."는 의미가 아니라, 이런 요인들이 있으니 반드시 유의해야 한다는 말이다. 처음에는 분명한 경계를 중심으로만 분할하고 나머지는 모놀리스로 남겨둬야 한다. 이를 통해 운영 관점에서 얼마나 성장했는지 평가할 수 있는 시간을 벌 수 있을 것이다. 만약 마이크로서비스와 모놀리스라는 서비스 2개도 관리하기 버겁다면, 마이크로서비스 10개를 관리하는 일은 더 어려울 것이다.  

##### 2.3.3. 고객 설치형 소프트웨어와 관리형 소프트웨어  
<br/>

소프트웨어 패키지로 만들어서 직접 운영할 고객에게 출시할 경우, 마이크로서비스는 나쁜 선택일지도 모른다. 마이크로서비스 아키텍처로 마이그레이션을 하면 운영 도메인에 많은 복잡성이 추가된다. 모놀리스 배포를 모니터링하고 문제를 해결하는 데 사용했던 기존 기술은 새 분산 시스템에서 제대로 작동하지 않을 수도 있다. 이제 마이크로서비스로 마이그레이션에 나선 팀은 새로운 역량을 채택하거나 아니면 새로운 기술을 채택함으로써 이런 문제를 해소하려 들지만, 이는 일반적으로 최종 고객에게 기대할 수 있는 성격이 아니다.  

일반적으로 고객 설치형 소프트웨어는 특정 플랫폼을 목표로 삼는다. 예를 들어 '윈도우 2016 서버 필요' 또는 '맥OS 10.12 이상 요구' 등은 잘 정의된 목표 배포 환경이며, 여러분은 이런 시스템(윈도우 서비스, 윈도우 설치 패키지 번들 등)을 관리하는 이들이 잘 이해할 수 있는 메커니즘을 활용해 십중팔구 여러분의 모놀리스 시스템을 패키징하고 있을 것이다. 여러분의 고객은 이런 방식으로 소프트웨어를 구매하고 실행하는 과정에 익숙할 것이다.  

고객에게 실행하고 관리할 프로세스를 1개만 제공했는데, 이후에 확장을 위해 10개 또는 20개로 늘어나고 난 뒤 여러분이 겪을 어려움을 상상해보자. 아니면 더 적극적으로, 고객들이 쿠버네티스 클러스터 또는 이와 유사한 환경에서 소프트웨어를 실행할 것으로 기대하는가? 현실을 말하자면 마이크로서비스 아키텍처를 관리하기 위해 사용 가능한 기술이나 플랫폼을 고객에게 기대할 수 없다. 심지어 고객에게 기술적인 역량이 있을지라도, 요구하는 동일 기술이나 플랫폼은 없을 수도 있다. 예를 들어 쿠버네티스 설치만 해도 각 경우마다 차이가 크다.  

##### 2.3.4. 좋은 이유를 못 찾겠다!  
<br/>

마지막으로, 마이크로서비스를 채택하지 않은 가장 큰 이유는 바로 마이크로서비스로 달성하려는 목표가 정확히 무엇인지에 대해 아무 생각이 없기 때문이다. 마이크로서비스 채택 과정에서 추구하려는 성과를 통해 마이그레이션을 어디서 시작하고 시스템 분해를 어떻게 할지를 정의할 수 있다. 목표에 대한 명확한 비전 없이, 어둠 속에 머뭇거리고 있다. 모든 사람이 마이크로서비스를 하기 때문에 따라 한다는 생각은 끔찍할 뿐이다.  

#### 2.4. 균형 조정  
<br/>

현실에서는 사람들이 흔히 한 가지가 아니라 여러 가지를 동시에 바꾸려고 시도한다. 이로 인해, 필요한 변경 범위가 빠르게 늘어나고 혜택을 보는 시점을 지연시킬 수 있는 우선순위 혼동이 발생한다.  

이 모든 것은 순수하게 시작된다. 늘어나는 트래픽 증가를 처리하기 위해 애플리케이션의 아키텍처를 새롭게 구성해야 하고, 마이크로서비스가 앞으로 나아갈 길을 결정해야 한다. 누군가가 "만약 마이크로서비스를 채택한다면 즉시 우리 팀의 자율성을 더 높일 수 있을 겁니다!"라고 말한다. 또 다른 사람이 "동시에, 코틀린을 프로그래밍 언어로 시도해 볼 수 있는 좋은 기회도 될 겁니다!"라고 맞장구를 친다. 순식간에 여러분은 팀에 자율성을 부여하고, 애플리케이션을 확장하고, 새로운 기술을 모두 한 번에 도입하는 거대한 변화의 여정을 시작한다. 덤으로, 작업 중인 프로그램에 사람들이 숟가락을 얹기 시작한다.  

게다가 이 상황에서는 마이크로서비스가 유일한 접근 방식으로 굳어져버린다. 확장성 측면에만 중점을 두면, 마이그레이션 과정에서 기존 모놀리스 애플리케이션을 수평으로 확장하는 편이 더 좋다는 사실을 깨닫게 될지도 모른다. 그러나 그렇게 하더라도 팀 자율성을 향상시키거나 코틀린을 프로그래밍 언어로 도입하려는 새로운 부차적인 목표에는 전혀 도움이 되지 않는다.  

따라서 원하던 부차적인 혜택과 변화 이면의 핵심 동인을 분리하는 것이 중요하다. 이 경우에는 애플리케이션의 개선된 확장을 처리하는 것이 가장 중요하다. (팀 자율성 향상과 같은) 부차적인 목표들을 위해 행해진 작업이 유용할 수도 있으나, 그것이 핵심 목표를 방해하거나 주의를 흩트린다면 이런 목표들은 뒤로 빠져야 마땅하다.  

여기서 일부 목표들의 중요도가 다른 목표보다 높다는 사실을 인식해야 한다. 그렇지 않으면 우선순위를 올바르게 정할 수 없다. 그렇지 않으면 우선순위를 올바르게 정할 수 없다. 내가 좋아하는 훈련이 하나 있는데, 원하는 각각의 결과를 슬라이더로 생각하는 것이다. 모든 슬라이더는 중간에서 시작된다. 한 가지 목표의 중요도를 높이면 다른 목표의 우선순위를 내려야 한다. 일례로 여러 개발 연어를 사용하는 폴리글랏(polyglot) 프로그래밍을 더 쉽게 만들고 싶디만, 지금은 애플리케이션의 회복탄력성을 향상시키는 목표가 더 중요할 경우를 들 수 있다. 앞으로 나아갈 방법을 알아낼 때 이런 결과를 명확하게 표현하고 순위를 매기면, 의사결정을 훨씬 더 쉽게 내릴 수 있다.  

이와 같은 상대적인 우선순위는 변경될 수 있다(그리고 더 많은 정보를 알게 될수록 변경되어야 마땅하다). 그러나 상대적인 우선순위는 의사결정을 도울 수 있다. 책임을 분산하고 새로 만든 자율적인 팀에 권한을 더 부여하려는 경우, 이와 같은 간단한 모델을 사용하면 팀 내부의 의사결정은 물론이고 전사적으로 수립한 목표에 부합하는 선택에 도움이 될 수 있다.  

#### 2.5. 사람들과 함께 여정을 떠나다  
<br/>

때로 사람들이 어떤 접근 방식에 동의하지 않을 때도 있다. 그건 여러분이 달성하려는 목표에 대해 견해가 다르기 때문일 것이다. 여러분과 여정을 함께해야 할 사람들은 반드시 여러분이 성취하려는 '목표'에 서로 공감해야 한다. 이에 대해 같은 입장이라면, 적어도 목표에 도착하는 방법에 대해서만 동의하지 않을 뿐임을 이해할 것이다. 결국 목표로 다시 돌아오기 마련이다. 즉 조직의 다른 사람들이 목표를 공유하면, 변화를 위한 여정에 참여할 가능성이 매우 높다. 실제로, 조직 변화에 도움이 되는 유명 모델 중 하나에서 착안해 어떻게 아이디어를 납득시키고 실현할지를 좀 더 자세히 살펴보면 좋을 듯하다.  

#### 2.6. 조직 변화 구현  
<br/>

필수 활동을 별개의 명료한 단계로 추출해내는 데 성공한, 존 코터(John Kotter) 박사의 조직 변화를 위한 8단계 과정은 전 세계 변화 담당 관리자들에게 각광을 받고 있다. 유일하면서 완벽한 모델이라고 할 수는 없지만, 가장 유용하다고 생각하는 모델 중 하나다.  

프로세스를 설명하는 내용은 많이 찾을 수 있을 테므로, 여기서 자세히 다루지는 않을 것이다. 그러나 마이크로서비스 아키텍처 도입을 고려한다면, 각 단계를 설명하고 우리에게 어떤 도움이 될지를 생각해봐야 한다.  

여기서 프로세스를 개괄하기 앞서, 이 변화 모델은 일반적으로 대규모 조직의 행동 변화를 유도하는 데 사용된다는 점을 알아두자. 따라서, 10명 인원인 팀에 마이크로서비스를 도입하려는 경우라면 변화 모델은 엄청난 과잉이 될지도 모른다. 하지만 심지어 이렇게 작은 조직인 경우에도 특히 초기 단계에서는 변화 모델이 유용함을 알게 됐다.  

##### 2.6.1. 위기감 조성  
<br/>

사람들은 마이크로서비스로 이전하려는 계획을 좋은 아이디어라고 생각할지도 모른다. 하지만 문제는 그 아이디어가 조직 내부에서 회자되는 수많은 좋은 아이디어 중 하나일 뿐이라는 사실이다. 지금이야말로 특별한 변화가 필요한 시점이라는 사실을 사람들이 이해하게 만드는 것이 중요하다.  

여기서 '가르칠 수 있는' 순간을 찾는 것이 도움이 될 수 있다. 오히려 소 잃고 외양간 고치는 편이 더 나을 수도 있는 이유는, 사람들이 도망친 소가 중요하다는 사실을 뒤늦게 인식하고 이제는 심지어 외양간만 봐도 "이것 봐, 이제 다 고쳐졌어!"라고 깨닫기 때문이다. 위기가 닥치고 나서야, 사람들의 의식이 깨어나는 찰나가 온다. 너무 오래 기다리면 고통도, 고통의 원인도 모두 사라지고 만다.  

"지금 마이크로서비스를 도입해야 합니다!"라는 말은 꺼내지도 말아야 한다는 사실을 명심하자. 이루고 싶은 사안에 대한 위기감을 조성하려는 시도와 다를 바 없다. 마이크로서비스는 목표가 아니다!  

##### 2.6.2. 혁신 추진체 구성  
<br/>

모든 사람을 합류시킬 필요는 없지만, 실현을 위해서는 충분한 인원의 사람들이 필요하다. 이와 같은 변화를 추진하려면, 도움을 줄 수 있는 조직 내 사람들을 파악해야 한다. 개발자라면 팀의 직속 동료나 아마도 상급자인 기술 책임자, 아키텍트 또는 배포 관리자부터 찾아보기 시작할 것이다. 변화의 수준에 따라 관여되는 인원이 많이 필요하지 않을 수도 있다. 만일 팀이 그저 사소하게 방식을 변경하는 수준이라면, 공중 엄호만으로 충분할지도 모른다. 만약 회사의 소프트웨어 개발 방식을 전반적으로 변화시키려는 경우라면, C레벨 임원진(CIO 또는 CTO)이 필요할 수도 있다.  

이런 변화를 도울 사람들을 합류시키기란 쉽지 않을 수도 있다. 자신의 아이디어가 아무리 훌륭하더고 자부하더라도, 상대방이 들어본 적 없거나 함께 일한 적이 없다면 그들이 아이디어를 뒷받침해야 할 이유가 있을까? 신뢰란 획득하는 것이다. 과거 협업해서 작지만 신속한 성공을 거둬 본 사람이라면, 원대한 이상을 후원할 가능성이 훨씬 더 높다.  

여기서, 소프트웨어 배포 과정 바깥의 외부인들을 참여시키는 것이 중요하다. 이미 'IT'와 '비즈니스' 사이의 장벽이 무너진 조직에서 일하고 있다면 별 문제가 없을 것이지만, 이런 장벽이 여전히 사일로처럼 굳건하게 존재하는 경우라면 다른 곳에서 후원자를 찾기 위해 바쁘게 운직여야 할 수도 있다. 물론, 이때 마이크로서비스 아키텍처를 채택하고자 하는 목표가 직면한 문제를 비즈니스적으로 해결하는 데 중점을 둔다면 사람들은 훨씬 더 쉽게 납득할 것이다.  

IT 사일로 바깥의 외부인들을 참여시켜야 하는 이유는, 만들어내는 수많은 변경사항이 잠재적으로 소프트웨어의 운영과 동작 방식에 중대한 영향을 미칠 수도 있기 때문이다. 예를 들어, 장애 모드에서 시스템이 작동하는 방식 또는 대시 시간을 해결하는 방식에 대해 다양한 절충안이 필요하다. 말하자면, 서비스 호출을 피하기 위해 데이터를 캐싱하는 방식은 분산 시스템에서 핵심 연산의 대기 시간을 줄이는 데는 좋은 방법이지만 시스템의 사용자가 김빠진 데이터를 보게 될지도 모르는 모순이 있다. 이렇게 하는 것이 올바른가? 아마도 사용자와 해당 문제를 논의해야 할 것이고, 조직 내부에서 사용자를 옹호하는 이들이 변화 이면에 자리잡은 근본을 이해하지 못한다면 이는 어려운 논의가 될 것이다.  

##### 2.6.3. 비전과 전략 수립  
<br/>

이제 사람들을 한데 모으고 어떤 변화를 희망하는지(비전), 그곳에 어떻게 갈 것인지(전략)에 대해 합의해야 한다. 비전은 까다롭다. 현실적이면서도 이상을 추구해야 하며, 둘 사이의 균형점을 찾는 것이 핵심이다. 비전을 더 널리 공유할수록, 사람들이 합류할 수 있게 포장하는 과정에서 더 많은 작업이 필요할 것이다. 그러나 비전이란 모호할 수 있으며, 그럼에도 소규모 팀에 적용이 가능하다(예: "버그 수를 줄여야 합니다!").  

비전은 대부분 목표와 관련이 있어서, 목표로 삼은 것이다. 전략이란 방법에 관한 것이다. 마이크로서비스는 정해진 목표를 달성할 것이다(여러분은 마이크로서비스가 전략의 일부가 될 것이라 기대한다). 전략은 변경 가능하다는 사실을 기억하자. 비전에 전념하는 것은 중요하지만, 반증에도 불구하고 특정 전략에 지나치게 몰두한다면 위험을 야기할 뿐만 아니라 심각한 매몰 비용 손실을 초래할 수 있다.  

##### 2.6.4. 변화 비전 전달  
<br/>

거대한 비전은 훌륭할 테지만, 사람들이 그 가능성을 믿지 못할 정도로 비전의 규모를 키우지는 말자.  

비전 공유는 소규모로 시작해도 좋다.  

이제 마지막 참고 사항을 정리한다. 최근 슬랙(Slack)같은 시스템이 선호됨에 따라 대면 커뮤니케이션은 다들 멀리하는 추세다. 이런 종류의 중요한 메시지를 공유할 때는 대면 커뮤니케이션(직접 만나는 게 이상적이겠지만 대부분은 영상을 이용할 듯)이 훨씬 더 효과적일 것이다. 그래야 생각을 듣는 사람들의 반응을 더 쉽게 이해하고, 그들의 반응에 맞춰 자신의 메시지를 교정하고 오해도 피할 수 있다. 심지어 더 큰 규모의 조직에 비전을 전파하려 할 때는 다른 형태의 커뮤니케이션이 필요할 수도 있겠지만 우선은 되도록 직접 대면하자. 메시지를 훨씬 더 효율적으로 다듬는 데 도움이 될 것이다.  

##### 2.6.5. 광범위한 조치를 위한 직원의 자율권 강화  
<br/>

'직원의 자율권 강화'라는 주제는 경영 컨설턴트가 사람들의 업무를 돕기 위해 꺼낸다. 대부분의 경우, 이 말은 '장애물을 제거한다'라는 상당히 직관적인 의미를 내포한다.  

비전을 공유하고 흥분을 고조시키고 난 뒤, 그다음에는 어떤 일이 벌어질까? 자율권은 오히려 방해물이 된다. 가장 흔한 문제 중 하나는 사람들이 각자 맡은 일에 바빠 변화를 위한 시간을 좀처럼 내지 못한다는 점이다. 이는 기업들이 조직에 새로운 인력(신규 인력 채용이나 컨설턴트로서)을 투입해서 팀에 여유 시간을 확보해주거나 변화를 위한 전문지식을 제공하는 이유기도 하다. 이게 바로 종종 회사가 (아마도 직접 고용하거나 컨설턴트를 통해) 새로운 직원을 조직에 투입해서 팀에 추가적인 대역폭과 변화를 위한 전문 지식을 제공하는 이유다.  

구체적인 예로, 마이크로서비스 채택과 관련해 기반 구조의 프로비저닝을 둘러싼 기존 프로세스는 실제로도 문제가 될 수 있다. 만약 조직에서 새로운 운영 서비스 배포를 추진하는데 하드웨어를 6개월 전에 미리주문하는 것이 관례인 경우, 가상화된 실행 환경(가상 머신 또는 컨테이너 등)이라는, 요구에 따른 적시 프로비저닝이 가능한 기술을 도입한다면 퍼블릭 클라우드 공급업체로의 전환이 가능해져 엄청난 도움이 될 것이다.  

다만, 부수적인 이익을 위해 새로운 기술을 혼용하지 마라. 당장 직면한 구체적인 문제를 해결하기 위한 기술을 도입하라. 장애물을 인식했다면 새 기술을 도입해서 문제를 해결하라. '완벽한 마이크로서비스 플랫폼'을 정의하겠다고 일 년을 보내고선 결국 아무 문제도 해결하지 못함을 깨닫게 되는 함정에 빠져서는 안 된다.  

우리는 테스트 스위트 생성과 관리를 더 쉽게 진행하기 위한 프레임워크를 만들었고, 코드 검토 시스템의 일부로 테스트 가시성을 높였으며, 테스트 실행을 더 쉽게 해주는 전사적인 CI도 새로 만들었다. 하지만 일거에 이 모든 작업을 수행한 건 아니었다. 우리는 몇 개 팀과 함께 일하면서 고충을 겪고 깨달음도 얻은 뒤, 긴 시간을 들여 새로운 도구를 도입했다. 또한 우리는 작은 것부터 시작했다. 테스트 스위트 작성을 더 쉽게 만드는 작업은 꽤 간단한 프로세스였지만, 전사적인 코드 검토 시스템 변경은 훨씬 더 큰 요구사항이었다. 우리는 다른 곳에서 약간의 성공을 거두고 나서야 변화를 시도하게 됐다.  

##### 2.6.6. 단기적인 성과 창출  
<br/>

진행 과정이 너무 더디면, 사람들은 비전에 대한 믿음을 잃게 되니 속전속결로 나서자. 애초 손 닿는 곳에 있는 작고 손쉬운 결실에 초점을 맞추면 탄력을 받을 수 있다. 마이크로서비스 분해와 관련해 우리의 모놀리스에서 쉽게 추출할 수 있는 기능은 작업 목록에서 최우선순위여야 한다. 그러나 앞서 밝혔듯이 마이크로서비스 자체가 궁극적인 목표는 아니다. 따라서 일부 기능을 추출하는 용이성과 그것이 가져다줄 이점 사이의 균형을 맞출 필요가 있다.  

물론, 뭔가를 결정하고 선택한 다음 이를 현실화하는 과정 중에 큰 문제가 발생한다면, 이것이 여러분의 전략에 귀중한 통찰로 작용하거나 현재 진행하는 일을 재고해야 할 수도 있다. 전혀 문제없다! 먼저 쉬운 일에 집중한다면 조기에 통찰력을 얻을 가능성이 높다. 실수는 자연스러운 일이다. 실수를 통해 가능한 빨리 배울 수 있는 구조를 갖추기만 하면 된다.  

##### 2.6.7. 이익 통합과 더 많은 변화 추구  
<br/>

일단 성공을 거머쥐고 나면 이미 성취한 것에 안주하지 않는 마음가짐이 중요하다. 계속 추진할 것이 아니라면, 빠른 승리만이 유일한 승리일 테다. 성공(그리고 실패)한 다음에는 변화에 올라타는 방법을 생각할 수 있도록 일단 멈춰서 신중하게 생각하는 것이 중요하다. 조직 내 타 부서들과 소통할 때는 접근 방식을 변경해야 할 수도 있다.  

마이크로서비스 전환 과정에서, 더 깊이 파고들수록 더 힘들어진다는 사실을 깨닫게 될 것이다. 데이터베이스 분해 작업을 초기엔 미뤄둘 수도 있지만, 영원히 외면할 순 없을 것이다. 선택 가능한 수많은 기술 중에 어떤 방식이 옳을지는 신중하게 고려해야할 것이다. 모놀리스의 한 영역에서 효과를 보인 분해 기술이 다른 곳에서는 전혀 효과가 없을지도 모른다는 사실을 기억하자. 향후 발전해나가기 위한 새로운 방법을 끊임없이 시도해야 할 것이다.  

##### 2.6.8. 혁신 문화의 정립  
<br/>

꾸준히 반복하고, 변화를 일으키며, 성공(그리고 실패)에 대한 이야기를 공유함으로써 새로운 작업 방식은 일상으로 자리잡기 시작할 것이다. 이런 과정은 동료나 다른 팀, 조직 내 여러 사람들과 경험을 공유하면서 이뤄진다. 어려운 문제를 일단 해결하고 나면 그 즉시 다음 단계로 넘어가는 경우가 너무나도 흔하다. 확장을 목표로 변화를 지속하려면, 조직 내에서 정보를 공유할 수 있는 방법을 계속해서 찾아야 한다.  

시간이 지남에 따라, 일을 하는 새로운 방식은 일을 끝내는 방식으로 이어진다. 마이크로서비스 아키텍처를 채택하기 위해 긴 여정을 걷는 회사를 살펴보면 마이크로서비스가 올바른 접근 방식인지 아닌지는 의문의 여지가 없다. 이런 식으로 마이크로서비스 작업은 완료되며, 조직은 마이크로서비스를 다루는 방법을 이해한다.  

이에 따라 새로운 문제가 생겨날 수도 있다. '엄청난 새로운 아이디어'가 '일상적인 작업 방식'으로 자리잡은 뒤에는, 어떻게 해야 미래에 더 나은 방법이 출현할 여지를 마련하고 일을 수행하는 방식을 바꿀 수 있을까?  

#### 2.7. 점진적인 마이그레이션의 중요성  
<br/>

기존 모놀리스 시스템의 분해가 필연적이라는 결론에 이르렀다면, 한 번에 조금씩 추출해 모놀리스에서 서서히 잘라내는 방식을 강력하게 추천한다. 점진적인 마이그레이션을 수행하다 보면 마이크로서비스에 대해 배울 수도 있고, 또한 뭔가 상황이 잘못될 때에도(항상 뭔가 잘못되기 마련이다!) 그로 인한 영향이 크지 않을 것이다. 모놀리스를 대리석 덩어리라 생각해보자. 큼직하게 깎아낼 수는 있지만 좀처럼 끝이 좋지 않다. 점진적으로 조금씩 잘라내는 방식이 훨씬 더 합리적이다.  

문제는 중차대한 모놀리스 시스템을 마이크로서비스 아키텍처로 옮기는 데 드는 실험 비용이 클 수 있으며, 모든 작업을 한 번에 수행하는 경우 제대로 작동하는지 여부에 대한 좋은 피드백을 얻기가 어려울 수 있다는 점이다. 긴 여정은 작은 단계로 분해하는 편이 훨씬 더 쉬우며, 각각을 분석하면서 배움을 얻을 수도 있다. 이런 이유로, 애자일이 출현하기 전부터 이미 나는 반복적인 소프트웨어 배포의 열렬한 지지자였다. 이는 내가 실수를 할 수도 있으며, 따라서 그 실수의 규모를 줄여야 함을 인정한다는 뜻이기도 하다.  

마이크로서비스 아키텍처로 전환할 때도 이런 원칙을 염두에 둬야 한다. 긴 여정은 다수의 작은 단계로 나눠라. 각 단계를 수행하며 배움을 얻을 것이다. 역행하는 단계라고 판명되더라도 작은 단계였으니 손해볼 건 없다. 어느 쪽이든, 그 과정에서 배움을 얻고, 앞선 단계에서 다음 단계로 넘아가기 위한 정보를 얻을 것이다.  

앞서 설명한 것처럼, 작은 조각으로 나누면 좋은 성과를 거뒀다는 사실을 빠르게 파악할 수 있으며 이로부터 우수 사례를 배울 수 있다. 이를 통해 다음 단계를 더 쉽게 진행할 수 있고 추진력도 커진다. 마이크로서비스를 한 번에 하나씩 분해하면 빅뱅 배포를 기다릴 필요 없이 점진적으로 가져오는 가치를 하나씩 눈으로 확인할 수 있다.  

이 모든 것은 마이크로서비스를 추구하는 사람들에게 거의 상투적인 조언이 되었다. 좋은 생각이라고 여겨진다면 작은 데서부터 시작하자. 기능에서 한두 영역을 선택하고, 마이크로서비스로 구현한 다음, 운영 환경에 배치하고, 실제 작동하는지를 신중하게 파악하자.  

##### 2.7.1. 운영 환경은 중요하다  
<br/>

마이크로서비스으 추출(extraction)은 운영 환경에서 활발히 사용되기 전까지는 완전한 것으로 간주될 수 없다는 점에 각별히 유의해야 한다. 점진적인 추출을 추구하다 보면, 분해 과정에서 발생하는 영향을 습득하고 이해하는 기회가 되기도 한다. 서비스가 상용 수준에 도달하고 나서야 비로소 귀중한 깨달음을 얻게 될 것이다.  

마이크로서비스 분해 과정 중에 문제 해결, 추적 흐름, 대기 시간, 참조 무결성, 연속적인 오류 등의 여러 문제가 야기되기도 한다. 대다수 문제는 운영을 시작하고 나서야 확인할 수 있다. 작은 변경을 가하면, 문제를 훨씬 더 쉽게 찾아서 해결할 수 있다.  

#### 2.8. 변화에 드는 비용  
<br/>

작고 점진적인 변화를 해야 한다고 강조하는 데이는 여러 이유가 있지만, 무엇보다도 중요한 것은 우리가 수행한 변경의 영향력을 이해하고, 필요한 경우 방향을 바꿔야 하기 때문이다. 이로써 실수에 따른 추가 비용 상승을 효과적으로 완화할 수 있지만, 실수할 가능성을 완전히 제거하지는 못한다. 우리는 언제든 실수를 범할 수 있으니, 이를 받아들여야 마땅하다. 하지만 한편, 이런 실수로 인한 비용 상승을 완화할 수 있는 최선의 방법은 무엇인지도 알아둬야 한다.  

##### 2.8.1. 가역적 결정과 비가역적 결정  
<br/>

모든 의사결정에 사업의 생사가 오간다. 모든 결정은 주요 사업으로 이어진다. 마이크로서비스 아키텍처를 채택하면 업무 수행 방식과 관련해 다양한 선택지가 눈앞에 놓인다는 점인데, 이는 이전보다 더 많은 결정이 필요해짐을 의미한다. 그리고 만약 개인이나 조직이 이런 관례에 익숙하지 않다면, 곧 함정에 빠져들고 발전은 멈추게 될 것이다.  

개념이 마음에 들긴 하지만, 본디 의사결정이란 것이 비가역적 결정이나 가역적 결정 중 하나에 속한다고는 결코 생각하지 않는다. 좀 더 미묘한 지점이 있으므로, 비가역과 가역이라는 개념이 각각 의사결정이라는 스펙트럼의 양 끝단에 놓여 있다고 가정한다.  

이 의사결정 스펙트럼에서 어디에 위치하는지를 평가하기란 처음에는 다소 어려울 것이다. 하지만 뒤늦게 결정을 바꾼다면, 결과적으로 따라올 영향에 대한 이해가 반드시 수반되어야 한다. 추후 궤도 수정이 초래할 영향이 클수록, 비가역적인 결정처럼 보일 확률이 더 높다.  

실제로, 마이크로서비스 전환의 일환으로 내릴 수많은 의사결정은 의사결정 스펙트럼 상에서 '가역적' 방향의 끝단을 향할 것이다. 소프트웨어에는 실행을 되돌리거나 취소가 가능한 속성이 있어서, 소프트웨어 변경이나 소프트웨어 배포를 되돌릴 수 있다. 따라서, 이후에 마음을 바꿨을 때 치르게 될 비용을 반드시 고려해야 한다.  

비가역적 의사결정에는 더 많은 참여, 신중한 숙고, 충분한 고려가 필요하며, 더 많은 시간을 (올바르게) 할애해야 마땅하다. 의사결정 스펙트럼 상에서 가역적 방향으로 향하는 오른쪽으로 갈수록 동료들이 잘못된 결정을 내리더라도 나중에 쉽게 고칠 수 있으므로, 문제를 함께 풀고 있는 동료들에게 안심하고 의지하기가 더 쉬워진다.  

##### 2.8.2. 실험을 시도해볼 만한 곳  
<br/>

코드베이스 내에서 코드를 이동하는 비용은 꽤 낮다. 이런 작업을 지원하는 도구는 많아서, 문제가 발생하더라도 대개는 수정을 빠르게 진행할 수 있다. 그러나 데이터베이스를 분리하는 작업은 훨씬 더 많은 노력이 들며, 데이터베이스 변경을 롤백하는 과정은 정말 복잡하다. 마찬가지로, 서비스 간에 지나치게 결합된 통합을 풀거나 여러 컨슈머가 사용하는 API를 완전히 재작성하는 작업은 많은 책임을 요한다. 높은 변경 비용은 운영이 점점 더 위험해진다는 사실을 의미한다. 이런 위험을 어떻게 관리할 수 있을까? 영향이 가장 적다고 예상하는 곳에서 실수를 시도하는 쪽을 추천한다.  

변화와 실수를 바로잡는 비용이 낮은 곳에서 생각을 하는 편이 좋다. 그곳은 바로 화이트보드 앞이다. 제안하는 설계를 화이트보드에 그려보라. 서비스 경계가 될 것으로 여겨지는 곳에서 사용 사례를 실행할 대 어떤 일이 발생하는지 확인해보라. 예를 들어, 상점의 경우, 고객이 음반을 검색하거나, 웹 사이트에 가입하거나, 음반을 구매할 때 어떤 일이 발생하는지 상상해보라. 어떤 호출이 일어나는가? 이상한 순환 참조가 보이기 시작하는가? 원래 하나가 되어야 한다는 상황을 간혹 시사해주는, 두 서비스 간에 지나치게 많은 호출이 일어나는 현상이 보이는가?  

#### 2.9. 우리가 시작해야 할 지점은?  
<br/>

자, 지금가지 우리의 목표를 명확하게 표현하고 잠재적인 상충 관계를 이해하는 것의 중요성을 이야기했다. 그다음은 무엇을 준비해야 할까? 일단은, 서비스로 추출하기를 원하는 기능 부분에 대한 자신만의 시각을 구책해야 한다. 그래야 다음에 구축할 마이크로서비스에 대해 합리적으로 생각할 수 있기 때문이다. 기존의 모놀리스 시스템을 분해함에 있어서, 어떤 형태로든 논리적인 분해가 필요하며, 여기서 도메인 주도 설계가 도움이 될 수 있다.  

#### 2.10. 도메인 주도 설계  
<br/>

도메인 모델을 개발하면 분해의 우선순위를 정하는 경우에도 도움이 된다.  

우리는 경계 컨텍스트 사이의 관계를 명확하게 볼 수 있으며, 이는 우리가 상상하는 조직 내에서 일어나는 상호작용을 표현한다.  

이와 같은 경계 컨텍스트는 각각 잠재적인 분해 단위를 나타낸다. 앞서 설명한 바와 같이, 경계 컨텍스트는 마이크로서비스 경계를 정의하기 위한 훌륭한 출발점이다. 따라서 우리에겐 우선순위를 정할 목록이 이미 있는 셈이다. 그러나 이런 제한된 컨텍스트 사이의 관계 형태로 표현되는 유용한 정보도 역시 가지고 있으며, 이는 다양한 기능을 추출하는 과정에서 겪는 상대적인 어려움을 평가하는 데 도움이 된다.  

마이크로서비스 전환 과정에서 밟아야 하는 필수적인 단계로서, 도메인 모델을 제안한다. 간혹 당혹스러운 점은 많은 사람이 이런 모델을 만들어 낼 정도의 직접적인 경험을 쌓지 못한다는 사실이다. 그들은 얼마나 많은 일이 관련되어 있는지에 대해서도 걱정을 한다. 현실적으로 경험은 이와 같은 논리적 모델을 제안하는 데 도움이 되겠지만, 아주 작은 노력만으로도 쏠쏠한 이익을 얻을 수 있다.  

##### 2.10.1. 작업 범위를 얼마나 넓게 잡아야 할까?  
<br/>

기존 시스템의 분해는 쉬운 작업이 아니다. 아마도 많은 사람이 시스템을 구축해왔고 앞으로도 계속 구축할 것이며, 십중팔구 더 많은 이들이 구축된 시스템을 일상적으로 사용할 것이다. 주어진 범위 내에서, 전체 시스템의 상세한 도메인 모델을 따라잡으려는 시도는 어려울지도 모른다.  

도메인 모델에서 필요한 것은 분해를 시작할 위치에 대해 합리적인 결정을 내리기에 충분한 한 줌의 정보라는 사실을 이해해둬야 한다. 아마도 가장 주의를 기울여야 할 특정 시스템 부분에 대한 아이디어를 이미 생각해뒀을 테니, 기능의 고수준 그룹화 측면에서 모놀리스에 대한 일반화된 모델을 고안해내고, 추가로 탐색이 필요한 부분을 선택하는 것만으로도 충분할 것이다. 시스템의 일부만 살펴본다면, 반드시 해결해야 하는 더 큰 쿤제를 간과하는 위험이 상존하게 된다. 그러나 강박에 쫓길 필요는 없다. 즉 처음부터 모든 것을 올바르게 이해할 필요도 없으며, 그저 다음 단계를 파악할 정도의 정보만 확보하면 된다. 깨달음을 얻으면서 도메인 모델을 지속적으로 다듬고, 출시하면 새로운 기능을 꾸준히 반영하기만 하면 된다.  

##### 2.10.2. 이벤트 스토밍  
<br/>

+ 이벤트 스토밍(Event Storming)  
기술 전문가와 비전 전문가가 다 같이 참여해 공유 도메인 모델을 함께 정의하는 협업 방식으로 상향식으로 작동하고 참가자는 시스템에서 발생하는 '도메인 이벤트'를 정의하면서 시작하여 집계(aggregate)로 그룹화되고 집계는 다시 경계 컨텍스트로 그룹화된다.  

이벤트 스토밍이라고 해서 이벤트 기반 방식의 시스템을 구축해야 한다는 사실을 의미하지는 않음에 유의하자. 그보다는 이벤트 스토밍이란, 시스템에서 발생하는 (논리적인) 이벤트를 이해하는 것과 시스템 전문가로서 신경서야 하는 사안을 식별하는 것에 중점을 둔다. 이와 같은 도메인 이벤트는 이벤트 기반 시스템의 일부로 시작된 이벤트에 매핑될 수 있지만, 다른 식으로 표현될 수도 있다.  

이벤트 스토밍 기법에서 주목하는 것은 모델을 정의하기 위해 협업하는 개념이다. 여기서 작업의 결과물은 모델 그 자체만이 아니며, 모델에 대한 공통된 이해다. 이와 같은 프로세스가 작동하려면, 적재적소에 올바른 전문가를 확보해야 하며, 이것이 가장 어려운 문제이기도 하다.  

##### 2.10.3. 우선순위 지정을 위한 도메인 모델 사용  
<br/>

업스트림 또는 다운 스트림 종속성의 수를 기반으로 추출하기가 더 쉬운 또는 더 어려운 기능에 대한 뷰를 추정할 수 있다. 예를 들어 통지 기능 추출을 고려하는 경우, 외부에서 내부로 의존 관계를 맺는 여러 종속성을 명확하게 볼 수 있으며, 시스템의 많은 부분에서 적용이 가능하다. 새로운 통지 서비스를 추출하고자 하는 경우, 기존 코드와 관련해 진행해야 할 작업이 많으며, 로컬 호출을 변경해 기존 통지 기능으로 바꾸고, 이를 서비스 호출로 만든다.  

따라서 통지는 시작하기에 적합한 장소가 아닐 수도 있다. 송장 작성은 추출하기 훨씬 더 쉬운 시스템 동작에 해당할 것이다. 외부에서 송장 작성에 의존하는 종속성이 없으므로 기존 모놀리스 수정에 필요한 변경사항은 줄어들 것이다. 이런 인바운드 호출은 모놀리스에 닿기 전에 쉽게 프록시할 수 있으므로, 이 경우 교살자 무화과(strangler fig) 패턴 등이 효과적일 수도 있다.  

추출이 어려움을 평가할 때 이와 같은 관계는 좋은 출발점이긴 하지만, 도메인 모델은 기존 시스템이 논리적인 뷰를 표현한다는 사실을 이해해야 한다. 모놀리스의 기반 코드 구조도 이런 식으로 구성되어 있다는 보장은 없다. 다시 말해, 결합도와 관련된 기능적인 측면에서 논리적인 모델이 도움을 줄 수 있지만, 기능이 얼마나 얽혀 있는지 파악하려면 여전히 코드 자체를 살펴 볼 필요가 있을 것이다. 이와 같은 도메인 모델은 데이터를 데이터베이스에 저장하는 경계 컨텍스트를 보여주지 않는다. 송장 작성은 대용량 데이터를 관리하므로, 데이터베이스 분해 작업의 영향을 고려해야 한다는 뜻이다. 모놀리스 데이터 저장소 분해도 마땅히 고려해야 하지만, 데이터 저장소 분해는 초기에는 마이크로서비스로 마이그레이션을 진행할 대상이 아니다.  

따라서, 난이도를 구분하는 렌즈를 통해 사물을 봐야 하며, 이렇게 해야 신속한 성공을 이끌어낼 수 있다. 그러나 구체적인 뭔가를 달성하는 수단으로 마이크로서비스를 고려하고 있음을 기억해야 한다. 실제로 송장 작성이 가장 손쉬운 첫 단계에 해당하지만, 만일 목표가 시장 출시를 앞당기는 것이며 송장 작성 기능을 변경하기가 쉽지 않다면, 마이크로서비스로의 마이그레이션 작업은 시간을 허비하는 일일 수도 있다.  

따라서, 난이도를 판별하는 시각과 마이크로서비스 분해로 인해 얻는 이점에 대한 시각을 결합할 필요가 있다.  

#### 2.11. 결합된 모델  
<br/>

빠른 진전을 이루고, 추진력을 얻으며, 택한 방식의 효용성에 대한 피드백을 일찌감치 얻기 위해 초반에 승부를 보길 원한다. 이 때문에 추출하기 더 쉬운 것을 선택해야 한다는 압박을 받는다. 그러나 우리는 분해로부터 이익도 얻어야 한다. 그렇다면 이를 어떻게 사고 과정에 반영할까?  

기본적으로, 2가지 우선순위는 모두 의미가 있지만, 이를 함께 시각화하고 적절한 균형을 유지하기 위한 메커니즘이 필요하다. 사분면을 사용한 간단한 구조가 선호된다. 여기서, x축과 y축을 따라 추출 대상 후보 서비스를 배치한다. x축에는 분해로 인해 얻는 가치를 표현한다. y축에는 난이도에 기반해 서비스를 정렬한다.  

이 프로세스를 팀 차원에서 수행하면 추출에 적합한 후보가 무엇인지 파악할 수 있다. 일반적인 우수한 사분면 모델과 마찬가지로, 1사분면인 우상단에 위치한 항목을 대부분 좋아한다. 송장 작성 등의 기능은 분해도 쉽고 분해에 따라 얻은 이익도 증가할 것으로 보인다. 따라서, 이 그룹에서 하나를 골라서, 추출할 첫 서비스로 채택해보자.  

변경을 시작하고 나면 더 많은 깨달음을 얻을 수 있을 것이다. 쉬울 거라 생각했던 것 중에는 막상 해보면 어려운 것도 있을 테다. 어려울 거라 생각했는데 막상 해보니 손쉬운 것도 있을 테다. 이는 자연스러운 것이다! 그러나 차츰 배워나가면서 작업의 우선순위를 다시 매기고 다시 계획을 세우는 것이 중요하다는 의미이기도 하다. 아마도 조금씩 잘라내는 과정에서, 통지 서비스를 추출하는 것이 생각보다 훨씬 더 쉽다는 사실을 깨닫게 될 것이다.  

#### 2.12. 팀 재구성하기  
<br/>

##### 2.12.1. 변화하는 구조  
<br/>

역사적으로, IT 조직은 핵심 역량을 중심으로 구조화되었다. 자바 개발자는 자바 개발자들끼리 팀을 이루고, 테스터는 테스터들끼리 팀을 이뤘다. 데이터베이스 관리자도 모두 자체적으로 팀을 구성했다. 소프트웨어를 만들 때, 각 팀에서 차출된 사람들은 이처럼 단기 프로젝트 수행 활동에 배정될 것이다.  

따라서 소프트웨어를 만드는 행위에는 팀들 간에 여러 차례의 업무 이관이 필요하다. 비즈니스 분석가는 고객과 대화해서 고객이 무엇을 원하는지를 찾아낼 것이다. 그런 다음 분석가는 요구사항을 작성해서, 작업을 진행할 개발 팀에 전달한다. 개발자는 몇 가지 작업을 마치고 테스트 팀에 결과물을 전달한다. 테스트 팀은 문제가 발견되면 개발 팀으로 돌려보낼 것이다. 문제가 없다면 운영 팀으로 넘겨 배포 단계에 들어갈 것이다.  

사일로 형태의 이런 구조는 꽤 친숙해 보인다. 계층화된 아키텍처를 떠올려보자. 계층화된 아키텍처에서는 간단한 변경사항을 배포할 때도 여러 서비스를 변경해야 할 수 있다. 조직 사일로도 마찬가지다. 즉 소프트웨어 제작과 변경에 참여하는 팀이 많을수롤 시간도 더 오래 걸린다.  

이런 사일로들은 분해되어 왔다. 오늘날 많은 조직에서 전담 테스트 팀은 과거의 유물이 되었다. 대신 테스트 전문가는 배포 팀에 통합되어, 개발자와 테스터는 더욱 긴밀하게 협력할 수도 있다. 또한 데브옵스(DevOps)의 바람이 불면서, 많은 조직은 중앙집중화된 운영 팀을 탈피해 운영에 대한 책임을 배포 팀으로 다수 이관시켰다.  

전담 팀의 역할이 배포 팀으로 넘어간 상황에서, 중앙집중화된 운영 팀의 역할이 바뀐 것이다. 중앙집중화된 운영 팀은 스스로 업무를 수행하는 대신, 배포 팀이 업무를 수행하도록 도와주는 형태로 변화했다. 여기에는 전문가를 팀에 포함시키거나, 셀프 서비스 도구를 만들거나, 교육을 제공하는 등의 다양한 활동을 수행할 수 있다. 중앙집중화된 운영 팀의 책임은 '수행'에서 '역량 부여'로 전환되었다.  

따라서 점점 더 많은 독립적이고 자율적인 팀이 과거 어느 때보다 더 많은 전 구간 배포 주기를 책임지고 있다. 기술 지향 서비스에서 수직적인 비즈니스 기능을 중심으로 모델링된 서비스로 전환되는 사례와 맞물려, 자율적인 팀은 특정 기술이나 활동이 아닌 제품의 다양한 영역에 초점을 맞춘다. 이와 같은 변화는 지난 몇 년간 뚜렸하게 나타난 추세이긴 하지만, 이는 보편적이지도 않고 그다지 빠른 변화도 아니라는 점에 주목해야 한다.  

##### 2.12.2. 만병통치약은 없다  
<br/>

마이크로서비스 사용 여부에 대한 의사결정은 현재 직면한 과제와 원하는 변화에 뿌리를 둬야 한다는 사실을 설명하며 시작했다. 조직 구조에 변화를 가하는 것도 그만큼 중요하다. 조직 변화의 필요성과 변화 방법에 대한 이해는 처한 상황, 작업 문화, 인력에 기초해야 한다. 다른 이들의 조직 설계도를 무작정 복사하는 방식이 특히 위험한 이유가 바로 여기에 있다.  

분명히 다른 조직이 수행한 작업에서 영감을 얻지만, 다른 누군가에게 맞아떨어진 이론이 자신의 상황에서도 효과가 있다고 가정해서는 안 된다.  

구체적인 예를 들자면, 많은 회사가 배포 팀에게 "지금 당장해야 할 일은 소프트웨어를 배포하고 연중 24시간 상시 지원을 실행하는 것입니다."라고 말한다. 이는 매우 혼란스러우며, 딱히 도움도 되지 않는다. 때로는 원대하며 담대한 발언이 조직을 움직이는 좋은 방법이지만, 그로 인해 야기될 혼돈에도 대비해야 한다. 개발자들이 대기하는 일 없이 정시 퇴근하고, 지원 또는 운영 환경에서 작업해본 적도 없으며, SSH를 전혀 모르는 조직 환경에서 일하고 있는 경우라면, 이런 과감한 시도는 직원을 소외시키고 많은 사람을 잃기에 딱이다. 그것이 조직을 위한 올바른 조치라고 생각한다면, 아무튼 훌륭하다! 그러나 무엇을 달성하고자 하는지, 포부를 이야기하고 왜 그렇게 해야 하는지의 이유를 설명하자. 그런 다음, 사람들과 협력해 그 목표를 향한 여정을 만들어야 한다.  

소프트웨어의 전체 수명주기를 완전하게 소유하는 팀으로 전환하기를 절실히 원한다면, 해당 팀의 기술에 변화가 필요하다는 사실을 이해해야 한다. 도움과 교육을 제공하고 (아마도 현재 운영 팀원들을 배포 팀에 포함시키는 방식으로) 팀에 새로운 인력을 충원할 수 있다. 소프트웨어와 마찬가지로 모든 변화는 점진적인 방식으로 실현할 수 있다.  

##### 2.12.3. 변화 일으키기  
<br/>

다른 누군가의 구조를 무작정 베껴서는 안 된다면, 어디서부터 시작해야 할까? 배포 팀의 역할을 바꾸고자 하는 조직과 협업해야 하는 경우라면 나는 회사 내에서 소프트웨어 배포와 관련된 모든 활동과 책임을 명시적으로 나열하는 일부터 시작한다. 다음으로, 이와 같은 활동을 기존 조직 구조에 분담한다.  

제작 경로를 이미 모델링한 경우라면, 기존 뷰 위에 해당 소유권 경계를 올려볼 수 있다. 혹은, 단순한 모델도 잘 작동할 수 있다. 관련된 모든 역할마다 전문가를 확보하고, 회사에서 소프트웨어 배포에 필요한 모든 활동을 그룹으로 브레인스토밍하자.  

현재 상태를 '있는 그대로' 이해함으로써 모든 이는 관련 작업에 대한 공통된 이해를 얻을 수 있다. 본질적으로 사일로화된 조직에서 한 사일로에 속한 이들은 다른 사일로가 무슨 일은 하는지 알기 어렵다. 현재 상태를 이해함으로써, 조직이 얼마나 빨리 변화할 수 있는지 스스로 깨닫는데 큰 도움이 된다는 사실을 발견했다. 모든 팀이 동등하지는 않다는 사실도 깨닫게 될 것이다. 즉 내부적으로 이미 많은 작업을 수행하는 팀도 있을 테고, 테스트에서 배포에 이르기까지 모든 사항을 타 부서에 전적으로 의존하는 팀도 있을 것이다.  

배포 팀이 이미 내부 테스트와 사용자 테스트 목적으로 소프트웨어를 직접 배포하고 있다면, 운영환경 배포 단계도 대수롭진 않을 것이다. 반면에, 1단계 지원(호출기 휴대), 운영 문제 진단 등에 미치는 영향은 여전히 고려해야 한다. 이런 운영 기술은 사람들이 수년에 걸쳐 다양한 작업을 통해 구축해온 것이므로, 개발자가 하룻밤 만에 일을 해치울 것이란 기대는 너무나 터무니없다.  

있는 그대로 그림을 그리고 나면, 합리적인 시간 척도 내에서 미래에 멀어질 일에 대해 비전을 세우고 다시 한번 그림을 고려보자. 아마도 지금부터 6개월에서 1년 정도 더 자세히 살펴보고 싶을 것이다. 권한이 바뀌는 책임은 무엇인가? 이런 전환은 어떻게 이뤄질 것인가? 이런 변화를 이루려면 무엇이 필요한가? 팀에 필요한 새로운 기술은 무엇인가? 원하는 다양한 변화의 우선순위는 무엇인가?  

프론트엔드와 백엔드 팀 책임을 병합하기로 결정했다. 또한 팀은 자체적인 테스트 환경을 프로비저닝할 수 있어야 한다. 그러나 이렇게 하려면, 운영 팀은 배포 팀이 사용할 셀프 서비스 플랫폼을 제공해야 할 것이다. 궁극적으로 배포 팀은 소프트웨어에 대한 모든 지원을 맡아 처리해야 하므로, 팀원들이 관련 작업을 더 행복하게 수행하면 좋을 것이다. 배포 팀이 테스트 배포의 소유권을 갖는 것이 바람직한 첫 단계다. 또한 팀이 사고 대응 업무를 일과 시간 내에 처리하며, 기존 운영 팀이 코치를 맡고 있는 안전한 환경에서 해당 프로세스를 신속하게 처리할 수 있는 기회를 팀에 제공할 것으로 결정했다.  

미래에 대한 큰 그림은 원하는 변화를 시작할 때 도움이 되기도 하지만, 아울러 실무자들을 직접 만나서 실제로 이런 변화가 실행 가능한지, 만약 그렇다면 변화를 어떻게 일으킬지 대화를 나누고 이해해야 할 것이다. 업무를 구체적인 책임으로 나눠 이런 변화에 점진적으로 접근할 수도 있다. 여기서는 운영 팀이 테스트 환경을 프로비저닝할 필요성을 없애는 쪽에 초점을 맞추는 단계가 우선이다.  

##### 2.12.4. 전문 기술 변경하기  
<br/>

사람들이 원하는 기술(skill)을 평가하고 그 격차를 해소하는 데 도움을 주는 과정에서, 나는 사람들이 스스로 기술을 평가하고 이용해서 해당 팀이 변화를 수행하기 위해 어떤 지원이 필요한지 좀 더 폭넓게 이해하기를 바란다.  

무엇보다도, 기술 변경은 고객의 요구뿐만 아니라 내부의 구성원과 문화를 이해하는 것으로부터 시작한다. 어떻게든, 다른 회사의 사례 연구에서 영감을 얻자. 그러나 그 회사의 문제와 해답을 무작정 베낀 것이 자신의 상황에서 잘 먹히지 않더라도 놀라지는 말자.  

#### 2.13. 전환이 순조로운지 어떻게 확인할까?  
<br/>

우리는 모두 실수를 한다. 호기롭게 마이크로서비스를 향한 여정을 시작했음에도, 모든 것을 알 수는 없으며 진행하다 보면 제대로 작동하지 않을 수도 있다는 현실을 받아들여야 한다. 질문은 다음과 같다. 일이 제대로 진행되고 있는지 알고 있는가? 행여 실수를 저지르지는 않았는가?  

달성하고자 하는 결과에 기반해, 이런 질문에 답하기 위한 추적 가능한 몇 가지 측정 방법을 정의해보자. 단순히 정량적인 지표만 말하는 것은 아님을 기억하기 바란다. 또한 실무자들의 정성적인 피드백을 고려할 필요도 있다.  

정량적이고 정성적인 측정을 통해 지속적인 검토 프로세스를 수행해야 한다. 팀이 올바른 방향으로 향하고 있는지에 대해 점검 항목을 수립할 필요가 있다. 이런 점검 항목 중에 스스로에게 물어야 할 질문은 "잘 되고 있는가?"가 아니라 "다른 뭔가를 시도해봐야 하지 않을까?"다.  

이런 점검 활동을 정리하는 방법과 추적 가능한 몇 가지 측정 사례를 살펴보자.  

##### 2.13.1. 정기 점검 사항  
<br/>

전환의 일환으로서, 사용 가능한 정보를 분석하고 진로 변경이 필요하는지를 판단하기 위해 잠시 멈춰 숙고하는 시간을 배포 프로세스 내에 확보해야 한다. 소규모 팀의 경우 이는 비공식적 혹은 정기적인 회고 활동으로 프로세스 내에 포함시킬 수 있다. 좀 더 큰 규모의 작업 프로그램이라면, 주기적인 중간 완료 마일스톤에서 명시적인 활동으로 계획해야 할 수도 있다. 예를 들면 월례회의에서 팀장이나 부서장을 모아 일이 어떻게 진행되고 있는지를 검토할 수도 있다.  

여러분이 이런 연습을 얼마나 자주 실행하는지, 그리고 얼마나 연습을 공식화(또는 비공식화)하는지에 무관하게, 다음과 같은 사항을 지켜주길 바란다.  

(1) 마이크로서비스로 전환한다면 기대하는 바가 무엇인지 다시 설명해보자. 사업 방향이 바뀌어 더 이상 의미 없는 쪽으로 가고 있다면, 바로 중단하자!  
(2) 운영 과정에서 정량적인 측정 데이터를 검토해 진척 사항을 확인하자.  
(3) 정성적인 피드백을 요청하자. 사람들은 여전히 문제가 잘 풀리고 있다고 생각하는가?  
(4) (어떤 것이든) 앞으로 무엇을 변화시킬 것인지 결정하자.  

##### 2.13.2. 정량적인 측정  
<br/>

진행 상황을 추적하기 위해 선택한 측정 요소는 무엇을 달성할지에 따라 달라질 것이다. 예를 들어, 시장 출시 시기를 단축하는 데 초점을 맞췄다면, 배포 주기, 배포 수, 실패율은 의미가 있다. 더 많은 부하를 처리하기 위해 애플리케이션을 확장하려는 경우라면, 최신 성능 테스트에 맞춰 보고서를 만드는 편이 합리적일 것이다.  

"측정한 대로 얻는다."라는 오랜 격언 때문에라도, 지표는 위험할 수 있다는 사실에 주목할 필요가 있다. 지표는 우연히 또는 의도적으로 길들여질 수 있다.  

다른 지표는 단기간에 변경하기가 어려울 수도 있다. 만일 여러분이 마이크로서비스 마이그레이션 과정을 시작한 지 불과 몇 달 만에 배포 주기를 대폭 개선할 수 있다면, 나는 깜짝 놀랄 것이다. 왜냐하면 나는 사실 초반에는 배포 주기가 악화될 것이라 예상하기 때문이다. 작업 실행 방식에 변화를 주면, 팀은 새로운 작업 방식으로 재빨리 일을 처리할 수 있지만 단기적으로 생산성에는 부정적인 영향을 미친다. 단계를 점진적으로 작게 나눠 수행하는 방식이 중요한 이유는 하나가 더 있다. 변화가 작을수록 부정적인 영향도 줄어들며, 문제가 발생할 때 더욱 신속하게 해소할 수 있기 때문이다.  

##### 2.13.3. 정성적인 측정  
<br/>

데이터가 우리에게 무엇을 보여주든지 간에, 소프트웨어를 구축하는 중심은 사람이며, 성공을 측정하는 과정에 사람들의 피드백이 포함되어 있다는 사실이 중요하다. 그들이 과정을 즐기고 있는가? 그들이 자율권을 부여받았다고 느끼는가? 아니면 압도당했다고 느끼는가? 새로운 책임을 맡거나 새로운 기술을 익히기 위해 필요한 자원을 받고 있는가?  

이런 유형의 전환에 대해 상부 경영진에게 성과 기록표를 보고할 때, 팀원들의 감정에 대한 점검사항도 넣어야 한다. 사람들이 업무를 즐긴다면, 훌륭하다! 그렇지 않다면, 여기에 대해 뭔가 조치가 필요할 수도 있다. 정량적인 지표에만 매달려 사람들이 말하는 내용을 무시하면, 난관에 봉착하게 될 것이다.  

##### 2.13.4. 매몰 비용 오류 방지  
<br/>

매몰 비용 오류(sunk cost fallacy)에 대해 알아야 한다. 검토 과정은 사람들을 늘 정직하게 만들고, 더 바람직하게는 매몰 비용 오류를 피할 수 있게 도와준다. 매몰 비용 오류는 사람들이 뭔가를 하기 위해 투자를 너무 많이 한 나머지, 문제가 존재한다는 사실에 대한 증거가 있음에도 불구하고 이를 무시하고 계속 진행할 때 발생한다. 때때로 우리는 "언제든 변화가 가능해!" 라며 스스로를 정당화한다. 변화를 위해 우리의 조직 내부에서 너무나도 많은 정치적으로 쌓아온 신뢰의 자본을 방출해온 바람에, 이제는 더 이상 이를 철회할 수 없는 상황에 놓일지도 모른다. 어느 쪽이든, 매몰 비용 오류가 모두 지나치에 감정적인 투자에 관한 것이라고 말하기에는 분명히 논쟁의 여지가 있다. 우리는 포기하지도 못하는 너무나 낡은 사고 방식에 갇혀 있다.  

계획이 웅장하고 팡파르를 크게 울릴수록, 뭔가 잘못되었을 때 계획을 철회하기가 어렵다. 매몰 비용 오류는 영국과 프랑스 정부가 초음속 여객기 제작에 엄청난 비용을 투자했지만 실패한 콩코드 프로젝트의 이름에서 유래한 콩코드 오류(Concorde fallacy)라고도 부른다. 결코 재정적 수익을 거두지 못할 것이라고 예상한 모든 증거에도 불구하고, 콩코드 프로젝트에는 점점 더 많은 자금이 투입되었다. 콩코드 항공기가 공학적으로는 성공을 거둘 수 있어도, 실용적인 상용 여객기로는 결코 적합하지 않았다.  

각 단계를 작게 만들면, 매몰 비용 오류의 함정을 피하기가 좀 더 쉬워진다. 이렇게 하면 방향을 바꾸기도 더 쉽다. 앞서 논의한 점검 항목 메커니즘을 사용해서 현재 상황을 반영하자. 문제가 발생할 조짐이 보인다고 바로 계획을 철회하거나 진로를 바꿀 필요는 없지만, 달성하고자 하는 변화의 성공(또는 실패)에 관해 수집된 중거를 무시하는 것은 애당초 증거를 수집하지 않는 것보다 더 어리석은 일임에 틀림없다.  

##### 2.13.5. 새로운 방식에 마음을 열자  
<br/>

여기까지 잘 따라왔다면 놀랄 일이 아니길 바라지만, 모놀리스 시스템 분해에는 여러 변수가 존재하며, 우리가 취할 수 있는 경로도 다양하다. 결코 모든 일이 순조롭게 진행되지는 않을 것이다. 변경사항을 되돌리거나, 새로운 것을 시도하거나, 잠시 기다리는 과정에서 개방적인 자세를 유지해야 한다.  

끊임없이 개선하는 문화를 수용하고 항상 새로운 것을 시도하려 노력한다면, 필요할 때 방향을 바꾸는 과정조차 훨씬 더 자연스러워진다. 변화나 프로세스 개선 작업을 통합해서 적용하는 대신 개별적으로 수행하면, 변화는 일회성 트랜잭션 활동으로 끝날 위험이 있다. 작업이 일단 끝나면 그것으로 끝이다! 더 이상 우리에게 변화는 없다! 이런 식으로 생각한다면, 수년 내에 모든 경쟁자에게 뒤처지고 말 것이며, 넘어야 할 또 다른 산을 마주하게 될 것이다.  

#### 2.14. 정리  
<br/>

마이크로서비스 도입이 적합한지를 결정할 때 팀이 자문해야 하는 주요 질문은 다음처럼 반복된다.  

+ 달성하고자 하는 목표는 무엇인가?
+ 마이크로서비스 사요에 대한 대안을 고려했는가?
+ 전환이 순조로운지 어떻게 확인할 것인가?  

마으키로서비스 추출 과정에서 점진적인 접근 방식의 중요성은 아무리 강조해도 지나치지 않다. 실수는 불가피하므로 어차피 발생한다고 가정한다면, 큰 실수보다는 작은 실수를 목표로 삼아야 한다. 마이크로서비스 아키텍처로 가기 위한 전환 과정을 점진적인 작은 단계로 나누면 저지르는 실수 또한 작아지고 복구하기도 쉬워질 것이다.  

대부분 실제 고객이 있는 시스템에서 작업한다. 고객이 사용하는 기존 애플리케이션을 방치해둔 채 애플리케이션을 완전히 재작성하는 데 몇 개월 또는 몇 년을 허비할 여유는 없다. 새로운 마이크로서비스를 점진적으로 작성하고 양산 서비스의 일부로 배포함으로써, 경험을 통해 배우고 최대한 빨리 혜택을 얻는 것을 목표로 삼아야 한다.  

기능을 새로운 서비스로 분리할 때, 이 서비스가 운영에 투입되어 실제 사용되어야 그제서야 모든 작업이 완료된다고 생각한다. 서비스들이 실제로 사용되는 과정에서 많은 깨달음을 얻게 된다. 초기에는 실제 서비스가 운영에 투입되는 것에 집중해야 한다.  

결국 우리는 새로운 마이크로서비스를 생성하고 이를 (바라건대) 크기가 줄어든 모놀리스와 통합할 수 있는 일련의 기술을 개발한 다음에 운영 환경에 배포해야 한다.  

### 3. 모놀리스 분할   
<br/>

#### 3.1. 모놀리스를 그대로 둘 것인가, 바꿀 것인가?  
<br/>

마이그레이션에서 고려할 첫 번째 사항 중 하나는 기존 모놀리스를 변경할 계획(또는 역량)이 있는지 여부다.  

기존 시스템을 변경할 역량이 있다면, 마음대로 사용 가능한 다양한 패턴의 측면에서 극대화된 유연성을 얻을 수 있을 것이다. 그러나 때에 따라서는, 이런 기회조차 얻을 수 없는 엄격한 제약 상황에 놓을 수도 있다. 기존 시스템이 소스 코드를 제공하지 않는 제조사가 만든 제공이거나 더 이상 보유하지 않은 기술로 작성된 것일지도 모른다.  

기존 시스템을 변경하지 못하게 주의를 빼앗는 다른 요인이 있을 수도 있다. 현재 모놀리스가 너무나 견고해서 변경 비용이 너무 많이 들 수도 있다. 결국 손실을 줄이고자. 다시 시작하길 원할 것이다. 또 다른 가능성이라면, 모놀리스에서 작업을 하는 사람들이 너무 많아서 자칫 사람들의 작업을 방해할까 걱정도 될 것이다. 곧 살펴볼 추상화에 의한 분기 패턴 등은 이런 문제를 완화할 수 있지만, 여전히 사람들에게 미치는 영향이 너무 크다고 판단할지도 모른다.  

기존 모놀리스 코드베이스로 작업할 수 있고, 코드를 변경할 수 있는 상황이기를 바란다. 그러나 만약 그렇게 할 수 없다면, 꼼짝 못 하게 발목 잡힌 상황인 걸까? 그렇진 않다. 이와는 정반대로, 여러 패턴을 통해 도움을 얻을 수도 있다. 그중 일부를 잠시 후 다룰 것이다.  

##### 3.1.1. 잘라 내기, 복사 또는 재구현?  
<br/>

기존 모놀리스의 코드에 접근할 수 있다 하더라도 새로운 마이크로서비스로 마이그레이션을 시작할 경우, 기존 코드로 수행해야 하는 작업이 항상 명확한 것은 아니다. 코드를 그대로 옮겨야 할까, 아니면 기능을 다시 구현해야 할까?  

기존의 모놀리스 코드베이스를 충분히 제대로 리팩터링하면, 코드 자체를 이동할 때 상당한 시간을 절약할 수도 있다. 여기서 핵심은 모놀리스에서 코드를 복사하기를 원하지만, 최소한 당장은 모놀리스 자체에서 이 기능을 제거하고 싶지는 않다는 점이다. 왜일까? 일정 기간 동안 모놀리스의 기능을 그대로 두면, 더 많은 선택지를 제공하기 때문이다. 이렇게 하면 복원 지점(rollback point)을 확보하거나, 혹은 두 가지 구현을 병행 실행하는 기회를 얻을 수 있다. 또한 이후에 마이그레이션이 성공적으로 완료되고 나면, 모놀리스에서 기능을 제거할 수 있다.  

##### 3.1.2. 모놀리스 리팩터링  
<br/>

새로운 마이크로서비스를 위해 모놀리스에서 가져온 기존 코드를 재사용하는 과정에서 간혹 가장 큰 장벽은 기존 코드베이스가 전통적으로 비즈니스 도메인 개념을 중심으로 구성되지 않았다는 문제였다. 기술 분류 방식에서 이는 훨씬 더 두드러진다(예를 들어 잘 알고 있는 모델, 뷰, 컨트롤러라는 패키지 이름을 생각해보자). 이는 특히 비즈니스 도메인 기능을 이동하려 할 때 난관이 될 수 있다. 기존 코드베이스가 해당 분류와 일치하지 않으므로, 이동시키려는 코드를 찾으려는 시도조차 난관에 빠질 수 있다!  

비즈니스 영역의 경계를 따라가며 기존 모놀리스를 재구성하는 과정을 밟는 경우라면, 마이클 페더스의 레거시 코드 활용 전략: 손대기 두려운 낡은 코드, 안전한 변경과 테스트 기법을 권장한다. 마이클은 봉합(seam)의 개념, 즉 기존 동작 방식을 수정하지 않고서도 코드 변경이 가능한 장소를 정의한다. 핵심을 정리하면, 변경을 원하는 코드 조각 주위에 봉합을 정의하고, 봉합의 새로운 구현 작업을 수행하며, 변경이 이뤄진 후 교체한다. 마이클은 이 책에서 코드베이스 정리를 돕는 수단으로서 경계를 안전하게 다루는 기법을 제공한다.  

일반적으로 마이클의 봉합 개념은 다양한 영역에 적용될 수 있지만, 특히 경계 컨텍스트(bounded context)에 매우 잘 맞아떨어진다. 따라서 레거시 활용 전략 책에서 도메인 주도 설계 개념을 직접적으로 설명하지 않을지라도, 여기서 나오는 기법을 활용해 원칙에 맞춰 코드를 조직화할 수 있을 것이다.  

###### 3.1.2.1. 모듈식 모놀리스?  
<br/>

기존 코드베이스를 이해하기 시작했다면, 새로 식별된 봉합(seam)을 가져와서 모놀리스를 모듈식 모놀리스로 만들기 위해 별도 모듈로 추출하는 다음 단걔를 고려하자. 아직 배포 유닛은 하나뿐이지만, 배포된 유닛은 정적으로 링크된 여러 개의 모듈로 구성되어 있다. 이 모듈의 정확한 구성은 기반 기술 스택에 따라 다르며, 자바의 경우 모듈식 모놀리스는 여러 JAR 파일의 구성되고, 루비 앱의 경우에는 루비 젬(gem) 모음일 수도 있다.  

이 책의 시작 부분에서 간략히 살펴봤듯이, 독립적으로 개발 가능한 모듈로 모놀리스를 분해하면 마이크로서비스 아키텍처의 많은 문제를 극복하면서 다양한 이점을 얻을 수 있으며, 많은 조직에 최고의 해법이 될 수도 있다. 마이크로서비스 아키텍처로 이동하려는 궁극적인 목적으로 모놀리스를 모듈식 모놀리스로 분해하는 작업을 시작한 여러 팀과 대화를 나눠보면, 모듈식 모놀리스만으로도 대다수 문제를 해결했다는 사실을 알 수 있다!

###### 3.1.2.2. 점진적인 재작성  
<br/>

대체로 기능을 무작정 재구현하는 방법으로 문제를 풀기보다는 항상 먼저 기존 코드베이스를 살리려고 노력한다. 때때로 팀들은 이와 같은 기존 코드 수정만으로 충분한 성과를 거두기에 애당초 마이크로서비스가 필요하지 않다는 사실을 깨닫게 된다.  

그러나 실제로는 마이크로서비스 전환에 앞서 모놀리스 리팩터링부터 먼저 진행하는 팀은 드물다는 사실을 받아들여야 한다. 그 대신, 일단 그 팀들이 새로 만들어진 마이크로서비스의 책임을 확인하고 나면, 해당 기능을 완전히 새롭게 구현하는 관례가 더 일반적인 것 같다.  

그러나 기능을 재구현하기 시작하는 경우, 완전히 새로 고쳐 쓰는 빅뱅에 수반된 문제를 반복할 위험에 처하진 않을까? 핵심은 한 번에 작은 기능만 재작성하고 이렇게 재작성된 기능을 고곡에게 정기적으로 출시하는 방법이다. 서비스의 동작을 재구현하는 작업이 며칠 또는 몇 주일 걸린다면 아마 괜찮을 것이다. 그러나 만약 일정이 몇 개월 이상 더 걸릴 경우, 나라면 이런 접근 방식을 재검토할 것이다.  

#### 3.2. 마이그레이션 패턴  
<br/>

#### 3.3. 패턴: 교살자 무화과 애플리케이션  
<br/>

시스템을 재작성할 때 자주 사용하는 기법을 교살자 무화과(Strangler Fig) 애플리케이션(https://martinfowler.com/build/StranglerFigApplication.html)이라고 한다. 숙주 나무의 위쪽 가지에 씨앗을 뿌리는 무화과 나무를 보고 영감을 얻은 마틴 파울러가 처음으로 이 패턴을 떠올렸다. 숙주 나무에 씨를 뿌린 무화과는 뿌리를 내리기 위해 땅으로 뻗으며 점차 숙주 나무를 감싸게 된다. 기존 나무는 처음에는 새로운 무화과 나무의 지지대가 되다가 마지막 단계에 이르면 썩어서 죽어버리고, 그 자리에는 이제 스스로 생존이 가능해진 무화과 나무만 남게 된다.  

소프트웨어 맥락에서 보면, 초기에 기존 시스템이 새로운 시스템을 지원하고, 새로운 시스템이 기존 시스템을 감싸는 형태로 병행된다. 기존 시스템과 새로운 시스템이 공존할 수 있으므로, 새로운 시스템은 성장할 시간을 얻고, 잠재적으로 기존 시스템을 완전히 대체할 수 있게 된다. 잠시 후 설명하겠지만, 이 패턴의 주요 장점은 새로운 시스템으로의 점진적인 마이그레이션을 허용한다는 목표를 뒷받침한다는 것이다. 또한 지금가지 배포된 새로운 시스템을 계속 활용하면서 심지어 중단할 능력도 제공한다.  

소프트웨어에서 이 개념을 구현할 때는 새로운 애플리케이션 아키텍처를 향한 점진적인 단계를 밟아 나갈 뿐만 아니라, 각 단계를 쉽게 되돌릴 수 있도록 보장함으로써 점진적 단계별로 발생할지도 모르는 위험을 줄여야 한다.  

##### 3.3.1. 작동 원리  
<br/>

교살자 무화과 패턴은 일반적으로 하나의 모놀리스 시스템에서 다른 모놀리스 시스템으로 마이그레이션하는 과정에 사용되어왔지만, 여기서는 모놀리스에서 일련의 마이크로서비스로 마이그레이션하는 과정을 살펴볼 것이다. 여기에는 (가능한 경우에) 실제로 모놀리스에서 코드를 복사하거나 해당 기능을 재구현하는 작업이 포함될 수도 있다. 또한, 이 기능에서 상태의 영속성이 필요하다면, 상태를 새로운 서비스로 마이그레이션하는 방법과 잠재적으로는 상태와 관련된 복구 방법도 고려해야 한다.  

교살자 무화과 패턴의 구현은 3가지 단계에 의존한다. 먼저 마이그레이션하기 원하는 기존 시스템의 대상을 식별하자. 일종의 균형 유지 활동을 사용해 시스템의 어느 부분을 먼저 공략할지에 대한 판단이 필요할 것이다. 그런 다음 이 기능을 새로운 마이크로서비스에서 구현해야 한다. 새로운 구현이 준비되면, 모놀리스에 대한 호출을 신규 마이크로서비스에 대한 호출로 전환하게끔 라우팅할 수 있어야 한다.  

이동된 기능으로 리디렉션되기 전까지는, 운영 환경에 배포된 경우라 할지라도 새 기능이 작동하지 않는다는 사실에 주목해야 한다. 해당 기능이 올바르게 동작하려면, 기능 구현에 일정 기간 동안의 작업 시간을 투입해야 한다. 새 기능을 아직 운영 환경에서 사용하지 않는다는 사실을 알고 있으므로, 안전하게 변경사항을 운영 환경에 추가할 수 있으며, 이는 새로운 서비스의 배포와 관리 측면에서 만족스러운 결과를 낳는다. 일단 새 서비스가 모놀리스와 동일한 기능을 구현하면, (곧 살펴볼) 병행 실행(parallel run)과 같은 패턴을 사용해 새 기능이 의도한 대로 작동하고 있음을 확신할 수 있다.  

배포(deployment) 개념을 릴리스(release)에서 분리하는 것이 중요하다. 특정 환경에 소프트웨어가 배포되었다고 해서 고객이 실제로 사용하는 것은 아니다. 이 두 가지를 별도 개념으로 취급하면 최종 운영 환경에서 사용하기 전에 소프트웨어를 검증할 수 있으므로 새로운 소프트웨어의 출시에 따른 위험을 줄일 수 있다. 교살자 무화과, 병행 실행, 카나리아 릴리스 등의 패턴은 배포와 릴리스가 분리된 활동이라는 사실을 잘 이용하는 패턴들이다.  

이 교살자 애플리케이션 접근 방식의 핵심은 새로운 기능을 신규 시스템으로 점진적으로 마이그레이션할 수 있을 뿐만 아니라 필요한 경우 변경사항을 매우 쉽게 되돌릴 수 있다는 점이다. 우리는 모두 실수를 한다는 사실을 기억하자. 따라서 우리에겐 실수를 하더라도 복귀 비용이 저렴할 뿐만 아니라 신속하게 실수를 해결할 수 있는 기술(따라서, 많은 작은 단계로 나눠서 마이그레이션을 수행해야 한다)이 필요하다.  

추출되는 기능이 모놀리스 내부의 다른 기능에서도 사용되는 경우 해당 호출 방법도 변경할 필요가 있다.  

##### 3.3.2. 적용 대상  
<br/>

교살자 무화과 패턴을 사용하면 기존 시스템을 건드리거나 변경하지 않고도 새로운 서비스 아키텍처로 기능을 이동할 수 있다. 이는 경합을 줄이는 데 도움이 되므로, 다른 사람들이 기존 모놀리스 자체를 대상으로 작업할 경우에 유리하다. 또한 모놀리스가 외부에서 만들어진 서드파티 소프트웨어이거나 SaaS 서비스의 경우인 블랙박스 시스템일 때도 매우 유용하다.  

간혹 전체 전 구간(end-to-end) 기능을 단일 조각으로 추출할 수 있다. 나중에 살펴보겠지만, 이는 데이터와 관련된 걱정 없이 추출 작업을 상당히 단순화한다.  

이와 같이 명확한 전 구간 추룰을 수행하려면, 전반적인 과정을 단순화하기 위해 더 큰 기능 그룹을 추출하고 싶을 수 있다. 이는 까다로운 균형 조정 작업이 될 수도 있다. 즉 더 큰 기능 조각을 추출해 더 많은 작업을 수행하겠지만, 통합 문제 중 일부는 단순해질 수도 있다.  

소규모로 시작하고 싶다면, '얕은' 추출을 고려해야 할지도 모른다. 여기서는 모놀리스 내부에 남아 있는 다른 기능(여기서는 사용자 통지를 보내는 기능)을 사용함에도 불구하고, 급여 기능을 추출하고 있다.  

또한 사용자 통지 기능을 재구현하는 대신, (모놀리스 자체에 대한 변경이 명시적으로 필요할) 사용자 통지 기능을 모놀리스에서 외부에 공개하는 방법으로 새로운 마이크로서비스에 노출시킨다. 그러나 교살자가 작동하려면, 인바운드 호출을 이동하려는 대상 자신에 대해 관심있는 기능으로 명확하게 매핑할 수 있어야 한다. 예를 들어 우리는 고객에게 사용자 통지를 보내는 기능을 새로운 서비스로 이동하고 싶다. 그러나 기존 모놀리스에 대한 인바운드 호출의 결과로 통지가 발생한다. 따라서 시스템 외부에서 일어나는 호출을 명확하게 리디렉션할 수 없다. 리디렉션 대신 '패턴: 추상화에 의한 분기' 절에서 설명할 기법을 살펴봐야 할 것이다.  

또한 기존 시스템에 대한 인바운드 호출의 성격도 고려해야 할 것이다. 잠시 후 살펴보겠지만, HTTP 같은 프로토콜은 리디렉션(redirection)에 상당히 적합하다. HTTP 자체에는 투명한 리디렉션 개념이 내장되어 있으며, 추가적으로 인바운드 요청의 특성을 명확하게 이해해서 방향을 변경하려면 프록시를 사용해야 한다. 예를 들어 RPC와 같은 유형의 프로토콜은 리디렉션에 적합하지 않을 수 있다. 인바운드 호출을 이해하고 (필요한 경우) 변환하기 위해 프록시 계층에서 수행해야 할 작업이 많을수록 이 선택지의 실현 가능성은 줄어든다.  

이런 제약에도 불구하고, 교살자 무화과 애플리케이션은 매우 유용한 마이그레이션 기법임을 스스로가 끊임없이 입증해왔다. 가볍게 수행하는 능력과 점진적인 변화를 다루는 손쉬운 접근 방법을 고려해보건대, 시스템 마이그레이션 방법을 찾으려 할 때 내게 최선의 선택지는 교살자 무화과 패턴이다.  

##### 3.3.3. 사례: HTTP 리버스 프록시  
<br/>

HTTP에는 몇 가지 흥미로운 기능이 있다. 그중 하나로, 호출하는 시스템에 투명하게 보이는 방법으로서, 호출을 가로채고 리디렉션하기가 매우 쉽다는 점을 들 수 있다. 이는 HTTP 인터페이스를 제공하는 기존 모놀리스를 교살자 무화과 패턴을 사용해 마이그레이션하기가 적합하다는 사실을 의미한다.  

HTTP 인터페이스를 제공하는 기존 모놀리스 시스템을 볼 수 있다. 이 애플리케이션은 UI가 없을 수도 있고, 실은 HTTP 인터페이스가 업스트림 UI에 의해 호출될 수도 있다. 어느 쪽이든, 업스트림 호출과 다운스트림 모놀리스 사이에 HTTP 리버스 프록시를 삽입한다는 목표는 동일하다.  

###### 3.3.3.1. 1단계: 프록시 삽입  
<br/>

재사용 가능한 적절한 HTTP 프록시가 아직 없는 경우에는 우선 HTTP 프록시를 배치하는 방식을 권장한다. 1단계에서 프록시는 모든 호출을 변경 없이 통과시키기만 할 것이다.  

1단계에서는 업스트림 호출과 다운스트림 모놀리스 사이에 추가될 네트워크 홉(hop) 삽입으로 인한 영향도를 평가하고, 새로운 구성 요소에 필요한 모니터링을 설정하며, 기본적으로 잠시 동안 이를 활용해 서비스를 진행할 것이다. 대기 시간 관점에서 모든 호출의 처리 경로에 네트워크 홉과 프로세스를 추가할 것이다. 적절한 프록시와 네트워크를 사용하면, 대기 시간에 최소의 영향(아마도 몇 밀리초 정도)만 미칠 것이다. 하지만 그렇지 않다고 판명된 경우에는 더 진행하기 전에 작업을 중지하고 문제를 조사할 수도 있다.  

모놀리스 앞에 이미 기존에 사용하던 프록시가 있는 경우라면, 1단계를 건너뛸 수 있지만 나중에 호출을 리디렉션하기 위해 프록시를 재구성하는 방법을 이해해야 한다. 나중에 수행할 수 있다고 가정하기에 앞서, 적어도 리디렉션 설정을 실험해봄으로써 의도한 대로 작동하는지 확인하기 바란다. 리디렉션이 불가능하다는 사실을 새로운 서비스를 실제 서비스하기 바로 직전에 알게 된다면 정말 끔찍할 것이다!  

###### 3.3.3.2. 2단계: 기능 마이그레이션  
<br/>

프록시를 사용하면 새로운 마이크로서비스 추출을 시작할 수 있다.  

2단계는 여러 단계로 분해할 수 있다. 아무 기능도 구현하지 안고 기본 서비스를 준비하고 실행하자. 일치하는 기능에 대한 호출을 받아들여야 하지만, 2단계에서는 "오루 501 구현되지 않음(501 Not Implemented)"만 반환할 수 있을 것이다. 2단계에서도 이 서비스를 운영 환경에 배포할 것이다. 이렇게 하면 운영 배포 프로세스에 익숙해질 수 있고, 현장에서 서비스를 테스트할 수 있다. 이 시점에서 기존 업스트림 호출을 리디렉션하지 않았으므로 새 서비스는 릴리스되지 않는다. 사실상 우리는 소프트웨어 릴리스에서 소프트웨어 배포 단계를 분리하는 중인데, 이는 일반적인 릴리스 기법이다.  

###### 3.3.3.3. 3단계: 호출 리디렉션  
<br/>

모든 기능의 이동을 완료하고 나서야 호출을 리디렉션하기 위해 프록시를 재구성한다. 어떤 이유로든 이 작업이 실패하면 리디렉션을 되돌릴 수 있다. 대다수 프록시의 경우, 리디렉션을 되돌리는 작업은 매우 빠르고 쉬운 과정이므로 신속한 복원이 가능하다.  

원하는 구성 상태를 훨씬 더 명확하게 만들 수 있는 기능 토글(feature toggle)과 같은 기법을 사용해 리디렉션을 구현하기로 결정할 수도 있다. 호출을 리디렉션하기 위해 프록시를 사용하는 방식은 뒤에서 설명할 카나리아 릴리스 패턴을 통해, 또는 완전한 병행 실행을 통해 새로운 기능의 점진적인 배포를 고려할 때도 훌륭한 토대가 된다.  

##### 3.3.4. 데이터?  
<br/>

##### 3.3.5. 프록시 옵션  
<br/>

프록시를 어떻게 구현할지는 부분적으로 모놀리스가 사용하는 프로토콜에 달려 있을 것이다. 기존 모놀리스가 HTTP를 사용한다면 손쉬운 출발이 가능하다. HTTP는 널리 지원되는 프로토콜이므로 리디렉션 관리를 위한 옵션이 다양하다. 나라면 아마도 엔진엑스(NGINX) 같은 전용 프록시를 선택할 것이다. 엔진엑스는 정확히 이런 유형의 사용 사례를 염두에 두고 만들어졌으며, 검증이 끝난 다양한 리디렉션 정책을 지원할 뿐만 아니라, 상당히 잘 동작한다.  

유형에 따라 더 간단한 리디렉션도 있다. REST 자원을 사용해 공개되는 URI 경로를 둘러싼 리디렉션을 고려하자.  

그러나 기존 시스템이 호출되는 기능의 특성에 대한 정보를 요청 본문(어쩌면 form 매개변수)의 어디쯤에 묻어버리면 리디렉션 규칙은 POST에서 매개변수를 활성화할 필요가 있을 것이다. 다만, 이는 가능하지만 제어하기가 더 복잡하다. 이런 상황에 처했다면 프록시에서 지원하는 기능 유무를 확인하기 위해 프록시 옵션을 점검하는 편이 바람직하다.  

가로채기와 리디렉션의 특성이 더 복잡하거나 제대로 지원되지 않는 프로토콜을 모놀리스가 사용하는 상황에서는 스스로 코드를 작성하고 싶은 유혹에 빠질 수 있지만, 이런 접근법은 매우 주의해야 한다. 더 복잡한 사용자 지정 동작(custom behavior)이 필요한 경우, 요즘은 사용자 지정 동작을 전용 프록시에 추가하는 방식을 더 많이 고려한다. 예를 들어, 엔진엑스는 루아(Lua)로 작성된 코드를 활용해 사용자 지정 동작을 추가할 수 있다.  

###### 3.3.5.1. 점진적인 배포  
<br/>

점진적 배포 기법을 활용하면 일련의 작은 단계를 통해 아키텍처를 변경할 수 있으며, 각 단계는 시스템의 다른 작업과 함께 수행할 수 있다. 새로운 급여 기능 구현으로 전환하는 작업이 방대하다는 생각이 든다면, 더 작은 기능으로 분할할 수 있다. 급여 기능의 일부만 마이그레이션하고 호출을 적절히 변경해, 모놀리스와 마이크로서비스에서 각각 일부 동작을 수행하는 방식을 고려할 수 있다. 이 과정에서 모놀리스와 마이크로서비스의 양쪽 기능이 동일한 데이터 집합에 접근해야 한다면 공유 데이터베이스가 필요하며, 이로 인해 다양한 문제가 발생할 가능성이 높다.  

엄청나게 많은 시스템을 최종적으로 하나로 합치는 빅뱅도, 라인을 멈추는 재플랫폼화도 필요하지 않다. 따라서 급여 기능 구현 작업을 다른 배포 작업과 함께 배포할 수 있는 단계로 나누는 일이 훨씬 쉬워진다. 백로그(backlog)를 '기능'과 '기술' 스토리로 분해하는 대신, 이 모든 작업을 하나로 묶자. 새로운 기능을 배포하는 동시에, 아키텍처를 점진적으로 변경하는 작업을 수행하자!  

##### 3.3.6. 프로토콜 변경  
<br/>

프록시를 사용해 프로토콜을 변환할 수도 있다. 예를 들어, 현재는 SOAP 기반 HTTP 인터페이스를 외부에 공개할 수도 있지만, 새 마이크로서비스는 HTTP를 대신해 gRPC 인터페이스를 지원할 것이다. 나는 이런 접근 방법이 다소 우려스러운데, 특히 프록시 자체에 누적되기 시작하는 복잡성과 로직 때문이다. 단일 서비스의 경우 이런 접근 방법이 크게 나쁘지는 않지만, 여러 서비스를 위한 프로토콜 변환을 시작하면 수행해야 할 작업이 프록시에 계속 누적된다. 일반적으로 서비스의 독립적인 배포 가능성을 최적화하고 있지만, 여러 팀이 수정해야 하는 공유 프록시 계층이 있을 경우에는 변경과 배포 프로세스가 느려질지도 모른다. 개발팀 사이에 경합을 일으키는 새로운 원천 요인을 하나 더 늘리는 것 이외에도 추가적으로 다른 문제가 생긴다는 사실에 주의할 필요가 있다. 마이크로서비스 아키텍처에 대해 언급할 때 항상 나오는 격언이 하나 있다. "파이프는 멍청하게 유지하고 종단점은 똑똑하게 유지하라." 공유 미들웨어 계층에 적용하는 기능의 수를 가급적 줄이고자 한다. 이 숫자가 많으면 기능 개발 속도가 현저히 느려지기 때문이다.  

사용 중인 프로토콜의 마이그레이션을 원한다면, 기존 프로토콜과 새 프로토콜을 모두 지원하는 서비스를 사용해 매핑을 서비스 자체에 적용하는 방식이 훨씬 더 낫다. 서비스 내에서 기존의 낡은 프로토콜에 대한 호출은 내부적으로 새로운 프로토콜로 다시 매핑될 수 있다. 이렇게 하면 다른 서비스가 사용하는 프록시 계층의 변경사항을 관리할 필요가 없으며, 시간이 지남에 따라 이 기능에 대한 변경을 서비스 차원에서 완벽하게 제어할 수 있다.  

마이크로서비스를 네트워크 종단점에서 제공하는 기능 모음으로 간주할 수 있다. 또한, 동일한 기능을 다른 컨슈머에게 또 다른 방식으로 공개할 수도 있을 것이다. 즉 이 서비스 내에서 다양한 메시지나 요청 형식을 지원함으로써, 기본적으로 업스트림 컨슈머의 다양한 요구를 충족한다.  

서비스에 밀접한 요청과 응답 매핑을 서비스 내에 적용함으로써 프록시 계층을 단순하면서도 훨씬 더 일반적인 형태로 유지할 수 있다. 또한 서비스가 이 두 가지 유형의 종단점을 모두 제공한다면 기존 API의 폐기에 앞서 업스트림 컨슈머가 마이그레이션할 시간을 벌 수 있다.  

###### 3.3.6.1. 그리고 서비스 메시  
<br/>

스퀘어(Square)에서는 이 문제를 해결하기 위해 하이브리드 접근법을 채택했다(엔보이 서비스 메시로 가는 길, https://squ.re/2nts1Gc). 스퀘어에서는 서비스 간 통신 목적으로 직접 제작한 RPC 메커니즘에서 벗어나기 위해, 매우 폭넓은 생태계를 토대로 풍부한 지원이 가능한 오픈소스 RPC 프레임워크인 gRPC를 채택하기로 결정했다. 고충을 최소로 경감시키기 위해, 악 각 서비스에 필요한 변경량을 줄이고자 했다. 이를 위해 스퀘어가 채택한 것은 서비스 메시(service mesh)였다.  

서비스 메시를 사용하면, 각 서비스 인스턴스는 독자적인 전용 로컬 프록시를 통해 다른 서비스 인스턴스와 통신한다. 각 프록시 인스턴스는 파트너가 되는 서비스 인스턴스에 맞춰 특별히 구성할 수 있다. 또한 제어 평면을 사용해 이런 프록시에 대한 중앙화된 제어와 모니터링을 제공할 수도 있다. 또한 제어 평면을 사용해 이런 프록시에 대한 중앙화된 제어와 모니터링을 제공할 수도 있다. 중앙 프록시 계층이 없기 때문에, 공유된 '똑똑한' 파이프를 유지하는 과정에서 부딪히는 위험을 피할 수 있다. 따라서 사실상, 각 서비스는 필요한 경우 서비스 간의(service-to-service) 독자적인 파이프를 효과적으로 소유할 수 있다. 스퀘어는 자사의 아키텍처가 진화한 방식으로 인해 링커드(Linkerd)나 이스티오(Istio) 같은 기존 솔루션을 사용하지 못하고 엔보이(Envoy) 오픈소스 프록시를 사용하지만, 필요에 따라 독자적인 서비스 메시를 작성해야 했다는 점에 주목해보자.  

서비스 메시의 인기는 점차 높아지고 있으며, 개념적으로 나도 서비스 메시가 적절하다고 생각한다. 서비스 메시는 일반적인 서비스 간 통신 문제를 처리하는 훌륭한 방법이 될 수도 있다. 내가 우려하는 바는 매우 똑똑한 몇몇 사람들의 많은 작업에도 불구하고 이 분야의 도구가 안정화되기까지 긴 시간이 걸렸다는 사실이다. 이스티오가 가장 눈에 띄는 선두주자인 듯하지만 확실한 선택지가 되기는 어려울 뿐만 아니라, 일주일이 멀다 하고 새로운 도구가 속속 등장하고 있다. 바라건대, 특정 기술을 선택하기에 앞서, 서비스 메시 분야에 좀 더 많은 시간을 투자해 안정화에 노력을 기울이기 바란다.  

##### 3.3.7. 사례: FTP  
<br/>

지금까지 HTTP 기반 시스템을 위해 교살자 패턴을 사용하는 방식에 대해 한참 동안 이야기했지만, 다른 형태의 통신 프로토콜을 가로채고 리디렉션하는 행위를 굳이 막을 필요는 없다. 스위스의 부동산 회사인 홈게이트(Homegate)는 교살자 패턴의 변형을 활용해서, 고객이 새로운 부동산 목록을 업로드하는 방법을 바꿨다.  

홈게이트 고객이 FTP를 통해 목록을 업로드하면, 기존의 모놀리스 시스템은 이렇게 업로드된 파일을 처리했다. 홈게이트는 마이크로서비스로 전환하고자 했으며, 기존의 배치 FTP 업로드 방식을 바꿔서 곧 비준될 표준에 맞춰 REST API를 사용하는 새로운 업로드 메커니즘을 지원하고 싶어 했다.  

홈게이트는 고객 관점에서 큰 변화가 감지되지 않길 바랐다. 즉 변경사항을 매끄럽게 만들기를 원했다. 이는 적어도 당분간은 FTP가 여전히 고객이 시스템과 상호작용하는 메커니즘이 되어야 한다는 사실을 의미한다. 결국 홈게이트는 (FTP 서버 로그의 변경사항을 감지해) FTP 업로드를 가로챘고, 새로 업로드된 파일을 새 REST API에 대한 요청으로 변환하는 어댑터로 향하게 만들었다.  

고객 관점에서 보면 업로드 과정 자체는 바뀌지 않았다. 업로드를 처리하는 새 서비스가 새로 올리는 데이터를 훨씬 더 빨리 다룰 수 있게 되어, 고객은 광고를 빠르게 게재하는 데 유리해졌다. 나중에는 새로운 REST API를 고객에게 직접 공개할 계획도 있다. 흥미롭게도 이 기간 동안 두 가지 목록 업로드 메커니즘은 모두 활성화되었다. 이를 통해 팀은 2가지 업로드 메커니즘이 제대로 작동하는지 확인할 수 있었다.  

##### 3.3.8. 사례: 메시지 가로채기  
<br/>

지금까지 동기식 호출을 가로채는 방법을 살펴봤지만, 모놀리스가 다른 형태의 프로토콜, 즉 메시지 브로커를 통해 메시지를 수신하는 경우에는 어떻게 될까? 기본 패턴은 동일하다. 호출을 가로채 새로운 마이크로서비스로 리디렉션하는 수단이 필요하다. 주요 차이점은 프로토콜 자체의 특성이다.  

###### 3.3.8.1. 콘텐트 기반 라우팅  
<br/>

모놀리스는 수많은 메시지를 수신하는데, 그중 일부를 가로채야 한다.  

간단한 접근 방법은 다운스트림 모놀리스를 위해 의도된 모든 메시지를 가로채고 해당 메시지를 필터링해 적절한 장소로 보내는 것이다. 이는 기본적으로 기업 통합 패턴에서 기술한 콘텐트 기반 라우터 패턴의 구현이다.  

이 기법을 사용하며 모놀리스를 건드리지 않고 요청 경로에 다른 대기열을 배치할 수 있지만, 대기 시간이 늘어날 수 있으며 관리해야 할 항목도 추가로 생긴다. 또 다른 문제는 메시징 계층에 '똑똑한 기능'을 몇 개 배치해야 하냐는 질문이다. 서비스 간 네트워크에서 똑똑한 기능을 너무 많이 사용하는 시스템으로 인해 발생되는 문제를 설명한 바 있다. 이런 경우에는 시스템을 이해하기 어렵고 변경하기도 더 어려워진다.  

따라서 그보다는, 계속 언급한 "똑똑한 종단점, 멍청한 파이프"라는 격언을 반드시 받아들이길 권고했다. 여기서 콘텐트 기반 라우터는 시스템 간에 호출이 라우팅되는 측면에 복잡성을 추가해 "똑똑한 파이프"를 구현한다는 문제가 불거질 수도 있다. 상황에 따라서는 매우 유용한 기법이긴 하지만, 결국 선택은 여러분의 몫이다.  

###### 3.3.8.2. 선택적 소비  
<br/>

대안이라면, 모놀리스를 변경해서 새로운 서비스가 수신해야 할 메시지를 무시하게 만드는 방법이 있다. 여기에는 새로운 서비스와 모놀리스가 동일 대기열을 공유하며 지역적으로 일종의 패턴 일치 프로세스를 사용해 관심있는 메시지를 수신하기 위해 대기한다. 이런 종류의 필터링은 메시지 기반 시스템에서 매우 일반적인 요구사항으로, JMS의 메시지 선택기(selector) 같은 기능을 사용하거나 다른 플랫폼에서 동등한 기술을 사용해 구현할 수 있다.  

이와 같은 필터링 접근 방식은 추가 대기열을 만들 필요성을 줄여주지만 몇 가지 문제가 있다. 우선, 기반 메세징 기술은 이와 같은 단일 대기열 구독을 공유하도록 허용할 수도, 허용하지 않을 수도 있다(일반적인 기능이지만, 이게 사실이라면 놀라운 일이 아닐 수 없다). 둘째, 호출을 리디렉션하고 싶다면 두 가지 변경사항을 적절히 조정해야 한다. 모놀리스가 새로운 서비스를 위한 호출을 더 이상 읽지 못하게 막아야 하고, 그 대신 새로운 서비스가 이 호출을 받아들이게 만들어야 한다. 마찬가지로, 호출 가로채기를 되돌리려면 복원을 위해 두 곳에 변경이 필요하다.  

동일한 대기열에 대해 더 많은 유형의 컨슈머가 있고 필터링 규칙이 복잡해질수록, 문제가 발생할 수 있는 가능성도 커진다. 규칙이 겹치는 바람에 2개의 컨슈머가 동일한 메시지를 받기 시작하거나 심지어 몇몇 메시지는 완전히 무시되는 반대 상황을 쉽게 상상할 수 있다. 이런 이유로, 적은 수의 컨슈머 또는 간단한 필터링 규칙 집합만으로 선택적 소비를 사용하는 방식을 고려해야 할 것이다. 앞서 설명한 잠재적인 단점, 특히 '똑똑한 파이프' 문제에 빠지는 단점을 인식해야 하지만, 콘텐츠 기반의 라우팅 접근 방식은 컨슈머 유형의 수가 증가함에 따라 더 타당할 것이다.  

이와 같은 해법이나 콘텐트 기반 라우팅 때문에 발생하는 추가적인 복잡성을 회피할 목적으로 비동기식 요청-응답 방식의 통신을 사용할 경우라면, 뭔가 변경되었다는 사실을 인식하지 않고서도 클라이언트에 요청을 리디렉션하게끔 라우팅할 필요가 있다. 메시지 기반 시스템에는 호출 라우팅에 대한 다른 선택지도 있으며, 이 중 많은 것이 교살자 무화과 패턴 마이그레이션을 구현하는 과정에 도움이 된다.  

##### 3.3.9. 그 밖의 프로토콜  
<br/>

다른 유형의 프로토콜을 사용하더라도 기존 모놀리스에 대한 인바운드 호출을 가로챌 수 있는 방법이 많다. 모놀리스가 배치(batch) 파일 업로드로 구동되는 경우에는 어떻게 될까? 배치 파일을 가로챈 다음 가로채기를 원하는 호출을 추출한 후 이를 전달하기 전에 배치 파일에서 해당 호출을 제거하자. 사실, 이 프로세스를 더욱 복잡하게 만드는 메커니즘들도 있고, HTTP 같은 프로토콜을 사용하면 훨씬 수월해지지만, 창의적인 사고를 발휘하면 놀랄 만큼 많은 상황에서 교살자 무화과 패턴을 사용할 수 있다.  

##### 3.3.10. 교살자 무화과 패턴의 다른 예  
<br/>

교살자 무화과 패턴은 기존 시스템을 점진적으로 재구축하려는 모든 상황에서 매우 유용하며, 마이크로서비스 아키텍처를 구현하는 팀에만 사용이 국한되지는 않는다. 이 패턴은 마틴 파울러가 2004년에 발표하기 전부터 오랫동안 사용되어왔다.  

#### 3.4. 기능을 마이그레이션하는 동안 동작 방식 변경하기  
<br/>

적극적으로 마이그레이션 중인 시스템 동작을 변경하거나 보강하기를 원할 때는 여전히 문제가 있다.  

예를 들어 기존 급여 기능을 모놀리스 밖으로 옮기기 위해 교살자 무화과 패턴을 사용하는 시나리오를 상상해보자. 교살자 무화과 패턴은 여러 단계로 이 작업을 수행할 수 있으며 이론적으로는 각 단계별로 복원을 허용한다. 고객에게 새로운 급여 서비스를 출시하고 문제가 발견되면 급여 기능에 대한 호출을 기존 시스템으로 다시 전환할 수 있었다. 이는 모놀리스와 마이크로서비스 급여 기능이 기능적으로 동등한 경우에는 잘 작동하지만, 마이그레이션의 일부로 급여 기능이 작동하는 방식을 변경한 경우에는 어떻게 될까?  

급여 마이크로서비스의 동작 방식에 몇 가지 버그 수정이 적용되었지만 모놀리스의 동등한 기능으로 역이식되지 않은 경우, 복원으로 인해 해당 버그가 시스템에 다시 나타날 수도 있다. 급여 마이크로서비스에 새로운 기능을 추가하면 문제가 더 커질 수 있는데, 복원하고 나면 고객이 사용하는 기능은 사라질 것이다.  

이 문제를 해결할 간단한 묘책은 없다. 마이그레이션이 완료되기 전에 기능 변경을 허용하면 복원을 더 어렵게 만든다는 사실을 인정해야 한다. 마이그레이션이 완료될 때까지 변경을 허용하지 않는 편이 훨씬 더 수월하다. 마이그레이션에 시간이 오래 걸릴수록 시스템에서 '기능 동결'을 강제하기가 훨씬 더 어려워진다. 시스템의 일부를 변경해야 하는 요구가 있을 경우에는 이를 회피하기가 어렵다. 마이그레이션을 완료하는 과정에서 시간이 더 오래 걸릴수록 '마이그레이션하는 동안 이 기능을 슬며시 적용'해야 하는 부담이 훨씬 더 커진다. 각 마이그레이션 범위가 작을수록 마이그레이션이 완료되기 전에 마이그레이션되어야 하는 기능 변경에 대한 입력은 훨신 더 줄어든다.  

기능을 마이그레이션할 때는 동작 방식에서 변경이 일어나지 않게 노력하자. 가능하면 마이그레이션이 완료될 때까지 새 기능 추가 또는 버그 수정을 뒤로 미루자. 그렇지 않으면 시스템 변경사항을 복원하는 능력을 떨어뜨릴지도 모른다.  

#### 3.5. 패턴:UI 컴포지션  
<br/>

지금가지 고려한 기법에서는 주로 서버에서 점진적인 마이그레이션 작업을 진행했지만, 사용자 인터페이스(UI)를 통해 기존 모놀리스 또는 새로운 마이크로서비스 아키텍처에서 제공하는 기능을 결합할 수 있게 됐다.  

##### 3.5.1. 사례: 페이지 컴포지션  
<br/>

&lt;가디언&gt;에서 우리는 단일 위젯을 출시하는 작업부터 시작했지만, 애당초 계획은 새로운 UI를 실현하기 위해 페이지 기반 마이그레이션을 사용하는 것이었다. 이 작업은 분야별(vertical-by-vertical basis)로 이뤄졌으며, 여행 분야를 처음으로 공개했다. 전환 기간 동안 웹사이트 방문자는 새로이 개선된 분야 페이지로 이동하면 전혀 색다른 UI와 UX를 접하게 될 터였다. 이런 페이지 링크는 모두 새 위치(변경된 URL)로 HTTP 페이지 전환이 되도록 엄청난 노력을 기울였다.  

몇 년 후 &lt;가디언&gt;이 자바 모놀리스에서 벗어나 또 다른 기술 변화를 시도했을 때도, 또 다시 분야별로 마이그레이션하는 유사한 기술을 사용했다. 이때도 사내 프록시 기술을 사용할 때처럼 패스틀리(Fastly) 사의 CDN(Content Delivery Network) 기술을 활용해 새로운 라우팅 규칙을 구현했다.  

호주에서 온라인 부동산 명부를 제공하는 REA 그룹에는 상업용 또는 주거용 명부를 담당하는 전담 팀이 나뉘어 있으며, 각각 전체 채널을 소유하고 있다. 이런 상황에서라면 한 팀은 전반적인 전 구간 경험을 소유할 수 있으므로 페이지 기반 구성 접근 방식이 적합하다. 실제로 REA는 채널마다 미묘하게 다른 브랜딩을 사용한다. 즉 각 고객 그룹마다 상당히 다른 경험을 제공할 수 있기 때문에, 페이지 기반 분해 방식이 훨씬 더 적합하다.  

##### 3.5.2. 사례: 위젯 컴포지션  
<br/>

&lt;가디언&gt;에서 여행 분야는 새로운 플랫폼으로 마이그레이션할 첫 번째 대상으로 선정되었다. 분류와 관련한 몇 가지 흥미로운 문제가 있었지만, 사이트에서 핵심 사안은 아니라는 판단이 이론적인 근거였다. 기본적으로, 우리는 뭔가를 서비스하고, 거기서 경험을 얻고, 혹시 뭔가가 잘못되더라도 사이트의 주요 부분에는 영향을 미치지 않기를 원했다.  

전 셰계의 매력적인 여행지에 대한 심층 보도로 가득한 웹 사이트의 전체 여행 부문을 바로 서비스하기보다는 시스템을 테스트하기 위해 훨씬 더 억제된 릴리스를 원했다. 대신 새로운 시스템을 사용해 정의된, 상위 10개 여행지를 표시하는 단일 위젯을 배포했다. 이 위젯을 인터넷신문의 오래된 여행 페이지에 이어 붙였다. 여기서는 아파치의 ESI(Edge-Side Includes)라는 기술을 사용했다. ESI로 웹 페이지에 템플릿을 정의해두면, 웹 서버가 이 내용을 이어 붙인다.  

요즘에는 순수하게 서버 측에서 위젯을 이어 붙이는 방식은 인기가 없다. 브라우저 기반 기술이 훨씬 더 정교해졌기에 브라우저 자체(혹은 곧 살펴볼 전용 앱)에서 훨씬 더 많은 구성을 수행할 수 있게 됐기 때문이다. 이는 위젯 서버를 여러 번 호출하는 경우가 많아진다는 뜻이다. 이런 경우, (지원 서비스를 사용할 수 없기 때문에) 위젯 하나가 로드되지 않을 때에도 다른 위젯은 여전히 화면에 표시될 수 있으므로 전체 서비스가 아니라 부분적인 성능 저하만 허용한다는 부가적인 장점이 있다.  

결국 우리는 &lt;가디언&gt;에서 대부분 페이지 기반 컴포지션을 사용했지만 다른 많은 회사에서는 백엔드 지원 서비스와 함께 위젯 기반 컴포지션을 많이 사용한다. 예를 들어 오르비치(Orbitz, 현재 익스피디아에 인수됨)는 단일 위젯을 제공하기 위한 전용 서비스를 만들었다. 마이크로서비스로 이전하기 앞서 오르비치 웹사이트는 이미 독립된 UI '모듈'(오르비츠 명명법에 의하면)로 분해되었다. 이들 모듈은 검색 양식(form), 예약 양식, 지도 등을 표현할 수 있다.  

이 UI 모듈들은 처음엔 콘텐트 오케스트레이션(Content Orchestration) 서비스에서 직접 제공되었다.  

콘텐트 오케스트레이션 서비스는 사실상 거대한 모놀리스였다. 이 모듈을 소유한 팀은 모두 모놀리스 내부에서 일어나는 변경사항을 조정해야 하므로 변경사항을 배포하는 과정에서 심각한 지연을 일으켰다. 이런 현상은 배포 경합 문제의 전형적인 예다. 팀이 변경사항을 배포하기 위한 조정을 시도할 때마다 변경 비용이 증가한다. 릴리스 주기를 앞당기기 위한 노력의 일환으로, 마이크로서비스 도입을 결정한 오르비츠는 편집 모듈부터 시작해 모듈 경계를 따라가는 분해에 집중했다. 콘텐트 오케스트레이션 서비스는 전환된 모듈에 대한 책임을 다운스트림 서비스로 위임하도록 변경되었다.  

UI가 이런 경계를 따라 시각적으로 이미 분해되어 있었기에 점진적인 방식으로 작업을 더 쉽게 수행할 수 있었다. 독립적으로 나뉜 모듈은 명확한 경계선에 따라 소유권을 확보했기에, 다른 팀을 방해하는 일 없이 손쉬운 마이그레이션이 가능해짐으로써 전환 과정에서 큰 도움이 되었다.  

모든 사용자 인터페이스가 깔끔한 위젯으로 분해되기에 적합한 것은 아니지만, 만약 그럴 수 있다면, 마이크로서비스로의 점직적인 마이그레이션 작업은 훨씬 쉬워진다는 사실에 주목할 필요가 있다.  

###### 3.5.2.1. 그리고 모바일 애플리케이션  
<br/>

지금까지는 주로 웹 기반 UI에 대해 이야기했지만, 이 기법들 중 일부는 모바일 기반 클라이언트에도 충분히 적용이 가능하다. 예를 들어 안드로이드와 iOS는 모두 UI의 일부를 컴포넌트로 구성할 수 있는 기능을 제공하므로, 좀 더 손쉽게 해당 UI 부분을 격리한 상태에서 작업하거나 다양한 방식으로 재결합할 수 있다.  

네이티브 모바일 애플리케이션으로 변경을 배포할 때 발생하는 문제 중 하나로, 애플 앱 스토어와 구글 플레이 스토어 모두에서 새 버전을 릴리스하려면 애플리케이션 제출과 심사가 필요하다. 지난 몇 년 동안 앱 스토어에서 애플리케이션을 승인받기 위해 걸리는 기간이 대체로 크게 줄긴 했지만, 여전히 새로운 소프트웨어 릴리스를 배포하려면 시간이 걸린다.  

모바일 애플리케이션 자체도 이런 관점에서는 역시 모놀리스다. 네이티브 모바일 애플리케이션의 한 부분을 변경하기를 원하면 전체 애플리케이션을 배포해야 하기 때문이다. 또한 변경사항이 바로 반영되는 특성으로 인해 새로운 기능 추가가 손쉬운 브라우저와는 달리, 네이티브 앱에 기능을 추가할 경우 새로 내려받아야 한다는 사실도 고려해야만 한다.  

많은 조직에서는 네이티브 앱을 새로 배포할 필요 없이 기존 설치된 네이티브 앱을 동적으로 변경할 수 있게 만들어 이 문제를 해결해왔다. 서버 쪽에서 변경사항을 배포하면 클라이언트 쪽에서는 전용 모바일 애플리케이션 버전을 재배포할 필요 없이 새로운 기능을 즉시 확인할 수 있다. 훨씬 더 정교한 기법을 사용하는 회사도 있지만, 내장 웹 뷰 등의 컴포넌트를 사용하면 손쉽게 목적을 달성할 수 있다.  

iOS와 안드로이드는 애플리케이션을 비롯해 모든 플랫폼을 통틀어 스포티파이(Spotify)의 UI는 상당히 컴포넌트 지향적이다. 간단한 텍스트 헤더부터 음반 커버 또는 재생 목록에 이르기까지, 보이는 거의 모든 것들이 독립된 컴포넌트다. 결국 몇몇 모듈은 하나 이상의 마이크로서비스에 의해 지원을 받는다. 이들 UI 컴포넌트의 구성과 배치는 서버 쪽에서 선언적인 방식으로 정의된다. 스포티파이 엔지니어는 새로운 애플리케이션 버전을 앱 스토어에 제출하지 않고도 사용자가 보는 뷰를 변경하고, 이 변경사항을 신속하게 배포할 수 있다. 이를 통해 훨씬 빠르게 실험하고 새로운 기능을 시도해볼 수 있다.  

##### 3.5.3. 사례: 마이크로 프론트엔드  
<br/>

웹 브라우저의 대역폭과 기능이 향상됨에 따라, 브라우저에서 실행되는 코드의 정교함도 향상되었다. 많은 웨 기반 사용자 인터페이스는 이제 여러 웹 페이지로 구성된 애플리케이션 개념을 없애는 단일 페이지 애플리케이션(Single Page Application, SPA) 형태의 프레임워크를 사용한다. 기존과는 달리 모든 것이 단일 창에서 실행되는 훨씬 더 강력한 사용자 인터페이스가 등장함으로써, 이전에는 자바의 스윙(Swing)처럼 '두꺼운(thick)' UI SDK를 사용하는 경우에만 이용할 수 있었던 브라우저 내의 사용자 경험을 누구나 효과적으로 누릴 수 있다.  

단일 페이지에 전체 인터페이스를 배포할 경우에는 명백히 페이지 기반 컴포지션을 고려할 수 없으므로 위젯 기반 컴포지션이라는 형태를 고려해야 한다. 웹을 위한 공통 위젯 형식을 체계적으로 정리하려는 시도가 계속되어왔다. 최근 W3C는 웹 컴포넌트(Web Component) 명세로 여러 브라우저 사이에서 지원되는 표준 컴포넌트 모델을 정의하려 시도하고 있다. 그러나 이 표준이 주목을 끄는 데는 오랜 시간이 걸렸으며 (다른 무엇보다) 브라우저 지원은 상당한 걸림돌이 되었다.  

뷰, 앵귤러, 리액트 등의 단일 페이지 앱 프레임워크 개발자들은 웹 컴포넌트로 문제가 해결되길 마냥 기다리기보단 전체 브라우저 창을 소유하도록 설계된 초창기 SDK로 만들어진 UI를 어떻게 모듈화할지에 대한 문제점을 해결하려고 노력해왔다. 그 결과, 몇몇 사람들이 마이크로 프론트엔드(Micro Frontends)라고 부르는 뭔가를 밀어붙이기 시작했다.  

언뜻 보면 마이크로 프론트엔드는 사용자 인터페이스를 독립적으로 작업할 수 있는 다른 컴포넌트로 분해하는 것에 불과하다. 이런 점에서 마이크로 프론트엔드는 전혀 새로운 것이 아니다. 컴포넌트 지향 소프트웨어는 이미 몇 년 앞서 태어났다. 더 흥미로운 점은 사람들이 웹 브라우저, SPA, SDK, 컴포넌트를 함께 작동하게 만드는 방법을 연구하고 있다는 사실이다. 어떻게 하면 종속성 충돌을 피하면서 뷰와 리액트를 사용해 단일 UI를 작성하고, 게다가 잠재적으로 정보를 공유하게 만들 수 있을까?  

이 주제 대산 세부 내용은 이 책의 범위를 벗어난다. 이런 작업을 수행하기 위한 정확한 방법은 사용 중인 SPA 프레임워크에 따라 다르기 때문이기도 하다. 그러나 분해하고자 하는 단일 페이지 애플리케이션과 씨름하고 있는 사람은 여러분만이 아님을 기억하자. 많은 사람이 이 작업을 성공시키기 위해 다양한 기법과 라이브러리를 공유하고 있다.  

##### 3.5.4. 적용 대상  
<br/>

시스템을 재플랫폼화하는 작업을 허용하는 기법인 UI 컴포지션(composition)은 전체 기능을 분야별로 나눠 마이그레이션하는 과정에서 매우 효과적이다. 하지만, UI 컴포지션이 동작하려면 새로운 기능을 안전하게 삽입할 수 있도록 기존 UI를 변경할 수 있어야 한다. 어떤 기법을 사용할 수 있는지는 UI를 구현하기 위해 사용되는 기술의 특성에 따라 다르다는 사실에 주목해야 한다. 전통적인 웹 사이트는 UI 컴포지션이 손쉬운 반면에 SPA 기술은 복잡성이 추가되므로 구현 방식이 종종 난잡해진다.  

#### 3.6. 패턴: 추상화에 의한 분기  
<br/>

+ 트렁크 기반 개발(trunk-based development)  
간선(trunk)에서 직접 변경하고 지선(브랜치)을 피하는 방식  

유용한 교살자 무화과 패턴을 이요하려면, 모놀리스 주위에서 호출을 가로챌 수 있어야 한다. 그러나 추출하기를 원하는 기능이 기존 시스템 내부에 깊이 들어가 있다면 어떻게 될까? 앞서 소개한 사례로 돌아가서 통지 기능을 추출하기 위한 요구사항을 고려해보자.  

이런 추출 작업을 수행하려면 기존 시스템을 변경해야 할 것이다. 이런 변경사항은 코드베이스에서 동시에 작업하는 다른 개발자들에게 심각한 지장을 줄 수도 있다. 여기서 경쟁적인 긴장 상황이 별어진다. 점진적인 단계에 맞춰 변경하기를 원하는 한편, 코드베이스의 다른 영역에서 작업하는 개발자들도 방해하지 않기를 원한다. 그러면 자연스럽게 우리는 작업을 빨리 완료하고 싶어질 것이다.  

간혹 기존 코드베이스의 일부를 재작업하는 경우, 사람들은 별도의 소스 코드 브랜치에서 작업할 것이다. 이렇게 하면 다른 개발자의 작업을 방해하지 않고도 변경 작업을 할 수 있다. 하지만 일단 브랜치에서 변경 작업이 완료되고 나면 이런 변경사항을 다시 병합해야 하는데, 이는 심각한 문제를 유발할 수도 있다. 브랜치를 병합하지 않고 내버려두면 나중에 문제가 생긴다. 지속적인 통합 원칙에 위배된다고 말하는 것 이외에는 장기간 병합되지 않은 상태로 남아있는 소스코드 브랜치와 관련된 문제를 여기서 자세히 설명하지는 않겠다. 또한 2017 데브옵스 상태 보고서(http://bit.ly/2pctNfn)의 자료에 따르면, 트렁크 기반 개발(trunk-based development)을 수용하고 단기 브랜치를 사용하면 IT 팀은 더 높은 효율을 발휘한다. 브랜치를 장기간 병합하지 않은 상태로 두는 것은 피해야 한다. 이런 주장을 하는 이가 나뿐만은 아닐 것이다.  

따라서 코드베이스를 점진적인 방식으로 변경해야 할 뿐더러, 코드베이스의 다른 부분에서 작업하는 개발자들의 업무 중단도 최소화할 수 있길 원한다. 소스 코드 브랜치에 의존하지 않고 모놀리스를 점진적으로 변경할 수 있는 패턴은 또 있다. 추상화에 의한 분기(Branch by abstraction) 패턴이란 기존 코드베이스를 변경함으로써, 구현된 코드가 안전하게 동일 버전의 코드에서 공존할 수 있고 중단도 최소화할 수 있는 방식이다.  

##### 3.6.1. 작동 원리  
<br/>

추상화에 의한 분기는 다음과 같은 5단계로 진행된다.  

(1) 대체할 기능을 위한 추상화를 생성하자.  
(2) 새로운 추상화를 사용하기 위해, 기존 기능을 이용하는 클라이언트를 변경하자.  
(3) 기능을 대체해 추상화를 새롭게 구현하자. 여기서 새로운 마이크로서비스를 호출할 것이다.  
(4) 새로운 구현을 사용하도록 추상화를 전환하자.  
(5) 추상화를 정리하고 기존 구현을 제거하자.  

###### 3.6.1.1. 1단계: 추상화 생성  
<br/>

첫 작업은 변경할 코드와 해당 코드의 호출자 간에 상호작용을 표현하는 추상화를 만드는 것이다. 기존 통지 기능이 제대로 팩터링되어 있으면, IDE에서 추출 인터페이스(Extract Interface) 리팩터링을 적용하는 만큼이나 간단할 수 있다. 그렇지 않다면, 봉합(seam)을 추출해야 할 수도 있다. 이 과정은 코드베이스에서 이메일, SMS, 혹은 그 밖에 있을 수도 있는 통지 메커니즘을 보내는 API에 대한 호출을 검색하는 방식과 관련이 있을지도 모른다. 관련 코드를 찾고, 다른 코드가 사용하는 추상화를 작성하는 단계는 필수다.  

###### 3.6.1.2. 2단계: 추상화 사용  
<br/>

추상화를 생성했으면, 이 새로운 추상화 지점을 사용하기 위해 통지 기능의 기존 클라이언트를 리팩터링할 필요가 있다. 추출 인터페이스 리팩터링이 자동으로 이 작업을 수행했을 수도 있지만, 일반적으로 문제의 기능에 대한 인바운드 호출을 수동으로 추적하는 점진적인 과정이 필요할 것이다. 여기서 좋은 점은 이런 변경이 작고 점진적이라는 사실이다. 기존 코드에 심각한 영향을 주지 않으면서 작은 단계로 수행할 수 있기 때문이다. 이시점에서 시스템 동작에 대해 기능적인 변경이 있어서는 안 된다.  

###### 3.6.1.3. 3단계: 새로운 구현 만들기  
<br/>

새로운 추상화가 자리를 잡고 나면, 이제 새로운 서비스를 호출하기 위한 구현 작업을 시작할 수 있다. 모놀리스 내부에서 통지 기능의 구현은 대부분 외부 서비스로 향하는 클라이언트 호출뿐이며, 대다수 기능은 서비스 자체에 있다.  

이 시점에서 이해해야 할 핵심은, 코드베이스에는 두 가지 추상화 구현이 동시에 존재하지만 시스템에서는 기존 구현 하나만 활성화되어 있다는 사실이다. 실제로, 새로운 서비스를 호출하기 위한 구현은 자동 준비가 될 때까지는 휴면 상태다. 새로운 서비스에서 동등한 모든 기능을 구현하기 위해 작업하는 동안, 새로운 추상화 구현은 '구현되지 않음' 오류를 반환할 수도 있다. 기존 구현만 활성화되어 있다는 특성으로 인해 새롭게 작성한 기능에 대한 테스트 구현이 방해받지 않으며, 최대한 빠르게 작업을 통합할 수 있기에 유리하다.  

이 과정에서 우리는, 교살자 무화과 패턴과 마찬가지로, 작업 중인 사용자 통지 서비스를 운영 환경에 배포할 수도 있다. 아직 구현이 완료되지 않아도 문제 없다. 이 시점에서 통지 추상화 구현이 활성화되지 않으므로 서비스는 실제로 호출되지 않는다. 그러나 사용자 통지 서비스를 배포하고, 현장에서 테스트하고, 구현한 기능의 일부가 올바르게 작동하는지 검증할 수 있다.  

이 단계는 상당히 오랫동안 지속될 수 있다. 제즈 험블(Jez Humble)은 지속적인 통합 애플리케이션인 GoCD(당시엔 크루즈(Cruise)라고 부름)에 사용된 데이터베이스 영속성 계층을 마이그레이션하기 위해 추상화에 의한 분기 패턴의 사용 경험을 자세히 설명했다(http://bit.ly/2p95lv7). 아이바티스(iBatis)에서 하이버네이트(Hibernate)로 전환하는 작업은 몇 달간 이어졌으며, 이 기간 동안 애플리케이션은 주 2회로 꾸준히 고객에게 출시되고 있었다.  

###### 3.6.1.4. 4단계: 구현 전환  
<br/>

새 구현이 올바르게 작동하는 것에 만족하면, 새 구현을 활성화하고 이전 기능이 더 이상 사용되지 않도록 추상화 지점을 전환한다.  

이상적으로는 교살자 무화과 패턴과 마찬가지로, 쉽게 끄고 켤 수 있는 전환 메커니즘을 사용하는 방식을 선호한다. 이렇게 하면 문제를 발견할 경우, 이전 기능으로 신속하게 전환할 수 있다. 이에 대한 일반적인 해법은 기능 토글(feature toggle)을 사용하는 것이다. 구성 파일을 사용해 구현한 토글을 볼 수 있으며, 이 기능을 활용하면 코드를 변경하지 않고도 사용 중인 구현을 변경할 수 있다. 기능 토글과 실제 구현 방법을 더 자세히 알고 싶다면 피트 호지슨(Pete Hodgson)이 작성한 훌륭한 글(https://martinfowler.com/articles/feature-toggle.html)을 읽어보자.  

이 단계에서는 동일한 추상화의 2가지 구현이 존재하며 기능적으로 동등해야 마땅하리라 기대한다. 테스트를 사용해 동등성을 검증할 수 있지만, 운영에서 2가지 구현을 모두 사용해 추가 검증을 제공하는 선택지도 존재한다.  

###### 3.6.1.5. 5단계: 정리  
<br/>

이제 새로운 마이크로서비스가 사용자에게 모든 통지를 제공했으므로 정리 작업에 집중하자. 이 시점에서 기존 사용자 통지 기능은 더 이상 사용되지 않으므로, 이를 제거하는 명시적인 단계를 밟는다. 드디어 모놀리스가 작아지기 시작했다!  

기존 구현을 제거할 때는, 혹시 추가했을지도 모르는 기능 플래그 전환 구현부도 제거하는 편이 합리적이다. 기능 플래그 사용과 관련된 현실적인 문제 중 하나는 오래된 플래그를 그대로 두는 것인데, 그렇게 해서는 안 된다! 더 이상 필요하지 않은 플래그는 제거해서 환경을 단순하게 유지하자.  

마지막으로, 기존 구현을 제거하고 나서 추상화 지점 자체를 제거하는 선택지도 있다. 그러나 앞서 만들어놓은 추상화를 필요한 위치에 두면, 코드베이스의 품질이 향상될 수도 있다. 기존에 만들어놓은 추상화가 인터페이스만큼 단순한 경우라면, 제거하지 않고 놓아둬도 기존 코드베이스에는 영향을 거의 미치지 않을 것이다.  

##### 3.6.2. 대체 메커니즘을 위한 분기 검증  
<br/>

새 서비스가 유용하게 작동하지 않는 경우라면 기존 구현으로 다시 전환할 수 있는 기능이 유용할 텐데, 이를 자동으로 수행할 수 있는 방법이 있을까? 스티브 스미스(Steve Smith)는 실시간 검증 단계를 구현하기 위해, 추상화에 의한 분기 패턴을 변형한 추상화에 의한 분기 검증(verify branch by abstraction, http://bit.ly/2mLVevz)이라는 패턴을 자세히 설명했다. 새로운 구현에 대한 호출이 실패하면 기존 구현을 대신 사용할 수 있다는 개념이다.  

추상화에 의한 분기 검증은 확실히 코드 측면뿐만 아니라 시스템에 대한 추론 측면에서도 약간의 복잡성이 추가된다. 사실상, 두 구현 모두 특정 시점에서 활성화될 수 있으므로 시스템 동작을 이해하기가 더 어려워질 수도 있다. 두 구현이 상태 보존형(stateful)이면 데이터 일관성도 고려해야 한다. 구현 간에 전환이 일어나는 모든 상황에서 데이터 일관성은 문제가 되지만, 추상화에 의한 분기 검증 패턴을 사용하면 요청별로 구현 간에 전환이 일어날 수 있으므로 두 구현이 모두 접근할 수 있는 공유 데이터 집합이 필요할 것이다.  


##### 3.6.3. 적용 대상  
<br/>

추상화에 의한 분기는 상당히 범용적인 패턴으로서, 기존 코드베이스를 변경하는 데 시간은 걸리지만 동료의 작업에 지장을 초래하지 않으려는 상황에서 유용하다. 거의 모든 상황에서 나는, 코드 브랜치를 오래 유지하는 쪽보다는 추상화에 의한 분기가 더 낫다고 생각한다.  

마이크로서비스 아키텍처로 마이그레이션하는 경우, 여러 면에서 더 단순한 교살자 무화과 패턴을 이용하는 편이 나을 것이다. 그러나 여기서 소개한 통지 기능과 같이 불가능한 몇몇 상황도 존재한다.  

추상화에 의한 분기 패턴은 기존 시스템의 코드를 변경할 수 있다는 전제도 가정한다. 어떤 이유로든 변경이 불가능하다면 다른 선택지를 검토해야 할 수도 있다.  

#### 3.7. 패턴: 병행 실행  
<br/>

새로운 구현을 배포하기 전에 할 수 있는 테스트는 무척 많다. 새로운 마이크로서비스에 대한 출시 전 검증을 최대한 운영 환경과 유사한 상황에서 정상적인 테스트 프로세스의 일부로서 수횅할 것이지만, 운영 환경 설정에서 일어날 수도 있는 시나리오에 모두 대응할 수는 없음을 우린 알고 있다. 그러나 우리에게는 대안이 있다.  

교살자 무화과 패턴과 추상화에 의한 분기 패턴은 모두, 동일한 기능에 대한 기존 구현과 새로운 구현이 운영 환경에서 동시에 공존할 수 있게 해준다. 일반적으로 이 두 기법을 통해, 기존의 모놀리스 구현과 새로운 마이크로서비스 기반 구현 사이에서 전환 실행이 가능하다. 두 기법을 사용할 경우, 새로운 서비스 기반 구조로 전환하는 과정에서 위험을 완화할 목적으로 문제가 발생할 경우 기존 구현으로 신속하게 되돌아갈 수 있다.  

병행 실행(parallel run)을 사용할 때, 기존 또는 새로운 구현 중 하나를 호출하는 대신 2가지를 모두 호출해서, 동일하게 동작하는지 결과를 비교해 확인할 수 있다. 2가지 구현을 모두 호출해도, 주어진 시점에서 오직 구현 하나만을 진실의 원천(source of truth)으로 간주한다. 일반적으로, 지속적인 검증 결과로 새로운 구현을 신뢰할 수 있음이 밝혀질 때까지는 기존 구현을 진실의 원천으로 간주한다.  

일반적으로 두 시스템을 병행 실행하는 데 쓰이는 병행 실행 패턴은 수십 년간 다양한 형태로 사용되어 왔다. 기능이 동일한 두 구현을 비교할 경우, 단일 시스템 내에서는 이 병행 실행 패턴이 가장 유용할 것이다.  

이 기법은 새로운 구현이 기존 구현과 동일한 답변을 제공하는지를 검증하는 과정은 물론, 허용 가능한 비기능적인 매개변수 내에서 작동하는지 검증하는 과정에서도 사용될 수 있다. 예를 들어, 새로운 서비스가 충분히 빠르게 응답하는가? 시간이 초과되는 현상이 계속해서 발생할까?  

##### 3.7.1. 사례: 신용파생 가격 비교  
<br/>

신용파생상품이라는 금융상품의 유형을 계산하는 데 사용되는 플랫폼을 변경하는 프로젝트가 있다. 은행은 제공하고 있는 다양한 파생상품이 합리적인 거래인지 확인이 필요했다. 이 거래에서 돈을 벌 수 있을까? 거래가 너무 위험했나? 일단 발행되고 아면 시장 상황도 달라질 것이다. 또한 시장 상황이 바뀐다면, 현재 거래의 가치를 평가해서 막대한 손실에 취약하지는 않은지 확인해볼 필요도 있었다.  

당시 이런 중요한 계산을 수행하던 기존 시스템들은 새로운 시스템으로 거의 완전히 대체되고 있었다. 사람들의 보너스 금액이 앞서 거래 가치에 일부 기반해서 산정되었다는 사실과 함께 투자 금액의 규모로 인해, 사람들은 시스템의 변경 결과에 관심이 많았다. 우리는 두 계산 집합을 나란히 실행하고 결과를 매일 비교하기로 결정했다. 가격 책정 이벤트가 트리거되었으며, 두 시스템이 계산을 수행하는 방식으로 복제가 쉬웠다.  

매일 아침, 결과에 대해 일괄 조정을 실행한 다음, 결과가 다른 이유를 설명해야 했다. 따라서 조정을 수행하는 프로그램을 작성해서, 은행 소속 전문가들과의 토론에 용이하도록 액셀 스프레드시트로 만들었다.  

우리가 해결해야 할 문제도 몇 가지 있었지만, 그보다는 기존 시스템의 버그 때문에 차이가 생긴 경우가 더 많았다. 차이를 보이는 결과 중에서 몇몇은 우리 구현이 정확했지만, 그래도 확인을 위해 우리가 진행한 작업 내역을 보여줘야만 했다(엑셀로 만들었기에 더 수월했다). 나는 확인을 위해 우리가 진행한 작업 내역을 보여줘야만 했다(엑셀로 만들었기에 더 수월했다). 나는 분석가들과 함께 앉아 기본적인 계산법을 적용해 결과가 올바른 이유를 설명했던 적이 있다.  

결국 한 달 후 우리는 우리가 만든 시스템을 계산에 대한 진실의 원천으로 사용하도록 전환했으며, 얼마 지나지 않아 기존 시스템을 폐기했다(이전의 시스템에서 행한 계산에 대한 감사(audit)를 수행해야 할 경우를 대비해 이전 시스템을 몇 개월 더 유지했다).  

##### 3.7.2. 사례: 홈게이트 목록  
<br/>

홈게이트(Homegate)는 목록 가져오기를 처리하는 새로운 마이크로서비스와 기존의 모놀리스를 비교하기 위해, 목록 가져오기 시스템을 병행 실행했다. 고객이 FTP에 업로드를 하면 두 시스템은 모두 구동된다. 새로운 마이크로서비스가 동등한 방식으로 작동하고 있음을 확인한 후에, FTP 가져오기는 기존 모놀리스에서 비활성화되었다.  

###### 3.7.2.1. N버전 프로그래밍  
<br/>

전기 신호식 비행조종 제어(fly-by-wire) 항공기와 같은 특정 안전 핵심 제어 시스템에는 병행 실행의 변형이 존재한다고 주장할 수 있다. 항공기는 기계식 제어에 의존하기보다 디지털 제어 시스템에 의존하는 경우가 점점 더 많아지고 있다. 조종사가 케이블 장치를 당겨서 방향타를 제어하는 것이 아니라 제어 장치를 사용하면, 전기 신호식 비행조종 제어 항공기는 제어 시스템에 입력을 보내고 이 시스템은 방향타의 회전각을 결정한다. 이런 제어 시스템은 전송된 신호를 해석하고 적절한 행동을 수행해야 한다.  

분명히, 이런 제어 시스템에 버그가 있다면 매우 위험할 수 있다. 결함의 영향을 상쇄하기 위해 몇몇 상황에서는 동일한 기능의 여러 구현이 나란히 사용된다. 동일한 하위 시스템의 모든 구현으로 신호가 전송되고 나면, 그다음으로 응답이 전송된다. 일반적으로 참가자들 사이에서 장족수를 찾는 방법으로, 결과를 비교하고 '올바른' 한 가지 결과를 선택한다. 이 기법을 N버전 프로그래밍(N-version programming)이라 부른다.  

이런 접근 방식의 최종 목표는 구현을 대체하지 않는 것이다. 그 대신, 주어진 하위 시스템 중 하나가 버그의 영향을 감소시킬 것이라는 희망하에 동일한 작업을 수행하는 여러 구현체가 계속해서 함께 존재할 것이다.  

##### 3.7.3. 검증 기법  
<br/>

병행 실행으로 기존 구현과 신규 구현(모놀리스와 마이크로서비스 버전)의 기능적인 동등성을 비교하고자 한다. 앞서 신용파생상품의 가격 결정 예를 살펴보면, 두 버전을 함수로 취급할 수 있다(동일한 입력을 제공할 경우 동일한 출력을 기대함). 그러나 비기능적인 측면도 당연히 검증할 수 있다. 네트워크 경계를 넘어 호출이 일어나면 대기 시간은 상당히 길어지고 시간 초과, 분할 등으로 인해 요청이 손실될 수 있다. 따라서 검증 프로세스는 새로운 마이크로서비스에 대한 호출이 적절한 실패율로 적시에 완료되도록 보장하는 범위까지 확장되어야 마땅하다.  

##### 3.7.4. 스파이 사용  
<br/>

앞서 설명한 통지 기능 사례의 경우, 고객에게 이메일을 두 번 보내기를 원하지 않는다. 이 상황에서는 스파이(Spy)가 유용하다. 단위 테스트(unit test)에서 유래한 패턴인 스파이는 일부 기능을 대신할 수 있으며, 특정 작업이 완료된 후 검증(verify)하는 것이다. 스파이는 기존 기능을 원래 위치에서 제거하고 자신의 기능으로 이를 대체한다.  

따라서 통지 기능의 경우 스파이를 사용하면 실제로 이메일을 전송하는 데 사용되는 하위 수준의 코드를 대체할 수 있다. 이렇게 심어놓은 스파이를 사용해 새로운 통지 서비스는 병행 실행 단계에서 sendNotification 호출을 서비스가 수신할 때 부작용(이메일 전송)을 유발하는지 검증한다.  

모놀리스 내부에서 스파이를 사용하기로 결정하는 동시에 RemoteNotification 코드가 서비스 호출을 하지 못하게 만들 수도 있었다는 사실에 주목하자. 그러나 새로운 통지 서비스에 대한 시간 초과, 실패 또는 일반적인 대기 시간이 운영 환경에서 문제를 초래하는지 이해할 목적으로 원격 호출의 영향을 실제로 고려하려는 경우, 이 방법은 원하는 방식이 아닐 수도 있다.  

여기서 또 하나 추가된 복잡성은 스파이가 독립적인 프로세스에서 실행되고 있다는 사실이며, 이는 검증 프로세스 수행 과정을 복잡하게 만들 것이다. 원래 요청의 범위 내에서 이 작업을 실시간으로 수행하려면,  통지 서비스에 초기 호출을 전송한 후 검증을 위해 통지 서비스에서 메소드를 외부로 공개할 필요가 있다. 외부 공개를 위한 코드 수정은 상당히 큰 작업일 수 있지만, 많은 경우 실시간 검증이 필요하지 않다. 프로세스 외부에 존재하는 스파이의 검증을 위한 가능성 있는 모델은 아마도 일상적으로 검증이 대역 외에서 이뤄질 수 있도록 상호작용을 기록하는 방식이다. 스파이를 사용해 통지 서비스에 대한 호출을 대체한 경우, 검증은 쉬워지지만 아무래도 테스트를 덜 하게 된다. 스파이로 대체하는 기능이 많을수록, 실제로 테스트하는 영역이 줄어든다.  

##### 3.7.5. 깃허브 사이언티스트  
<br/>

코드 수준에서 이 패턴을 구현하는 경우에 주목할 만한 라이브러리인 깃허브의 사이언티스트 라이브러리(Scientist library, https://github.com/github/scientist)는 두 구현을 나란히 실행하고 재구현에 대한 정보를 캡처해 제대로 작동하는지 파악하는 기능을 제공하는 루비(Ruby) 라이브러리다. 내가 직접 사용해보지는 않았지만 이와 같은 라이브러리는 기존 시스템과 대비해 새로운 마이크로서비스 기반 기능을 검증하는 과정에서 실제로 도움을 주는 방안을 제시한다. 지금은 자바, 닷넷(.NET), 파이썬, 노드제이에스(Node.JS) 등의 여러 언어에 이식되어 있다.  

##### 3.7.6. 어둠의 출시와 카나리아 릴리스  
<br/>

병행 실행은 전통적인 카나리아 릴리스(canary release)와는 다르다는 사실에 주목할 필요가 있다. 카나리아 릴리스는 사용자 중 일부만 새로운 기능으로 안내하고 대다수 사용자는 기존 구현을 그대로 사용하게 만든다. 새로운 시스템에 문제가 있는 경우 몇몇 사용자의 요청에만 영향을 미친다는 개념이다. 병행 실행에서는 두 가지 구현을 모두 호출한다.  

또 다른 관련 기법을 어둠의 출시(dark launching)라고 한다. 어둠의 출시에서는 새 기능을 배포하고 테스트하지만 새 기능이 사용자에게는 보이지 않는다. 따라서 작동하는 시스템으로 전환할 때까지 '새로운' 기능이 사실상 사용자에게 보이지 않기 때문에 병행 실행은 어둠의 출시를 구현하는 한 가지 방법이다.  

어둠의 술시, 병행 실행, 카나리아 릴리스는 모두, 새로운 기능이 올바르게 작동하는지 검증하고, 그렇지 않을 경우 영향력을 줄이기 위해 사용되는 기법이다. 이 모든 기법은 점진적 배포(progress delivery)의 가치 아래에 있다. 여기서 점진적 배포란 소프트웨어가 사용자게 출시되는 방법을 더 미묘한 방식으로 제어하는 과정에 도움을 주는 방법론을 기술하기 위해 제임스 거버너(James Governer)가 처음 쓴 포괄적 용어(http://bit.ly/2lZjrxK)로서, 소프트웨어의 유효성을 검증하고 문제가 발생했을 때 문제의 영향력을 줄이면서 소프트웨어를 더 신속하게 릴리스하게 만드는 기법이다.  

##### 3.7.7. 적용 대상  
<br/>

병행 실행의 구현은 결코 사소하지 않으며, 일반적으로는 변경되는 기능의 위험성이 높다고 간주되는 경우에 사용된다. 이 패턴을 사용할 대상은 주의 깊게 선택해야 하며, 구현 과정에서 얻는 장단점을 꼼꼼하게 따질 필요가 있다.  

#### 3.8. 패턴: 협업자 데코레이터  
<br/>

모놀리스 내부에서 발생하는 사건에 기반해 몇몇 동작을 트리거하기를 원하지만, 모놀리스 자체를 변경할 수 없는 경우에는 어떻게 할까? 협업자 데코레이터(decorating collaborator) 패턴은 여기서 큰 도움이 될 수 있다. 널리 알려진 데코레이터 패턴을 사용하면 관련된 기반 기능을 모르더라도 새로운 기능을 뭔가에 연결할 수 있다. 실제로 기반 모놀리스를 변경하지 않았더라도, 모놀리스가 서비스를 직접 호출하는 것을 드러내기 위해 여기서 데코레이터를 사용할 것이다.  

이런 호출이 모놀리스에 도달하기 전에 가로채는 대신, 정상적으로 호출을 허용할 수 있다. 그런 다음 이 호출의 결과에 기반해서, 우리가 임의로 선택한 협업 메커니즘을 통해 외부 마이크로서비스를 호출할 수 있다.  

##### 3.8.1. 사례: 멤버십 프로그램  
<br/>

주문 결과에 따라 포인트를 적립할 수 있는 기능을 추가하고 싶지만, 현재 주문 기능이 복잡해 지금 당장은 변경하지 않을 것이다. 따라서 주문 기능은 기존 모놀리스에 그대로 유지되지만, 프록시를 사용해 호출을 가로채고 결과에 기반해 제공할 포인트를 결정할 것이다.  

성공적으로 주문을 접수하고 나면 프록시는 고객에게 포인트를 추가하기 위해 멤버십 서비스를 호출한다.  

교살자 무화과 패턴에서 프록시는 상당히 단순했다. 여기서 우리의 프록시는 훨씬 더 많은 '똑똑한 기능'을 구현하고 있다. 프록시는 새로운 마이크로서비스를 자체적으로 호출하고 고객에게 다시 응답을 보내야 한다. 이전과 마찬가지로 프록시에 존재하는 복잡성에 주목해보자. 여기에 추가할 코드가 많을수록, 기술적인 문제가 아니더라도 앞서 설명한 모든 문제를 해결하기 위해 프록시는 자체적인 마이크로서비스가 될 가능성도 높아진다.  

마이크로서비스를 호출할 수 있도록 인바운드 요청에 충분한 정보가 필요하다는 또 다른 잠재적인 과제도 남아 있다. 예를 들어 주문 금액을 기준으로 포인트를 보상하고 싶지만, 주문 요청이나 응답에서 주문 금액이 명확하지 않은 경우 추가 정보를 추출하기 위해 모놀리스를 다시 호출해야 할 수도 있다.  

멤버십 서비스는 보상 포인트가 얼마인지 알아내기 위해 세부 주문 내역을 로드해야 한다.  

이 호출로 인해 추가적인 부하가 생겨나고 어쩌면 순환 종속성을 일으킬 수도 있으므로, 주문이 완료되는 시점에 필요한 정보를 제공하는 방식으로 모놀리스를 변경하는 편이 더 바람직할 수도 있다. 그러나 이를 위해서는 모놀리스 코드를 변경한다거나, 변경 데이터 캡처처럼 내부를 파고드는 기술을 사용해야 할 것이다.  

##### 3.8.2. 적용 대상  
<br/>

협업자 데코레이터 패턴은 단순하게 유지하면 변경 데이터 캡처보다 더 우아하고 덜 결합된 접근 방식이다. 이 패턴은 인바운드 요청 또는 모놀리스에서 오는 응답에서 필요한 정보를 추출할 수 있는 경우에 가장 효과적이다. 새로운 서비스에 대한 올바른 호출을 위해 더 많은 정보가 필요한 경우, 이 구현은 더 복잡해지고 이리저리 얽히게 된다. 모놀리스에 대한 요청과 응답에 필요한 정보가 포함되어 있지 않다면, 이 패턴을 사용하기 앞서 신중하게 생각하는 편이 좋을 것 같다.  

#### 3.9. 패턴: 변경 데이터 캡처  
<br/>

모놀리스에 대한 인바운드 호출을 가로채 처리하는 대신, 변경 데이터 캡처(change data capture)를 사용해 데이터 저장소에 일어난 변경사항에 대응한다. 변경 데이터 캡처가 작동하려면 기반 캡처 시스템이 모놀리스의 데이터 저장소에 결합되어야 한다. 이는 변경 데이터 캡처 패턴에서 결코 피할 수 없는 과제다.  

##### 3.9.1. 사례: 멤버십 카드 발급  
<br/>

사용자가 가입할 때 멤버십 카드를 발급하기 위해 일부 기능을 통합하고자 한다. 현재는 고객이 등록될 때 멤버십 계정이 만들어진다. 모놀리스에서 등록 결과가 반환되면 고객이 성공적으로 등록되었음을 알 수 있다. 카드를 발급하려면, 고객에 대한 세부정보가 필요하다. 따라서 협업자 데코레이터를 사용해 이 동작을 업스트림에 삽입하는 작업은 정보 획득 과정 때문에 더 어려워진다. 호출이 반환되는 시점에서 모놀리스에 추가 쿼리를 보내 우리가 원하는 다른 정보를 추출해야 하는데, 이 정보는 API를 통해 공개될 수도, 공개되지 않을 수도 있다.  

여기서 변경 데이터 캡처를 사용하기로 결정했다. LoyaltyAccount 테이블에 내용이 추가됐음을 감지하고, 내용이 추가되면 새로운 멤버십 카드 발급 서비스를 호출한다. 이와 같은 상황에서 우리는 멤버십 계정 생성 이벤트를 일으키기로 결정한다. 발급 프로세스는 일괄 작업으로 가장 잘 작동하므로, 이를 통해 카드 발급 목록을 메시지 브로커에서 작성할 수 있다.  

##### 3.9.2. 변경 데이터 캡처 구현  
<br/>

다양한 기술을 사용해 변경 데이터 캡처를 구현할 수 있으며, 복잡성, 신뢰성, 적시성 측면에서 다양한 절충안이 존재한다.  

###### 3.9.2.1. 데이터베이스 트리거  
<br/>

대다수 관계형 데이터베이스에서는 데이터가 변경될 때 사용자 지정 동작을 트리거할 수 있다. 정확한 트리거 정의 방식과 트리거 대상은 각기 다르지만 모든 최신 관계형 데이터베이스는 어떤 식으로든 이런 기능을 지원한다. 예에서 서비스는 INSERT가 LoyaltyAccount 테이블에 적용될 때마다 호출된다.  

트리거는 다른 저장 프로시저(stored procedure)와 마찬가지로 물리적으로 데이터베이스 자체에 설치돼야 한다. 이런 트리거가 수행할 수 있는 작업에 대한 제약이 있을지도 모르지만, 적어도 오라클(Oracle)에는 웹 서비스 또는 사용자 정의 자바 코드를 호출하는 기능이 상당히 잘 만들어져 있다.  

처음에는 트리거 구현이 매우 간단한 작업처럼 보일 수 있다. 다른 소프트웨어를 실행할 필요가 없으며 새로운 기술을 도입할 필요도 없다. 그러나 저장 프로시저와 마찬가지로 데이터베이스 트리거는 골칫거리 기능이 될 수도 있다.  

랜디 슈프(Randy Shoup)는 언젠가 이런 말을 한 적이 있다. "데이터베이스 트리거가 한 두 개라면 큰 문제는 아니다. 전체 시스템을 트리거로 구축한다면 그건 끔찍한 발상이다." 물론 간혹 이는 데이터베이스 트리거 기술과 연관된 문제이기도 하다. 트리거가 많을수록 시스템이 실제로 어떻게 작동하는지 이해하기가 더 어려워질 수 있다. 문제는 종종 데이터베이스 트리거의 도구나 변경 관리와 연관이 있다. 너무 많이 사용하면 애플리케이션은 지나치게 장식이 화려한 바로크 건축물 같아질 수도 있다.  

따라서 트리거를 사용하려면, 아주 적게 사용하라.  

###### 3.9.2.2. 트랜잭션 로그 가져오기  
<br/>

대다수 데이터베이스, 특히 모든 주류 관계형 데이터베이스에는 트랜잭션 로그(transaction log)가 존재한다. 이 로그는 일반적으로 파일이며, 모든 변경사항에 대한 기록이 저장된다. 변경 데이터 캡처를 수행하는 가장 정교한 도구(tooling)는 트랜잭션 로그를 사용하는 경향이 있다.  

이런 시스템은 별도 프로세스로 실행되며, 기존 데이터베이스와 유일한 상호작용은 이 트랜잭션 로그를 통해 이뤄진다. 커밋된 트랜잭션만 트랜잭션 로그에 표시된다(이것이 요접이다)는 사실에 유의하자.  

변경 데이터 캡처 도구는 기반 트랜잭션 로그 형식을 이해해야 하며, 로그 형식은 일반적으로 데이터베이스 유형에 따라 다르다. 그렇기 때문에 데이터베이스별로 사용 가능한 도구가 달라진다. 트랜잭션 로그를 지원하는 도구는 매우 많지만, 대부분은 데이터 복제를 지원하는 데 사용된다. 트랜잭션 로그의 변경사항을 메시지 브로커에 전송될 메시지에 매핑하도록 설계된 솔루션도 많다. 트랜잭션 로그를 지원하는 도구는 마이크로서비스가 비동기식일 경우에 특히 유용하다.  

몇몇 제약 사항을 제외하면, 트랜잭션 로그 분석은 여러 측면에서 변경 데이터 캡처를 구현하기 위한 가장 깔끔한 해법이다. 트랜잭션 로그 자체에는 기반 데이터에 대한 변경사항만 표시되므로, 바뀐 내용을 알아내기 위해 걱정할 필요는 없다. 도구는 데이터베이스의 외부에서 동작하며, 트랜잭션 로그의 복제본을 대상으로 실행할 수도 있으므로 결합도(coupling) 또는 경합에 대한 우려도 줄어든다.  

###### 3.9.2.3. 배치 델타 복사기  
<br/>

아마도 가장 단순한 방법은 주기적인 일정에 따라 관심있는 데이터베이스에서 변경된 데이터를 검색하고 이 데이터를 목적지에 복사하는 프로그램을 작성하는 방식일 것이다. 이런 작업은 종종 크론(cron) 또는 이와 유사한 배치 스케줄러(batch scheduler) 같은 도구를 사용해 실행된다.  

가장 큰 문제는 배치 델타 복사기(batch delta copier)가 마지막으로 실행된 이후 실제로 어떤 데이터가 변경됐는지를 알아내는 것이다. 스키마 설계(schema design)에 따라 데이터 변경이 명확하게 드러날 수도 있지만 아닐 수도 있다. 일부 데이터베이스에서는 테이블 메타데이터를 확인해서 언제 데이터베이스가 변경됐는지 확인할 수도 있지만, 보편적인 방법은 아니다. 또한, 이런 기능이 있더라도 행 수준 정보만큼 세밀하지 못한 테이블 수준의 변경된 타임 스탬프만 얻을 수 있다. 이런 타임 스탬프를 직접 추가할 수도 있지만 상당한 부가 작업이 필요하므로, 변경 데이터 캡처 시스템을 토앻 이 문제를 훨씬 더 우아하게 처리할 수 있을 것이다.  

##### 3.9.3. 적용 대상  
<br/>

변경 데이터 캡처는 특히 데이터를 복제할 필요가 있을 경우 유용한 범용 패턴이다. 마이크로서비스 마이그레이션의 경우라면 변경 데이터 캡처가 모놀리스의 데이터 변경에 반응하기 위한 최고의 후보지만, 교살자 패턴이나 데코레이터 패턴을 사용해 시스템 주변에서 이를 가로챌 수 없으며 관련 코드베이스를 변경할 수도 없다.  

일반적으로, 구현의 어려움 때문에 변경 데이터 캡처 패턴은 최소한으로 사용하는 편이 좋다. 데이터베이스 트리거에는 단점이 있으며, 트랜잭션 로그를 처리하는 완전한 변경 데이터 캡처 도구는 솔루션에 상당한 복잡성을 가중시킬 수 있다. 그럼에도 이런 잠재적인 문제를 이해한다면, 변경 데이터 캡처 패턴은 원하는 대로 사용할 수 있는 유용한 도구가 될 것이다.  

#### 3.10. 정리  
<br/>

지금까지 살펴본 바와 같이, 다양한 기법을 활용해 기존 코드베이스를 점진적으로 분해할 수 있으며, 마이크로서비스 세계로 쉽게 진입할 수 있다. 대다수 사람들은 여러 가지 접근법을 혼합해 사용하며, 기법 하나로 모든 상황을 처리하는 경우는 드물다.  

### 4. 데이터베이스 분해  
<br/>

마이크로서비스는 정보은닉을 수행할 때 가장 잘 작동하며, 정보 은닉은 일반적으로 자체 데이터 저장소와 인출 메커니즘을 수행할 때 가장 잘 작동하며, 정보 은닉은 일반적으로 자체 데이터 저장소와 인출 메커니즘을 완전히 캡슐화하는 마이크로서비스로 발전할 수 있다. 따라서 마이크로서비스 아키텍처로 마이그레이션할 때 최대한 좋은 결과를 이끌어내고 싶다면, 모놀리스 데이터베이스를 분리해야 한다는 결론으로 이어진다.  

그러나 데이터베이스를 분리하는 작업은 단순한 노력과는 거리가 멀다. 전환 과정에서 데이터 동기화 문제, 논리적 스키마와 물리적 스키마의 분해, 트랜잭션 무결성, 조인(join), 대기 시간 등을 고려해야 한다.  

#### 4.1. 패턴: 공유 데이터베이스  
<br/>

도메인 결합도, 시간적 결합도, 구현 결합도의 3가지 측면에서 결합도를 생각할 수 있다. 데이터베이스를 공유하는 개발자들은 여러 스키마(schema)에 흩어져 있기 때문에, 데이터베이스를 고려할 때 3가지 결합도 중 가장 큰 비중을 차지하는 결합도는 구현 결합도다.  

언뜻 보기에, 여러 서비스 간에 단일 데이터베이스를 공유하는 방식에는 문제가 많다. 그러나 가장 중요한 문제는 무엇을 공유하고 무엇을 숨길지 결정하는 기회를 부정하는(즉 정보은닉을 무시하는) 것이다. 이는 스키마의 어떤 부분을 안전하게 변경할 수 있는지 이해하기 어려울 수 있다는 뜻이다. 외부 관계자가 데이터베이스에 접근할 수 있음은 알지만, 스키마의 어느 부분을 사용하는지는 모른다는 것은 별개의 문제다. 이는 곧 살펴볼 뷰(view)를 사용해 완화할 수 있으나 완벽한 해법은 아니다.  

또한 누가 데이터를 '제어'하는지 명확하지 않다는 문제도 있다. 해당 데이터를 조작하는 비즈니스 로직은 어디에 있을까? 여러 서비스는 흩어져 있을까? 만약 그렇다면, 이는 비즈니스 로직의 응집력이 부족함을 시사한다. 앞서 설명한 바와 같이 마이크로서비스를 동작과 상태의 조합으로 간주할 때, 마이크로서비스는 하나 이상의 상태 머신(state machine)을 캡슐화한다. 이렇게 상태를 변경하는 동작 방식이 시스템 전체에 퍼져 있다면, 이 상태 머신을 올바르게 구현할 수 있는지 확인하는 작업은 까다로워진다.  

3개 서비스 주문 정보를 직접 변경할 수 있는 경우, 서비스 간에 동작 방식이 일치하지 않으면 어떻게 될까? 이런 동작 방식을 변경해야 한다면 어떻게 될까? 변경사항을 모든 서비스에 적용해야 할까? 앞서 설명했듯이, 우리는 비즈니스 기능의 높은 응집력을 목표로 하지만, 공유 데이터베이스의 존재는 자주 그 반대 현상이 일어나고 있음을 암시한다.  

##### 4.1.1. 패턴 다루기  
<br/>

어려운 작업이 될지도 모르지만, 각 마이크로서비스가 자체적인 데이터를 소유할 수 있도록 데이터베이스를 분리하는 방식이 거의 항상 선호한다. 이런 방식이 불가능하다면, 데이터베이스 뷰 패턴을 사용하거나(167페이지 참고) 데이터베이스 래핑 서비스 패턴을 채택하자(171페이지 참고).  

##### 4.1.2. 적용 대상  
<br/>

데이터베이스를 직접 공유하는 것은 다음과 같은 단 2가지 상황에서만 마이크로서비스 아키텍처에 적합하다고 생각한다. 첫째는 읽기 전용 정적 참조 데이터를 고려할 경우다. 곧 이 주제에 대해 자세히 살펴보겠지만, 국가 통화코드 정보, 우편번호 또는 우편번호 조회 테이블 등을 담는 스키마를 고려해보자. 여기서 데이터 구조는 매우 안정적이며 이와 같은 데이터의 변경 제어는 흔히 관리 작업으로 처리된다.  

둘째로, 여러 서비스가 동일한 데이터베이스에 직접 접근해도 좋다고 생각하는 또 다른 지점은 서비스가 여러 컨슈머를 다루기 위해 설계되고 관리되는 종단점으로서 데이터베이스를 직접 외부에 공개하는 경우다. 서비스로서 데이터베이스(DaaS) 인터페이스 패턴으로 논의할 때 이 개념을 자세히 소개할 것이다(174페이지 참고).  

#### 4.2. 그러나 수행할 수 없다!  
<br/>

따라서 이상적으로 우리는 새 서비스에 각기 독립적인 스키마가 존재하기를 바란다. 그러나 기존 모놀리스 시스템으로 시작하는 경우에는 스키마가 독립적으로 나뉘어 있지 않다. 이는 항상 스키마를 분리해야 한다는 사실을 의미할까? 스키마 분리가 대부분의 상황에서 적절하다고 확신하지만, 초기에 항상 실현 가능하지는 않다. 곧 살펴보겠지만 관련 작업에 시간이 너무 오래 걸리거나, 시스템에서 특히 민감한 부분을 변경해야 할 경우도 있을 것이다. 이런 경우, 최소한 상황이 더 악화되는 것은 막는 다양한 패턴을 사용하는 편이 유용할 수 있으며, 그래야 향후 더 나은 시스템을 위한 현명한 발판을 마련할 수 있다.  

현재 시스템에서 지금 당장 처리하기가 불가능해 보이는 문제에 부딪히게 될 것이다. 지금 당장은 해법을 찾지 못하더라도, 팀원들과 문제를 파고들어, 곧 해결해야 할 문제임을 모두가 동의할 수 있게 해야 한다. 그런 다음에는 최소한 지금 당장 옳은 길로 가고 있다고 자각하게 만들어야 한다. 시간이 흘러 새로운 기술과 경험을 쌓으면, 처음에는 극복하기 어려워 보였던 문제를 다루기가 훨씬 더 쉬워질 것이다.  

##### 4.2.1. 스키마 vs 데이터베이스  
<br/>

기술적으로 보자면, 스키마는 데이터를 담는, 논리적으로 분리된 테이블 집합으로 간주할 수 있다. 이후에 다중 스키마는 단일 데이터베이스 엔진에서 제공될 수도 있다. 상황에 따라, 사람들이 말하는 '데이터베이스'는 스키마나 데이터베이스 엔진을 지칭하기도 한다("데이터베이스가 다운되었습니다!").  

데이터베이스 엔진의 단일 인스턴스는 여러 스키마를 제공할 수 있으며, 각 스키마는 논리적으로 데이터를 격리한다.  

특히 클라우드 공급자가 제공하는 데이터베이스를 다룰 때, 특출나고 다양한 NoSQL 데이터베이스는 논리적 격리와 동일한 개념을 제공할 수도, 제공하지 않을 수도 있다는 사실에 유의해야 한다. 예를 들어 AWS의 다이나모DB에는 테이블 개념만 있으며, 데이터를 보거나 변경할 수 있는 사람을 제한하기 위해 역할 기반 접근 제어(role-based access control)를 사용한다. 이런 상황에서는 데이터베이스 서비스가 논리적 격리를 어떻게 바라보는지에 대해 문제가 생길 수 있다.  

#### 4.3. 패턴: 데이터베이스 뷰  
<br/>

여러 서비스를 위한 단일 데이터 소스(single source of data)를 원하는 상황에서는 뷰(view)를 사용해 결합도와 관련된 문제를 완화할 수 있다. 뷰를 사용하면 기반 스키마에서 제한적으로 투사한 형태의 스키마를 서비스에 제공할 수 있다. 이와 같은 투사(projection) 기법을 통해 서비스에 표출하는 데이터를 제한함으로써, 접근해서는 안 되는 정보를 은닉할 수 있다.  

##### 4.3.1. 공개된 계약으로서 데이터베이스  
<br/>

투자 은행에서 기존의 신용파생 시스템을 재플랫폼화하는 프로젝트에 참여했던 사례를 이야기했다. 데이터베이스 결합도 문제를 대대적으로 공략했다. 시스템을 사용하는 트레이더들에게 더 빠른 피드백을 제공하기 위해 시스템 처리량을 늘려야 했다. 몇 가지 분석을 수행한 결과, 데이터베이스에 수행되는 쓰기 작업이 프로세싱의 병목 현상을 야기한다는 사실을 알게 됐다. 쓰기 시간의 급등을 목격하고 나서야, 스키마를 재구성하면 쓰기 성능을 대폭 향상시킬 수 있다는 사실을 깨달았다.  

그제서야 제어권 밖에 있는 많은 애플리케이션이 데이터베이스에 대한 읽기 접근 권한을 갖고 있으며, 일부 애플리케이션의 경우에는 읽기/쓰기 접근 권한을 동시에 갖고 있음을 알게 되었다. 안타깝게도 이 모든 외부 시스템에 동일한 사용자 이름과 비밀번호 자격 증명이 부여되어 있음을 알게 됐고, 따라서 개별 사용자가 누구인지 또는 무엇에 접근하고 있는지를 파악하는 것은 불가능했다. '20개가 넘는' 애플리케이션이 관련되어 있다고 추정했지만, 이는 네트워크에서 인바운드 호출의 몇 가지 기본적인 분석 결과에서 유추할 뿐이었다.  

각 행위자(actor)(예: 사람 또는 외부 시스템) 각기 다른 자격 증명 집합을 가진 경우, 특정 당사자에 대한 접근을 제한하기가 쉬워지며, 자격 증명 취소의 자격 증명 교대로 인한 영향을 줄이기도, 각 행위자가 무엇을 하는지 제대로 이해하기도 훨씬 더 수월해진다. 다양한 자격 증명 집합을 관리하는 것은 서비스마다 관리할 자격 증명이 여러 집합에 흩어져 있을 수 있는 마이크로서비스 시스템에서 특히 어려울 것이다. 이 문제를 해결하기 위해 전용 비밀 저장소를 사용한다. 수명이 짧고 범위가 제한될 수 있는 데이터베이스 등의 자원에 대해 행위자별 자격 증명을 생성할 수 있는 해시코프(HashiCorp)의 볼트(Vault, https://www.vaultproject.io/)는 이 분야에서 사용 가능한 훌륭한 도구다.  

따라서 우리는 이 사용자들이 누군인지는 알지 못했지만 연락을 해야 했다. 마침내 누군가가 아이디어를 하나 냈다. 사람들이 사용 중인 공유 계정을 비활성화해서, 그들이 항의 문의를 보내길 기다려보자는 아이디어였다. 애당초 일어나지 말았어야 할 문제였기에, 그에 대한 훌륭한 해결책은 분명히 아니었지만, 어느 정도 효과는 있었다. 그러나 이런 대다수 애플리케이션의 대부분이 적극적인 유지 관리하에 있지 않음을 곧바로 깨달았다. 즉 새로운 스키마 설계를 반영해 애플리케이션을 업데이트할 기회는 없다는 사실을 의미했다. 실제로, 데이터베이스 스키마는 마치 API처럼 변경 불가능한 공개적인 약속이 되어, 스키마 구조를 계속 유지해야만 했다.  

##### 4.3.2. 표현할 뷰  
<br/>

일단 외부 시스템이 스키마에 스기 작업을 하는 상황부터 해결하고자 했다. 운좋게도, 이는 상황에 적절한 해법이었다. 그러나 데이터를 읽기 원하는 모든 클라이언트를 위해 기존 스키마처럼 보이는 전용 스키마 호스팅 뷰를 작성하고 원본 스키마 대신 클라이언트가 해당 스키마를 가리키게 했다. 이를 통해 뷰를 유지하는 한, 자체 스키마를 변경할 수 있었다. 많은 저장 프로시저가 관련되었다는 정도만 알고 넘어가자.  

이번 투자 은행 사례에서, 뷰와 기반 스키마는 상당한 차이가 있었다. 물론 뷰를 훨씬 더 단순하게 사용한다면, 외부 사용자에게 보이고 싶지 않은 일부 정보를 숨길 수도 있다. 멤버십 서비스는 시스템의 멤버십 카드 목록일 뿐이다. 현재 이 정보는 고객 테이블에 열(column)로 저장된다. 따라서 고객 테이블에 있는 다른 정보를 외부에 공개하지 않은 채로 고객 ID와 멤버십 ID 매핑만 단일 테이블에 공개하는 뷰를 정의한다. 마찬가지로 모놀리스 데이터베이스에 있을지도 모르는 다른 테이블은 멤버십 서비스에서 완전히 숨겨져 있다.  

기반 스키마에서 제한된 정보만 투사할 수 있는 뷰의 능력을 활용해 정보 은닉 형태를 구현할 수 있다. 뷰를 통해 무엇이 공유되었으며 무엇이 숨겨졌는지를 제어할 수 있다. 하지만 이것은 완벽한 해법이 아니며, 한계가 있다.  

데이터베이스의 특성에 따라, 구체화된 뷰를 작성하는 옵션이 있을 수도 있다. 구체화된 뷰를 사용하면, 일반적으로 캐시 사용을 통해 뷰는 사전 계산된다. 즉 뷰에서 읽을 경우 기반 스키마에서 직접 읽을 필요가 없기 때문에 성능을 높을 수 있다. 하지만 사전 계산된 뷰가 어떻게 업데이트되는지와 관련해 어려움이 생기며, 이는 뷰에서 '김이 빠진(stale)' 데이터 집합을 읽을 수도 있다는 의미일 것이다.  

##### 4.3.3. 한계  
<br/>

뷰 구현 방법은 여러 가지가 있는데 일반적으로는 쿼리 결과다. 이는 뷰 자체가 읽기 전용임을 의미한다. 이런 특성은 유용성을 즉시 제한한다. 또한 관계형 데이터베이스에는 뷰가 공통적인 기능이며, 기술적으로 성숙한 여러 NoSQL 데이터베이스도 뷰를 지원하지만(예: 카산드라와 몽고 모두), 전부는 아니다. 데이터베이스 엔진이 뷰를 지원하더라도, 기반 스키마와 뷰가 동일 데이터베이스 엔진에 존재해야 하는 등의 여러 제약이 있을 가능성이 높다. 이는 물리적인 배포 결합도를 증가시켜 잠재적인 단일 장애 지점을 만들 수 있다.  

##### 4.3.4. 소유권  
<br/>

기반 스키마를 변경하면 뷰를 업데이트해야 할 수도 있으니, 뷰의 소유권이 누구에게 있는지를 신중하게 고려해야 마땅하다. 공개된 데이터베이스 뷰는 서비스 인터페이스와 유사하므로, 기반 스키마를 관리하는 팀이 최신으로 업데이트해서 관리하는 편이 좋다.  

##### 4.3.5. 적용 대상  
<br/>

기존의 모놀리스 스키마를 분해하는 방식이 실용적이지 않다고 여겨지는 상황일 때, 늘 데이터베이스 뷰를 사용한다. 서비스 인터페이스를 통해 이 정보를 외부로 공개하는 것이 최종 목표라면, 되도록 뷰가 필요하지 않게 만들어야 한다. 그에 따라 적절한 스키마 분해로 진행하는 편이 훨씬 더 좋다. 이와 같은 기술의 제약은 꽤 클 수 있다. 그럼에도 완전한 스키마 분해에 들어가는 노력이 너무 크다고 느껴지면, 뷰는 올바른 방향으로 나아가는 첫 단계가 될 수 있다.  

#### 4.4. 패턴: 데이터베이스 래핑 서비스  
<br/>

종종 뭔가를 다루기가 너무 어려운 경우에는 혼란을 숨기는 편이 합리적일 수 있다. 데이터베이스 서비스 패턴(database wrapping service pattern)을 사용하면 정확히 다음과 같은 작업을 수행할 수 있다. 즉 얇은 래퍼(wrapper) 역할을 하는 서비스 뒤에 데이터베이스를 숨기고 데이터베이스 종속성에서 서비스 종속성으로 이동하게 만든다.  

데이터베이스 뷰를 사용할 때와 마찬가지로, 래핑 서비스를 사용하면 공유 대상과 숨겨진 대상을 제어할 수 있다. 래핑 서비스는 고객에게 인터페이스를 제공하며, 상황 개선 목적으로 수신이 필요할 경우 아래쪽에서 변경이 일어난다.  

##### 4.4.1. 적용 대상  
<br/>

데이터베이스 래핑 서비스 패턴은 기반 스키마 분리를 고려하기가 매우 어려운 상황에서 정말 잘 작동한다. 스키마를 둘러싼 명시적인 래퍼(wrapper)를 배치하고 해당 래퍼를 통해서만 데이터에 접근할 수 있음을 분명하게 만들면 적어도 데이터베이스가 더 이상 증가하지 않게 제동을 걸 수 있다. 이런 접근 방법은 기반 스키마와 서비스 계층의 소유권을 동일 팀에 부여할 때 가장 효과적일 것이다. 서비스 API는 이 API 계층이 어떻게 변경되는지에 대한 적절한 감독과 함께 관리형 인터페이스로 수용해야 한다. 이 접근법은 또한 다운스트림 스키마를 사용하는 방법을 훨씬 더 쉽게 이해할 수 있기 때문에 업스트림 애플리케이션에도 이점이 있다. 따라서 테스트 목적을 위한 스텁 추가 등의 활동을 관리하기가 훨씬 더 용이해진다.  

또한, 이 패턴은 단순한 데이터베이스 뷰를 사용하는 경우에 비해 장점이 있다. 첫째, 기존 테이블 구조에 매핑할 수 있는 뷰를 표현하는 과정에 제약이 없으며, 래퍼 서비스에서 코드를 작성해 기반 데이터에 접근하는 창을 정교하게 표현할 수 있다. 래퍼 서비스는 또한 (API 호출을 통해) 쓰기를 수행할 수도 있다. 물론 이 패턴을 채택하려면 업스트림 컨슈머 쪽에서 변경해야 하는데, 데이터베이스에 직접 접근에서 API 호출로 전환해야 한다.  

이 패턴을 사용하면 이상적으로는 근본적인 변화를 위한 발판이 되어 API 계층 아래에서 스키마를 분해할 시간이 생긴다. 근본적인 문제를 해소하기보다는 임시방편으로 문제를 해결하는 방법이라는 주장도 나올 수 있다. 그럼에도 점진적인 개선이라는 정신에 따라 이 패턴은 많은 도움이 될 것이라 생각한다.  

#### 4.5. 패턴: 서비스로서 데이터베이스(DaaS) 인터페이스  
<br/>

때로 클라이언트는 쿼리를 위한 데이터베이스가 필요하다. 많은 양의 데이터를 쿼리하거나 가져와야 하거나, 이해관계자가 작업을 위해 SQL 종단점을 요구하는 도구를 이미 사용하고 있기 때문일 수도 있다(비즈니스 지표에 대한 통찰력을 얻기 위해 주로 사용하는 태블로(Tableau) 같은 도구를 생각해보자). 이런 상황에서 데이터베이스 내에서 서비스가 관리하는 데이터를 클라이언트에 공개하는 것이 의미가 있을지도 모르지만, 서비스 경계 내에서 사용하는 데이터베이스와 외부로 공개된 데이터베이스를 분리할 수 있도록 유의해야 한다.  

바람직하게 생각하는 접근 방법 중 하나는, 읽기 전용 종단점으로 외부에 공개되도록 설계된 전용 데이터베이스를 만들고, 기반 데이터베이스의 데이터가 변경될 때 이 데이터베이스를 채우는 방식이다. 실제로 서비스에서 이벤트 스트림과 동기식 API를 각기 다른 종단점으로 외부에 공개하는 방식과 동일하게, 데이터베이스를 외부 컨슈머에 공개할 수도 있다. API를 통한 읽기/쓰기 종단점과 함께 읽기 전용 인터페이스로 데이터베이스를 외부에 공개하는 주문 서비스의 예로 들 수 있다. 매핑(mapping) 엔진은 내부 데이터베이스에서 변경사항을 가져와서 외부 데이터베이스에 해당 사항을 반영한다.  

매핑 엔진은 변경사항을 완전히 무시하거나 변경 내용을 직접 외부에 공개하거나, 또는 그 사이 어딘가에 자리잡을 수 있다. 여기서는 매핑 엔진이 내부 데이터베이스와 외부 데이터베이스 간의 추상화 계층 역할을 한다는 사실이 핵심이다. 내부 데이터베이스가 구조를 변경할 때 외부 데이터베이스가 일관성을 유지한 채로 남아있도록, 매핑 엔진은 변경될 필요가 있다. 사실상 거의 모든 경우에 매핑 엔진은 내부 데이터베이스에 대한 쓰기보다 한 박자 뒤처질 것이다. 일반적으로 매핑 엔진 구현을 선택하면 이런 지연은 필연적으로 따라올 것이다. 외부에 공개된 데이터베이스에서 읽는 클라이언트는 이미 김빠졌을지(stale)도 모를 데이터를 보고 있음을 이해해야 하며, 외부 데이터베이스가 마지막으로 업데이트된 시기에 대한 정보를 프로그래밍적으로 외부에 공개하는 방식을 적절할 수도 있다.  

##### 4.5.1. 리포팅 데이터베이스 패턴  
<br/>

마틴 파울러가 이미 이 방식을 리포팅(reporting) 데이터베이스 패턴(https://martinfowler/com/bliki/Reporting Database.html)이라고 문서화했음에도 불구하고 여기서 다른 이름을 사용한 이유가 무엇일까? 더 많은 사람들과 이야기를 나누면서, 보고서 작성은 리포팅 데이터베이스 패턴의 주요 사례지만 사람들이 이 기법을 사용하는 유일한 이유는 아니라는 사실이다. 클라이언트가 임의로 만들어내는 쿼리를 정의할 수 있는 기능은 기존의 배치(batch) 지향 워크플로우보다 훨씬 더 광범위하다. 따라서 이 리포팅 데이터베이스 패턴이 보고서 작성 목적으로 널리 사용될지라도, 다른 곳에도 적용될 가능성이 높기에 다른 이름으로 표현하기를 원했다.  

##### 4.5.2. 매핑 엔진 구현  
<br/>

여기서 설명할 세부 내역은 업데이트 방법, 즉 매핑 엔진을 구현하는 방법이다. 앞서 살펴본 변경 데이터 캡처 시스템은 여기서도 탁월한 선택이다. 실제로 이 해법은 가장 견고할 뿐만 아니라 가장 최신의 뷰를 제공할 가능성이 높다. 또 다른 선택은 배치 프로세스가 데이터를 복사하는 방식이지만 이는 내부 데이터베이스와 외부 데이터베이스 간의 뒤처짐이 더 길어질 가능성이 높기 때문에 문제가 될 수 있으며, 몇몇 스키마에서는 어떤 데이터를 복사해야 할지 결정하기가 어려울 수도 있다. 세 번째 선택은 해당 서비스에서 일으킨 이벤트를 수신하고 이를 사용해 외부 데이터베이스를 업데이트하는 방식이다.  

과거에는 이를 처리하기 위해 배치 작업(batch job)을 사용했을 것이다. 하지만 요즘에는 아마도 데비지움(Debezium, https://github.com/debezium/debezium) 같은 전용 변경 데이터 캡처 시스템을 활용할 것이다. 배치 프로세스가 실행되지 않거나, 실행하는 과정에서 시간이 너무 오래 걸리는 바람에 여러 차례 고생한 경험이 있다. IT 업계가 배치 작업에서 점차 멀어지고 데이터를 더 빠르게 원하면서 배치 작업은 실시간 처리에 자리를 내주고 있다. 이런 경향에 발맞추기 위해 변경 데이터 캡처 시스템을 준비하는 것은, 특히 서비스 경계 바깥으로 이벤트를 공개할 목적이라면 의미가 있다.  

##### 4.5.3. 뷰와의 비교  
<br/>

이 DaaS(서비스로서 데이터베이스) 패턴은 단순 데이터베이스 뷰보다 훨씬 더 정교하다. 데이터베이스 뷰는 일반적으로 특정 기술 스택과 연결되어 있다. 오라클 데이터베이스의 뷰를 제공하고 싶다면, 기반 데이터베이스와 뷰를 호스팅하는 스키마를 모두 오라클에서 실행해야 한다. DaaS 패턴 형태로 우리가 외부에 공개하는 데이터베이스는 완전히 다른 기술 스택이 될 수 있다. 서비스 내에서는 카산드라(Cassandra)를 사용하지만 전통적인 SQL 데이터베이스를 공개된 종단점으로 제공할 수도 있다.  

DaaS 패턴은 데이터베이스 뷰보다 더 높은 유연성을 제공하지만 추가 비용이 든다. 컨슈머의 요구를 간단한 데이터베이스 뷰를 만족시킬 수 있다면, 인스턴스 하나에서 구현하는 작업량이 적을 것이다. 하지만 이로 인해 인터페이스가 진화하는 방식을 제한할 수도 있다는 사실에 주의하자. 데이터베이스 뷰로 시작해 나중에 전용 리포팅 데이터베이스로 전환하는 방식도 고려할 수 있겠다.  

##### 4.5.4. 적용 대상  
<br/>

종단점으로 외부에 공개된 데이터베이스는 읽기 전용이므로, 읽기 전용 접근이 필요한 클라이언트에게만 유용하다. 고객이 특정 서비스에서 보유하는 많은 양의 데이터를 대상으로 조인해야 할 수도 있는 상황인 리포팅 데이터베이스 패턴에 상당히 적합하다. 이 개념을 확장해 이 데이터베이스의 데이터를 더 큰 데이터 웨어하우스로 가져와 여러 서비스에서 데이터를 쿼리할 수 있다.  

이와 같은 외부 데이터베이스 투사와 관련해 최신 상태를 유지하기 위해 필요한 작업을 과소평가해서는 안 된다. 현재 서비스가 구현된 방식에 따라 복잡한 작업이 될 수도 있다.  

#### 4.6. 소유권 양도  
<br/>

가장 근본적인 문제는 아직 공략하지 않았다. 거대한 공유 데이터베이스에 임시방편으로 다양한 땜질을 해왔을 뿐이다. 거대한 모놀리스 데이터베이스에서 데이터를 가져오는 까다로운 작업을 고려하기에 앞서 문제의 데이터를 실제로 어디에 배치해야 할지 고려해야 한다. 모놀리스에서 서비스를 분리할 때, 어떤 데이터는 서비스와 함께 이동하며, 어떤 데이터는 원래 위치에 머물러야 한다.  

하나 이상의 집계(aggregate)와 관련된 로직을 캡슐화하는 마이크로서비스라는 개념을 수용하는 경우, 상태와 데이터 관리 부분을 마이크로서비스의 자체 스키마로 이동할 필요도 있다. 반면에, 새로운 마이크로서비스가 여전히 모놀리스가 소유한 집계를 대상으로 상호작용을 수행해야 할 경우, 잘 정의된 인터페이스를 통해 이 기능을 외부에 공개해야 한다. 이제 이 2가지 방식을 살펴보겠다.  

##### 4.6.1. 패턴: 집계를 외부에 공개하는 모놀리스  
<br/>

새로운 송장 작성 서비스는 송장 작성 관리와 직접 관련이 없는 다양한 정보에 접근해야 한다. 적어도 승인 워크플로우를 관리하려면 현재 직원에 대한 정보가 필요하다. 이 데이터는 현재 모두 모놀리스 데이터베이스 안에 있다. 모놀리스 자체에서 서비스 종단점(API 또는 이벤트 스트림일 수 있음)을 통해 직원에 대한 정보를 외부에 공개함으로써, 송장 작성 서비스가 요구하는 정보를 명시적으로 제공한다.  

마이크로서비스를 행동(behavior)과 상태(state)의 조합으로 간주하기를 원한다. 마이크로서비스를 도메인 집계를 관리하는 하나 이상의 상태 머신을 포함하는 것으로 생각하자고 앞서 이야기한 바 있다. 행동과 상태 조합이라는 동일한 조건에서 생각하기를 원한다. 모놀리스는 자체적으로 상태 변화를 허용하거나 허용하지 않는 규칙을 '소유'하고 있다. 단순히 데이터베이스를 감싸는 래퍼처럼 모놀리스를 취급하고 싶지는 않다.  

데이터를 외부에 공개하는 기능 이외에도 이해관계자가 집계의 현재 상태를 쿼리하고 새로운 상태를 전환하기 위한 요청을 허용하게끔 연산을 외부에 공개하고 있다. 또한 서비스 경계를 기준으로 외부에 공개되는 특정 집계의 상태를 제한하고, 외부에서 요청할 수 있는 상태 전이 연산도 제한하기로 결정할 수도 있다.  

###### 4.6.1.1. 더 많은 서비스로 가는 통로  
<br/>

송장 서비스의 요구를 정의하고 명확하게 정의된 인터페이스에 필요한 정보를 명시적으로 외부에 공개함으로써, 미래의 서비스 경계를 잠재적으로 발견할 수 있는 길을 가고 있다. 다음 단계는 두말할 필요 없이 직원 서비스 추출이다. 직원 관련 데이터에 대해 API를 외부에 공개함으로써, 이미 새로운 직원 서비스의 컨슈머가 요구하는 바가 무엇인지 이해하는 작업을 진행해왔다.  

물론 모놀리스에서 직원을 추출하고 나서 모놀리스가 해당 직원 데이터를 요구하는 경우, 새롭게 만든 서비스를 사용하도록 모놀리스를 변경해야 할 수도 있다!  

###### 4.6.1.2. 적용 대상  
<br/>

접근이 필요한 데이터를 여전히 데이터베이스가 '소유'하고 있을 경우, 이 패턴을 새 서비스가 요구하는 접근을 허용하는 과정에서 효과적으로 동작한다. 서비스를 추출할 때, 필요한 데이터에 접근하기 위해 새로운 서비스가 거꾸로 모놀리스를 호출하는 경우는 모놀리스의 데이터베이스에 직접 접근하는 경우보다 조금 더 작업이 필요할 가능성이 높지만 장기적으로는 훨씬 더 좋은 방식이다. 새로운 종단점을 외부에 공개하기 위해 문제의 모놀리스를 변경할 수 없는 경우에만 이 패턴보다 데이터베이스 뷰를 사용하는 방법을 고려하자. 이런 경우 원하는 직원 정보를 외부에 공개하기 위해 앞서 설명한 변경 데이터 캡처 패턴 또는 모놀리스 스키마 위에서 전용 데이터베이스 래핑 서비스 패턴 만들기와 같은 방식으로 모놀리스 데이터베이스에서 데이터베이스 뷰가 작동할 수 있다.  

##### 4.6.2. 패턴: 데이터 소유권 변경  
<br/>

직원 데이터에 접근할 필요가 있었던 이전 절에서 다른 기능이 소유한 데이터에 새 송장 서비스가 접근할 때 무슨 일이 발생하는지를 살펴봤다. 새로 추출된 서비스의 제어를 받아야 할 데이터가 모놀리스에 존재할 경우, 무슨 일이 벌어질까?  

변경이 필요한 부분을 다음과 같다. 송장 관련 데이터는 모놀리스에서 새 송장 서비스로 옮기고, 여기서 데이터 수명주기를 관리해야 한다. 그런 다음 송장 서비스를 송장 관련 데이터에 대한 진실의 원천으로 취급하고, 데이터를 읽거나 변경을 요청하기 위해 송장 서비스 종단점을 호출하도록 모놀리스를 변경해야 한다.  

그러나 기존 모놀리스 데이터베이스에서 꼬여 잇는 송장 데이터를 풀어내는 작업은 복잡할 수 있다. 외래 키 제약 조건 위반이나 트랜잭션 경계 위반 등의 영향을 고려해야 할지도 모른다. 송장 관련 데이터에 대한 읽기 접근만 필요하게 모놀리스를 변경할 수 있다면 송장 서비스 데이터베이스에서 뷰를 투사하는 방식을 고려할 수도 있다. 그러나 이렇게 하면 데이터베이스 뷰의 모든 제한 사항이 적용될 것이다. 따라서 새로운 송장 서비스를 직접 호출하게끔 모놀리스를 변경하는 방식을 가장 선호한다.  

###### 4.6.2.1. 적용 대상  
<br/>

데이터 소유권 변경 패턴은 명확하게 데이터 분리가 가능하다. 새로 추출한 서비스가 몇몇 데이터를 변경하는 비즈니스 로직을 캡슐화하는 경우, 해당 데이터는 새 서비스의 제어하에 있어야 한다. 데이터는 원래 위치에서 새 서비스로 옮겨져야 한다. 물론 기존 데이터베이스에서 데이터를 이동하는 프로세스는 간단한 프로세스와는 거리가 멀다.  

#### 4.7. 데이터 동기화  
<br/>

교살자 무화과 패턴 등은 새로운 서비스로 전환할 때 문제가 있는 경우 다시 전환할 수 있다는 장점이 있다. 하지만, 해당 서비스가 모놀리스와 새 서비스 사이에서 동기화 상태를 유지해야 하는 데이터를 관리할 때는 문제가 발생한다.  

새 송장 서비스로 전환하는 중이다. 그러나 새로운 서비스는 물론이고 모놀리스에 위치한 기존의 동등한 코드도 이 데이터를 관리한다. 구현 간에 전환하는 기능을 유지하려면, 두 코드 집합 모두 동일한 데이터를 볼 수 있게 해야 하고 이 데이터를 일관된 방식으로 유지해야 한다.  

그렇다면 여기서 선택지는 무엇일까? 먼저, 두 뷰 사이에서 데이터가 일관성을 요구하는 수준을 고려할 필요가 있다. 코드 집합 중 하나가 항상 일관된 송장 데이터의 뷰를 봐야 할 경우에는 데이터를 한곳에 보관하는 방식이 가장 직관적이다. 이렇게 하면 새로운 송장 서비스는 임시방편으로 짧은 기간 동안만 모놀리스에서 직접 데이터를 읽으며, 이를 위해 뷰를 사용하는 방식을 활용한다. 성공적으로 전환이 완료되면 데이터를 마이그레이션할 수 있다. 그러나 공유 데이터베이스는 매우 유의해서 사용해야 하며 더 완벽한 추출을 위해 매우 짧은 기간 동안만 사용할 것을 고려해야 한다. 공유 데이터베이스를 너무 오랫동안 방치하면 장기적으로 심각한 고충이 초래될 수 있다.  

애플리케이션 코드와 데이터를 동시에 마이그레이션하는 빅뱅 전환(되도록 피하려고 노력하는 상황이긴 하지만)을 수행하는 경우 새로운 마이크로서비스로 전환하기 전에 배치 프로세스를 사용해 데이터를 복사할 수 있다. 송장 관련 데이터를 새로운 마이크로서비스로 복사하고 나면 트래픽 처리를 시작할 수 있다. 송장 관련 데이터를 새로운 마이크로서비스로 복사하고 나면 트래픽 처리를 시작할 수 있다. 그러나 기존 모놀리스 시스템에 있는 기능을 사용하게 되돌려야 한다면 어떤 상황이 벌어질까? 마이크로서비스 스키마에서 변경된 데이터는 모놀리스 데이터베이스의 상태에 반영되지는 않을 것이므로 상태를 잃을 수도 있다.  

아니면 코드를 통해 두 데이터베이스를 동기화 상태로 유지하는 또 다른 접근 방법도 있다. 이런 방법에서는 모놀리스 또는 새로운 송장 서비스가 양쪽 데이터베이스에 모두 기록하게 된다. 이렇게 하는 경우에는 동기화가 잘못되지 않도록 신중하게 생각해야 한다.  

#### 4.8. 패턴: 애플리케이션에서 데이터 동기화  
<br/>

한 장소에서 다른 장소로 데이터를 전환하는 작업은 최상의 상황일 때도 복잡하지만 데이터 가치가 높을수록 더 어려워질 수 있다. 의료 기록 관리와 같은 민감한 부분에서는 데이터 마이그레이션 방법을 더욱 더 신중하게 고민해야 한다.  

몇 년 전 컨설팅 사 트라이포크(Trifork)는 덴마크 시민의 의료 기록에 대한 통합 뷰를 저장하는 프로젝트에 참여했다. 이 주제에 대한 세부 발표 내용은 크레스튼 크랍 쏘럽(Kresten Krab Thorup)이 발표한 "약물에 대한 리악(그리고 반대)"(Riak on Drugs and the Other Way Around) 영상(http://bit.ly/2m1CvLP)에서 볼 수 있다. 이 시스템의 초기 버전은 MySQL 데이터베이스에 데이터를 저장했지만 시간이 지남에 따라 시스템이 직면한 문제에 적합하지 않을 수 있다는 사실이 명백해졌다. 대안으로 NoSQL 데이터베이스인 리악(Riak)을 사용하기로 결정했다. 이 과정에서 시스템이 예상되는 부하를 처리할 수 있도록 더 나은 시스템 확장성뿐만 아니라 향상된 회복탄력성(resilliency)도 제공할 수 있기를 희망했다.  

기존 시스템은 하나의 데이터베이스에 데이터를 저장했지만, 시스템이 오프라인 상태일 수 있는 기간에는 제한이 있었으며, 데이터를 잃어버리지 않아야 한다는 요구사항이 필수였다. 따라서 회사가 데이터를 새 데이터베이스로 이동하고, 마이그레이션을 검증하는 메커니즘을 구축하며, 그 과정에서 빠른 롤백 메커니즘을 갖춘 솔루션이 필요했다.  

애플리케이션 자체에서 두 데이터 소스 간의 동기화를 수행하기로 결정했다. 이는 초기에는 기존 MySQL 데이터베이스가 진실의 원천(source of truth)으로 존재하지만, 일정 기간 동안 애플리케이션이 MySQL과 리악에 있는 데이터가 동기화된 상태로 유지하도록 보증하는 개념이다. 일정 시간이 지나면, 리악은 MySQL이 폐기되기에 앞서 애플리케이션을 위한 진실의 원천으로 전환될 것이다.  

##### 4.8.1. 1단계: 데이터 대량 동기화  
<br/>

1단계는 새 데이터베이스에 데이터 사본을 확보하는 지점에 도달하는 것이다. 의료 기록 프로젝트의 경우 이전 시스템에서 새로운 리악 데이터베이스로 데이터를 배치(batch) 마이그레이션하는 작업이 진행되었다. 배치 가져오기 작업이 진행되는 동안에도 기존 시스템은 계속 실행되었으므로, 가져올 데이터 소스는 기존 MySQL 시스템에서 잡은 데이터의 스냅샷이었다. 배치 가져오기 작업이 완료될 시점에 소스 시스템의 데이터가 변경되었을 경우에는 동기화 문제가 발생한다. 그러나 이 경우 소스 시스템을 오프라인으로 만드는 방식은 실용적이지 않았다.  

일단 배치 가져오기가 완료되고 나면, 그 이후부터 변경사항을 반영하는 변경사항을 반영하는 변경 데이터 캡처 프로세스를 구현한다. 이렇게 하면 리악을 동기화할 수 있게 된다. 여기까지 완료하고 나면 새로운 버전의 애플리케이션을 배포할 차례가 온다.  

##### 4.8.2. 2단계: 이전 스키마에서 읽고 쓰기를 동기화  
<br/>

이제 두 데이터베이스가 동기화도니 상태에서 새 버전의 애플리케이션이 배포되어 두 데이터베이스에 모든 데이터를 기록한다. 이 단계에서 목표는 애플리케이션이 두 데이터베이스 양쪽에 올바르게 쓰기 작업을 수행하는지를 확인하고, 리악이 허용 가능한 오차 범위 내에서 동작하는지도 확인하는 것이다. 여전히 MySQL에서 모든 데이터를 읽음으로써 혹여 리악이 갑작스럽게 동작이 멈추더라도 기존 MySQL 데이터베이스에서 데이터를 인출할 수 있다.  

일단 새로운 리악 시스템에 대한 충분한 확신이 들면, 다음 단계로 넘어간다.  

##### 4.8.3. 3단계: 새 스키마에서 읽고 쓰기를 동기화  
<br/>

2단계에서는 리악에 대한 쓰기를 검증했다. 마지막 단계로 읽기 작업도 작동하는지를 확인해보자. 애플리케이션을 간단히 변경하면 리악은 진실의 원천이 된다. 여전히 두 데이터베이스 양쪽에 쓰기를 수행하므로 문제가 있더라도 대체 옵션이 있다.  

새 시스템을 확실하게 설치하고 나면 기존 스키마를 안전하게 제거할 수 있다.  

##### 4.8.4. 이 패턴을 사용하는 사례  
<br/>

덴마크 의료 기록 시스템은 단일 애플리케이션으로 처리했다. 그러나 마이크로서비스를 분리하려는 상황에 대한 이야기하고 있었다. 이 패턴이 정말 도움이 될까? 애플리케이션 코드를 분할하기 전에 스키마를 분할하기를 원하는 경우, 이 패턴을 후보로 가장 먼저 고려해야 한다.  

올바르게 구현되었다면 두 데이터 소스는 항상 동기화되어 있기에, 롤백 시나리오에서 데이터 소스 간에 빠른 전환이 필요할 때 상당히 유리하다. 덴마크 의료 기록 시스테므이 예에서는 오랫동안 애플리케이션을 오프라인 상태로 만들 수 없기에 이 패턴을 사용하는 것은 적절해 보인다.  

##### 4.8.5. 적용 대상  
<br/>

모놀리스와 마이크로서비스 양쪽에서 데이터에 접근하는 경우에 이 패턴을 고려할 수는 있지만, 상당히 복잡하다. 이 패턴이 작동하려면, 모놀리스와 마이크로서비스 둘 다 데이터베이스 사이에서 적절한 동기화가 보장돼야 한다. 어느 쪽이든 실수를 하면 문제가 생길 수 있다. 특정 시점에 송장 서비스만 데이터베이스에 쓰기를 수행하고 있거나 아니면 모놀리스의 송장 기능만 데이터베이스에 쓰기를 수행하고 있다고 확신할 수 있거나 아니면 모놀리스의 송장 기능만 데이터베이스에 쓰기를 수행하고 있다고 확신할 수 있거나 아니면 모놀리스의 송장 기능만 데이터베이스에 쓰기를 수행하고 있다고 확신할 수 있을 경우라면, 이런 복잡성은 크게 완화된다. 여기서 교살자 무화과 패턴에서 설명한 단순 전환 기법을 사용하면 제대로 동작할 것이다. 그러나 카나리아 릴리스의 일부로서 요청이 모놀리스의 송장 기능 또는 새로운 송장 기능 중 하나에만 영향을 줄 수 있는 경우에는 동기화가 까다로워지는 결과가 발생하므로 이 패턴 사용을 피하고 싶을 수도 있다.  

#### 4.9. 패턴: 예광탄 기록  
<br/>

예광탄 기록(Tracer Write) 패턴은 애플리케이션에서 데이터 동기화 패턴의 변형으로도 볼 수 있다. 예광탄 기록을 사용해 점진적인 방식으로 데이터를 위한 진실의 원천을 이동시키며, 마이그레이션 과정에서 진실의 두 원천이 존재한다는 사실을 받아들인다. 여러분은 재배치된 데이터를 제공할 새로운 서비스를 파악하게 된다. 현재 시스템은 여전히 이 데이터의 레코드를 로컬에 유지하지만, 변경을 수행할 때 서비스 인터페이스를 통해 새로운 서비스에서도 이 데이터가 기록되게 보장한다. 기존 코드를 변경해 새로운 서비스에 접근하기 시작하고, 일단 모든 기능이 새 서비스를 진실의 원천으로 사용하면 오래된 진실의 원천을 폐기할 수 있다. 두 진실의 원천 간에 어떻게 데이터가 동기화되는지를 주의 깊게 고려할 필요가 있다.  

예광탄 기록은 마이그레이션 중에 두 진실의 원천을 수용하는 방법으로 한 시스템에서 다른 시스템으로 데이터를 점진적으로 마이그레이션 할 수 있다.  

진실의 원천이 하나뿐이기를 바라는 마음은 전혀 이상하지 않다. 이렇게 하면 데이터의 일관성을 보장하고 해당 데이터에 대한 접근을 제어하며 유지 관리 비용을 줄일 수 있다. 하지만 데이터를 위한 진실의 원천이 하나만 존재해야 한다고 주장할 경우, 이 데이터가 존재하는 위치를 바꾼다면 대규모 전환이 필요한 상황을 맞닥뜨리게 된다는 문제가 있다. 릴리스 전에는 모놀리스가 진실의 원친이며, 릴리스 후에는 새로운 마이크로서비스가 진실의 원천이다. 문제는 이와 같은 변경 과정에서 다양한 문제가 발생할 수 있다는 사실이다. 예광탄 기록 패턴 등을 사용하면 단계별 전환이 가능하므로 2개 이상의 진실의 원천을 유지함으로써 내결함성을 희생하는 대가로 각 릴리스의 영향을 줄일 수 있다.  

이 패턴을 예광탄 기록이라고 부르는 이유는 동기화되는 작은 데이터 집합으로 시작해 시간이 지남에 따라 점점 늘어나면서 새로운 데이터 소스의 컨슈머 수가 증가하기 때문이다. 송장 관련 데이터가 모놀리스에서 새로운 송장 마이크로서비스로 이동하면 먼저 기본 송장 데이터를 동기화한 다음 송장의 연락처 정보를 마이그레이션하고 마지막으로 지불 레코드를 동기화한다.  

송장 관련 정보를 원하는 다른 서비스는 요구하는 정보에 따라 모놀리스 또는 새로운 서비스 자체에서 이를 가져오게 선택할 것이다. 여전히 모놀리스에서만 사용 가능한 정보가 필요한 경우에는 해당 데이터와 지원 기능이 이동될 때까지 기다려야 한다. 일단 새로운 마이크로서비스에서 데이터와 기능을 사용할 수 있게 되면 컨슈머는 새로운 진실의 원천으로 전환할 수 있다.  

최종 목표는 송장 서비스를 사용하기 위해 모놀리스 자체를 포함한 모든 컨슈머를 마이그레이션하는 것이다. 마이그레이션 과정에서 일어나는 몇 단계에 걸친 예를 보여준다. 초기에는 기본 송장 정보만 양쪽 진실의 원천에 기록하고 있다. 일단 이 정보가 적절하게 동기화되고 있음을 확인하면 모놀리스는 새로운 서비스에서 데이터를 읽기 시작할 수 있다. 더 많은 데이터가 동기화됨에 따라 모놀리스는 점점 더 많은 데이터에 접근하기 위한 진실의 원천으로 새로운 서비스를 사용할 수 있다. 모든 데이터가 동기화되고 기존 진실의 원천에 의존하는 마지막 컨슈머가 전환되면 데이터 동기화를 중지할 수 있다.  

##### 4.9.1. 데이터 동기화  
<br/>

예광탄 기록 패턴에서 해결해야 하는 가장 큰 문제는 데이터가 중복된 불일치 상황을 일으키는 경우에 발생한다. 이를 해결하기 위한 몇 가지 선택지가 있다.  

+ 진실의 원천 중 한쪽에 쓰기  
모든 쓰기는 진실의 원천 중 한쪽으로만 전송된다. 쓰기가 일어난 후 데이터는 다른 진실의 원천과 동기화된다.  

+ 진실의 원천 양쪽에 쓰기  
업스트림 클라이언트의 모든 쓰기 요청은 진실의 양쪽으로 전송된다. 이는 클라이언트가 진실의 원천 양쪽을 호출하거나 중개자에게 의존해 각 다운스트림 서비스에 요청을 브로드캐스트하는 방법으로 일어난다.  

+ 진실의 원천 중 아무 쪽에나 쓰기  
클라이언트는 쓰기 요청을 진실의 원천 중 아무 쪽에나 전송할 수 있으며 이면에서 시스템 간에 데이터가 양방향으로 동기화된다.  

진실의 원천 양쪽에 쓰기를 전송하거나 또는 진실의 원천 한 쪽에만 쓰기를 전송하고 백그라운드에서 동작하는 동기화에 의존하는, 2가지 독립된 선택지는 동작 가능한 듯이 보이며, 곧 살펴볼 예제는 이 2가지 기법을 모두 사용한다. 그러나 비록 기술적인 선택지 중 하나로 제시했음에도 아무 쪽에나 쓰기(진실의 원천 한쪽 또는 다른 쪽에 번걸아 쓰기)는 양방향 동기화(달성하기 아주 어려운 기법)가 필요하기 때문에 이런 상황은 반드시 피해야 한다.  

이 모든 경우에, 두 진실의 기록된 데이터가 일치하는 과정에서 약간의 지연이 발생할 것이다. 이런 불일치 기간은 몇 가지 요인에 따라 달라질 것이다. 예를 들어 야간 배치 프로세스를 사용해 특정 진실의 원천에서 다른 진실의 원천으로 업데이트 내역을 복사하는 경우 두 번째 진실의 원천은 최대 24기간이 지난 데이터가 포함될 수 있다. 아마도 변경 데이터 캡처 시스템을 사용해 특정 시스템에서 다른 시스템으로 지속적으로 업데이트 내역을 스트리밍하는 경우 불일치 기간은 몇 초 이내로 줄어들 것이다.  

그러나 이처럼 불일치가 발생하는 기간이 길어지더라도, 동기화 덕분에 결과적 일관성(eventual consistency)이라는 결과를 얻게 된다. 궁극적으로 두 진실의 두 원천은 모두 동일한 데이터를 갖게 될 것이다. 불일치 기간이 사례에 적합한지 판단한 다음, 이에 대응하는 동기화 구현 방법을 구현해야 할 것이다.  

##### 4.9.2. 사례: 스퀘어의 주문 처리  
<br/>

원래 이 예광탄 기록 패턴은 스퀘어(Square) 개발자인 데릭 해머(Derek Hammer)가 공유해줬으며, 이후 이 패턴의 다른 사례를 현장에서 발견했다. 상기타 한다(Sangeeta Handa)는 QCon SF 컨퍼런스에서 넷플릭스가 데이터 마이그레이션의 일부로 이 패턴을 사용하는 방식에 대해 발표했으며, 이후 다니엘 브라이언트(Daniel Bryant)가 이 내용을 정리해 글을 기고했다(http://bit.ly/2m1EwHT). 해머는 배달 음식 주문과 고나련해 스퀘어 업무의 꼬인 문제를 해결하는 과정에 도움이 된 용법을 자세히 설명했다. 초기 시스템에서는 단일 주문 개념을 사용해 여러 워크플로우를 관리했다. 즉 음식을 주문으하는 고객을 위한 워크플로우, 음식을 준비하는 식당을 위한 워크플로우, 고객에게 음식을 배달하는 배달원과 관련된 워크플로우로 나눠 관리했다. 세 이해관계자 부류의 요구는 서로 다르며, 모든 이해관계자가 동일 주문을 대상으로 작업하지만 각 이해관계자에게 해당 주문이 의미하는 내용도 다르다. 고객의 경우에 주문이란, 배달을 요청한 음식과 지불해야 하는 돈일 뜻한다. 식당의 경우에 주문이란, 조리해서 포장해야 하는 음식이다. 그리고 배달원의 경우에 주문이란, 식당에서 고객에게 적시에 배달해야 하는 음식이다. 이런 다양한 요구에도 불구하고, 주문에 대한 코드와 관련 데이터는 모두 함께 묶여 있었다.  

이 모든 워크플로우를 단일 주문 개념에 묶은 것은 앞서 내가 배포 경합(delivery contention)이라고 부른 문제의 근본 원인이었다. 다른 사용 사례를 위해 변경을 시도하는 개발자들은 필요에 따라 동일 코드베이스의 다른 부분에 변경을 가할 필요가 있기에 서로의 작업을 방해할 것이다. 스퀘어는 주문을 분해해 각 워크플로우에 대한 변경을 격리하고 요구에 따른 다양한 확장성과 견고성을 보장할 수 있었다.  

###### 4.9.2.1. 새로운 서비스 만들기  
<br/>

첫 단계는 식당과 배달원이 연계된 주문 데이터를 관리하는 새로운 주문 처리 서비스를 작성하는 것이다. 이 서비스는 주문 데이터의 부분 집합을 위한 새로운 진실의 원천이 될 것이다. 처음에 이 서비스는 주문 주문 처리 관련 엔티티를 작성하는 기능만 공개했다. 일단 새로운 서비스가 운영을 시작하면, 회사는 백그라운드에서 동작하는 워커(worker)가 기존 시스템에서 새로운 주문 처리 서비스로 주문 처리 관련 데이터를 복사했다. 백그라운드 워커는 데이터베이스에 직접 접근하지 않아도 되도록 데이터베이스에 직접 넣지 않고 주문 처리 서비스가 외부에 공개한 API만을 사용했다.  

새로운 주문 처리 서비스는 기존 시스템에서 주문 처리 관련 데이터를 복제하기 위해 사용되었다.  

백그라운드 워커는 기능 플래그로 제어되었으며, 이를 통해 복사 프로세스를 중지하는 기능을 활성화하거나 비활성화할 수 있었다. 이 플래그로 제어하는 덕분에 백그라운드 워커가 운영 환경에서 문제를 일으킨 경우 해당 프로세스를 쉽게 종료할 수 있다. 개발자들은 동기화가 제대로 작동하고 있음을 신뢰할 때까지 충분한 시간 동안 운영환경에서 새로운 시스템을 실행했다. 백그라운드 워커가 예상대로 동작하고 있다는 사실에 만족하고 나서야 기능 플래그를 제거했다.  

###### 4.9.2.2. 데이터 동기화  
<br/>

이런 종류의 동기화와 관련된 문제점 중 하나는 일방통행이라는 사실이다. 기존 시스템에 변경을 가하면, 주문 처리 관련 데이터가 API를 통해 새 주문 처리 서비스에 기록된다. 스퀘어는 두 시스템에 업데이트가 모두 이뤄지게 만드는 방법으로 이 문제를 해결했다. 그러나 두 시스템에 모든 내용을 업데이트할 필요는 없다. 데릭이 설명했듯이 주문 처리 서비스는 주문 개념의 부분 집합만 표현하므로 배달원 또는 식당 고객이 신경 쓸 필요가 있는 주문의 변경사항만 복사하면 됐다.  

모든 컨슈머가 두 서비스 두 서비스 모두에 대해 적절한 API 호출을 수행하는 방법으로 후속 업데이트를 동기화했다.  

식당 또는 배달 관련 정보를 변경한 모든 코드는 API 호출을 두 번(한 번은 기존 시스템에 대한 API 호출, 다른 한 번은 동일한 작업을 하는 마이크로서비스에 대한 API 호출) 수행하도록 변경되어야 했다. 또한 이런 업스트림 클라이언트는 한쪽의 쓰기 작업은 성공했지만 다른 쪽의 쓰기 작업은 실패한 경우에 오류 조건을 처리해야 할 것이다. 다운스트림 시스템 두 곳(기존 주문 시스템과 새로운 주문 처리 서비스)에 대한 변경은 원자적인 방법으로 수행되지 않는다. 즉 한 시스템에서 변경사항을 볼 수 있지만 다른 시스템에서는 아직 변경사항을 볼 수 없는 짧은 기간이 존재할 수 있음을 의미한다. 양쪽 변경사항이 모두 적용될 때까지, 두 시스템 간에 불일치가 발생할 수 있다. 이는 앞서 설명한 결과적 일관성의 한 형태다.  

주문 정보의 결과적 일관성 특성이라는 관점에서 보면, 여기서 설명한 특수한 사용 사례에서는 문제가 없었다. 두 시스템 간에 데이터가 충분히 빠르게 동기화되어 시스템 사용자에게 영향을 미치지 않았다.  

만약 스퀘어가 API 호출을 사용하는 대신 주문 업데이트 관리를 위해 이벤트 기반 시스템을 사용해왔다면, 대체 구현을 고려할 수 있었을 것이다. 주문 상태의 변경을 일으킬 수 있는 단일 메시지 스트림이 있다. 기존 시스템과 새로운 주문 처리 서비스 모두 동일 메시지를 수신한다. 업스트림 클라이언트는 이런 메시지를 수신하는 여러 컨슈머가 있다는 사실을 알 필요가 없다. 이는 펍-섭(pub-sub) 스타일 브로커를 사용해 처리할 수 있는 내용이다.  

대안으로 제시하는 동기화 접근 방법은 두 진실의 원천이 동일 이벤트를 구독하는 방식일 수 있다.  

이런 종류의 사용 사례를 충족시키기 위해 스퀘어 아키텍처를 이벤트 기반으로 개조하려면 많은 작업이 필요하다. 그러나 만일 이벤트 기반 시스템을 이미 사용하고 있다면 동기화 프로세스를 더 수월하게 관리할 수 있을 것이다. 또한 기존 시스템과 주문 처리 서비스가 동일 이벤트를 동시에 처리한다고 보장할 수 없으므로 이런 아키텍처는 결국 결과적 일관성에 맞춰 동작한다는 사실에 주목해야 한다.  

###### 4.9.2.3. 컨슈머 마이그레이션  
<br/>

새로운 주문 처리 서비스는 이제 식당과 배달원의 워크플로우에 필요한 모든 정보를 담고 있으므로, 해당 워크플로우를 관리하는 코드가 새 서비스를 사용하도록 전환을 시작할 수 있다. 이와 같은 마이그레이션 과정에서 컨슈머의 요구를 지원하기 위해 더 많은 기능을 추가할 수 있다. 초기에 주문 처리 서비스는 백그라운드에서 동작하는 워커를 위해 새 레코드 작성을 지원하는 API만 구현하면 된다. 일단 신규 컨슈머를 마이그레이션하고 나면 요구사항을 평가하고 이를 지원하기 위해 새로운 기능을 서비스에 추가할 수 있다.  

새로운 진실의 원천을 사용하도록 컨슈머를 변경하는 동시에 양쪽 데이터를 점진적으로 마이그레이션하는 방식은 스퀘어의 사례에 매우 효과적이라는 사실이 증명되었다. 데릭에 따르면, 모든 컨슈머가 마이그레이션이 끝난 시점을 기념하는 이벤트는 시시하게 끝났다. 즉 일상적인 릴리스 중에 수행된 또 하나의 작은 변경에 불과했다(점진적인 마이그레이션 패턴을 강력하게 주장한 이유기도 하다!).  

도메인 주도 설계(DDD) 관점에서, 배달원, 고객, 식당과 관련된 기능은 모두 다양한 범위의 경계 컨텍스트(bounded context)를 표현한다고 자신 있게 주장할 수 있다. 이런 관점에서 데릭은 주문 처리 서비스를 , 하나는 식당을 위한 서비스, 그리고 다른 하나는 배달원을 위한 서비스 등 2가지 서비스로 이상적으로 분리하는 방식을 제안했다. 추가 분해가 필요한 영역도 있었지만, 그럼에도 이 마이그레이션은 매우 성공적인 듯이 보였다.  

스퀘어의 경우, 중복된 데이터를 유지하기로 결정했다. 기존 시스템에 식당과 배송 관련 주문 정보를 남겨두면 회사는 주문 처리 서비스를 사용할 수 없는 경우에도 이런 정보의 가시성을 확보할 수 있었다. 물론 이렇게 하려면 동기화를 유지해야 한다. 시간이 지난 뒤, 이렇게 내린 결정을 재논의하게 될지 궁금하긴 하다. 주문 처리 서비스의 가용성에 대한 충분한 확신만 있으면 백그라운드에서 동작하는 워커와 두 차례에 걸친 컨슈머의 업데이트 호출을 제거하는 방법이 아키텍처를 간소화하는 과정에 도움이 될 수도 있다.  

##### 4.9.3. 적용 대상  
<br/>

동기화 구현은 대부분의 작업이 일어나고 있는 장소일 가능성이 높다. 양방향 동기화가 필요치 않고 앞서 설명한 간단한 선택지를 사용할 수 있다면 이 패턴을 구현하기가 훨씬 더 쉬울 것이다. 이벤트 기반 시스템을 이미 사용 중이거나 변경 데이터 캡처 파이프라인을 사용할 수 있는 경우라면, 동기화 작업을 수행하기 위해 사용 가능한 많은 빌딩 블록이 이미 존재할 가능성이 높다.  

두 시스템 간의 불일치를 얼마나 오래 견딜 수 있는지 신중하게 고려해야 한다. 몇몇 사용 사례는 시스템 간의 불일치에 관대할 수도 있으며 다른 사용 사례는 거의 즉시 복제를 원할지도 모른다. 수용 가능한 불일치 기간이 짧을수록 이 패턴을 구현하기는 훨씬 더 어려워진다.  

#### 4.10. 데이터베이스 분리  
<br/>

여러 서비스를 통합하는 방법으로 데이터베이스를 사용하는 과정에서 발생하는 문제를 자세히 설명했다. 이는 경계를 깨끗하게 분리하기 위해 데이터베이스에서도 봉합(seam)을 찾아낼 필요가 있음을 의미한다. 그러나 데이터베이스는 다루기가 상당히 까다로운 상대다. 접근 방식의 예를 살펴보기 전에 논리적 분리와 물리적 배포가 어떻게 관련되는지 간략하게 짚고 넘어가야 한다.  

##### 4.10.1. 물리적 데이터베이스 분리 vs 논리적 데이터베이스 분리  
<br/>

설명한 맥락에서 보면, 데이터베이스 분리는 주로 논리적인 분리를 의미한다. 단일 데이터베이스 엔진은 논리적으로 분리된 스키마를 2개 이상 완벽하게 제공할 수 있다.  

물리적 데이터베이스 엔진 하나에서 실행되지만 분리된 형태의 논리적인 스키마를 사용하는 2가지 서비스처럼 물리적 분리를 제공하기 위해 한걸음 더 나아가서, 데이터베이스 엔진을 2개로 분리해서 각각에 논리적인 스키마를 유지할 수도 있다.  

스키마를 논리적으로 분해하면서도 여전히 단일 데이터베이스 엔진에 유지하려는 이유는 무엇일까? 근본적으로, 논리적 분해와 물리적 분해는 달성하려는 목표부터 각기 다르다. 논리적 분해는 독자적인 변경과 정보 은닉이 가능한 반면, 물리적 분해는 잠재적으로 시스템 견고성을 개선하고 자원 경합을 제거하는 과정에 도움이 되므로 처리량이나 대기 시간을 향상시킬 수 있다.  

논리적으로 데이터베이스 스키마를 분해하지만 물리적으로 동일한 데이터베이스 엔진에 유지하면, 잠재적인 단일 장애 지점(single point of failure)이 존재한다. 데이터베이스 엔진이 다운되면 두 서비스는 모두 영향을 받는다. 그러나 세상이 그렇게 만만치는 않다. 많은 데이터베이스 엔진에는 복제와 클러스터로 구성된 다중 데이터베이스 모드, 장애극복 메커니즘 등의 단일 장애 지점을 회피하는 메커니즘이 있다. 실제로 조직 내에서 회복탄력성이 뛰어난 데이터베이스 클러스터를 만들기 위해 상당한 노력을 들였을지도 모르며, 시간, 노력, 비용(성가신 라이선스 비용이 추가될 수 있다!)으로 인해 클러스터를 여러 개 유지하는 상황을 정당화하기 어려울 수도 있다.  

데이터베이스의 뷰를 외부에 공개하기를 원하는 경우에는, 동일 데이터베이스 엔진을 공유하는 여러 스키마가 필요하다는 점도 고려사항이다. 기반 데이터베이스와 뷰를 담은 스키마는 모두 동일 데이터베이스 엔진에 존재해야 한다.  

물론, 분리된 서비스를 다른 물리적인 데이터베이스 엔진에서 실행하는 선택지가 있는 경우에도, 먼저 논리적으로 스키마를 분해해 놓을 필요가 있다!  

#### 4.11. 데이터베이스를 먼저 분할할까, 아니면 코드를 먼저 분할할까?  
<br/>

지금까지 공유 데이터베이스로 작업하는 과정에 도움이 되는 패턴에 대해 설명했지만, 결합도가 낮은 모델로 넘어가기를 바란다. 잠시 후에 데이터베이스 분해와 관련된 패턴을 자세히 살펴보겠다. 하지만 분해와 관련된 패턴 소개에 앞서 분할 순서부터 논의할 필요가 있다.  

애플리케이션 코드가 자체 서비스에서 실행될 때까지 마이크로서비스 추출은 '완료'되지 않으며, 제어하는 데이터는 논리적으로 격리된 독자적인 데이터베이스로 추출된다. 그러나 이 책은 주로 점진적인 변화를 다루므로, 추출 순서를 어떻게 정해야 할지도 고민해야 한다.  

+ 데이터베이스를 먼저 분할한 다음, 코드를 분할
+ 코드를 먼저 분할한 다음, 데이터베이스를 분할
+ 둘 다 함께 분할  

각 선택지마다 장단점이 있다. 선택한 접근 방식에 따라 도움이 될 몇 가지 패턴과 함께 각 방법을 살펴보자.  

##### 4.11.1. 데이터베이스를 먼저 분할  
<br/>

분리된 스키마를 사용하면 단일 작업을 수행하기 위한 데이터베이스 호출 수가 아마도 증가할 것이다. 이전에는 단일 SELECT 문으로 원하는 모든 데이터를 담을 수 있었지만, 이제는 두 위치에서 데이터를 가져와 메모리에서 조인(join)할 필요가 있다. 또한 2개의 스키마로 나누면 트랜잭션 무결성을 깨버리기에 애플리케이션에 큰 영향을 줄 수 있다. 분산 트랜잭션을 비롯해 사가(saga)와 같은 주제를 다루면서 이런 문제를 설명할 것이다. 스키마를 분리하지만 애플리케이션 코드는 함께 유지하면, 엉뚱한 방향으로 향하고 있다는 사실을 알게 될 경우에 변경사항을 되돌리거나 아니면 서비스를 사용하는 컨슈머에게 영향을 주지 않으면서 변경사항을 계속 조정할 수 있다. 일단 데이터베이스 분리에 성공하면 애플리케이션 코드를 2개의 서비스로 분리하는 단계로 넘어갈 수 있다.  

스키마를 먼저 분할하면 성능과 트랜잭션 무결성 문제를 초기에 발견할 수도 있다.  

하지만 이런 접근 방식은 단기적 이점을 제공할 가능성이 희박하다. 여전히 모놀리스 코드 배포에 의존하고 있다. 십중팔구, 공유 데이터베이스로 인한 고충은 점차 커지기 때문에, 눈앞의 이익보다는 장기적 혜택을 추구하기 위해 시간과 노력을 들이고 있다. 이런 이유로 나는 성능이나 데이터 일관성 문제가 특히 우려되는 경우에만 데이터베이스를 먼저 분할하는 방식을 택한다. 또한 모놀리스 자체가 상용 소프트웨어처럼 블랙박스 시스템인 경우, 이 선택지를 사용할 수 없다는 점도 고려해야 한다.  

###### 4.11.1.1. 도구에 대한 참고 사항  
<br/>

데이터베이스 변경은 여러 가지 이유로 어렵다. 그중 하나는 데이터베이스를 쉽게 변경하게 만드는 도구가 제한적이라는 사실이다. 코드인 경우에는 IDE(통합개발환경)에 리팩터링 도구가 내장되어 있으며 변경 중인 시스템이 기본적으로 무상태라는 추가적인 이점도 있다. 데이터베이스인 경우에는 변경 중인 내역에 상태가 있으며 리팩터링을 지원하는 도구도 부족하다.  

몇 년 전, 도구 때문에 발생하는 간극으로 인해 닉 애슐리와 그레이엄 태클리라는 동료 2명과 함께 DB디플로이(DBDeploy)라는 오픈소스 도구를 만들었다. 이제는 쓰이지 않는(오픈소스 도구를 만드는 일과 유지보수 하는 일은 전혀 별개의 문제다!) 이 도구는 스키마를 대상으로 결졍적인 방식으로 실행될 수 있는 SQL 스크립트에서 변경사항을 캡처하는 방식으로 동작했다. 스키마 스크립트를 추적하기 위해 사용되는 특수 테이블이 각 스키마마다 존재한다.  

DB디플로이의 목표는 스키마에 점진적인 변경을 가하고, 각 변경 비전을 제어하며, 변경사항을 다양한 시간대(개발자 스키마, 테스트 스키마, 운영 스키마 등을 생각해보자)에서 여러 스키마를 대상으로 실행할 수 있게 만드는 것이다.  

요즘 사람들에게 플라이웨이DB(FlywayDB, https://flywaydb.org/) 또는 유사한 기능을 제공하는 도구를 알려주지만, 어떤 도구를 선택하든 버전 제어가 가능한 델타 스크립트(버전 사이에 변경사항만 기록하는 스크립트)에서 각 변경사항을 캡처하는 기능은 꼭 사용하길 바란다.  

###### 4.11.1.2. 패턴: 경계 컨텍스트 단위의 저장소  
<br/>

일반적으로는, 하이버네이트(Hibernate) 같은 일종의 프레임워크가 지원하는 저장소 계층을 사용해 코드를 데이터베이스에 묶어 객체 또는 데이터 구조를 데이터베이스에 쉽게 매핑하게 만든다. 모든 데이터 접근을 처리할 단일 저장소 계층보다는 경계 컨텍스트를 따라 이런 저장소를 분해하는 방법이 값어치를 한다.  

특정 컨텍스트를 위한 코드 내에 데이터베이스 매핑 코드를 함께 배치하면 어떤 코드가 데이터베이스의 어떤 부분을 사용하는지를 좀 더 손쉽게 이해할 수 있다. 예를 들어 하이버네이트에서는 경계 컨텍스트가 스키마의 어떤 테이블에 접근하는지를 확인할 수 있다. 이는 향후 분해의 일부로 어떤 테이블을 이동할지를 파악하는 데 큰 도움이 될 수 있다.  

하지만 이는 전모를 밝혀주지는 않는다. 재무 코드가 원장 테이블을 사용하고 카탈로그 코드가 물품 테이블을 사용한다고 말할 수도 있겠지만, 데이터베이스가 원장 테이블에서 물품 테이블로 외래 키 관계를 강제하는지는 명확하지 않을 수도 있다. 장애물이 될지도 모르는 데이터베이스 수준 제약 조건을 보려면, 다른 도구를 사용해 데이터를 시각화해야 한다. 일례로 무료로 제공되는 스키마스파이(SchemaSpy, http://schemaspy.sourceforge.net/) 같은 도구를 사용해 테이블 간의 관계를 그래픽으로 표현할 수 있다.  

결국 이 모든 것은 서비스 경계가 될 수도 있는 테이블 사이의 결합도를 이해하는 데 도움이 된다. 히지만 관계를 어떻게 잘라낼까? 그리고 여러 경계 컨텍스트에서 동일한 테이블을 사용하는 경우는 어떨까?  

+ 적용 대상  
경계 컨텍스트 단위의 저장소 패턴은 모놀리스 분리 방법을 더 잘 이해하기 위해 제작업하는 어떤 상황에서든 효과가 있어 보인다. 도메인 개념의 경계선을 따라가면서 이런 저장소 계층을 분해하면 데이터베이스뿐만 아니라 코드 자체에서도 마이크로서비스를 위한 경계선이 존재하는 위치를 이해하는 데 도움이 된다.  

###### 4.11.1.3. 경계 컨텍스트 단위의 데이터베이스  
<br/>

일반적으로는, 하이버네이트(Hibernate) 같은 일종의 프레임워크가 지원하는 저장소 계층을 사용해 코드를 데이터베이스에 묶어 객체 또는 데이터 구조를 데이터베이스에 쉽게 매핑하게 만든다. 모든 데이터 접근을 처리할 단일 저장소 계층보다는 경계 컨텍스트를 따라 이런 저장소를 분해하는 방법이 값어치를 한다.  

특정 컨텍스트를 위한 코드 내에 데이터베이스 매핑 코드를 함께 배치하면 어떤 코드가 데이터베이스의 어떤 부분을 사용하는지를 좀 더 손쉽게 이해할 수 있다. 예를 들어 하이버네이트는 경계 컨텍스트가 스키마의 어떤 테이블에 접근하는지를 확인할 수 있다. 그 결과로 어떤 경계 컨텍스트가 스키마의 어떤 테이블에 접근하는지를 확인할 수 있다. 이는 향후 분해의 일부로 어떤 테이블을 이동할지를 파악하는 데 큰 도움이 될 수 있다.  

하지만 이는 전모를 밝혀주지는 않는다. 예를 들어 재무 코드가 원장 테이블을 사용하고 카탈로그 코드가 물품 테이블을 사용한다고 말할 수도 있겠지만, 데이터베이스가 원장 테이블에서 물품 테이블로 외래 키 관계를 강제하는지는 명확하지 않을 수도 있다. 장애물이 될지도 모르는 데이터베이스 수준 제약 조건을 보려면, 다른 도구를 사용해 데이터를 시각화해야 한다. 일례로 무료로 제공되는 스키마스파이(SchemaSpy, http://schemaspy.sourceforge.net/) 같은 도구를 사용해 테이블 간이 관계를 그래픽으로 표현할 수 있다.  

결국 이 모든 것은 서비스 경계가 될 수도 있는 테이블 사이의 결합도를 이해하는 데 도움이 된다. 하지만 관계를 어떻게 잘라낼까? 그리고 여러 경계 컨텍스트에서 동일한 테이블을 사용하는 경우는 어떨까?  

+ 적용 대상  
경계 컨텍스트 단위의 저장소 패턴은 모놀리스 분리 방법을 더 잘 이해하기 위해 재작업하는 어떤 상황에서든 효과가 있어 보인다. 도메인 개념의 경계선을 따라가면서 이런 저장소 계층을 분해하면 데이터베이스뿐만 아니라 코드 자체에서도 마이크로서비스를 위한 경계선이 존재하는 위치를 이해하는 데 도움이 된다.  

###### 4.11.1.4. 패턴: 경계 컨텍스트 단위의 데이터베이스  
<br/>

일단 애플리케이션 관점에서 데이터 접근을 명확하게 격리하고 나면 이런 처리 방식을 스키마에 계속해서 적용하는 방식이 의미가 있다. 마이크로서비스의 독립적인 배포 가능성이라는 핵심 개념에 따르면 마이크로서비스는 자신의 데이터를 소유해야 마땅하다. 애플리케이션 코드를 분리하기에 앞서, 식별된 경계 컨텍스트를 둘러싼 데이터베이스를 명확하게 분리하는 방법으로 분해를 시작할 수 있다.  

소트웍스에서 수익을 계산하고 예측할 목적으로 몇 가지 새로운 메커니즘을 구현하고 있었다. 이 과정에서 작성해야 하는 3가지 광범위한 기능 영역을 파악했다. 이 문제를 해당 프로젝트의 책임자인 피터 길라드모스(Peter Gillard-Moss)와 논의했다. 피터는 기능이 상당히 분리되어 있는 듯이 보여도, 이 기능들을 별도 마이크로서비스로 제공할 경우 추가적으로 발생하는 유지 보수 작업이 우려된다는 의견을 피력했다. 그 당시 피터의 팀은 단 3명의 팀원으로 구성되어 규모가 작았으며, 팀은 새로운 서비스 분리가 굳이 필요하지는 않다고 생각했다. 결국 고민 끝에 격리된 경계 컨텍스트 3가지(각각 개별 JAR 파일로 나뉨)를 포함하는 식으로 단일 서비스를 만들어 새로운 수익 기능을 효과적으로 배포하는 모델로 간다는 결론을 내렸다.  

각 경계 컨텍스트마다 완전히 분리된 독자적인 데이터베이스가 있었다. 나중에 마이크로서비스로 분리할 필요가 있다면 작업이 훨씬 수월하리라 여겨졌다. 그러나 결국 분리 작업은 전혀 필요하지 않았다. 몇 년이 지난 후에도 이 수익 서비스는 연관된 데이터베이스가 여러 개 있는 모놀리스(모듈식 모놀리스의 훌륭한 예) 형태로 그대로 남아 있다.  

+ 적용 대상  
언뜻 보기에는, 분리된 데이터베이스를 유지관리하기 위한 추가 작업은 모놀리스인 경우에는 큰 의미가 없다. 이는 분산 두자와 유사한 패턴이다. 단일 데이터베이스보다 약간 더 많은 작업을 수행하지만 나중에 마이크로서비스로 이동할 경우에 선택지를 열어 둔다. 심지어 마이크로서비스로 결코 이동하지 않더라도 데이터베이스를 뒷받침하는 스키마를 명확하게 분리하면 특히 많은 사람들이 모놀리스에서 작업하는 경우 정말 큰 도움이 될 수 있다.  

이는 (기존 시스템을 재구현하는 경우와는 대조적으로) 새로운 시스템을 구축하는 사람들에게 거의 항상 권장하는 패턴이다. 신제품이나 스타트업을 위한 마이크로서비스 구현을 지지하지 않는다. 두 경우에는 관련 이해당사자들의 도메인에 대한 이해가 안정적인 도메인 경계를 식별하기에 충분히 성숙하지 않을 가능성이 높다. 특히 스타트업의 경우, 구축하려는 대상의 특성이 큰 폭으로 바뀔 수 있다. 그러나 이 패턴은 멋진 중간 지점이 될 수 있다. 향후 서비스 분리가 있을 것으로 예상되는 장소에 스키마를 분리해서 유지하자. 이렇게 하면 시스템의 복잡성을 줄이는 동시에 이런 스키마를 분리함으로써 얻을 수 있는 이점이 생긴다.  

##### 4.11.5. 코드를 먼저 분할  
<br/>

대다수 팀이 코드를 먼저 분할한 다음 데이터베이스를 분할한다는 사실을 알게 됐다. 새로운 서비스에서 단기적인 개선을 (바라건대) 얻을 수 있으므로, 데이터베이스를 분리하는 방법으로 분해를 완료할 수 있다는 확신이 생긴다.  

애플리케이션 계층을 분리하면 새로운 서비스가 요구하는 데이터가 무엇인지 훨씬 더 쉽게 이해하게 된다. 또한 독립적으로 배포 가능한 코드 산출물을 더 일찍 확보한다는 이점도 얻을 수 있다. 이런 접근 방식에서 내가 항상 겪어온 문제는 팀이 상황을 개선한 후에 중단하는 바람에 공유 데이터베이스를 지속적으로 운영한다는 점이다. 이런 방향을 택했다면, 데이터 계층으로 분리를 완료하지 않을 경우 미래에 발생할 문제를 묻어두게 된다는 사실을 알아둬야 한다. 저스트소셜(JustSocial)은 독자적인 마이크로서비스 마이그레이션의 일부로 이와 같은 접근 방식을 사용한 조직 중 하나다. 여기서 또 다른 문제라면, 조인 연산을 애플리케이션에 밀어넣을 때 발생하는 돌발상황을 뒤늦게 알아차릴 수도 있다는 점이다.  

이 방향을 택했다면, 스스로에게 솔직해지자. 조직은 이후 이어지는 단계에서 마이크로서비스가 소유한 모든 데이터를 분리할 만큼의 역량을 충분히 갖췄는가?  

###### 4.11.5.1. 패턴: 데이터 접근 계층으로 작동하는 모놀리스  
<br/>

모놀리스에서 직접 데이터에 접근하는 대신, 모놀리스 자체에 API를 생성하는 모델로 이동해보자. 송장 서비스는 고객 서비스와 관련해 직원에 대한 정보가 필요하므로 송장 서비스가 직원 정보에 접근할 수 있게 직원 API를 생성한다. 저스트소셜의 수잔 카이저는 자사에서 마이크로서비스 마이그레이션의 일환으로 성공적으로 사용된 이 패턴을 내게 알려줬다. 그간 이 패턴을 기반으로 수많은 작업이 진행되었기에, 이 패턴이 예상만큼 잘 알려지지 않았다는 사실이 놀라웠다.  

이 패턴이 더 널리 사용되지 않는 이유 중 하나로는, 아마도 뭔가 사람들이 모놀리스는 이미 죽었고 쓸모도 없다는 생각을 하기 때문일 것이다. 사람들은 모놀리스에서 벗어나고 싶어 한다. 사람들은 모놀리스를 더 유용하게 만들 생각을 하지 않는다! 그러나 여기서 긍정적인 면은 분명하다. (아직) 데이터 분해와 씨름할 필요는 없어도 정보는 은닉해야 하므로 새로운 서비스를 모놀리스로부터 격리시키기가 훨씬 더 쉽다. 모놀리스의 데이터가 그대로 남아 있을 거라고 판단하는 경우여야 이 모델을 채택할 수 있을 것이다. 하지만 새로운 서비스가 사실상 무상태형이 되리라 생각한다면, 이 모델은 잘 작동할 것이다.  

이 패턴을 이용해 다른 후보 서비스를 판별하기란 그리 어렵지 않다. 이 개념을 확장하면, 직원 API가 모놀리스에서 떨어져 나와 자체적인 마이크로서비스로 발전할 수 있다.  

+ 적용 대상  
이 패턴은 데이터를 관리하는 코드가 여전히 모놀리스에 있을 때 가장 잘 작동한다. 앞서 언급했듯이 데이터 관점에서 바라본 마이크로서비스는 상태와 이런 상태의 전이를 관리하는 코드의 캡슐화로 정의할 수 있다. 따라서 이 데이터의 상태 전이가 여전히 모놀리스에서 일어나는 경우, 해당 상태에 접근(또는 변경)하기를 원하는 마이크로서비스는 모놀리스에서 상태 전이를 거쳐야 한다.  

모놀리스 데이터베이스에서 접근을 시도하는 데이터를 실제로는 마이크로서비스가 '소유'해야 한다면 이 패턴을 건너뛰고 데이터 분리 방안을 제안할 것이다.  

###### 4.11.5.2. 패턴: 다중 스키마 저장소  
<br/>

앞서 살펴봤듯이 나쁜 상황은 더 악화시키지 않는 편이 좋다. 여전히 데이터베이스의 데이터를 직접 사용하더라도 마이크로서비스가 저장할 데이터 역시 기존 데이터베이스에 들어가야 한다는 의미는 아니다. 송장 핵심 데이터는 여전히 모놀리스에 존재하며, (현재) 접근할 수 있는 장소다. 송장에 검토 내용을 추가할 수 있는 기능을 추가했다. 이는 모놀리스에 없는 새로운 기능에 해당한다. 이를 지원하려면 직원을 송장 ID에 매핑하는 검토자(reviewer) 테이블을 저장해야 한다. 이 새로운 테이블을 모놀리스에 넣으면 데이터베이스 덩치만 키울 뿐이다! 그 대신 이 새로운 데이터를 송장 서비스의 자체적인 스키마에 넣었다.  

이 예에서, 외래 키(foreign-key) 관계가 스키마 경계를 실질적으로 확장할 때 발생하는 문제를 고려해야 한다. 이 문제를 깊이 있게 살펴볼 것이다.  

모놀리스 데이터베이스에서 데이터를 꺼내려면 시간이 걸리며, 이는 한 단계로 수행 가능한 작업이 아닐지도 모른다. 따라서 마이크로서비스가 자체적인 로컬 저장소를 관리하는 동시에 모놀리스 데이터베이스의 데이터에도 접근 가능하다면, 이는 매우 기쁜 일이다. 모놀리스에서 나머지 데이터를 끌어다 가져오는 식으로 관리하면, 테이블을 새로운 스키마로 한 번에 마이그레이션할 수 있다.  

+ 적용 대상  
이 패턴은 새로운 데이터를 저장해야 하는 새로운 기능을 마이크로서비스에 추가할 때 효과적으로 동작한다. 모놀리스가 요구하는 데이터는 분명하지 않으므로(기능은 여기에 없다). 처음부터 분리하자. 이 패턴은 또한 모놀리스에서 데이터를 마이크로서비스의 자체적인 스키마로 이동하기 시작할 때도 의미가 있다. 이 과정에서 시간이 오래 걸릴 수도 있다.  

모놀리스의 스키마에 접근해야 하는 데이터가 스키마로 이동할 계획이 전혀 없다면 이 패턴과 연관지어 '데이터 접근 계층으로 작동하는 모놀리스' 패턴을 사용하는 방식을 강력히 권장한다.  

##### 4.11.6. 데이터베이스와 코드를 함께 분할  
<br/>

단계별 이동 관점에서 볼 때, 큰 단계 하나로 사물을 분해할 수 있는 선택지가 있다. 모든 코드와 데이터를 한 번에 분할한다.  

이 수행 방식은 훨씬 더 큰 조치이기 때문에, 내린 결정이 어떤 영향을 미치는지 평가하는 데 꽤 오랜 시간이 걸린다는 점이 문제다. 따라서 이런 접근 방식보다는 스키마나 애플리케이션 계층을 먼저 분할하는 방식을 강력하게 권장한다.  

##### 4.11.7. 그렇다면 무엇을 먼저 분할해야 할까?  
<br/>

만일 모놀리스를 변경할 수 있는데 성능이나 데이터 일관성에 대한 영향이 우려되는 경우라면, 스키마를 먼저 분할하는 편이 좋다. 그런 경우가 아니라면, 코드를 분리해 코드가 데이터 소유권에 미치는 영향을 이해하는 데 도움이 되는 방향으로 사용할 것이다. 그러나 스스로 판단해, 특정 상황에서 의사결정 과정에 영향을 미칠 수 있는 모든 요소를 고려하는 것도 중요하다.  

#### 4.12. 스키마 분리 사례  
<br/>

지금까지 상당히 고수준에서 스키마 분리를 검토한 결과, 데이터베이스 분해와 관련한 복잡한 난제와 까다로운 문제들이 생겼다. 이제 저수준의 데이터 분해 패턴 몇 가지를 살펴보고 이들이 미치는 영향을 알아보자.  

##### 4.12.1. 관계형 데이터베이스와 NoSQL 비교  
<br/>

관계형 스키마로 작업할 때 발생하는 문제를 살펴본다. 이런 관계형 데이터베이스 유형의 특성은 스키마를 분리하는 측면에서 추가적인 문제를 일으킨다. 아마ㅗ 대다수는 비관계형 데이터베이스(NoSQL)을 사용하고 있을 것이다. 그러나 곧이어 설명할 다음 패턴 중 상당수가 NoSQL에서도 적용될 수 있다.  

#### 4.13. 패턴: 테이블 분할  
<br/>

간혹 서비스 경계를 2개 이상 가로질러 분할할 필요가 있는 단일 테이블에서 데이터를 찾게 될텐데, 이는 꽤 흥미로운 일이다. 단일 공유 테이블인 물품이 있으며 여기에는 판매 중인 물품뿐만 아니라 재고 수준에 대한 정보도 저장된다.  

이 예에서는 카탈로그와 창고를 새로운 서비스로 분리하고자 하나, 양쪽을 위한 데이터가 단일 테이블에 혼합되어 있다. 따라서 데이터를 별도 테이블 2개로 분할할 필요가 있다. 점진적인 마이그레이션이라는 세계에서는 스키마를 분리하기 전에 기존 스키마에서 테이블을 분리하는 방식이 타당할 수 있다. 이런 테이블들이 단일 스키마에 존재하면, 재고 물품 SKU(재고 단위) 열에서 카탈로그 물품 테이블로 연결되는 외래 키 관계를 선언하는 방식이 의미가 있을 것이다. 그러나 결국 이런 테이블을 별도 데이터베이스로 옮길 계획이므로 외래 키를 설정하더라도 데이터 일관성을 강제하는 단일 데이터베이스가 사라져 외래 키로부터 별다른 이익을 거두지 못한다(잠시 후에 이 개념을 더 자세히 살펴본다).  

이 예제는 매우 간단하다. 열 단위로 데이터 소유권을 쉽게 분리할 수 있었다. 그러나 여러 코드 조각이 동일 열을 업데이트하면 어떻게 될까? 상태 열이 포함된 고객(Customer) 테이블이 있다.  

상태 열은 해당 고객이 이메일을 확인했는지(또는 확인하지 않았는지)를 알려주며, 고객 등록 과정에서 NOT&#95;VERIFIED(확인됨)로 바뀌는 값이다. 일단 고객이 VERIFIED(확인됨) 상태면, 쇼핑이 가능하다. 재무 코드는 고객이 청구 요금을 납부하지 않은 경우, 그에 따라 고객의 상태를 정지됨(SUSPENDED)으로 변경할 것이다. 이 경우, 고객의 상태는 여전히 고객 도메인 모델의 일부가 되어야 할 것이므로, 조만간 생성될 고객 서비스가 그렇게 관리해야 할 것이다. 가능하다면 단일 서비스 경계 내부에 도메인 엔티티를 위한 상태 머신을 유지하고자 하며, 고객의 상태 업데이트는 확실히 고객을 위한 상태 머신의 일부처럼 취급해야 한다! 이는 서비스 분할이 이뤄졌을 때, 새로운 재무 서비스가 상태를 업데이트하기 위해 서비스를 호출할 필요가 있음을 의미한다.  

이와 같은 테이블 분할의 큰 문제는, 기존에는 데이터베이스 트랜잭션으로 인해 보장되고 있었던 안정성을 잃을 수도 있다는 점이다.  

##### 4.13.1. 적용 대상  
<br/>

표면적으로, 테이블 분할 패턴은 상당히 직관적으로 보인다. 현재 모놀리스에서 2개 이상의 경계 컨텍스트가 테이블을 소유하는 경우에는, 해당 경계를 따라 테이블을 분할해야 한다. 코드베이스의 여러 부분에서 업데이트할 듯이 보이는 테이블에서 특정 열이 발견되면, 누가 이 열에 속한 데이터를 '소유'할지에 대해 결정을 내려야 한다. 영역 내에 있는 기존 도메인 개념으로 설명할 수 있을까? 이는 데이터를 옮길 장소를 결정하는 데 도움이 될 것이다.  

#### 4.14. 패턴: 외래 키 관계를 코드로 이동  
<br/>

아티스트, 트랙, 음반에 대한 정보를 관리하고 외부에 공개할 수 있는 카탈로그 서비스를 추출하기로 결정했다. 현재 모놀리스 내부의 카탈로그 관련 코드는 음반 테이블을 사용해, 판매하게 될 수도 있는 CD에 대한 정보를 저장한다. 이 음반들은 결국 모든 판매를 추적하는 원장(Ledger) 테이블에서 참조된다. 원장 테이블의 행에는 판매된 물품을 가리키는 식별자와 함께, CD를 판매하고 받은 금액이 기록된다. 식별자는 소매 시스템의 일반적인 관행인 SKU(재고 단위)라고 한다.  

월말마다 가장 많이 판매된 CD를 요약한 보고서를 작성해야 한다. 원장 테이블은 가장 많이 판매한 SKU를 이해하는 데 도움이 되지만 해당 SKU에 대한 정보는 음반 테이블을 넘어간다. 멋지고 읽기 쉬운 보고서를 원했기에, "SKU 123을 400개 판매하고 1,596달러를 벌었습니다."라고 말하기보다는 판매와 관련된 더 많은 정보를 추가해 "브루스 스프링스턴의 &lt;본 투 런&gt; 음반을 400장 판매해 1,596달러를 벌었습니다."라고 말하고 싶었다. 이를 위해서는 재무 코드에 의해 수행된 데이터베이스 쿼리가 원장 테이블에서 음반 테이블로 정보를 조인해야 한다.  

원장 테이블의 행이 음반 테이블의 행과 관계를 맺도록 만들기 위해 스키마에 외래 키 관계를 정의했다. 이런 관계를 정의함으로써 기반 데이터베이스 엔진은 데이터 일관성을 보장할 수 있다. 즉 원장 테이블의 한 행이 음반 테이블의 한 행을 참조하면 해당 행이 존재한다는 사실을 알 수 있다. 이 상황에서는 판매된 음반에 대한 정보를 항상 얻을 수 있다. 또한 이와 같은 외래 키 관계를 통해 데이터베이스 엔진은 성능 최적화를 수행하며, 그 결과로 조인 작업은 최대한 빨리지게 된다.  

카탈로그 코드와 재무 코드를 각각의 서비스로 분리하길 원한다. 즉 이는 데이터도 함께 따라와야 함을 의미한다. 음반과 원장 테이블이 다른 스키마에 존재하는 상황이 벌어질 경우 외래 키 관계는 어떻게 될까? 글쎄, 고려해야 할 2가지 핵심 문제가 있다. 첫째, 새로운 재무 서비스에서 향후 이 보고서를 생성할 때 데이터베이스 조인으로 작업을 수행할 수 없는 경우라면, 카탈로그 관련 정보는 어떻게 검색할까? 둘째, 이제 데이터 불일치가 새로운 세계에 존재할 수 있다는 사실에 대해 어떻게 대응해야 할까?  

##### 4.14.1. 조인 이동  
<br/>

먼저 조인을 대체하는 방법을 살펴보자. 모놀리스 시스템을 사용하면 음반 테이블의 행을 원장의 판매 정보와 조인하는 작업을 데이터베이스가 자체적으로 수행한다. 음반 테이블에 조인할 단일 SELECT 쿼리를 수행한다. 즉 쿼리를 실행하고 필요한 모든 데이터를 가져오기 위해 단일 데이터베이스 호출이 필요하다.  

새로운 마이크로서비스 기반 세계에서 새로운 재무 서비스는 가장 많이 팔린 제품 보고서를 생성할 책임이 있지만, 음반 데이터는 마이크로서비스 내부에 가지고 있지 않다. 따라서 새 카탈로그 서비스에서 이 정보를 가져와야 할 것이다. 보고서를 생성할 때 재무 서비스는 먼저 원장 테이블을 쿼리해 직전 달에 가장 많이 팔린 SKU 목록을 추출한다. 이 시점에서, SKU 목록과 각 음반당 판매 수량만을 보유하고 있으며, 이게 바로 마이크로서비스 내부에 확보한 유일한 정보다.  

다음으로, 각 SKU에 대한 정보를 요청하기 위해 카탈로그 서비스를 호출해야 한다. 이 요청을 통해 카탈로그 서비스는 자체 데이터베이스에서 SELECT 쿼리를 내리게 된다.  

당연히 조인 작업은 여전히 진행 중이지만, 이제는 데이터베이스 내부가 아니라 재무 서비스 내부에서 일어난다. 불행히도 효율성은 데이터베이스 내부에서 조인 작업을 하는 경우와 비교해 엄청나게 떨어질 것이다. 단일 SELECT 문이 있는 데이터베이스 의존 환경에서 원장 테이블에 대해 SELECT 쿼리를 내린 다음, 카탈로그 서비스에 대한 서비스 호출을 수행해 연이어 음반 테이블에 대해 SELECT 문을 일으키는 애플리케이션 의존 환경으로 이동했다.  

이런 상황에서 이와 같은 연산의 대기 시간이 늘어난 것은 너무나도 당연했다. 이 보고서는 매달 생성되며 공격적으로 캐시될 수 있으므로 사례처럼 특별한 경우에는 별 문제가 되지 않을 것이다. 그러나 빈번한 연산이라면 더 큰 문제가 될 수 있다. 카탈로그 서비스에서 SKU를 대량으로 조회하거나, 아니면 필요한 음반 정보를 서비스 내부에서 캐싱하는 방법으로 대기 시간 증가로 인한 영향을 어느 정도 완화할 수 있다.  

결국 이런 대기 시간 증가가 문제인지 아닌지 결정할 수 있도록 핵심 연산에 허용되는 대기 시간을 이해하고 현재 대기 시간을 측정할 수 있어야 한다. 예거(Jaeger, https://www.jaegertracing.io/)와 같은 분산 시스템ㄴ을 통해 여러 서비스에 걸친 연산의 정확한 작업 타이밍을 수집할 수 있으므로 이런 상황에서 실제로 도움이 될 것이다. 연산이 다소 느려지더라도 업무에 지장이 없는 범위 내라면, 특히 대기 시간을 희생해 얻을 수 있는 이점이 있다면 사람들은 얼마든지 수긍할 것이다.  

##### 4.14.2. 데이터 일관성  
<br/>

더 까다로운 고려사항은 카탈로그와 재무가 분리된 서비스이며, 스키마도 분리된 경우라면 데이터 불일치가 발생할지도 모른다는 사실이다. 단일 스키마를 사용하는 경우, 원장 테이블에서 해당 행에 대한 참조가 있으면 음반 테이블에서 행을 삭제할 수 없다. 단일 스키마는 데이터 일관성을 강화하고 있었다. 새로운 세계에는 이런 강제적인 규칙이 존재하지 않는다. 여기서 선택지는 무엇일까?  

###### 4.14.2.1. 삭제하기 전에 확인  
<br/>

첫 번째 선택지는 음반 테이블에서 레코드를 제거할 때 재무 서비스를 사용해 레코드에 대한 참조가 없는지 확인하는 방식이다. 여기서 문제는 이를 제대로 확인하기 어렵다는 점이다. SKU 683을 삭제하기를 원한다고 가정하자. "683을 사용하고 있습니까?"라고 재무 서비스에 호출을 보낸다. 재무 서비스는 이 레코드가 사용되지 않았다고 응답한다. 응답을 받고 나서 이 레코드를 삭제하지만, 삭제 작업을 수행하는 동안 683에 대한 새로운 참조가 재무 시스템에 만들어진다. 이런 상황이 발생하지 않게 하려면 삭제가 완료될 때까지 레코드 683에 새로운 참조가 생성되지 못하게 막아야 하는데, 잠금은 물론이고 분산 시스템에 수반되는 모든 문제가 발목을 잡는다.  

레코드가 이미 사용 중인지 확인하는 작업은 카탈로그 서비스에서 사실상 거꾸로 된 의존성을 만들어낸다는 또 다른 문제를 수반한다. 이제 레코드를 사용하는 다른 서비스들을 확인해야 할 것이다. 정보를 사용하는 서비스가 하나만 있어도 이미 나쁜 상황인데 컨슈머가 더 많아지면 상황은 훨씬 더 악화된다.  

이런 연산은 올바르게 구현하기가 어려울 뿐만 아니라 이로 인해 발생하는 높은 수준의 서비스 결합도 바람직하지 않기 때문에, 이 옵션은 고려하지 않기를 강력히 권고한다.  

###### 4.14.2.2. 적절한 삭제 처리  
<br/>

좀 더 나은 선택지를 생각해보자면, 카탈로그 서비스가 음반에 대한 정보를 모른다는 사실을 재무 서비스가 우아하게 처리하도록 만드는 방식이다. 원하는 SKU를 조회할 수 없는 경우, 보고서에 '음반 정보를 사용할 수 없음'을 표시하는 방식으로 간단하게 처리할 수 있다.  

이 상황에서 카탈로그 서비스는 (실제로 존재하지 않지만) 존재한다고 생각한 SKU를 요청받고 나서 응답 코드로 결과를 알려줄 수 있다. HTTP를 사용하는 경우, 410 GONE 응답 코드를 활용한다. 410 응답 코드는 일반적으로 사용되는 404 Not Found 응답 코드와는 다르다. 404는 요청된 자원을 찾을 수 없음을 나타내는 반면에, 410은 요청된 자원을 예전엔 사용할 수 있었지만 요청된 자원이 더 이상 존재하지 않는다는 사실을 나타낸다. 특히 데이터 불일치 문제를 추적할 때 이런 구분은 중요할 수 있다! HTTP 기반 프로토콜을 사용하지 않더라도, 이런 종류의 응답을 지원함으로써 어떤 이익을 얻을 수 있을지를 생각해보자.  

정말 제대로 삭제를 처리하고 싶다면, 카탈로그 물품이 제거될 때 이벤트를 구독함으로써 재무 서비스에 정보를 제공할 수도 있다. 카탈로그 삭제 이벤트를 받으면, 삭제될 음반 정보를 로컬 데이터베이스로 복사하도록 결정할 수 있다. 여기서 예제로 든 상황에서는 다소 과한 것 같지만, 다른 시나리오에서는 유용할 수 있다. 서비스 경계에서 연속적인 삭제와 같은 작업을 수행하기 위해 분산 상태 머신을 구현하기를 원하는 경우에 특히 그렇다.  

###### 4.14.2.3. 삭제 금지  
<br/>

시스템에 불일치가 너무 많이 발생하지 않도록 보증하는 한 가지 방법은 간단히 카탈로그 서비스의 레코드 삭제를 허용하지 않는 것이다. 물품을 삭제하는 기존 시스템에서 판매 또는 이와 유사한 작업이 가능하지 않게 보증한다면, 논리적인 삭제(soft delete) 기능만 구현하면 된다. 이 작업은 상태 열을 사용해 해당 행을 사용 불가로 표시하거나 아니면 행을 전용 '휴지통' 테이블로 이동해 수행할 수 있다. 특정 음반의 레코드가 삭제되었더라도 재무 서비스에서 해당 음반의 레코드를 요청할 수 있다.  

###### 4.14.2.4. 그러면 삭제를 어떻게 처리해야 할까?  
<br/>

기본적으로, 마이크로서비스를 도입하면서 모놀리스 시스템에는 존재할 수 없는 실패 모드를 만들어왔다. 이에 대한 해결 방식을 모색하는 과정에서, 각 해법마다 다양한 방식으로 사용자에게 영향을 미치므로 사용자의 요구를 고려해야 한다. 따라서 올바른 해법을 선택하려면 구체적인 상황을 이해해야 한다.  

이런 특정 상황에서는 2가지 방법으로 문제를 해결하겠다. 카탈로그에서 음반 정보의 삭제를 허용하지 않는 방법과 재무 서비스에서 누락된 레코드를 처리할 수 있도록 보장하는 방법으로 해결할 수 있을 것이다. 카탈로그 서비스에서 레코드를 제거할 수 없다면 재무에서 조회하는 작업도 실패하지 않을 거라 주장할 분도 있을 것이다. 그러나 데이터 손상의 결과로 인해 카탈로그 서비스가 이전 상태로 복구될 가능성이 있으며, 이는 찾는 레코드가 더 이상 존재하지 않음을 의미한다. 이런 상황에서 재무 서비스가 와르르 무너지기를 원하지는 않을 것이다. 이런 곤란한 상황은 드물겠지만, 항상 회복탄력성을 구축하고 호출이 실패하면 어떻게 될지를 생각해본다. 재무 서비스에서 이를 우아하게 처리하는 방식은 꽤 쉬운 해결책일 것이다.  

##### 4.14.3. 적용 대상  
<br/>

외래 키 관계를 효과적으로 분해하는 작업을 고려할 때 가장 먼저 확실히 보장해야 할 사항은 진짜로 하나로 만들고 싶은 2가지를 나누지 않는 것이다. 집계와 관련된 분해가 걱정된다면 일시 중지하고 다시 생각해보자. 여기서 원장과 음반의 경우, 둘 사이에 관계가 있는 분리된 2가지 집계가 있다는 사실이 분명해 보인다. 그러나 다른 경우도 고려하자. 예를 들어 주문한 물품의 세부사항을 포함하는 주문서 테이블에는 주문 테이블과 연결된 행이 많다. 주문서 테이블을 별도 서비스로 분할하면 데이터의 무결성 문제를 고려해야 한다. 실제로 주문서에는 각각의 개별 주문이 담겨 있다. 그러므로 개별 주문들을 각각 주문 단위로 취급해야 하며, 이들을 모놀리스 밖으로 옮기고 싶다면 함께 옮겨야 한다.  

간혹 외래 키 관계의 양쪽 면을 모두 이동하는 식으로 모놀리스 스키마에서 큰 부분을 덮어내면 일이 훨씬 더 수월해질 것이다!  

##### 4.14.4. 사례: 공유 정적 데이터  
<br/>

(자주 변경되지는 않지만 대체로 중요한) 정적 참조 데이터(static reference data)는 몇 가지 흥미로운 문제를 만들어낼 수 있으며 이를 관리하기 위한 다양한 접근 방식을 목격해왔다. 종종 이런 데이터는 데이터베이스로 숨어 들어가는 길을 찾는다. 자바 프로젝트를 수행하면서 수많은 국가 코드가 데이터베이스에 저장되어 있었다.  

국가 코드처럼 자주 변경되지 않는 소량의 데이터가 데이터베이스에 존재해야 하는 이유에 대해 항상 의문을 제기했지만, 근본적인 이유가 무엇이든 간에 데이터베이스에 저장된 정적 공유 데이터의 예는 여기저기서 등장한다. 그렇다면 코드의 많은 부분에서 동일한 정적 참조 데이터가 필요한 음악 판매 서비스에서 무엇을 해야 할까? 글쎄다. 여기에는 선택지가 많다.  

###### 4.14.4.1. 패턴: 중복 정적 참조 데이터  
<br/>

서비스마다 독자적인 데이터 사본을 유지하면 어떨까? 이야기를 듣자마자 아마도 숨이 탁 막힐 것이다. 중복된 데이터? 미친 거 아닌가? 하지만 끝까지 들어보기 바란다! 생각하는 것보다는 덜 미쳤다.  

데이터 복제에 대한 우려는 2가지로 귀결되는 경향이 있다. 먼저 데이터를 변경할 필요가 있을 때마다 여러 곳에서 변경해야만 한다. 그러나 국가 코드와 관련된 상황에서 데이터는 얼마나 자주 변경될까? 가장 마지막으로 수립되어 공식 인정된 국가는 2011년에 탄생된 남수단이다(남수단의 국가 코드는 SSD). 따라서 이런 문제가 큰 고려사항이라고 생각하지 않는다. 그렇지 않나? 하지만 더 큰 걱정거리가 있는데, 만일 데이터가 일치하지 않으면 어떻게 될까? 예를 들어 재무 서비스는 남수단이 국가라는 사실을 알고 있으나, 이해하기 어렵지만 창고 서비스는 과거에 존재하며 남수단에 대해서는 아무것도 모른다.  

불일치가 문제인지 여부는 데이터 사용 방법에 달려 있다. 이 사례에서는 창고가 이 국가 코드 데이터를 사용해 CD가 제조되는 위치를 기록한다고 가정해보자. 남수단에서 만들어진 CD 재고가 하나도 없기 때문에 이 데이터가 없어도 전혀 문제가 되지 않는다. 반면, 재무 서비스는 판매에 대한 정보를 기록하기 위해 국가 코드 정보가 필요하며 남수단에 고객이 있으므로 업데이트된 항목이 필요하다.  

데이터가 각 서비스 내에서만 단독으로 사용될 때는 불일치 유무가 문제되지 않는다. 경계 컨텍스트에 대한 정의를 떠올려보자. 경계 컨텍스트란 정보가 경계 안에 숨겨져 있음을 뜻한다. 판변에 데이터가 이런 서비스 간 통신의 일부라면 다른 문제가 있다. 창고와 재무 모두 국가 정보에 대한 동일한 뷰가 필요한 경우, 불일치는 분명히 우려해야 할 사항이다.  

물론 백그라운드에서 동작하는 프로세스를 사용해 이런 사본을 동기화 상태로 유지하는 방법을 고려할 수도 있다. 이런 상황에서는 모든 복사본의 일관성을 보장할 수는 없지만 백그라운드에서 동작하는 프로세스가 충분히 자주 (그리고 빠르게) 실행된다고 가정하면 데이터의 불일치 가능성을 줄일 수 있으며 이 정도면 충분할지도 모른다.  

개발자로서 종종 중복을 볼 때 심하게 반응한다. 중복된 정보 사본을 관리하는 데 드는 추가비용이 걱정되며, 이런 데이터가 분산될 경우 더더욱 걱정스럽다. 그러나 때때로 복제는 2가지 해악 중 그나마 나은 쪽이다. 데이터에서 일부 중복을 수용하는 방식이 결합도를 피하기 위한 수단일 경우, 의미 있는 거래가 될 수 있다.  

+ 적용 대상  
이 패턴은 사용하지 않는 편이 좋으며, 이보다는 다른 옵션을 선택해야 한다. 이 패턴은 모든 서비스가 정확히 동일한 데이터 집합에 의존하지 않아도 되는 대랑의 데이터일 경우에 유용하다. 우편번호를 주소로 매핑해서 제공하는 최신 정보를 주기적으로 제공하는 영국의 우편번호 파일 등의 사례가 이 경우에 적합할 것이다. 이런 파일은 코드 형식으로 관리하기가 꽤 어려운 매우 큰 데이터 집합이다. 이와 같은 데이터에 직접 관리하기를 원한다면, 이 선택지를 고려해볼 수도 있겠지만, 솔직히 말해 지금까지 직접 이런 작업을 수행했던 기억은 없다!  

###### 4.14.4.2. 패턴: 전용 참조 데이터 스키마  
<br/>

정말로 국가 코드에 대한 진실의 원천을 하나만 원한다면, 이 데이터를 전용 스키마로 재배치할 수 있다. 아마도 모든 정적 참조 데이터를 따로 챙겨둘 수 있다.  

여기서 공유 데이터베이스의 모든 문제점을 고려해야 한다. 어느 정도까지, 결합도와 변경에 대한 우려 사항은 데이터의 특성에 의해 다소 상쇄된다. 자주 변경되지 않고 간단하게 구성되므로, 이 참조 데이터 스키마를 정의된 인터페이스로 쉽게 간주할 수 있다. 이런 상황에서, 참조 데이터 스키마를 자체 버전이 있는 엔티티로 관리하고, 사람들이 스키마 구조가 컨슈머에 대한 서비스 인터페이스를 표현하고 있다는 사실을 이해하게 만들 것이다. 이 스키마의 파괴적 변경이 생기면 난감할 것 같다.  

스키마에 데이터가 들어 있으면, 서비스가 이 데이터를 자체적인 로컬 데이터에 대한 조인 쿼리의 일부로 사용할 수 있는 기회가 열린다. 그러나 이렇게 하려면 스키마가 동일한 기반 데이터베이스 엔진에 위치하는지 확인해야 한다. 이는 잠재적인 단일 장애 지점 문제를 완전히 제쳐놓고서도 논리적 세계에서 물리적 세계로 매핑하는 방식에 있어 어느 정도의 복잡성을 추가한다.  

+ 적용 대상  
이 선택지에는 많은 장점이 있다. 중복에 대한 우려를 피하고 데이터 형식이 변경될 가능성이 거의 없기 때문에, 결합도 문제도 완화된다. 대량의 데이터 또는 교차 스키마 조인 옵션을 원할 경우 유효한 접근 방식이다. 스키마 형식을 변경하면 여러 서비스에 걸쳐 심각한 영향을 줄 가능성이 높다는 사실만 기억하자.  

###### 4.14.4.3. 패턴: 정적 참조 데이터 라이브러리  
<br/>

좀 더 자세히 살펴보면, 국가 코드 데이터에는 항목이 많지 않다. ISO 표준 목록을 사용한다고 가정하면, 대표적인 249개국만 표시되어 있다. 이는 간단한 정적 열거형과 같이 코드 형태에 잘 맞아 떨어질 것이다. 실제로, 소량의 정적 참조 데이터를 코드 형식으로 저장하는 방식은 마이크로서비스 아키텍처를 설계하는 과정에서 여러 차례 적용해왔다.  

물론 특별한 이유가 없는 경우라면 중복을 피하는 편이 좋으므로, 데이터를 원하는 서비스에서 정적으로 링크할 수 있는 라이브러리에 데이터 배치를 고려해야 한다. 미국의 패션 소매없체인 스티치 픽스(Stitch Fix)는 종종 이와 같은 공유 라이브러리를 사용해 정적 참조 데이터를 저장한다.  

스티치 픽스의 엔지니어링 부사장인 랜디 슈프(Randy Shoup)는 분량이 작고, 드물게 혹은 전혀 변경되지 않는(만일 변경이 일어난다면 변경에 대한 전면적인 경고에 직면할 것이다) 데이터 유형에 이 기법이 최고라고 말했다. 일반적인 XS, S, M, L, XL 분류나, 바지를 안쪽 솔기 길이로 표시하는 전통적인 의류 사이즈를 생각해보자.  

국가 코드 매핑을 Country 열거형으로 정의하고 이를 서비스에 사용할 수 있게 라이브러리에 묶는다.  

이것은 깔끔한 해법이지만 단점이 없지는 않다. 기술 스택이 혼합되어 있으면, 분명히 단일 프로그래밍 언어로 작성된 공유 라이브러리를 공유하기 어려울 것이다. 또한 마이크로서비스의 황금률을 기억하는가? 마이크로서비스를 독립적으로 배포하도록 보증할 필요가 있다. 국가 코드 라이브러리를 업데이트하고 모든 서비스가 새 데이터를 즉시 가져올 필요가 있다면, 새 라이브러리를 사용할 수 있는 시점에 모든 서비스를 재배포해야 할 것이다. 이것은 고전적인 '보조를 맞춘 릴리스(lock-step release)'이며, 마이크로서비스 아키텍처에서 반드시 피하고자 하는 방식이다.  

실제로, 모든 곳에서 동일한 데이터를 사용해야 할 경우, 변경사항에 대한 충분한 통지가 도움이 될 수도 있다. 랜디가 든 예는 스티치 픽스의 데이터 집합 중 하나에 새로운 생상을 추가해야 할 필요성이었다. 이러한 변경사항은 이 데이터 유형을 사용하는 모든 서비스에 적용해야 했지만 모든 팀이 최신 버전을 사용하도록 보장하려면 상당한 시간이 필요했다. 다시 한번 국가 코드의 예를 들면, 새 국가를 추가해야 할 경우라면 사전 통지에 충분한 여유가 있다. 예륻 들어, 남수단은 국민투표를 마치고 난 뒤 6개월 후 2011년 7월에 독립국이 되었으며, 대응할 시간은 충분했다. 즉흥적으로 새로운 국가가 수립되는 경우는 거의 없다!  

마이크로서비스가 공유 라이브러리를 사용하는 경우, 운영 환경에 다른 버전의 라이브러리가 배포되어 있을지도 모른다는 사실을 기억하자!  

즉 국가 코드 라이브러리를 업데이트할 필요가 있는 경우, 모든 마이크로서비스에 항상 동일 버전의 라이브러리를 배포한 상태를 유지하기 어렵다는 사실을 받아들여야 함을 의미한다. 이런 방식이 적합하지 않다면, 아마도 다음에 설명할 선택지가 도움이 될 것이다.  

이 패턴의 단순한 변형에서, 문제의 참조 데이터는 구성 파일, 아마도 표준 속성 파일 또는 필요한 경우에는 더 구조화된 JSON 형식으로 유지된다.  

+ 적용 대상  
서비스맏 데이터의 다른 버전을 사용해도 되는 소량의 데이터인 경우, 이 선택지는 훌륭하지만 종종 간과되기도 한다. 어떤 서비스에 어떤 버전의 데이터가 있는지에 대한 가시성이 특히 유용하다.  

###### 4.14.4.4. 패턴: 정적 참조 데이터 서비스  
<br/>

이게 끝이 보이기 시작했다. 마이크로서비스 구현에 대한 책인 만큼 국가 코드만을 위한 전담 서비스를 만들어보면 어떨까?  

전 세계 각지의 그룹과 함께 꼼꼼하게 이 시나리오를 살펴본 결과 양쪽으로 나뉘는 경향이 있었다. 바로 "동작하겠네!" 라고 생각하는 사람들도 있지만, 대체로 대다수의 사람들은 머리를 흔들면서 "미쳤구만!" 이라는 말을 내뱉으며 투덜거리기 시작할 것이다. 더 깊숙하게 파고들다 보면, 이런 방식은 작업량이 많으며 큰 이점을 얻지 못한 상태로 잠재적으로 복잡성만 더해지는 듯이 보인다는 핵심적인 우려사항에 도달한다. 여기서 '과잉'이라는 단어가 자주 등장한다!  

이 부분을 조금 더 살펴보자. 사람들과 이야기를 나누면서 왜 이 선택지를 좋아하는 사람들이 있는 반면, 다른 사람들은 그렇지 않은지를 이해하려고 노력해보면, 일반적으로 가능성은 몇 가지로 좁혀진다. 마이크로서비스 운영 수준이 낮은 환경에서 일하는 사람들은 이 선택지를 몇 가지로 좁혀진다. 마이크로서비스 운영 수준이 낮은 환경에서 일하는 사람들은 이 선택지를 고려할 가능성이 훨씬 더 높다. 반면에 이와 같이 간단한 사례인 경우에도, 새로운 서비스를 만드느라 며칠 또는 몇 주간의 작업이 소요된다면 사람들은 당연히 주저할 것이다.  

키예프 모리스(Kief Morris)는 영국 소재의 대규모 국제은행 프로젝트에서 겪은 자신의 경험을 내게 털어놨다. 당시 프로젝트에서는 몇몇 소프트웨어의 최초 릴리스에 대한 승인을 얻는 과정에 거의 1년이 걸렸다. 10개가 넘는 은행 사내 팀은 설계를 승인하는 단계부터 배포를 위한 컴퓨터 프로비저닝에 이르기까지 모든 것이 서비스되기 전에 먼저 컨설팅부터 받아야 했다. 불행히도 이런 경험은 대규모 조직에서 흔히 찾아볼 수 있다.  

새로운 소프트웨어를 배포하려면, 많은 수작업과 승인이 필요하며, 심지어 새로운 하드웨어의 조달과 구성이 필요한 조직에서 특정 서비스를 만들기 위한 내재적인 비용 또한 상당하다. 따라서, 이런 환경에서 새로운 서비스를 만들려면 매우 신중해야 하며, 추가 작업을 정당화하려면 많은 가치를 제공해야 한다. 이로 인해 국가 코드 같은 서비스 작성은 정당화하기 어려울 수도 있다. 반면에, 서비스 템플릿을 만들어 하루 안에 운영 환경으로 밀어넣고 모든 작업을 수행할 수 있다면, 이를 실용적인 선택지로 생각할 가능성이 훨씬 더 높다.  

또한 국가 코드 서비스는 애저 클라우드 펑션(Azure Cloud Functions) 또는 AWS 람다(Lambda) 같은 서비스형 함수(FaaS, Function-as-a-Service) 플랫폼 제품에 더욱 적합하다. 서비스형 함수에 드는 저렴한 운영 비용은 매력적이며, 국가 코드 서비스 같은 간단한 서비스에 아주 적합하다.  

국가 코드를 위한 서비스를 추가함으로써 대기 시간에 영향을 줄 수 있는 또 다른 네트워크 종속성이 늘어난다는 우려도 있을 것이다. 이와 같은 접근 방식은 이 정보에 대한 전용 데이터베이스를 보유하는 경우보다 나쁘지 않으며, 더 빠를지도 모른다. 왜 그럴까? 이미 설명했듯이 이 데이터 집합 항목은 249개뿐이다. 우리의 국가 코드 서비스는 이런 레코드를 코드 내부에 저장하며 영속적인 데이터 저장소는 필요하지 않다.  

물론 이 데이터는 클라이언트 쪽에서 적극적으로 캐시도 가능하다. 결국 이 데이터에 새로운 항목을 자주 추가하지는 않는다! 또한 이벤트를 사용해 컨슈머에게 이 데이터가 변경된 시점을 알리는 방식도 고려할 수 있다. 데이터가 변경될 때, 관심있는 컨슈머에게 이벤트를 통해 경고하고 이를 사용해 로컬 캐시를 업데이트할 수 있다. 낮은 변경 빈도로 인해 이 시나리오에서는 전통적인 TTL 기반의 클라이언트 캐시만으로 충분하리라는 생각도 들지만, 몇 년 전 범용 참조 데이터 서비스를 대상으로 이벤트와 유사한 접근 방식을 사용해 훌륭한 효과를 얻은 적이 있다.  

+ 적용 대상  
코드에서 데이터 자체의 수명주기를 관리할 경우에는 이 선택지가 적합하다. 예를 들어 데이터를 업데이트하기 위한 API를 외부에 공개하려면, 해당 코드를 운영할 수 있는 장소가 필요하며 이를 전용 마이크로서비스에 넣는 방식이 합리적이다. 이 시점에서 상태관리 목적의 상태 머신을 포함하는 마이크로서비스가 있다. 또한 정적 참조 데이터 서비스는 데이터가 변경될 때 이벤트를 생성하거나 또는 테스트 목적으로 끼워 넣기 위한 더 편리한 연결점을 제공하기를 원하는 경우에도 적절하다.  

결국 여기서 주요 이슈는 또 다른 마이크로서비스를 만드는 비용 문제가 될 듯하다. 작업을 정당화할 만큼 비용이 적절할까? 아니면 다른 접근 방법 중에서 선택하는 게 합리적일까?  

###### 4.14.4.5. 어떻게 해야 할까?  
<br/>

지금까지 여러 가지 선택지에 대해 이야기했다. 그래서 어떻게 해야 할까? 결단을 내리지 않은 채 모호한 태도를 취할 수는 없을 테니, 이렇게 해보면 어떨까? 국가 코드가 모든 서비스에서 항상 일관성을 유지할 필요가 없다면, 이 정보를 공유 라이브러리에 보관할 것 같다. 이런 종류의 데이터의 경우, 로컬 서비스 스키마에서 데이터를 복제하는 방식보다 공유 라이브러리가 훨씬 더 합리적으로 보인다. 이런 유형의 데이터는 본질적으로 단순하고 크기도 작다(국가코드, 의류 사이즈 등). 참조 데이터가 복잡하거나 더 클 경우에는 각 서비스의 로컬 데이터베이스에 이를 넣어두는 방식이 도움이 될지도 모른다.  

데이터가 서비스 간에 일관성을 유지해야 하는 경우라면, 전용 서비스를 만들거나 또는 더 큰 범위의 정적 참조 서비스의 일부로 이 데이터를 제공하는 방법을 모색할 것이다. 새 서비스의 생성 작업을 정당화하기 어려운 경우에만 이런 종류의 데이터에 대한 전용 스키마에 의지하는 방식을 따를 것이다.  

#### 4.15. 트랜잭션  
<br/>

앞서 데이터베이스를 분리할 때 발생할 수 있는 몇 가지 문제를 이미 다뤘다. 참조 무결성 유지는 문제가 많으며, 대기 시간이 길어질 수 있고, 리포팅과 같은 활동을 더욱 복잡하게 만들 수 있다. 이와 같은 몇 가지 과제에 대한 다양한 대처 패턴을 살펴봤지만, 난제가 하나 남아 있다. 트랜잭션(transaction)은 어떨까?  

트랜잭션에서 데이터베이스를 변경할 수 있는 기능은 시스템을 훨씬 더 쉽게 추론하게 만들기 때문에 개발과 유지 관리가 쉬워질 수 있다. 데이터의 안정성과 일관성 보장은 데이터베이스에 맡기고 다른 문제를 살펴보면 된다. 그러나 여러 데이터베이스로 데이터를 분할하면, 원자적인 방식으로 상태 변화를 적용하기 위해 데이터베이스 트랜잭션을 사용하는 이점이 사라진다.  

이 문제를 해결하는 방법을 모색해보기 앞서, 일반적인 데이터베이스 트랜잭션이 어떤 기능을 제공하는지부터 간단히 살펴보자.  

##### 4.15.1. ACID 트랜잭션  
<br/>

일반적으로 데이터베이스 트랜잭션에 대해 이야기할 때는, ACID 트랜잭션이 주인공이다. ACID는 데이터 저장소의 내구성과 일관성을 보장하기 위해 신뢰할 수 있는 시스템으로 이끄는 데이터베이스 트랜잭션의 주요 속성을 개괄하는 약어다. ACID는 원자성(Atomicity), 일관성(Consistency), 격리(Isoloation), 내구성(Durability)을 의미하는 약어로서, 각 속성이 제공하는 특징은 다음과 같다.  

+ 원자성  
트랜잭션 내에서는 모든 연산이 모두 완료되거나 모두 실패하거나 둘 중 한 가지 상태를 보증한다. 어떤 이유로든 시도하는 변경 내역이 실패하면 전체 연산은 중단되고 마치 아무런 변경사항도 없는 것처럼 보인다.  

+ 일관성  
데이터베이스가 변경되면, 유효하며 일관된 상태로 유지된다.  

+ 격리  
여러 트랜잭션이 간섭 없이 동시에 작동할 수 있다. 이는 어떤 트랜잭션 중에 이뤄진 모든 중간 상태 변경이 다른 트랜잭션에 보이지 않게 하는 방법으로 달성한다.  

+ 내구성  
일단 트랜재션이 완료되고 나면 시스템 오류가 발생하는 상황에서도 데이터가 손실되지 않는다고 보장한다.  

모든 데이터베이스가 ACID 트랜잭션을 제공하지는 않는다는 사실을 주목해야 한다. 지금까지 사용한 모든 관계형 데이터베이스 시스템과 네오포제이(Neo4j) 같은 최신 NoSQL 데이터베이스만 ACID 트랜잭션을 지원한다. 수년 동안 몽고DB는 단일 문서(document)에 대한 ACID 트랜잭션만 지원했기에, 문서를 둘 이상 원자적으로 업데이트하고 싶은 경우에는 문제가 일어날 수 있다. 버전 4.0에서 다중 문서 ACID 트랜잭션을 지원하도록 변경되었다.  

ACID 개념에 대해 자세하고 심도 있게 다루지는 않기에 간단히 정리했다. 다른 속성들이 중요하지 않다는 것은 아니지만 원자성은 트랜잭션 경계를 분리할 때 가장 먼저 겪게 될 문제일 가능성이 높다.  

##### 4.15.2. 여전히 ACID이지만 원자성이 부족한가?  
<br/>

데이터베이스를 분리할 때 ACID 방식의 트랜잭션은 여전히 사용 가능하지만, 이런 트랜잭션의 범위나 유용성은 줄어들었다는 점을 분명히 밝혀둔다. 시스템에 새로운 고객을 합류시키는 프로세스를 추적하고 있다. 고객 상태를 보류 중(PENDING)에서 확인됨(VERIFIED)으로 변경하는 프로세스를 거의 마무리지었다. 이제 등록이 완료되면 등록대기 테이블에서 일치하는 행을 제거하는 일도 해야 한다. 단일 데이터베이스를 사용하면 단일 ACID 데이터베이스 트랜잭션 범위에서 이런 작업을 수행한다. 즉 새로운 행이 추가되거나 추가되지 않거나 둘 중 하나다.  

정확히 동일한 변경을 수행하지만 이제는 각기 다른 데이터베이스에서 변경된다. 이는 고려해야 할 트랜잭션이 두 가지로 늘었다는 사실을 의미하며, 각 트랜잭션은 서로 독립적으로 작동하거나 실패할 수 있다.  

물론 고객 테이블에서 행을 변경할 수 있는 경우에만 등록대기 테이블에서 행을 제거해 두 트랜잭션을 연이어 수행하기로 결정할 수 있다. 그러나 등록대기 테이블에서 삭제가 실패할 경우 무엇을 수행할지, 즉 구현할 필요가 있는 모든 로직에 대해서도 추론해봐야 한다. 그러나 이런 사용 사례를 처리하기 위해 단계를 재정렬한다는 아이디어는 정말 유용할 수 있다. 그러나 근본적으로는 이 연산을 분리된 데이터베이스 트랜잭션 2개로 분해함으로써 연산에서 전반적으로 보장된 원자성을 잃어버렸다는 사실을 받아들여야 한다.  

원자성이 부족하면 특히 직전에 이 속성에 의존했던 시스템을 마이그레이션하는 경우 심각한 문제가 발생하기 시작할 수 있다. 이 시점에서 사람들은 한 번에 일어난 여러 서비스에 대한 변경사항을 추론하기 위한 다른 해법을 찾기 시작한다. 일반적으로 사람들이 고려하는 첫 번째 선택지는 분산 트랜잭션이다. 분산 트랜잭션과 관련된 문제를 전반적으로 개괄하기 위해 분산 트랜잭션을 구현하는 가장 일반적인 알고리즘 중 하나인 2단계 커밋을 살펴보자.  

##### 4.15.3. 2단계 커밋  
<br/>

2단계 커밋(Two-Phase Commit) 알고리즘(2PC라고도 부름)은 분산 시스템에서 트랜잭션 변경을 수행할 수 있는 기능을 제공하려는 경우에 주로 사용되며, 이 경우 전체 연산의 일부로 여러 개별 프로세스를 업데이트해야 할 수도 있다. 2PC에는 제한 사항이 있다는 사실을 이해하기 바라며, 나중에 설명하겠지만 그럼에도 2PC를 알아야 할 가치는 충분하다. 분산 트랜잭션, 그리고 더 구제적으로 2단계 커밋은 마이크로서비스 아키텍처로 전환하는 팀이 자신들이 직면한 문제를 해결하는 방법으로 자주 언급한다. 그러나 앞으로 살펴볼 것이지만 2단계 커밋은 문제를 해결하지 못할 수도 있으며, 심지어 시스템에 더 많은 혼란을 가져올지도 모른다.  

2PC 알고리즘은 투표(voting) 단계와 커밋(commit) 단계라도 두 단계(그래서 2단계 커밋업)로 나뉜다. 투표 단계에서 중앙 코디네이터(coordinator)는 트랜잭션에 참가할 모든 워커에게 연락하고 일부 상태 변경이 가능한지 여부를 확인하도록 요청한다. 2가지 요청이 있는데, 하나는 고객 상태를 확인됨(VERIFIED)으로 변경하는 요청이고, 다른 하나는 등록대기 테이블에서 행을 제거하라는 요청이다. 모든 워커가 요청받은 상태 ㅂ녀경이 가능하다고 동의하면, 알고리즘은 다음 단계로 넘어간다. 어떤 워커라도 요청받은 상태 변경이 일부 내부 조건을 위반해 변경을 수횅할 수 없다고 말하면, 전체 연산은 중단된다.  

워커가 변경할 수 있다고 알려준 직후에 변경사항이 즉시 적용되지는 않는다는 사실이 중요하다. 즉시 적용하는 대신, 워커는 미래 어느 시점에서 그 변경을 수행할 수 있음을 보증하고 있다. 워커는 어떻게 수행을 보증할까? 예를 들어, 워크 A는 고객 테이블의 행 상태를 변경해 특정 고객의 상태를 확인됨(VERIFIED)으로 업데이트할 수 있다고 말했다. 이후 어느 시점에 다른 연산이 행을 삭제하거나 또 다른 더 작은 변경을 수행하는 과정에서, 확인됨(VERIFIED)으로 변경한 내역이 나중에 유효하지 않게 되면 어떻게 해야 할까? 이와 같은 변경을 나중에 수행할 수 있도록 보증하기 위해, 워커 A는 이런 변경이 일어나지 않도록 방어할 목적으로 아마도 해당 레코드를 잠가야 할 것이다.  

커밋을 위해 투표하지 않은 워커가 있는 경우, 모든 워커에게 롤백 메시지를 보내 로컬에서 정리할 수 있도록 보장해 워커가 이미 잡고 있을지도 모르는 잠금을 해제하게 만들어야 한다. 모든 워커가 변경에 동의한 경우, 커밋 단계로 이동한다. 여기서 실제로 변경이 일어나고 관련된 잠금은 해제된다.  

이런 시스템에서 두 커밋이 정확히 동시에 발생할 것이라는 보장은 어떤 식으로도 불가능하다는 사실에 주목하자. 코디네이터는 커밋 요청을 모든 워커에게 보내야 하며, 해당 메시지는 다른 시간에 도착해 처리할 수도 있다. 이는 트랜잭션 코디네이터 외부에서 두 워커의 상태를 보지 못할 수도 있음을 의미한다. 코디네이터 사이의 대기 시간이 길수록 그리고 워커가 응답을 처리하는 속도가 느릴수록, 불일치 구간은 더 커질지도 모른다. ACID의 정의로 돌아가보면, 격리는 트랜잭션 중에 중간 상태를 볼 수 없게 보장한다. 그러나 2단계 커밋 때문에 격리라는 속성이 사라져버렸다.  

2단계 커밋이 작동할 때, 내부에서 분산 잠금을 조정하는 경우가 상당히 잦다. 워커는 커밋이 2번째 단계에서 이뤄질 수 있도록 로컬 자원을 잠글 필요가 있다. 단일 프로세스 시스템에서 잠금을 관리하고 교착 상태를 피하는 작업조차도 재미있지 않다. 이제 여러 워커 간에 잠금을 조정해야 하는 문제를 상상해보자. 재미는 커녕 머리가 아프다.  

여기서 자세히 설명하지는 않겠지만, 2단계 커밋과 관련된 여러 가지 실패 모드가 있다. 트랜잭션을 진행하기 위해 투표를 했지만 나중에 커밋을 요청할 때 응답하지 않는 워커 문제를 생각해보자. 이런 경우 어떻게 해야 할까? 이런 실패 모드 중 일부는 자동으로 처리될 수 있지만, 몇몇은 시스템을 어중간한 상태로 만들 수 있기에 수동으로 선택을 해제해야 한다.  

워커가 많을수록 그리고 시스템에서 대기 시간이 길수록, 2단계 커밋에 더 많은 문제가 발생한다. 특히 잠금 범위가 크거나 트랜잭션 지속 시간이 큰 경우, 2단계 커밋은 시스템에 엄청난 대기 시간을 유발하는 장본인이 된다. 이런 이유로 2단계 커밋은 일반적으로 수명이 매우 짧은 연산에만 사용된다. 연산에 들어가는 시간이 길수록 자원을 더 오래 잠가둬야 한다!  

##### 4.15.4. 분산 트랜잭션? 그냥 아니라고 말하자  
<br/>

지금까지 개괄한 모든 이유로 인해, 마이크로서비스 전반에 걸친 상태 변화를 조정하기 위한 2단계 커밋 등의 분산 트랜잭션은 피할 것을 강력히 제안한다. 그렇다면 대안은 무엇일까?  

첫 번째 선택지는 처음부터 데이터를 분리하지 않는 방법이다. 진짜 원자적이고 일관된 방식으로 관리하려는 상태 조각이 있고 ACID 스타일의 트랜잭션 없이 이런 특질(functionality)을 현명하게 얻는 방법을 찾지 못할 경우, 해당 상태를 단일 데이터베이스에 남겨두고 단일 서비스(또는 모놀리스)에서 해당 상태를 관리하는 기능도 그대로 남겨두자. 모놀리스를 어디서 분할해야 할지, 그리고 어떤 분해 작업이 쉬울지(또는 어려울지)를 찾는 과정이라면, 현재 관리되는 데이터를 트랜잭션에서 분리하는 작업이 지금 당장은 너무 어렵다는 판단을 내릴 수도 있다. 시스템의 다른 영역부터 작업한 다음, 나중에 다시 돌아오자.  

그러나 정말로 이 데이터를 분해해야 하지만, 분산 트랜잭션 관리의 모든 고통을 원하지 않으면 어떻게 해야 할까? 여러 서비스에서 작업을 수행하지만 잠금을 피할 수 있는 방법은 무엇일까? 작업에 몇 분, 며칠, 심지어 몇 달이 걸리는 경우에는 어떻게 해야 할까? 이와 같은 경우에 우리는 사가(Saga)라는 대안을 고려할 수 있다.  

#### 4.16. 사가 패턴  
<br/>

2단계 커밋과 달리 사가는 설계상 상태의 여러 변경사항을 조정할 수 있지만, 자원을 장기간 잠글 필요는 없는 알고리즘이다. 우리는 독립적으로 실행할 수 있는 개별 활동과 관련 단계를 모델링하는 방법으로 작업을 수행한다. 사가는 비즈니스 프로세스를 명시적으로 모델링하도록 강제하는 꽤 중요한 이점도 추가로 제공한다.  

헥터 가르시아몰리나와 케네스 세일럼은 긴 연산을 처리하는 최선의 방법인 LLT(Long Lived Transaction, 수명이 긴 트랜잭션)라고 부르는 도전 과제에 대한 해법을 제시했다. 트랜잭션은 실행 과정에서 긴 시간(몇 분, 몇 시간 또는 며칠)이 걸릴 수 있으며 해당 프로세스의 일부로 데이터베이스의 변경이 필요하다.  

LLT를 일반 데이터베이스 트랜잭션에 직접 매핑할 경우, 단일 데이터베이스 트랜잭션은 LLT의 전체 수명주기 동안 이어질 것이다. 이로 인해 LLT가 발생하는 동안 여러 행 또는 심지어 전체 테이블이 오랫동안 잠길 수도 있으며 다른 프로세스가 이런 잠긴 자원을 읽거나 수정하려면 심각한 문제가 발생할 수 있다.  

대신, 이 논문을 작성한 저자들은 이런 LLT를 일련의 트랜잭션으로 분해하면 각 트랜잭션을 독립적으로 처리할 수 있다고 제안한다. 이와 같은 각 '하위' 트랜잭션의 수명은 더 짧아지고, 그 과정에서 전체 LLT의 영향을 받는 데이터의 일부만 수정할 것이라는 내용이다. 결과적으로 잠금 범위와 지속 시간이 크게 줄어들기 때문에 기반 데이터베이스에서의 경합은 훨씬 덜할 것이다.  

사가는 원래 단일 데이터베이스에 대해 작동하는 LLT를 지원하기 위한 메커니즘으로 구상되었지만, 여러 서비스에 걸친 변경을 조정할 경우에도 효과적이다. 단일 비즈니스 프로세스는 단일 사가의 일부로서 협업 서비스에 대한 일련의 호출로 분해할 수 있다.  

좀 더 살펴보기 전에, 여기서 사가는 일반적인 데이터베이스 트랜잭션에서 익숙한 ACID 관점의 원자성을 제공하지 않는다는 사실을 이해해둬야 한다. LLT를 개별 트랜잭션으로 분해하면, 사가 자체의 수준에서 원자성은 없다. 필요한 경우 각 하위 트랜잭션을 ACID 트랜잭션 변경과 연관지을 수 있기 때문에, LLT 내부의 개별 하위 트랜잭션에는 원자성을 보장할 수 있다. 사가가 제공하는 것은 그것이 어떤 상태에 있는지 추론할 수 있는 만큼의 정보며, 이 정보의 의미를 처리하는 책임은 우리에게 놓여 있다.  

이제 마이크로서비스 아키텍처라는 컨텍스트에서 사가를 깊이 알아보기 위해 간단한 주문 처리 흐름을 살펴보자.  

주문 처리 프로세스는 다른 서비스가 수행할 수 있는 연산을 표현하는 흐름의 각 단계로서 단일 사가를 대표한다. 각 서비스 내부의 모든 상태 변경은 로컬 ACID 트랜잭션 내에서 처리될 수 있다. 예를 들어 창고 서비스를 사용해 재고를 확인하고 예약(reservation)하는 경우, 창고 서비스는 내부적으로 예약 상황을 기록하는 로컬 예약 테이블에 행을 만들 것이다. 이런 변경은 일반 트랜잭션 내에서 처리될 것이다.  

##### 4.16.1. 사가 실패 모드  
<br/>

사가를 개별 트랜잭션으로 분해하려면, 장애 처리 방법, 특히 더 구체적으로 장애 발생시의 복구 방법을 고려해둬야 한다. 앞서 기술한 「사가」라는 첫 논문에는 역방향 복구(backward recovery)와 정방향 복구(forward recovery)라는 2가지 복구 유형이 기술되어 있다.  

역방향 복구에는 장애 복구와 이후에 일어나는 정리 작업인 롤백이 포함된다. 이와 같은 작업을 위해서는, 이전에 커밋된 트랜잭션을 취소할 수 있는 보상 조치를 정의해둬야 한다. 정방향 복구는 오류가 발생한 지점에서 데이터를 가져와 계속 처리할 수 있다. 이런 작업을 위해, 트랜잭션을 재시도할 필요가 있으며, 이는 시스템이 재시도를 위한 충분한 정보를 지속적으로 제공함을 의미한다.  

모델링 대상 비즈니스 프로세스의 특성에 따라, 실패 모드에서 역방향 복구나 정방향 복구, 2가지를 혼합하는 상황을 고려할 수도 있다.  

###### 4.16.1.1. 사가 롤백  
<br/>

ACID 트랜잭션을 사용하면 커밋에 앞서 롤백이 발생한다. 롤백 후에는 마치 아무것도 일어나지 않은 상황이 된다. 즉 시도하려 했던 변경은 일어나지 않았다. 그러나 사가에는 관련된 여러 트랜잭션이 있으며, 몇몇 트랜잭션은 전체 연산을 롤백하기로 결정하기 전에 이미 커밋되었을지도 모른다. 그렇다면 트랜잭션이 이미 커밋된 후에 어떻게 트랜잭션을 롤백할 수 있을까?  

주문 처리의 예로 돌아가서, 잠재적인 실패 모드를 고려해보자. 물품 포장을 시도했지만 창고에서 물품을 찾을 수 없었다. 시스템은 그 물품이 존재한다고 생각하지만, 창고 선반 어디에도 물품은 없다!  

이제 고객에게 물품을 이월 주문하도록 선택지를 제공하는 대신, 전체 주문을 되돌리기로 결정했다고 가정하자. 여기서 이미 결제를 완료한 고객에게 해당 주문에 대한 멤버쉽 포인트를 부여했다는 문제가 있다.  

이 모든 단계가 단일 데이터베이스 트랜잭션에서 수행된 경우라면, 간단한 롤백으로 모든 처리 과정을 정리할 수 있다. 그러나 주문 처리 프로세스의 각 단계는 다양한 트랜잭션 범위에서 운영되는 각 서비스 요청으로 처리되었다. 전체 연산을 한 번에 되돌릴 간단한 '롤백'은 없다.  

차라리, 롤백 구현을 원한다면 보상 트랜잭션을 구현해야 한다. 보상 트랜잭션은 이전에 커밋된 트랜잭션을 취소하는 연산이다. 주문 처리 과정을 롤백하려면, 이미 커밋된 사가에서 각 단계에 대한 보상 트랜잭션을 일으킬 것이다.  

이런 보상 트랜잭션은 일반적인 데이터베이스 롤백과 정확히 동일한 동작을 수행할 수 없다는 사실이 매우 중요하다. 데이터베이스 롤백은 커밋 전에 발생하며, 롤백 후에는 트랜잭션이 전혀 발생하지 않은 듯이 취급할 수 있다. 물론 사가 패턴을 적용한 상황에서는 이미 트랜잭션이 발생했다. 여기서 원래 트랜잭션이 반든 변경을 되돌리는 새로운 트랜잭션을 만들고 있지만, 시간을 롤백해 원래 트랜잭션이 전혀 일어나지 않은 것처럼 만들 수는 없다.  

트랜잭션을 항상 깔끔하게 롤백할 수는 없기 때문에, 이런 보상 트랜잭션을 일리 의미론적인(semantic) 롤백이라고 말한다. 항상 모든 것을 정리할 수는 없지만, 사가의 컨텍스트 내에서는 충분한 작업을 할 수 있다. 예를 들어 주문 처리 단계 중 하나는 주문이 진행 중임을 알리기 위해 고객에게 이메일을 보내는 것과 비슷하다 할 수 있다. 롤백하기로  결정한다 해도 전송된 이메일은 취소할 수 없다! 그 대신, 보상 트랜잭션은 고객에게 두 번째 이메일을 발송해서, 문제가 생겨 주문이 취소되었음을 알릴 수는 있다.  

롤백 사가와 관련된 정보를 시스템에 영속적으로 유지하는 방식은 전적으로 적절하다. 실제로 이 정보는 매우 중요할지도 모른다. 여러 가지 이유로 무엇이 발생했는지 알려주는 정보와 함께 중단된 주문에 대한 정보를 주문 서비스에 유지하고 싶을 수도 있다.  

###### 4.16.1.2. 롤백을 줄이기 위한 단계 재정렬  
<br/>

단계를 재정렬하는 방법으로 롤백 시나리오를 다소 단순하게 만들 수 있었다. 간단히 변경한다면, 주문이 실제로 발송된 경우에만 포인트를 부여하는 방식이 될 것이다. 이렇게 하면 주문을 포장하고 발송을 준비하는 동안 문제가 발생할 경우, 해당 단계를 롤백하는 과정에서 걱정할 필요가 없을 것이다. 때로는 프로세스 실행 방식을 조율하는 방법만으로도 롤백 연산을 단순화할 수 있다. 실패할 가능성이 가장 높은 단계를 앞에서 진행하고 프로세스가 더 빨리 실패하면, 처음부터 진행되지도 않은 단계에 대해서는 나중에 보상 트랜잭션을 진행할 필요도 없다.  

이런 변경사항을 수용할 수만 있다면 몇몇 단계에 대해서는 보상 트랜잭션을 만들 필요도 없으므로, 일은 훨씬 더 수월해진다. 이는 보상 트랜잭션을 구현하기가 어려운 경우에 특히 중요할 것이다. 프로세스에서 보상이 어려운 단계는 롤백이 전혀 필요하지 않는 후반부로 올겨 놓는 방법도 고려할 수 있다.  

###### 4.16.1.3. 역방향 실패와 정방향 실패 상황의 혼합  
<br/>

장애 복구 모드를 혼합해 사용하는 방식이 전적으로 바람직하다. 롤백이 필요한 실패도 있고, 정방향 실패가 필요한 경우도 있다. 예를 들어 주문 처리 과정에서 고객이 돈을 지불하고 창고에서 물품이 포장되면, 이제 남은 일은 포장된 택배 물품을 발송하는 단계뿐이다. 어떤 이유로 인해 택배 물품을 배송할 수 없는 경우(아마도 오늘자 배송 차량에 해당 물품을 실을 공간이 부족한 경우) 전체 주문을 되돌리는 방식은 매우 이상한 듯이 보인다. 그보다는, 아마도 그저 배송을 재시도할 것이고, 그래도 실패할 경우에는 사람이 개입해서 상황을 해결해야 한다.  

사가 패턴에서 롤백이 복잡한 단계를 뒤쪽으로 이동하면, 실패할 경우 롤백해야 하는 내용을 줄일 수 있다.  

###### 4.16.1.4. 사가 패턴 구현  
<br/>

지금까지 사가가 동작하는 방식에 대한 논리적인 모델을 살펴보았지만, 사가 자체를 구현하는 방식을 알아보기 위해 조금 더 깊이 살펴볼 필요가 있다. 2가지 사가 구현 방식을 살펴볼 것이다. 오케스트레이션 기반 사가(orchestrated saga)는 원래 해법 공간을 밀접하게 따라가며 주오 중앙집중식 조정과 추적에 의존한다. 오케스트레이션 기반 사가는 연출된 사가(choregraphed saga)와 비교할 수 있는데, 연출된 사가는 더 느슨하게 결합된 모델을 선호하므로 중앙집중식 조정이 필요하지 않지만 사가의 진행을 추적하는 작업을 더 복잡하게 만들 수 있다.  

###### 4.16.1.5. 오케스트레이션 기반 사가  
<br/>

오케스트레이션 기반 사가는 중앙 코디네이터(central coordinator)(지금부터 조율자를 의미하는 오케스트레이터(orchestration)라고 부름)를 사용해 실행 순서를 정의하고 필요한 보상 조치를 트리거한다. 오케스트레이션 기반 사가는 명령과 제어방식(command-and-control approach)이라고 생각할 수 있다. 중앙 오케스트레이터는 어던 일이 언제 일어나는지를 제어하며, 이를 통해 사가에서 어떤 일이 일어나는지를 충분히 파악할 수 있다.  

주문 처리 프로세스를 가져와서, 중앙 조정 프로세스가 협업 서비스의 집합으로 어떻게 작동하는지를 살펴보자.  

여기에서 오케스트레이터 역할을 담당하는 중앙 주문 처리기가 주문 처리 프로세스를 조정한다. 중앙 주문 처리기는 연산을 수행하는 데 어떤 서비스가 필요한지를 알고 있으며 언제 해당 서비스를 호출해야 할지를 결정한다. 호출이 실패하면 그 결과에 따라 어떤 작업을 수행할지를 서비스를 호출해야 할지를 결정한다. 호출이 실패하면 그 결과에 따라 어떤 작업을 수행할지를 결정할 수 있다. 이렇게 오케스트레이션 기반의 처리기는 서비스 간 요청/응답 호출을 많이 사용하는 편이다. 즉 주문 처리기는 서비스(예: 지불 게이트웨이)에 요청을 보내고, 요청이 성공했는지 여부를 알려주는 응답을 기대하며 요청 결과를 제공한다.  

주문 처리기 내부에서 비즈니스 프로세스를 명시적으로 모델링해두면 매우 유용하다. 이를 통해 우리는 시스템에서 한곳만 바라봐도 이 프로세스가 어떻게 작동하는지를 이해할 수 있다. 그 결과로, 새로운 사람들을 쉽게 합류시킬 수 있으며 시스템의 핵심 부분을 좀 더 쉽게 이해시킬 수 있다.  

그러나 고려해야 할 몇 가지 단점도 있다. 첫째, 특성상 이는 다소 결합된 접근 방식이다. 주문 처리기는 관련된 모든 서비스에 대해 알아야 하므로, 도메인 결합도를 설명한 내용에 따르면 높은 결합도를 발생시킨다. 본질적으로 이것이 나쁘지는 않지만, 가능하다면 도메인 결합도를 최소로 유지하고 싶을 것이다. 여기서 주문 처리기는 너무 많은 것들에 대해 알고 제어할 필요가 있기 때문에 이런 형태의 높은 결합도를 회피하기가 상당히 까다로울 것이다.  

서비스에 적용되어야 하는 로직이 오케스트레이터에 홀수되기 시작한다는 문제가 더 미묘하다. 이런 상황이 발생하기 시작하면, 서비스는 주문 처리가 등의 오케스트레이터로부터 주문만 받으며 자신의 행동은 거의 하지 않는 무기력한 상태에 이를 수 있다. 이렇게 오케스트레이션 기반으로 흐름을 구성하는 서비스는 고유한 로컬 상태와 동작을 보유한 엔티티로 간주해야 한다. 엔티티는 독자적인 로컬 상태 머신을 담당한다.  

오케스트레이션 기반의 흐름으로 너무 많은 중앙집중화를 피하는 방법 중 하나는 각 흐름에 대해 오케스트레이터 역할을 수행하는 개별 서비스들을 만드는 것이다. 주문 처리를 담당하는 주문 처리 서비스, 반품과 환불 프로세스를 담당하는 반품 서비스, 창고에 도착해 선반에 놓이는 새로운 재고를 처리하는 입고 서비스 등이 있을 것이다. 창고 서비스 등은 모든 오케스트레이터가 사용할 수도 있다. 이런 모델은 모든 흐름에 걸쳐 기능의 재사용을 허용하므로, 창고 서비스 자체에서 기능을 유지하는 작업이 수월해진다.  

###### 4.16.1.6. 비즈니스 프로세스 모델링(BPM) 도구?  
<br/>

비즈니스 프로세스 모델링(BPM, Business Process Modeling) 도구는 여러 해 동안 사용되어 왔다. 대체로 BPM 도구는 비개발자가 드래그앤드롭 류의 GUI 도구를 사용해 비즈니스 프로세스 흐름을 정의하도록 설계되었다. 개발자가 단위 프로세스의 빌딩 블록을 만든 다음, 다른 비개발자는 이런 빌딩 블록을 더 큰 프로세스 흐름에 연결하는 방식으로 이뤄진다. BPM 도구의 사용은 오케스트레이션 기반 사가를 구현하는 수단으로 정말 잘 어울리는 듯하며, 실제로도 프로세스의 오케스트레이션화는 BPM 도구의 주요 사용 사례이기도 하다(또는 반대로, BPM 도구를 사용하면 반드시 오케스트레이션화를 채택해야 한느 결과를 낳기도 한다).  

경험상, BPM 도구를 매우 싫어하게 됐다. 주된 이유는, 비개발자가 비즈니스 프로세스를 정의할 수 있다는 BPM 도구 업체의 떵떵거림은 실제로 겪어 보니 거의 대부분 사실이 아니었기 때문이다. 비개발자를 대상으로 하는 도구는 결국 개발자가 사용하게 되며 많은 문제가 발생하기도 한다. 워크플로우를 변경하기 위해 GUI를 요구하는 경우가 많으며, 이렇게 만들어진 워크플로우는 버전 제어가 어렵거나 불가능할 수도 있으며, 그 워크플로우 자체가 테스트를 염두에 두고 설계되지 않은 경우도 있다.  

개발자가 비즈니스 프로세스를 구현하려 한다면, 워크플로우를 이해하고 워크플로우에 있는 도구를 만들자. 일반적으로 이는 코드를 사용해 워크플로우를 구현하는 방식을 의미한다. 비즈니스 프로세스가 어떻게 구현되는지 또는 어떻게 운영되는지 가시적으로 보여줘야 한다면, 코드 동작을 기술한 목적으로 워크플로우를 시각화한 결과를 사용하기보다는 코드에서 워크플로우의 시가적인 표현을 끌어내는 편이 훨씬 더 쉽다.  

좀 더 개발자 친화적인 BPM 도구를 만들려는 시도가 있다. 개발자로부터 이런 도구에 대한 피드백을 받아보면 의견은 분분하지만 만족해 하는 개발자들도 있으며, 이와 같은 프레임워크를 개선하려고 시도하는 사람들을 지켜보면 기분이 좋다, 이런 도구에 대해 더 자세히 살펴보고 싶은 분들께 카문다(https://camunda.com/)와 지비(https://zeebe.io/)를 추천한다. 둘 다 마이크로서비스 개발자를 대상으로하는 오픈소스 오케스트레이션 프레임워크다.  

###### 4.16.1.7. 연출된 사가  
<br/>

연출된 사가(choreographed saga)는 여러 협력 서비스 사이에서 사가 운영에 대한 책임을 분산시키는 것을 목표로 한다. 오케스트레이션 기반 사가가 명령을 제어라면, 연출된 사가는 신뢰하지만 검증된 아키텍처를 나타낸다. 연출된 사가는 종종 서비스 간 협업을 위해 이벤트를 많이 사용한다.  

연출된 사가는 상당히 많이 연구되었기에 자세히 살펴볼 가치가 있다. 먼저, 이런 서비스는 수신되는 이벤트에 반응한다. 개념적으로 이벤트는 시스템에서 브로드캐스트되며 관심 있는 서비스가 이를 수신할 수 있다. 특정 서비스에 이벤트를 보내는 대신 단지 이벤트를 뿌리고, 해당 이벤트에 관심 있는 서비스는 이벤트를 수신해 이에 따라 동작할 수 있다. 우리가 다룬 예에서, 창고 서비스는 받은 주문 이벤트를 수신하면 적절한 재고를 예약하고, 이런 작업을 마치면 창고 서비스는 다시 이벤트를 발생시키는 임무를 알고 있다. 재고를 받을 수 없는 경우, 창고 서비스는 주문을 중단하기 위해 적절한 이벤트(아마도 재고 부족 이벤트인 것이다)를 발생시킨다.  

대체로 안정적인 메시지 브로드캐스트와 이벤트 전달을 관리학 위해 일종의 메시지 브로커를 사용한다. 여러 서비스가 동일한 이벤트에 반응할 수도 있으며, 여기서는 토픽을 사용한다. 특정 유형의 이벤트에 관심이 있는 서비스는 해당 이벤트의 출처에 대해 걱정할 필요 없이 특정 토픽을 구독할 수 있으며 브로커는 해당 토픽의 내구성을 보장하고 해당 토픽의 이벤트가 구독자에게 성공적으로 전달되도록 보장한다. 예를 들어 주문 접수 이벤트를 수신하고 , 이를 사용해 원하는 음반 선택 데이터베이스를 구성하는 추천 서비스를 만들 수도 있다.  

앞서 소개한 아키텍처에서는 모든 서비스가 상태 서비스에 대해 전혀 모른다. 특정 이벤트가 수신될 때 자신이 할 일만 파악하면 된다. 본질적으로 이런 상황은 결합도가 상당히 낮은 아키텍처를 만든다. 주문 처리기를 중심으로 하는 구현이 3가지 서비스(창고, 지불 게이트웨이, 멤버십)로 분해되어 배포되므로 로직의 중앙집중화에 대한 우려도 피할 수 있다(비즈니스 로직을 중아에 모을 수 있는 장소가 없다면 중앙화가 일어나지도 않을 것이다!).  

또 다른 측면은 지금 무슨 일이 일어나고 있는지를 이해하기가 더 어려워질 수 있다는 사실이다. 앞서 오케스트레이션을 사용해서 오케스트레이터(orchestrator)에서 명시적으로 프로세스를 모델링했다. 이제, 앞서 설명한 바와 같이 연출된 아키텍처로, 프로세스에 기대해야 할 멘탈 모델을 어떻게 구성할까? 각 서비스의 동작을 격리해서 살펴보고 머릿속에서 그림을 재구성해야 할 것이다. 이와 같은 간단한 비즈니스 프로세스로도 단순하지만은 않다.  

비즈니스 프로세스를 명시적으로 나타내지 못하는 것도 괴롭지만, 사가가 어떤 상태에 있는지를 파악할 방법도 부족하기 때문에 필요한 경우 보상 조치를 취할 기회조차 허락되지 않을 수도 있다. 보상 조치를 수행하기 위해 개별 서비스에 어느 정도 책임을 부여할 수 있지만, 근본적으로 복구를 위해 사가의 현재 상태를 파악할 방법이 필요하다. 사가의 상태를 둘러볼 수 있는 중심이 되는 서비스가 없다는 점이 큰 문제다. 앞서 오케스트레이션을 도입해 중심이 되는 서비스를 확보했는데, 여기서는 이 문제를 어떻게 해결할 수 있을까?  

이 작업을 수행하는 가장 쉬운 방법 중 하나는 뿌려지는 이벤트를 소비하는 방식으로 기존 시스템에서 사가의 상태에 대한 뷰를 투사하는 것이다. 사가에 대한 고유 ID를 생성하면 이 사기의 일부로 뿌려진 모든 이벤트에 상관관계 ID(correlation ID)라고 알려진 식별자를 넣을 수 있다. 그런 다음 모든 이벤트를 정리하고, 각 주문의 상태에 대한 상태를 표현하고, 다른 서비스가 스스로 수행할 수 없는 경우 처리 프로세스의 일부로 문제를 해결하기 위한 조치를 프로그래밍 방식으로 수행하는 서비스를 만들 수 있다.  

###### 4.16.1.8. 혼합 방식  
<br/>

오케스트레이션 기반 사가와 연출된 사가는 사가의 구현 방식에 있어 정반대의 견해를 취하는듯 보이겠지만, 이 둘을 혼합해서 사용하는 모델을 고려해 볼 수도 있겠다. 각 모델에 좀 더 어울리는 몇 가지 비즈니스 프로세스가 시스템에 존재할 수도 있다. 또한 혼합 방식의 단일 사가가 있을지도 모른다. 예를 들어 주문 처리 사용 사례 경우, 창고 서비스의 경계 내에서 포장과 발송을 관리할 때 원래 요청이 규모가 좀 더 연출된 사가의 일부로 이뤄진 경우에도 오케스트레이션 기반 흐름을 사용할 수도 있다.  

두 모델을 혼합하기로 결정한 경우에도, 사가의 일부로 어떤 일이 일어났는지 이해하기 위한 명확한 방법이 여전히 존재해야 한다. 이것 없이는 실패 모드의 이해가 복잡해지고 실패에서 복구하기도 어려워진다.  

###### 4.16.1.9. 오케스트레이션 기반 사가와 연출된 사가, 둘 중 무엇을 선택해야 할까?  
<br/>

연출된 사가를 구현하면 자신과 팀에 생소한 아이디어가 필요할 수도 있다. 연출된 사가는 일반적으로 널리 알려지지 않은 이벤트 기반 방식의 협업을 많이 사용한다고 가정한다. 그러나 경험에 따르면, 사가의 진행상황 추적과 관련해 생겨나는 보갖ㅂ성은 느슨하게 결합된 아키텍처로 얻는 이점을 상쇄해버린다.  

그러나 개인적인 취향은 차차하고라도, 오케스트레이션 기반 사가와 연출된 사가의 비교에 관한 일반적인 제언은 한 팀이 전체 사가의 구현을 소유할 때 오케스트레이션 기반 사가가 훨씬 더 편안하다는 사실이다. 이런 상황에서, 본질적으로 결합된 아키텍처는 팀 경계 내에서 관리하기가 훨씬 더 쉽다. 여러 팀이 관련된 경우에 분리도가 높은 연출된 사가를 선호한다. 사가 구현에 대한 책임을 팀에 분배하기가 더 쉽기 때문인데, 느슨하게 결합된 아키텍처는 팀이 격리된 상태에서 더 많은 일을 수행하게 만들어준다.  

##### 4.16.2. 사가와 분산 트랜잭션의 비교  
<br/>

지금까지 설명한 대로라면, 분산 트랜잭션에는 몇 가지 중요한 문제가 있으며 매우 구체적인 몇 가지 상황을 제외하면 분산 트랜잭션을 피하는 편이다. 분산 시스템의 개척자인 펫 핼런드(Pat Helland)는 오늘날 구축하는 애플리케이션 유형을 위한 분산 트랜잭션 구현과 관련된 근본적인 문제의 핵심을 다음과 같이 뽑아냈다.  

> 대다수 분산 트랜잭션 시스템에서 단일 노드에 장애가 발생하면 트랜잭션 커밋은 중단된다. 이로 인해 애플리케이션은 쐐기가 박힌 상태가 된다. 이런 시스템에서는 그 크기가 커질수록 시스템이 죽을 가능성도 높아진다. 모든 엔진이 작동해야 하는 비행기를 운항할 때, 엔진을 하나만 추가해도 이 비행기의 가용성은 감소된다.  

경험상 비즈니스 프로세스를 사가로 모델링하면 분산 트랜잭션으로 인한 다양한 문제를 피할 수 있으며, 사가를 사용하지 않을 경우 암시적으로 모델링되어야 하는 프로세스를 개발자 관점에서 더욱 명확하게 만들 수 있는 장점도 따라온다. 시스템의 핵심 비즈니스 프로세스를 내재화하면 많은 이점이 있을 것이다.  

#### 4.17. 정리  
<br/>

서비스 경계(service boundary)가 드러나는 봉합(seam)을 찾아 시스템을 분해하며, 이는 점진적인 접근 방식이 될 수 있다. 이런 봉합을 잘 찾고 처음부터 서비스 분할 비용을 줄이기 위해 노력해야만, 시스템이 계속해서 성장하고 진화하는 과정에서 등장하는 모든 요구사항을 충족할 수 있다. 지금까지 살펴봤듯이 이런 작업은 간혹 힘들 수도 있으며 해결이 필요한 중대한 문제를 일으킬 수 있다. 그러나 점진적으로 수행할 수 있다는 사실은 이 작업을 두려워 할 필요가 없음을 의미한다.  

### 5. 마이크로서비스 도입 과정에서 직면하는 문제와 해법  
<br/>

#### 5.1. 서비스가 늘어날수록 고충도 커지게 마련  
<br/>

마이크로서비스 아키텍처에서 정확히 문제가 발생하는 시점은 여러 요인과 관련이 있다. 서비스 상호작용의 복잡도, 조직의 규모, 서비스의 개수, 다양한 기술의 선택, 대기 시간, 가동 시간 요구사항 등은 고통, 괴로움, 흥분, 스트레스를 유발할 수 있는 일부 요인에 불과하다. 이는 언제 혹은 실제로, 이런 문제에 직면할지를 말하기 어렵다는 사실을 의미한다.  

그러나 일반적으로, 서비스를 10개만 운영하는 회사에서 발생하는 문제 유형은 서비스가 수백 개에 이르는 회사에서 발생하는 문제와는 분명히 차원이 다르다. 서비스 수는 특정 문제가 언제 나타날 가능성이 가장 높은지를 나타내는 좋은 척도로 보인다. 특별히 명시하지 않는 한, 서비스 수에 대해 이야기할 때는 다양한 논리적 서비스를 논한다는 사실을 명시하고자 한다. 이런 서비스가 운영 환경에 배포되면 여러 서비스 인스턴스로 배포될 수 있다.  

마이크로서비스 채택을 마치 스위치를 껐다 켜는 행위라고 생각하기보단, 다이얼을 돌리는 행위로 간주해보자. 다이얼을 돌려서 더 많은 서비스로 나누게 되면 마이크로서비스에서 이점을 얻을 기회도 아마 더 높아질 것이다. 그러나 다이얼을 돌림에 따라 다른 고충점을 만나게 될 것이다. 점차 새로운 사고 방식이나 새로운 기술, 다양한 기법, 즉 아마도 새로운 첨단 기술을 요하는 문제들에 대한 해법을 찾게 될 것이다.  

다음은 서비스가 성장하는 과정에서 문제가 발생할 가능성이 가장 높은 부분에 기반해 고충점을 대략적인 표 형태로 만들었다. 엄청난 과학이 담겨 있지는 않으며 입증되지는 않은 경험에 근거한 것이지만, 개요로서는 유용할 것이다.  

<table>
	<tbody>
		<tr>
			<td class="align-center">
				2~10개의 서비스<br/>
				하나 또는 몇 개 팀
			</td>
			<td class="align-center">
				10~50개의 서비스<br/>
			</td>
			<td class="align-center">
				50개 이상의 서비스<br/>
				더 많은 팀/개발자
			</td>
		</tr>
		<tr>
			<td class="align-center">
				파괴적 변경<br/>
				리포팅
			</td>
			<td class="align-center">
				규모에 맞는 소유권<br/>
				개발자 경험<br/>
				너무 많은 것들을 실행
			</td>
			<td class="align-center">
				전역 최적화와 지역 최적화 비교<br/>
				외톨이 서비스
			</td>
		</tr>
		<tr>
			<td colspan="3">
				← 견고성과 회복탄련성 →
				← 모니터링과 트러블슈팅 →
			</td>
		</tr>
	</tbody>
</table>
<br/><br/>

프로젝트 진행 기간 동안 앞서 제시한 모든 문제를 확실히 목겨하리라고 말하는 것은 아니다. 이와 같은 간단한 표에서 실제로는 분명히 표현할 수 없는 특정 변수가 존재한다. 특히 이런 문제가 갑자기 튀어나올 때 변경될지도 부르는 한 가지 요소는 아키텍처의 결합 방식이다. 결합도가 높은 아키텍처를 사용하면 견고성, 테스트, 추적 등과 관련된 문제가 더 일찍 드러날지도 모른다. 그저 고충점이 숨어 있을지도 모르는 함정에 빛을 비출 뿐이다.  

그러나 이를 일반적인 지표로 사용해야 함을 명심하자. 여기서 설명하는 몇 가지 잠재적인 지표를 찾으려면 피드백 메커니즘을 확실하게 구축해야 한다.  

앞서 표에서 문제점을 경고했으므로 이에 대해 조금 더 자세히 살펴보자. 각 문제에 대해, 어떤 요인이 이런 문제들을 전면에 드러나게 만드는지를 살펴보고, 이런 문제가 어떤 영향을 미칠지, 그리고 이런 문제가 발생할 때 해결하기 위한 몇 가지 지침을 살펴볼 것이다.  

#### 5.2. 규모에 맞는 소유권  
<br/>

마이크로서비스 아키텍처에서 작업하는 개발자 수가 점점 많아질수록, 소유권 관리 방식을 재고해야 할 상황에 부딪힐 것이다.  

마틴 파울러는 일반적인 코드 소유권 관점에서 다양한 유형의 소유권(https://martinfowler.com/build/CodeOwnership.html)을 구분한 바 있으며, 대체로 이런 구분은 마이크로서비스 소유권의 맥락에서도 적용 가능하다. 여기서는 주로 코드 변경 관점에서 소유권을 검토하는 것이지. 배포나 일차적인 지원 등을 누가 처리하는지의 관점에서 소유권을 이야기하는 것이 아니다. 불쑥 튀어나오는 여러 문제에 대해 이야기하기에 앞서, 먼저 파울러가 개괄한 개념을 살펴보고 이를 마이크로서비스 아키텍처 컨텍스트에 적용해보자.  

+ 강한 코드 소유권  
모든 서비스는 각기 소유자가 있다. 소유권 그룹 외부의 누군가가 변경을 원하면, 이를 허용할지 말지를 결정하는 각 소유자에게 해당 변경사항을 제출해야 한다. 소유권 그룹 외부의 사람들을 위한 풀 요청(PR, Pull Request) 사용이 이를 처리하는 방법의 한 예다.  

+ 약한 코드 소유권  
전부는 아니더라도 대다수 서비스는 누군가가 소유하지만 여전히 풀 요청 등의 방식에 의존하지 않고 모듈을 직접 변경할 수 있다. 사실상 소스 제어는 누구라도 어떤 것이든 변경할 수 있게 설정되어 있지만, 누군가각 다른 이의 서비스를 변경하려 할 땐 대화가 선행되어야 한다는 기대가 있다.  

+ 집단 코드 소유권  
아무도 소유하는 사람이 없으며, 누구나 원하는 것을 변경할 수 있다.  

##### 5.2.1. 문제가 드러나는 방식  
<br/>

서비스 수와 개발자 수가 늘어남에 따라, 집단 소유권에 대한 문제를 겪기 시작할 수도 있다. 집단 소유권이 잘 동작하려면, 바람직한 변화는 어떤 것이며, 기술적 관점에서 특정 서비스가 나아가야 할 방향에 대해 공통적인 이해가 자리잡도록 집단 내에 충분한 연결고리가 형성되어 있어야 한다.  

집단 코드 소유권을 그대로 방치해두면 서비스 수와 개발자 수의 규모가 커짐에 따라 마이크로서비스 아키텍처에 재앙이 되기도 한다. 한 핀테크 회사는 개발자가 3,40명이던 소규모 팀에서 출발해 100명이 넘는 급격한 성장을 이뤘지만, 시스템의 다른 부분에 대한 책임도 없고, '사람들이 옳다고 여기는 것' 이상의 소유권 개념도 갖추질 못했다.  

시스템 아키텍처가 진화하면서 명확한 비전을 갖추지 못했으며, 끔찍하게 얽힌 '분산 모놀리스'가 등장했다. 자신들의 아키텍처에 구멍이 너무 많다고 느낀 한 개발자는 이를 '소쿠리 아키텍처'라고 불렀다. 사람들은 데이터를 외부에 공개하거나 종단 간 호출을 많이 수행하는 방법으로 필요할 때마다 그저 '새로운 구멍만 뚫고' 있었다. 실제로 이런 종류의 문제는 모놀리스 시스템으로 해결하기가 쉬우며 분산 시스템에서는 훨씬 더 어렵다. 사실 분산 모놀리스의 엉킴을 푸는데 비용이 훨씬 더 많이 든다.  

##### 5.2.2. 문제가 드러나는 시점  
<br/>

소규모로 시작하는 많은 팀의 경우 집단 코드 소유권 모델은 의미가 있다. 함께 배치된 소수의 개발자들(20명 남짓)이 작업한다면, 이 모델이 적당하다고 생각한다. 개발자 수가 늘거나 개발자들이 여러 부서에 흩어지게 되면, 무엇이 좋은 커밋을 만드는지, 또는 어떻게 개별 서비스를 진화시켜야 할지 등의 사항에 대해 모든 사람이 동일하게 이해하게 만들기는 점점 더 어려워진다.  

빠른 성장을 경험하는 팀의 경우라면 집단 소유권 모델에는 문제가 많다. 집단 소유권이 작동하려면 합의를 이루기 위한 시공간이 필요하며, 새로운 지식을 배우면서 업데이트해야 한다는 문제가 생긴다. 이는 대체로 인원이 많아질수록 어려워지며, 신규 인력 채용이 급격히 늘거나 또는 사람들을 다른 프로젝트로 이전하는 경우에는 정말 어려워진다.  

##### 5.2.3. 잠재적인 해법  
<br/>

강한 코드 소유권은 거의 보편적으로 여러 팀과 개발자 100명 이상으로 구성된 대규모 마이크로서비스 아키텍처 구현 조직이 채택하는 모델이다. 강한 코드 소유권은 좋은 변화를 구성하기 위한 규칙을 개별 팀이 결정하기가 더 수월하며, 개별 팀이 내부적으로 집단 코드 소유권을 채택한 것으로도 볼 수 있다. 이 모델은 또한 제품 지향 팀을 만든다. 즉 팀에서 일부 서비스를 소육하고 해당 서비스가 비즈니스 도메인을 중심으로 만들어지는 경우, 팀은 비즈니스 도메인의 한 영역에 더 집중하게 된다. 따라서 도메인 전문 지식을 구축하는 고객 중심 팀을 좀 더 쉽게 유지할 수 있으며, 간혹 파견된 제품 소유자가 작업을 이끌기도 한다.  

#### 5.3. 기존 호환성을 깨뜨리는 파괴적 변경  
<br/>

마이크로서비스는 더 거대한 시스템에 속해 있다. 다른 마이크로서비스가 제공하는 기능을 사용하거나 다른 마이크로서비스 컨슈머에게 자신의 기능을 공개하거나, 혹은 이 2가지 모두를 수행할 수 있다. 마이크로서비스 아키텍처에서는 독립적인 배포가 중요하지만, 이렇게 하려면 마이크로서비스를 변경할 때 컨슈머가 의존하는 기존 호환성을 깨뜨리지 않도록 주의해야 한다.  

다른 마이크로서비스에 공개하는 기능을 계약 측면에서 생각할 수도 있을 것이다. 단순히 "이것이 내가 반환할 데이터입니다." 라고 말하는 것만이 아니다. 여기에 덧붙여 계약은 서비스의 예상되는 동작을 정의하는 것이다. 컨슈머와 명시적으로 계약을 체결했는지 여부와 상관 없이 계약은 존재한다. 서비스를 변경할 때 이 계약을 절대로 위반해서는 안 된다. 만약 위반하게 된다면 고약한 운영 문제가 발생할 수 있다.  

머지않아, 기존 호환성을 깨뜨리는 파괴적 변경으로 인한 문제를 해결할 필요가 생길 것이다. 하위 호환성을 유지하지 못하는 변경을 의식적으로 결정했거나 아니면 단지 로컬 서비스에만 영향을 미칠 거라고 생각한 악의 없는 변경으로 인해 상상하지 못한 다른 서비스를 망가뜨렸다는 사실을 발견하고 나서 부딪히는 문제다.  

##### 5.3.1. 문제가 드러나느 방식  
<br/>

이 문제와 관련해 생각할 수 있는 최악의 경우는 기존 서비스와의 호환성을 깨는 새로운 마이크로서비스 때문에 운영이 중단되는 상황을 목격할 때다. 이것은 우발적인 계약 파기를 충분히 조기에 포착하지 못했다는 신호다. 빠른 롤백 메커니즘이 없다면 이런 문제는 치명적일 수 있다. 이런 실패 모드에서 얻는 유일한 위안은 거의 사용되지 않는 서비스 계약의 일부가 호환성을 깨뜨리는 상황을 제외하고는 일반적으로 릴리스 즉시 문제가 드러난다는 것이다.  

또 다른 경우라면, 사람들이 여러 서비스를 묶어 동시 배포를 조율하려고 시도하는 상황(보조를 맞춘 릴리스(lock-step release)라고도 부른다)을 목격하기 시작하는 경우다. 이런 경우는 클라이언트의 서버 간의 계약 변경을 관리하기 때문에 발생하는 신호일 수도 있다. 팀 내에서 가끔씩 일어나는 보조를 맞춘 릴리스는 그리 나쁘지는 않지만, 이것이 일반적인 관례라면 조사할 필요가 있다.  

##### 5.3.2. 문제가 드러나는 시점  
<br/>

이 문제가 특히 개발 인력이 2개 팀 이상으로 나뉘어 있을 때 팀이 직면하는 꽤 이른 성장통이라고 생각한다. 사람들이 모두 한 팀에 속해 있을 때 파괴적 변경을 조금 더 빨리 인지하는 경향이 있다. 어느 정도 개발자들은, 현재 변경을 진행하는 서비스와 기존에 사용하고 있는 서비스 모두에 대해 작업할 가능성이 높기 때문이다. 어떤 팀이 사용하는 서비스를 또 다른 팀이 변경하는 상황에 처하는 경우에 이런 문제는 더 자주 일어날 수 있다.  

시간이 지나면서 팀의 성숙도가 높아지면, 각 팀은 애당초 계약 파기를 피하기 위해 변경 과정에서 더욱 부지런히 문제 파악을 위해 노력할 것이며, 문제를 조기에 포착할 수 있는 메커니즘도 마련하게 된다.  

##### 5.3.3. 잠재적인 해법  
<br/>

계약 파기 관리 규칙을 세워뒀다. 아주 간단하다.  

(1) 계약을 위반하지 마라.
(2) 1번 항목을 참조하라.  

좋다. 다소 농담이긴 히자만 진지한 이야기다. 외부에 공개하는 계약에 대해 기존 호환성을 깨뜨리는 파괴적 변경을 일으키는 악행은 좋지 않으며 관리하기도 고통스럽다. 정말 가능한 범위 내에서 파괴적 변경은 최소로 유지하기 바란다. 여기서 좀 더 현실적인 규칙은 다음과 같다.  

(1) 우발적으로 기존 호환성을 깨뜨리는 파괴적 변경을 제거한다.  
(2) 파괴적 변경을 진행하기 앞서 다시 한번 생각하자. 이를 피할 수 있을까?  
(3) 파괴적 변경을 진행해야 할 경우, 컨슈머에게 마이그레이션할 시간을 제공하자.  

각 단계를 자세히 살펴보자.  

###### 5.3.3.1. 우발적으로 기존 호환성을 깨뜨리는 파괴적 변경을 제거하기  
<br/>

마이크로서비스를 위한 명시적인 스키마를 보유하면, 계약에서 구조적인 파기를 신속하게 감지할 수 있다. 2개의 정수를 매개변수로 사용하는 계산 메소드를 외부에 공개했지만 이제는 단일 정무나 사용하는 경우, 이는 명백히 기존 호환성을 깨뜨리는 파괴적 변경사항이므로 새 스키마에서 명백히 드러나게 만들어야 한다. 이 스키마를 개발자에게 명시적으로 보이게 만들면, 우발적으로 기존 호환성을 깨뜨리는 상황을 조기에 발견하는 데 도움이 된다. 개발자들이 내부로 파고들어 수동으로 스키마를 변경해야 한다면, 바라건대 이런 절차가 개발자들에게 잠시 멈추고 변경 내역을 고민하게 만드는 명시적인 단계가 될 것이다. 정형적인 스키마 형식을 갖췄다면, 물론 내가 원하는 정도는 아니지만, 프로그래밍 방식으로 이를 처리할 수 있는 옵션도 있을 것이다. 포로토록(protolock, https://github.com/nilslice/protolock)은 실제로 프로토콜 버퍼에 호환되지 않는 변경을 금지하는 도구 중 하나다.  

대다수 사람들은 기본적으로 스키마가 없는 교환 형식을 선호하며, JSON이 가장 일반적인 예다. 이론적으로는 JSON을 위한 명시적인 스키마를 정의할 수 있지만, 실제로는 사용되지 않는다. 일반적으로 개발자들은 초기에 정형적인 스키마의 제약 조건을 저주하는 경향이 있다. 나중에 서비스 간의 파괴적 변경사항을 해결하고 나서야 하믕믕 바꿀 것이다. 또한 스키마를 사용하는 일부 직렬화(serialization) 형식은 정형적인 타입 덕분에 데이터 직렬화 해제 과정에서 성능 개선을 달성할 수 있다는 점도 주목할 필요가 있다.  

그러나 구조적 파기는 일부일 뿐이다. 또한 의미론적 파기도 고려해야 한다. 계산 메소드는 여전히 정수 2개를 사용하지만, 단순히 정수를 더하기 위해 사용하는 상황에서 최신 버전의 마이크로서비스가 두 정수를 곱한다면 계약은 파기된다. 실제로 테스트는 이를 감지하는 가장 좋은 방법 중 하나다. 곧 살펴볼 것이다.  

무엇을 하든 가장 빠른 해법은 개발자가 외부 계약을 변경할 때 가능한 한 명백히 문제가 드러나게 만드는 것이다. 데이터를 마법처럼 직렬화하거나 코드에서 스키마를 생성하는 기술보다는, 수동으로 생성하는 기술을 선호한다. 믿기 바란다. 서비스 계약을 변경하기 어렵게 만드는 편이 끊임없이 컨슈머가 의존하는 기존 호환성을 깨뜨리는 것보다는 바람직하다.  

###### 5.3.3.2. 파괴적 변경을 진행하기 앞서 다시 한번 생각하기  
<br/>

가능하면 계약에 대한 확장 변경을 선택하자. 기존 계약을 제거하지 않고, 새로운 메소드, 자원, 토픽 등 뭐가 됐든 새로운 기능을 지원하는 항목을 추가하자. 새로운 것을 지원하면서도 예전 것을 지원하는 방법을 찾으려 노력하자. 이는 예전 코드를 계속해서 지원해야 한다는 사실을 의미할 수도 있지만, 파괴적 변경을 처리하는 작업보다 여전히 작업량이 적을지도 모른다. 계약을 깨뜨리기로 결정했다면, 이런 결정에 내재된 영향을 처리하는 것도 스스로의 몫임을 기억하자.  

###### 5.3.3.3. 컨슈머에 마이그레이션할 시간을 제공하기  
<br/>

처음부터 분명히 밝혔듯이 마이크로서비스는 독립적으로 배포 가능하게 설계되었다. 마이크로서비스를 변경할 때는 다른 것을 배포하지 않고도 해당 마이크로서비스를 운영 환경에 배포할 수 있어야 한다. 이를 위해서는 기존 컨슈머에 영향을 미치지 않는 방식으로 서비스 계약을 변경해야 한다. 따라서 새로운 계약이 사용 가능하더라도 컨슈머가 여전히 기존 계약을 계속 사용할 수 있게 허용해야 한다. 그런 다음, 모든 컨슈머에 구축한 새로운 서비스 버전으로 마이그레이션하기 위해 자신들의 서비스를 변경할 시간을 제공해야 할 것이다.  

2가지 방법으로 이와 같은 작업을 수행해왔다. 첫 번째는 2가지 버전의 마이크로서비스를 실행하는 것이다. 통지 서비스에 대한 2가지 빌드를 동시에 사용할 수 있으며, 각 버전은 컨슈머가 선택 가능한 2가지 호환되지 않는 종단점을 외부에 공개한다. 이와 같은 접근 방식의 주요 문제는 추가 서비스를 실행하기 위해 더 많은 기반 시스템이 필요하고, 서비스 버전 간에 데이터 호환성을 유지해야 하며, 실행 중인 모든 버전에 대해 버그 수정이 필요하므로 불가피하게 소스 코드 브랜치를 요구할 수도 있다는 사실이다. 두 가지 버전이 짧은 기간 동안에만 공존하는 경우 이런 문제는 다소 완화될 수 있으며, 이와 같은 접근 방식을 고려할 수 있는 유일한 상황이다.  

선호하는 방법은 마이크로서비스 버전을 하나만 실행하지만 두 계약을 모두 지원하는 것이다. 예를 들어 서로 다른 두 포트를 열어 2개의 API를 외부에 공개한다. 이는 마이크로서비스 구현에 복잡성을 가중시키지만, 앞서 설명한 접근 방식의 문제점을 회피할 수 있다. 외부 컨슈머의 변경이 불가능한 이유로, 동일한 서비스에서 몇 년에 걸쳐 3개 이상의 오래된 계약을 지원하는 몇몇 팀과 이야기를 나눠봤다. 즐거운 상황은 아니지만, 컨슈머가 여전히 바뀌지 않는다면 여전히 이런 방법이 최선이라고 생각한다.  

물론 동일 팀이 컨슈머와 프로듀서를 모두 다루는 경우 보조를 맞춘 릴리스를 수행하고 동시에 컨슈머와 프로듀서 모두에 해당하는 새 버전을 배포할 수 있다. 내가 선호하는 방식은 아니지만 적어도 한 팀 내에서 릴리스 조정을 관리하는 편이 더 쉬울 수도 있다. 단, 이런 버릇을 들이지는 말자!  

컨슈머와 프로듀서라는 방정식의 양변을 제어하므로, 팀 내의 변경사항을 관리하기가 더 쉽다. 변경하고자 하는 마이크로서비스가 더 광범위하게 사용되면 변경 관리 비용은 더 커진다. 결과적으로, 팀 내에서는 변경이 기존 호환성을 깨뜨려도 여유가 있지만 외부 조직에 공개되는 API의 호환성을 깨뜨리면 상당히 고통스러울 것이다.  

그러나 이렇게 하려면 서비스를 사용하고 있는 다른 서비스를 관리하는 사람들과 원활한 커뮤니케이션이 필요하다. 여러 이해관계들에게 (아무리 노력해도) 불편을 끼칠 확률이 크므로, 좋은 관계를 유지하는 편이 바람직하다. 서비스의 컨슈머를 고객처럼 취급하자. 고객에게는 잘 대해야 한다!  

###### 5.3.3.4. 어떻게든 정리하자, 빠르게!  
<br/>

관리하는 마이크로서비스가 점점 늘어날수록, 긍극적으로 조직은 우발적인 파괴적 변경으 최대한 제거할 방법을 고민하고, 의도적인 변경을 처리할 관리 메커니즘을 마련한다. 그렇지 않은 경우, 마이크로서비스 아키텍처를 유지할 수 없을 정도로 후폭풍은 심각해진다. 다시 말하면, 이런 유형의 문제점을 정리하지 않는 소규모 마이크로서비스 조직은 대규모 마이크로서비스 조직이 될 만큼 성장을 이어나가기가 어려울 것이다.  

#### 5.4. 리포팅  
<br/>

모놀리스 시스템에는 일반적으로 모놀리스 데이터베이스가 있다. 이는 모든 데이터를 함께 분석하고자 하는(종종 데이터 전체에서 대규모 조인 작업이 필요한) 이해관계자가 리포팅을 위한 레거시 스키마를 가지고 있음을 의미한다. 이해관계자는 모놀리스 데이터베이스, 즉 아마도 읽기 복제본에 대해 직접 작업을 실행할 수 있다. 마이크로서비스 아키텍처를 도입하면서, 이런 모놀리스 스키마를 분해했다. 그렇다고 여기저기 흩어진 모든 데이터에 대한 리포팅의 필요성이 사라졌다는 의미는 아니다. 이제 데이터가 논리적으로 격리된 여러 스키마에 분산되어 있어서, 리포팅 작업은 훨씬 더 어려워진다.  

##### 5.4.1. 문제가 드러나는 시점  
<br/>

이 문제는 매우 일찍 괴롭히는 경향이 있으며, 일반적으로 모놀리스 스키마의 분해를 고려하기 시작하는 단계에서 등장한다. 다행인 것은, 리포팅은 보통 문제가 되기 전에 사전에 발견할 수 있다. 하지만 안타깝게도 마이크로아키텍처로 가는 과정에서 리포팅에 관심이 있는 이해관계들에게 불행을 초래할 것이라는 사실을 프로젝트 중반까지 자각하지 못하는 팀을 나는 수차례 목격해왔다. 다운스트림 리포팅에 대한 필요성은 일반적인 소프트웨어 개발과 시스템 유지 관리 영역을 벗어나서 꽤 자주 발생하므로 초기에 충분히 고려되지 않는 경우가 많다. 논에서 멀어지면, 마음에서도 멀어진다.  

모놀리스가 데이터 웨어하우스나 데이터 레이크 리포팅 목적을 위한 전용 데이터 소스를 이미 사용하는 경우라면 이 문제를 회피할 수 있을 것이다. 이런 경우라면 마이크로서비스가 적절한 데이터를 기존 데이터 소스에 복사할 수 있는지 확인하기만 하면 된다.  

##### 5.4.2. 잠재적인 해법  
<br/>

대다수 상황에서, 한곳에서 모든 데이터에 접근하고자 하는 이해관계자는 일반적으로 SQL을 사용해 데이터베이스에 직접 접근하기를 기대하는 툴체인과 프로세스에도 투자할 것이다. 이에 덧붙여 리포팅은 모놀리스 데이터베이스의 스키마 설계와 밀접하게 묶여 있을 가능성도 있다. 즉 동작 방식을 변경하기를 원하지 않는 이상, 리포팅을 위해 여전히 단일 데이터베이스를 제공해야 하며, 변경의 영향을 제한하기 위해 가능한 한 예전 스키마 설계와 일치하는 데이터베이스가 되어야 한다.  

이 문제를 해결하기 위한 가장 직관적인 방법은 데이터 저장과 인출에 사용되는 마이크로서비스의 여러 데이터베이스에서 리포팅 목적으로 데이터를 저장하는 하나의 데이터베이스를 분리해야 한다. 이렇게 하면 리포팅 데이터베이스의 내용과 설계를 각 서비스마다 다른 데이터 저장소 요구 사항의 설계나 향후 발전에서 분리할 수 있다. 또한 사용자의 특정 요구사항을 염두에 두고 새로운 리포팅 데이터베이스를 변경할 수도 있다. 그러고 나서 마이크로서비스가 데이터를 새로운 스키마에 '밀어넣을' 수 있는 방법을 알아내기만 하면 된다.  

변경 데이터 캡처 시스템은 이 문제를 해결하기 위한 가능성이 높은 해법임에 분명하지만, 뷰 같은 기법도 유용할 수 있다. 여러 마이크로서비스 데이터베이스의 스키마에서 외부로 공개된 뷰를 통해 단일 리포팅 스키마를 투가할 수 있을 것이기 때문이다. 또한 마이크로서비스 코드의 일부로서 프로그래밍 방식으로 리포팅 스키마에 데이터를 복사하거나 아니면 업스트림 서비스의 이벤트를 수신해서, 리포팅 데이터베이스를 채울 중간 구성 요소를 제공하는 다른 기술을 고려할 수도 있다.  

#### 5.5. 모니터링과 트러블슈팅  
<br/>

표준적인 모놀리스 애플리케이션을 사용하며 모니티링에 대해 매우 단순한 접근 방식이 가능하다. 관심을 기울여야 할 컴퓨터는 몇 대 되지 않으며, 애플리케이션의 실패 모드는 둘 중 하나다. 즉 애플리케이션은 모두 가동되거나 아니면 모두 작동이 중단된다. 마이크로서비스 아키텍처에서는 단지 하나의 서비스 인스턴스나 한 가지 유형의 인스턴스 실패만 가능하다. 실패를 적절히 알아낼 수 있을까?  

모놀리스 시스템에서 CPU 사용률이 한참동안 100%로 멈춰 있으면 큰 문제가 생긴 것임이 분명하다. 프로세스가 수십 개이거나 수백 개 있는 마이크로서비스 아키텍처에서 동일한 사실을 알 수 있을까? 오전 3시에 프로세스 하나만 100% CPU 사용률에 멈춰 있다면 누군가를 깨워야 하는 걸까?  

문제가 있는 곳을 확인하고, 찾아낸 문제가 실제로 걱정해야 할 부분인지 파악하는 과정은 구동하는 부품이 많을수록 훨씬 더 복잡해진다. 마이크로서비스 아키텍처가 커짐에 따라 모니터링과 트러블슈팅에 접근하는 방식도 변경되어야 할 것이다. 이는 지속적인 관심과 투자가 필요한 영역이다.  

##### 5.5.1. 문제가 드러나는 방식  
<br/>

어느 정도까지는 쉽게 발견할 수 있다. 설명하거나 이해할 수 없는 운영 문제를 발견할 것이고, 누가 봐도 시스템이 정상적임에도 경고를 받으며, "모든 것이 정상입니까?"라는 간단한 질문에 대답하기도 점점 더 어려워질 것이다.  

##### 5.5.2. 문제가 드러나는 시점  
<br/>

문제가 발생할 시점을 정확히 예측하는 일은 조금 더 까다롭다. 간단한 대답은 "운영 환경에서 처음으로 문제가 발생했을 때"이겠지만, 실제로는 개발자와 테스터가 운녕에 들어가기에 앞서 어떤 문제가 어디서 잘못됐는지를 알아내려고 노력해야 한다. 서비스가 몇 개뿐이라면 이렇게 할 수 있겠지만, 20개가 넘어가면 어림도 없다.  

기존 모니터링 방식이 언제 실망시킬지 정확하게 예측하기 어려울 수 있으므로, 몇 가지 기본적인 개선 사항을 미리 구현하는, 작업의 우선순위를 높이는 방식을 제안하는 바이다.  

##### 5.5.3. 잠재적인 해법  
<br/>

구현하기 쉽기도, 복잡하기도 한 다양한 메커니즘들은 마이크로서비스 아키텍처의 문제를 모니터링하고 해결하는 방식을 변경하는 데 도움이 될 것이다. 다음은 고려해야 할 몇 가지 주요 사항에 대한 포괄적인 개요다.  

###### 5.5.3.1. 로그 집계  
<br/>

컴퓨터가 몇 대 안 되고, 특히 오래된 컴퓨터를 사용하면, 로그를 점검해야 할 때 일반적으로 해당 컴퓨터로 바로 이동해 정보를 파악하고 가져온다. 마이크로서비스 아키텍처의 문제점은 대체로 많은 시스템에서 동작하는 수명이 짧은 프로세스가 모놀리스에 비해 훨씬 더 많다는 사실이다(예를 들면 가상 머신이나 컨테이너 등).  

로그 집계(log aggregation) 시스템을 사용하면 모든 로그를 캡처해 검색할 수 있는 중앙 위치로 전달할 수 있으며 경우에 따라서는 경고를 생성하는 과정에도 사용될 수 있다. 오픈소스 ELK(Elastic Search, Logstash/FluentD, Kibana) 스택(https://www.elastic.co/kr/what-is/elk-stack)부터 내가 개인적으로 좋아하는 휴미오(Humio, https://www.humio.com/)에 이르기까지 많은 선택지가 존재하며, 이와 같은 집계 시스템들은 상당히 유용하다.  

마이크로서비스 아키텍처를 구현하기에 앞서, 먼저 로그 집계부터 구현하는 방식을 적극적으로 고려하자. 로그 집계 시스템은 믿기 어려울 만큼 유용하며, 운영 과정에서 변화를 줄 수 있는 조직과 역량을 시험하는 잦대가 된다.  

로그 집계는 가장 간단한 구현 메커니즘 중 하나로, 초기에 수행해야 한다. 사실상 마이크로서비스 아키텍처를 구현할 때 가장 먼저 진행해야 하는 작업일 것이다. 맨처음부터 매우 유용하기 때문인 이유도 있다. 또한 적절한 로그 집계 시스템을 구현하는 과정에 어려움을 겪고 있는 조직이라면, 마이크로서비스에 대한 준비가 갖춰졌는지 여부를 다시 고려해야 할 것이다. 로그 집계 시스템을 구현하기 위해 필요한 작업은 매우 간단하며 조직 차원에서 이 정도 준비도 되지 않은 상황이라면 마이크로서비스는 너무 먼 단계일 가능성이 높다.  

###### 5.5.3.2. 추적  
<br/>

격리된 각 서비스에서 받은 정보만 분석할 수 있는 경우라면, 마이크로서비스 간의 호출 순서가 어디에서 실패했는지, 또는 어떤 서비스가 대기 시간 급증을 초래했는지 등은 파악하기 어려울 수 있다. 일련의 흐름을 조합해서 전체를 볼 수 있으면 매우 유용하다.  

첫 출발점으로서, 시스템에 대한 모든 인바운드 호출에 대한 상관관계 ID를 생성하자. 송장 서비스가 호출을 받으면 상관관계 ID가 제공된다. 통지 마이크로서비스로 호출할 때 해당 상관관계 ID를 HTTP 헤더나 메시지 페이로드의 필드 또는 다른 메커니즘을 통해 전달할 수 있다. 대체로 API 게이트웨이나 서비스 메시를 사용해 초기 상관관계 ID를 생성한다.  

통지 서비스는 호출을 처리할 때 동일한 상관관계 ID와 함께 수행 중인 작업에 대한 정보를 로그에 기록할 수 있으므로, 로그 집계 시스템을 사용해 주어진 상관관계 ID와 관련된 모든 로그를 쿼리할 수 있다(로그 형식의 표준 위치에 상관관계 ID를 넣었다는 가정하에). 물론, 상관관계 ID로 사가 관리와 같은 작업을 수행할 수도 있다.  

이 개념을 더욱 발전시키면, 도구를 사용해 호출에 걸린 시간도 추적할 수 있다. 로그가 정기적으로 중앙 에이전트에 배치되고 전달되는 로그 집계 시스템의 동작 방식으로 인해, 호출 체인 과정 중 어느 곳에서 시간이 소비될지를 정확하게 알아낼 수 있는 정밀한 정보를 얻기가 불가능하다. 오픈 소스 예거(https://www.jaegertracing.io/)같은 분산 추적 시스템이 도움될 수 있다.  

애플리케이션이 대기 시간에 좀 더 민감할수록 예거 같은 분산 추적 도구를 더 빨리 구현해야 한다. 상관관계 ID 생성을 수행하고 기존 마이크로서비스 아키텍처에 적용했다면 (일반적으로 분산 추적 도구가 필요하기 전에 내가 주장한 일반적인 내용), 기존 서비스 스택에서 적절한 도구에 데이터을 밀어넣을 목적으로 쉽게 변경할 수 있는 장소를 이미 확보했을 가능성이 높다. 서비스 메시를 사용하면, 개별 마이크로서비스 내에서 호출을 계측하는 과정에서는 별다른 도움이 되지 않더라도, 최소한 들어오고 나가는 추적을 처리하기에 도움이 될 수 있다.  

###### 5.5.3.3. 운영 환경에서 테스트  
<br/>

기능적으로 자동화된 테스트(functional automated tests)는 일반적으로 소프트웨어가 배포하기에 충분한 품질인지 여부와 관련해 배포 전 피드백(feedback before deployment)을 제공하는 데 사용된다. 그러나 일단 소프트웨어가 운영 수준에 도달하고 나서도 여전히 동일한 피드백을 원한다! 주어진 기능이 운영 환경에서 일단 작동한 다음에도, 새로운 서비스를 배포하거나 환경이 바뀌면 나중에 해당 기능의 호환성을 보장하지 못할 수도 있다.  

시스템에 가짜 사용자 행동을 주입해, 종종 가상 트랜잭션이라는 형태로 예상되는 행동을 정의하고 여기서 벗어난 경우 경고할 수 있다. 아토미스트(Atomist)에서는 깃허브와 슬랙 계정으로 소프트웨어를 인증해야 하는 신규 고객 가입을 위한 다소 복잡한 등록 프로세스가 있었다. 이 프로세스 초반에 깃허브 API의 속도 제한 같은 다양한 문제를 일으크니느 코드 영역이 많았다. 실뱅 헬레구아르는 가짜 고객 등록 절차를 스크립트로 만들었다. 전체 프로세스를 전 구간에 걸쳐 스크립트로 만든 다음에, 주기적으로 이런 가짜 고객 중 하나에 대한 가입 프로세스를 진행했다. 이 과정에서 실패한다면, 이는 시스템에 뭔가 문제가 있다는 신호였으며 실제 사용자보다 '가짜' 사용자로 문제를 잡는 편이 훨씬 더 바람직했다!  

운영 환경에서 테스트를 수행하기 위한 좋은 출발점은 기존 전 구간 테스트(end-to-end test) 사례를 가져와 운영 환경에서 사용하기 위해 재작업하는 방식이다. 이런 '테스트'가 운영에 예기치 않은 영향을 미치지 않게 각별히 주의해야 한다. 아토미스트에서는 가상 트랜잭션에 사용하기 위해 통제가 가능한 깃허븝와 슬랙 계정을 만들었으므로 실제 사람이 관여하거나 영향을 받지 않았으며 이후 스크립트에서 이런 계정을 쉽게 정리할 수 있었다. 반면에, 시험 주문임에도 실제로 물품이 발송될 것이라는 사실을 제대로 설명하지 않아서, 실수로 세탁기 200대를 본사에 배송시킨 회사의 일화를 들은 적이 있다. 그러니 항상 조심하자!  

###### 5.5.3.4. 관측성을 향해  
<br/>

전통적인 모니터링과 경고 프로세스를 활용해, 무엇이 잘못될지 생각하고, 이런 경우를 알려주는 정보를 수집하며, 이를 사용해 경고를 발생시킨다. 따라서 주로 디스크 공간이 부족해지고, 서비스 인스턴스가 응답하지 않거나, 아마도 대기 시간이 급증하는 현상과 같은 알려진 문제의 원인을 처리하도록 자체적으로 준비하고 있다.  

오늘날 시스템이 점점 더 복잡해짐에 따라, 시스템이 중단될 수 있는 이 모든 불쾌한 상황을 예측하기가 점점 더 어려워지고 있다. 이 시점에서는 무엇보다도, 이런 문제가 발생할 때 시스템에 대해 개방형 질문을 해야 하며, 끔찍한 사태를 멈추고 시스템이 계속 작동하게 도움을 주는 핵심 정보는 물론이고 앞으로 일어날 문제를 해결하기 위한 충분한 정보를 수집해야 한다.  

따라서 시스템이 수행하는 작업에 대한 더 많은 정보를 수집해야 하며, 이로써 처음에는 중요성조차 파악하지 못한 데이터에 대해 사후에 쿼리해서 궁금증을 풀 수 있다. 추적과 로그는 운영 과정에서 중요한 데이터를 수집해서 저장하게 만들기에, 추측이 아니라 쿼리를 통해 문제가 무엇인지 판단하는 데 도움을 준다. 이 정보를 쉽게 쿼리하고 전체 맥락에서 볼 수 있게 만드는 것이 핵심이다.  

정답을 미리 알고 있다고 가정하지 말자. 그보다는 깜짝 놀랄 만한 견해를 채택함으로써, 시스템에 대해 질문하는 행위에 능숙해지고, 정보를 임의로 쿼리할 수 있는 툴체인을 사용해야 한다. 이 개념을 더 자세히 살펴보려면 전자책으로 출간된 「분산 시스템 관측성」을 권장한다.  

#### 5.6. 로컬에서 개발하는 동안 겪는 개발자 경험  
<br/>

서비스가 점점 더 많아짐에 따라, 개발자는 개발 환경의 제약으로 인해 고통을 겪을 수 있다. JVM처럼 자원을 많이 사용하는 런타임은 단일 개발자 컴퓨터에서 실행할 수 있는 마이크로서비스 수를 제한할 수 있다. 노트북 컴퓨터에서 별도 프로세스로 JVM 기반 마이크로서비스를 4, 5개을 실행할 수 있지만 10개 또는 20개도 실행할 수 있을까? 아마 아닐 것이다. 실행 과정에서 CPU와 메모리를 적게 사용하는 런타임이라도 로컬에서 실행할 수 있는 작업 수에는 제한이 있기에, 한 컴퓨터에서 전체 시스템을 실행할 수 없는 경우 무엇을 해야 할지에 대한 논의를 시작해야 한다.  

##### 5.6.1. 문제가 드러나는 방식  
<br/>

더 많은 서비스를 유지해야 하므로, 로컬에서 수행하는 빌드와 실행 시간이 길어지면서 일상적인 개발 프로세스가 느려지기 시작할 수 있다. 개발자들은 처리해야 할 서비스의 수를 늘리기 위해 CPU와 메모리가 더 강력한 컴퓨터를 요구하기 시작할 것이다. 단기적인 해결책으로는 이런 방식이 괜찮겠지만, 서비스 자산이 계속 증가하면 잠시 시간을 버는 미봉책에 불과하다.  

##### 5.6.2. 문제가 드러나는 시점  
<br/>

이런 문제가 정확히 모습을 드러낼 시점은 개발자가 로컬에서 실행하기 원하는 서비스 수와 해당 서비스의 자원 규모가 결합된 함수 형태로 표현될 가능성이 높다. 고(Go), 노드, 파이썬 등을 사용하는 팀은 자원 제약 조건에 도달하기 전에 더 많은 서비스를 로컬에서 실행할 수 있다는 사실을 알게 되겠지만 JVM을 사용하는 팀은 이런 문제를 훨씬 더 일찍 겪을지도 모른다.  

또한 여러 서비스에 대한 집단 소유권을 따르는 팀이 이 문제에 더 민감하다고 생각한다. 이런 팀은 개발 과정에서 다른 서비스 간에 전환할 수 있는 능력을 요구할 가능성이 더 높다. 몇몇 서비스에 대한 강력한 소유권을 가진 팀은 주로 자신의 서비스에만 초점을 맟추고 통제 바깥에 있는 서비스이 영향을 제거하기 위한 메커니즘을 개발할 가능성이 높을 것이다.  

##### 5.6.3. 잠재적인 해법  
<br/>

로컬에서 개발하되 실행랄 서비스의 수는 줄이고 싶은 경우 일반적인 기법으로, 직접 실행하고 싶지 않은 서비스를 처내는 방법 또는 다른 곳에서 실행 중인 인스턴스에 의존하는 방법이 있을 수 있다. 순수한 원격 개발자 설정을 통해, 더 강력한 인프라스트럭처에서 호스팅되는 많은 서비스를 대상으로 개발할 수 있다. 그러나 이로 인해 연결성 요구(원격 작업자나 출장이 잦은 개발자가 겪을 문제), 동작 확인에 앞서 원격으로 소프트웨어를 배포할 필요성으로 인한 느린 피드백 주기, 개발자 환경에 필요한 자원(그리고 부대 비용)의 폭발적인 증가 같은 문제가 따라온다.  

텔레프레즌스(Telepresence, https://www.telepresence.io/)는 쿠버네티스 사용자를 위해 하이브리드 로컬/원격 개발자 워크플로우를 더 쉽게 만들어주는 도구다. 서비스를 로컬에서 개발할 수 있지만, 텔레프레즌스는 다른 서비스에 대한 호출을 원격 클러스터로 프록시할 수 있으므로 (바라건대) 로컬과 원격의 2가지 장점을 활용하게 만들어준다. 애저(Azure)의 클라우드 펑션(function)은 로컬에서 실행할 수 있지만 원격 클라우드 자원에도 연결할 수 있으므로 잠재적으로 광범위한 클라우드 환경에서 실행 가능하면서도, 빠른 로컬 개발자 워크플로우로 펑션을 사용한 서비스를 만들 수 있다.  

서비스 수 증가에 따라 개발자의 경험이 어떻게 변화하는지 확인하는 것은 중요하므로, 적재적소에 피드백 메커니즘을 갖춰야 한다. 작업하는 서비스 수가 증가함에 따라 개발자도 최대한 생산성을 유지하도록 지속적인 투자가 필요하다.  

#### 5.7. 너무 많은 것들을 실행  
<br/>

서비스와 서비스 인스턴스가 더 많아질수록, 배포하고 구성하고 관리해야 하는 프로세스도 더 많아진다. 관리해야 하는 구동 부분이 많아질수로, 모놀리스 애플리케이션의 배포와 구성을 처리하는 기존 기술은 확장되기 어려울 수 있다.  

특히 바람직한 상태 관리는 점점 더 중요해지고 있다. 바람직한 상태 관리란 여러분이 요구하는 서비스 인스턴스의 수와 위치를 명세하고 시간이 지남에 따라 이를 유지하는 능력이다. 현재는 수동 프로세스를 사용해 모놀리스로 이를 관리하겠지만, 마이크로서비스가 수십 또는 수백 개로 넘어가면, 특히 마이크로서비스마다 상태를 다르게 유지해야 할 경우에는 확장성이 떨어질 것이다.  

##### 5.7.1. 문제가 드러나는 방식  
<br/>

배포를 관리하고 배포 도중에 발생하는 문제를 해결하는 과정에 소요되는 시간의 비율이 증가하기 시작할 것이다. 프로세스가 수작업에 의존할 경우 항상 실수가 발생할 것이며, 무고한 실수로 인해 분산 시스템에 미치는 영향을 예측하기 어려울 수도 있다.  

서비스와 서비스 인스턴스를 더 많이 추가할수록, 운영이나 배포와 관련된 활동을 관리하는 데 더 많은 인력이 필요하게 될 것이다. 이로 인해 운영 팀 지원에 더 많은 사람들을 투입하거나 배포 팀의 배포 문제에 상당한 시간이 소요되는 상황을 목격하게 될 수도 있다.  

##### 5.7.2. 문제가 드러나는 시점  
<br/>

이 모든 것은 확장에 관한 문제다. 보유하고 있는 마이크로서비스가 많을수록, 그리고 마이크로 서비스를 구동하는 인스턴스가 많을수록, 더 많은 수동 프로세스 또는 셰프(Chef)나 퍼핏(Puppet)같은 전통적인 자동화된 구성 관리 도구가 필요하므로, 더 이상 비용을 감당하지 못하게 된다.  

##### 5.7.3. 잠재적인 해법  
<br/>

개발자는 높은 수준의 자동화가 지원되고, 개발자가 직접 수행하는 프로비전 배포에 이상적으로 사용할 수 있으며, 바람직한 상태 관리가 가능한 자동화된 도구를 원한다.  

마이크로서비스의 경우, 이 영역에서 개발자들이 선택하는 도구로 쿠버네티스가 부상했다. 쿠버네티스를 사용하려면 서비스를 컨테이너화해야 하지만, 일단 컨테이너로 만들어 놓고 나면, 쿠버네티스가 여러 컴퓨터에 걸쳐 서비스 인스턴스 배포를 관리할 수 있기에 (하드웨어를 충분히 확보했다고 가정하면) 견고성의 개선과 함께 부하 처리를 위한 확장이 가능하게 된다.  

다른 기능을 추가하지 않는 원래 상태의 쿠버네티스는 개발자 친화적이라고 할 수 있다. 일반 대중들은 고차원이며 더 개발자 친화적인 추상화 위에서 작업하고 있으며, 이런 추세는 앞으로 계속될 전망이다. 아마도 앞으로 쿠버네티스에서 소프트웨어를 운영하는 많은 개발자들은 이미 구현 세부사항이 되어버린 쿠버네티스를 인식조차 못 할 것이라고 예상한다. 규모가 더 큰 조직에서는 레드햇(RedHat)의 오픈시프트(OpenShift) 같은 패키지 버전의 쿠버네티스를 채택하는 경향이 있다. 오픈시프트 솔루션은 회사 환경 내에서의 회사의 IAM(Identity and Access Management) 제어를 처리하는 방식으로 작업을 더 쉽게 만드는 도구와 함께 쿠버네티스를 번들로 제공한다. 이런 패키지 버전 중 일부는 개발자가 작업할 수 있는 단순화된 추상화도 제공한다.  

퍼블릭 클라우드 운영이 가능할 정도로 운이 좋은 분들이라면 관리형 쿠버네티스 서비스를 비롯한 마이크로서비스 아키텍처를 배포하기 위한 다양한 선택지를 사용할 수 있다. 예를 들어 AWS와 애저는 이 분야에서 여러 선택지를 제공한다. 적절한 플랫폼을 사용하면 개발자는 코드만 걱정하면 되고, 기반 플랫폼이 대다수 운영 작업을 처리한다. 현재 FaaS 제품군은 기능이나 능력의 한계가 있지만, 그럼에도 운영에 필요한 간접 비용이 대폭 줄어들 가능성을 보여준다.  

퍼블릭 클라우드에 이미 진입한 팀과 작업할 때 나는 쿠버네티스 류의 컨테이너 기반 플랫폼을 무작정 도입하는 편은 아니다. 대신 운영 작업을 줄이기 위해 FaaS 같은 서버리스 기술부터 시도하는 서버리스 우선 방식을 채택해왔다. 현재 사용 가능한 서버리스의 제약사항 때문에 여러분이 겪는 문제를 해결하지 못한다면 다른 선택지를 찾아야 한다. 풀고자 하는 문제가 당연히 똑같지는 않겠지만, 이미 퍼블릭 클라우드를 도입했다면 쿠버네티스 같은 컨테이너 기반 플랫폼의 복잡성이 항상 필요하지는 않다.  

쿠버네티스에 경도된 사람들이 쿠버네티스를 마이크로서비스 도입 과정의 전제조건으로 여기는 광경을 많이 봐왔다. 하지만 오히려 그 반대다. 쿠버네티스 같은 플랫폼은 여러 프로세스를 관리하는 능력은 탁월하지만, 우리는 쿠버네티스를 사용하기 앞서 현재 사용 중인 방식과 기술이 운영에 부담을 주기 시작할 만큼 프로세스가 복잡해질 때까지 기다릴 필요가 있다. 여러분은 마이크로서비스 5개면 충분하며, 기존 솔루션으로 이를 행복하게 처리할 수 있음을 느끼게 될 것이다. 물론 이 경우는 훌륭하다! 여러분을 제외한 모든 사람이 쿠버네티스로 뭔가를 하며 이를 마이크로서비스라고 부른다고 해서, 무작정 쿠버네티스 기반 플랫폼을 채택하지는 말자!  

#### 5.8. 전 구간 테스트  
<br/>

특정 유형의 자동화된 기능 테스트로 섬세한 균형 잡기가 가능하다. 테스트가 더 많은 기능을 수행할수록(테스트의 범위가 넓을수록) 애플리케이션에 대한 자신감이 더 높아진다. 반면에 테스트의 대상 범위가 클수록 실행 시간은 오래 걸리고, 실패했을 때 망가진 부분을 해결하기가 더 어려워진다.  

특정 유형의 시스템에 대한 전 구간(end-to-end) 테스트는 기능 측면에서 극단적인 끝부분에 위치하며 우리는 더 작은 범위의 단위 테스트보다 전 구간 테스트의 구현과 유지 관리에 더 많은 문제를 경험해왔다. 하지만 전 구간 테스트는 실제와 동일한 동작에 대한 확신을 주기 때문에 때로는 수행할 만한 가치가 있다.  

그러나 마이크로서비스 아키텍처를 사용하면 전 구간 테스트의 '영역'이 매우 넓어진다. 이제 여러 서비스에서 테스트를 실행해야 하며, 모든 서비스를 테스트 시나리오에 맞춰 배포하고 적절히 구성해야 한다. 또한 서비스 인스턴스 종료 또는 실패한 배포의 네트워크 시간 초과 같은 환경적인 문제로 인해 테스트가 실패할 때 발생하는 거짓 음성(false negative)에도 대비해야 한다. 표준적인 모놀리스 아키텍처보다 마이크로서비스 아키텍처에 대한 전 구간 테스트를 실행할 때, 통제 밖에 있는 문제에 훨씬 더 취약할 것이다.  

테스트 범위가 중가함에 따라 발생하는 문제와 싸우는 데 더 많은 시간을 소비하게 될 것이며, 전 구간 테스트를 작성하고 유지하기 위한 노력에 투입되는 시간이 더 이상 감내하기 어려운 지점에 도달할 것이다.  

##### 5.8.1. 문제가 드러나는 방식  
<br/>

이 문제가 나타나는 한 가지 경우는 전 구간 테스트 스위트(test suite)가 커지고 완료까지 시간이 오래 걸리는 것이다. 이는 여러 팀이 어떤 시나리오를 다루는지 확신하지 못하고 '혹시라도 만일의 경우에 대비해' 새로운 시나리오를 추가하기 때문에 발생한다. 여러분은 전 구간 테스트 스위트에서 코드 관련 문제를 드러내지 못하는 실패 사례를 많이 보게 되며, 개발자들은 테스트를 통과하는지 보기 위해 종종 테스트를 다시 돌릴 뿐이다.  

전 구간 테스트에 소요되는 시간은 점점 더 길어지며, 더 많은 테스터와 (존재한다면) 별도 테스트 팀에 가해지는 압박을 어느 순간 여러분도 느끼기 시작할 것이다.  

##### 5.8.2. 문제가 드러나는 시점  
<br/>

이 문제는 스리슬쩍 일어나지만, 내 경우에는 대부분 다수의 팀이 여러 사용자를 위한 작업을 처리하는 상황에서 가장 예리하게 문제를 느꼈다. 각 팀이 격리되어 작업할수록 자신의 테스트를 로컬에서 더 쉽게 관리할 수 있다. 팀 간 흐름을 테스트할 필요성이 더 커질수록 전 구간에 더 많은 문제가 발생하며, 대규모 테스트가 된다.  

##### 5.8.3. 잠재적인 해법  
<br/>

###### 5.8.3.1. 기능적으로 자동화된 테스트의 범위 제한  
<br/>

여러분이 여러 서비스를 다루는 테스트 케이스를 작성한다면, 되도록 이런 서비스를 관리하는 팀 내부에서 테스트를 진행하는 편이 바람직하다. 즉 팀 경계를 넘어서는 더 큰 영역의 테스트를 피해야 한다. 하나의 팀 안에서 테스트 소유권을 유지하면, 어떤 시나리오가 올바르게 적용되는지 훨씬 더 쉽게 이해할 수 있으며, 개발자가 테스트를 실행하고 디버깅할 수 있고, 테스트 실행과 통과 여부를 누가 확인해야 할지 등을 훨씬 더 명확하게 지정할 수 있다.  

###### 5.8.3.2. 컨슈머 중심 계약 사용  
<br/>

교차 서비스(cross-service) 테스트 케이스의 필요성을 대체하기 위해 컨슈머 중심 계약(Consumer-Driven Contract, CDC) 사용을 고려해볼 수도 있다. CDC를 사용하면 마이크로서비스의 컨슈머는 서비스가 실행 가능한 명세(테스트)라는 관점에서 서비스의 동작 방식에 대한 기대치를 정의하게 된다. 서비스를 변경할 때 여러분은 테스트가 계속해서 통과할 수 있게 보증해야 한다.  

이런 테스트는 컨슈머의 관점에서 정의되기 때문에, 우발적인 계약 파기를 복구하는 범위가 넓다. 우리는 또한 컨슈머 관점에서 우리 고객의 요구사항을 이해하고, 고객의 요구사항이 우리의 요구사항과 얼마나 다른지도 확실히 이해한다. 간단한 개발 워크플로우를 사용해 CDC를 구현할 수도 있지만, 이 기법을 지원하도록 설계된 도구를 사용하면 CDC를 훨씬 더 쉽게 구현할 수 있다. 가장 좋은 예는 아마도 팩트(Pact, https://docs.pact.io/)일 것이다.  

이런 접근 방식으로 큰 성긍을 거둔 팀들도 있었지만, 그런 방식을 다른 팀에서 채택하기는 어려웠다는 사실에 주목해야 한다. 아이디어는 그럴듯하며 제대로 동작한다는 사실을 나도 알고는 있지만, 이 기법을 채택하는 과정에서 직면하는 어려움을 여전히 완벽하게 이해하지는 못한다. 이런 접근 방식은 정말 여러운 문제를 해결하기에 적합하지만, 제대로 사용되지 않고 있다.  

###### 5.8.3.3. 자동화된 릴리스 복원과 점진적인 배포 사용  
<br/>

자동화된 테스트에서는 일반적으로 운영에 영향을 미치기 전에 문제를 찾으려 시도하지만, 시스템이 더 복잡해짐에 따라 문제를 해결하기가 점점 더 어려워질 수 있다. 따라서 문제가 발생할 경우, 운영 문제에 미치는 영향력을 줄이기 위해 노력을 기울여야 한다.  

점진적인 배포(progressive delivery)는 고객에게 새로운 버전의 소프트웨어를 점차 늘려가면서 배포하는 방식을 일컫는 포괄적인 용어다. 점진적인 배포는 소규모 고객 그룹에서 새 릴리스의 영향을 평가해서 계속할지 혹은 되돌릴지를 결정하는 개념이다. 점진적인 배포 기술의 예는 카나리아 릴리스(canary release)다.  

기대하는 서비스 동작 방식에 대한 수용 가능한 척도를 정의하면 자동화된 방식으로 점진적인 배포를 제어할 수 있게 된다. 간단한 예로, 95번째 백분위수 대기 시간과 오류율에 대해 허용 가능한 임계 값을 정의하고 이런 측정 값이 충족되는 경우에만 배포를 계속할 수 있다. 그렇지 않으면 최신 릴리스를 자동으로 되돌려, 어떤 일이 일어났는지 분석할 기회를 제공한다.  

많은 조직에서 이런 자동화된 릴리스 복원 기법을 사용한다. 특히 넷플릭스는 이 개념을 사용하는 방법을 상세하게 설명해왔다. 서비스를 위한 점진적인 배포를 제어하는 과정에 도움을 주기 위해 배포 관리 도구로 스피내커(Spinnaker, https://github.com/spinnaker/spinnaker)를 개발했지만 이외에도 이런 개념을 실제로 적용할 수 있는 방법은 많다.  

테스트 대신 자동화된 릴리스 복원을 고려해야 한다는 말을 하려는 것이 아니다. 여러분의 노력에 상응하는 가장 좋은 결과를 얻을 방안을 생각해야 한다. 단순히 문제가 처음 발생한 곳에서 문제를 막기 위한 방법에 초점을 맞추기보다는, 문제가 발생할 경우 문제를 찾아내는 데 노력을 기울임으로써 더 견고한 시스템을 만들 수 있을 것이다.  

이런 기법들이 함께 잘 작동하지만, 횩여 자동화된 복원이 당면한 문제가 아니라고 생각하도라도 점진적인 배포에서 얻는 가치가 여전히 높다는 사실에 주목하자. 점진적인 배포를 수동으로 제어하기만 해도 단순히 새로운 소프트웨어를 모든 사람에게 배포하는 방식과 비교해 한 단계 위로 올라설 수 있다.  

###### 5.8.3.4. 품질 피드백 주기의 지속적인 개선  
<br/>

테스트의 수행 방식과 수행 대상은 우리가 지속적으로 고민해야 하는 과제다. 애플리케이션을 어떻게, 어디서 테스트할지를 조정하려면, 개발 프로세스를 전반적으로 살펴볼 수 있는 컨텍스트를 이해하는 사람들이 필요하다. 즉 상용 서비스에서 결합이 증가하고 있는 시스템 영역을 다루려면 새로운 테스트를 추가할 필요성을 식별할 수 있는 사람과 피드백 주기를 개선하기 위해 이미 커버리지가 있을 때 테스트를 제거할 수 있는 사람을 확보해둬야 한다. 요컨대, 이는 빠른 피드백의 필요성과 시스템의 안전성 사이에서 균형을 유지하는 것이다. 새 테스트를 추가할 때와 마찬가지로, 잘못된 테스트를 기꺼이 식별하고 제거하거나 교체할 수 있어야 한다.  

#### 5.9. 전역 최적화와 지역 최적화 비교  
<br/>

지역적 의사결정에 더 많은 책임이 있는 팀의 모델을 수용하고 아마도 그들이 관리하는 마이크로서비스의 전체 수명주기를 소유하고 있다고 가정하면, 지역적 의사결정과 더 전역적 고려사항 사이에서 균형을 맞춰야 하는 지점에 도달하게 된다.  

이 문제가 모습을 드러내는 예로서, 송장 발행, 통지, 주문 처리 서비스를 관리하는 세 팀을 고려해보자. 오라클을 잘 아는 송장 발행 팀은 오라클 데이터베이스를 사용하기로 결정했다. 통지 팀은 프로그래밍 모델에 잘 맞는 몽고DB를 사용하고 싶어 한다. 한편 주문 처리 팀은 이미 사용 중인 PostgreSQL을 사용하기를 원한다. 각 결정을 차례로 살펴보면 저마다 일리가 있으며, 각 팀이 기술을 선택한 이유를 이해할 수 있다.  

하지만, 한발 물러나서 큰 그림을 본다면 조직으로서 여러분은 다소 유사한 기능을 갖춘 3가지 데이터베이스에 대한 기술을 구축하고 라이선스 비용을 지불하기를 원하는지 자문해야 한다. 데이터베이스 하나만 채택해 모두에게 완벽하지는 않지만 대다수 사람에게 충분하다는 사실을 인정하는 편이 더 낫지 않을까? 지역적으로 무슨 일이 일어나고 있는지 확인하는 능력이나 이를 전반적인 컨텍스트에 적용하는 능력이 없다면, 어떻게 이런 종류의 결정을 내릴 수 있을까?  

##### 5.9.1. 문제가 드러나는 방식  
<br/>

동일한 문제를 여러 팀이 각기 다른 방식으로 해결했지만, 어느 누구도 자신들이 같은 문제를 해결하려고 노력한다는 사실을 깨닫지 못했음을 인식할 때, 흔히 이 문제가 부상하게 된다. 시간이 지나면 이 문제는 엄청나게 효율을 떨어뜨린다.  

호주의 부동산 회사인 REA의 사람들과 대화를 나눈 적이 있다. 수년 동안 마이크로서비스를 구축하고 나서, 그들은 팀이 서비스를 배포할 수 있는 방법이 너무나도 다양하다는 사실을 깨닫게 됐다. 다양한 배포 방식 때문에 한 팀에서 다른 팀으로 이동하게 되면 새로운 작업 방식을 익혀야 하는 문제가 발생했다. 또한 각 팀이 수행한 중복 작업을 정당화하기도 어려워졌다. 결국 사람들은 이 문제를 처리하는 공통적인 방식을 고안하기 위해 몇 가지 추가 작업을 진행하기로 결정했다. 대체로 점심 식사를 하면서 우연히 흘려 들은 이야기를 통해 이런 문제를 알게 될 것이다. 실무 공동체와 같은 교차 기능 팀이 있을 경우 이런 유형의 문제를 훨씬 더 일찍 발견할 수 있다.  

##### 5.9.2. 문제가 드러나는 시점  
<br/>

+ 정보 사일로: 특정 집단이나 조직 내에서만 통용되는 정보의 관리 체계  

이 문제는 시간이 지남에 따라 다중 팀 조직에서 발생하는 경향이 있으며, 특히 팀이 업무를 수행하는 방식에 대해 더 많은 자유를 주는 조직에서 흔히 나타난다. 마이크로서비스를 목표로 하는 프로젝트 초기에 이 문제가 발생하리라고 기대해서는 안 된다. 아마도 어떻게 진행해야 할지에 대한 명확한 이해를 공유하는 선에서 시작할 것이다. 시간이 지남에 따라 각 팀은 점점 더 지역적인 문제에 집중하게 될 것이며 이를 기반으로 팀이 문제를 해결하는 방법을 최적화할 것이므로, "이것이 우리가 일하는 방식"이라는, 팀 간에 서로 공유하는 핵심 관점이 이동하기 시작한다.  

조직이 갑작스레 커지고 난 뒤 이런 문제가 제기되는 광경이 종종 목격할 수 있다. 짧은 시간 내에 많은 개발자가 유입되면 개별적으로 이뤄지는 정보 공유 방식을 확장하기가 더 어려워진다. 이는 연결이 필요할 수도 있는 더 많은 정보 사일로를 만들어낸다.  

서비스의 집단 소유권은 문제 해결 관점에서 어느 정도의 일관성을 필요로 하기 때문에, 잘 실행한다면 문제를 피하거나 최소화하는 데 도움이 될 것이다. 한편, 집단 소유권을 원한다면 이렇듯 정보 사일로가 늘어나는 문제를 해결해야 한다. 그렇지 않으면 집단 소유권의 확장성은 떨어질 것이다.  

##### 5.9.3. 잠재적인 해법  
<br/>

변경 비용이 높을수록 영향도 더 커지고 의사결정 이면에 폭넓은 합의가 필요할 것이다. 영향이 작을수록 되돌리기도 더 쉬워지고 더 많은 결정을 지역 팀에 맡길 수 있다.  

<table>
	<tbody>
		<tr>
			<td>
				호스팅 회사 변경<br/>
				공개 API 변경
			</td>
			<td>
				전체 조직에 걸쳐 새로운 프로그래밍 언어 채택<br/>
				데이터베이스 변경
			</td>
			<td>
				새로운 프로그래밍 언어 실험<br/>
				오픈소스 라이브러리 선정
			</td>
		</tr>
		<tr>
			<td>←</td>
			<td>-</td>
			<td>→</td>
		</tr>
		<tr>
			<td>비가역적</td>
			<td></td>
			<td>가역적</td>
		</tr>
		<tr>
			<td>
				전반적인 승인 필요<br/>
				의사결정을 변경하기가 아주/거의 불가능함<br/>
				신중한 숙고가 필요함
			</td>
			<td></td>
			<td>
				더 지역화된 의사결정<br/>
				의사결정을 반복하는 비용이 적게 듦<br/>
				즉흥적인 의사결정도 가능함/괜찮음
			</td>
		</tr>
	</tbody>
</table>
<br/><br/>

팀원들이 내린 결정이 이 스펙트럼의 비가역적 방향 또는 가역적 방향의 양극단으로 향할 수 있다는 사실을 인식하게 만드는 것이 비결이다. 결정이 비가역적인 방향으로 갈수록 팀 경계 밖의 사람들이 의사결정에 참여할 가능성이 높아진다. 이런 방식이 제대로 작동하려면, 겹칠 수 있는 부분을 파악하기 위해 팀은 최소한 문제와 관련해 기본적으로 더 큰 그림을 이해해야 하며, 이런 문제를 표면으로 끌어내 다른 팀의 동료가 참여할 수 있는 네트워크도 필요할 것이다.  

간단한 메커니즘으로는, 각 팀에서 최소 한 명의 기술 리더가 이런 문제를 해결할 수 있는 기술 교차 그룹의 일원이 되게 하는 것이 합리적이다. 이 그룹의 의장은 CTO나 수석 설계자 또는 회사의 전체 기술 비전을 담당하는 사람이 맡을 수 있다.  

이 교차 기능 팀은 양방향으로 작동할 수 있다. 더 큰 포럼에서 팀이 논의하고 싶은 지역적인 문제를 표면으로 끌어낼 뿐만 아니라 사람들이 공통 문제를 가져올 수 있는 장소를 제공한다. 팀 간에 의사소통이 없다면, 우리가 각자 다른 방식으로 지역적으로 문제를 해결하고 있다는 사실이나 전역적으로 문제를 해결하는 것이 타당할 거라는 사실을 어떻게 알 수 있겠는가?  

조직의 특성에 따라 임의적인 비공식 프로세스에 의존할 수도 있을 것이다. 예를 들어 몬조(Monzo)에서 사람들은 내부적으로 '제안서'라고 지칭하는 자유 형식의 문서를 제출할 수 있다. 이 문서는 공유된 공간에 게시되며, 사내에 새로운 제안이 게시됐음을 슬랙을 통해 알려준다. 이때 관심있는 사람들이 있다면 제안을 논의하고 개선하는 과정에 도움을 줄 수 있다. 이런 제안은 완성된 결과물이 아니며, 실제로도 변경 가능하도록 열려 있어야 한다는 기대치가 있다. 이것은 부분적으로 의사소통과 책임 공유를 둘러싼 조직의 문화 때문에, 몬조에 더욱 효과가 있어 보인다.  

근본적으로 각 조직은 전역적 의사결정과 지역적 의사결정 사이에서 올바른 균형을 차자야 한다. 팀에 얼마나 많은 책임을 부여해야 여러분이 행복해질까? 여러분은 중앙에서 얼마나 많은 통제력을 유지하고 싶은가? 팀에 더 많은 책임을 부여할수록 더 큰 자율권의 이점을 얻겠지만, 문제 해결 방법의 일관성이 떨어질 수 있다는 반대급부도 준재한다. 중앙에서 이끌수록 합의가 많이 필요하므로 속도도 느려질 수 있다. 적합한 두 세력의 균형을 달성하는 사실을 인식하고 있어야 하며, 시간이 지남에 따라 이런 균형을 조정할 수 있도록 올바른 정보를 수집하고 있는지 확인해야 한다.  

#### 5.10. 견고성과 회복탄력성  
<br/>

분산 시스템은 모놀리스 시스템에 익숙한 이들에겐 꽤 낯설, 엄청난 장애 모드를 드러낼 수 있다. 네트워크 패킷이 손실되거나 네트워크 호출 시간이 초과될 수 있으며 컴퓨터가 죽거나 응답을 멈출 수도 있다. 이런 상황은 전통적인 모놀리스 애플리케이션 등의 단순한 분산 시스템에서는 드물지만 서비스 수가 증가함에 따라 점점 더 흔히 발생하게 된다.  

##### 5.10.1. 문제가 드러나는 방식  
<br/>

불행히도 이런 문제는 운영 환경 설정에서 발생할 가능성이 꽤 높다. 전통적인 개발과 테스트 주기에 걸쳐, 짧은 시간 동안에만 운영 환경과 유사한 환경을 재현하고 있다. 이런 경우는 드물기 때문에 발생할 가능성이 적으며, 문제가 발생하면 종종 묵살된다.  

##### 5.10.2. 문제가 드러나는 시점  
<br/>

서비스 수가 증가하고 서비스 요청 수가 증가하게 되면 회복탄력성 문제가 발생할 때 점점 더 대응 능력이 취약해질 것이다. 서비스의 상호 연결이 더 늘어날수록 연속적인 장애나 매입(back pressure) 같은 문제를 겪을 가능성도 더 높아질 것이다.  

##### 5.10.3. 잠재적인 해법  
<br/>

좋은 출발점은 개별 서비스 요청에 대해 몇 가지 질문을 스스로에게 하는 것이다. 이 호출이 실패할지도 모르는 시나리오를 알고 있는가? 호출이 실패하면 무엇을 해야 할지 알고 있는가?  

일단 이 질문에 답을 찾았다면 다양한 해법을 살펴볼 수 있을 것이다. 시간적 결합도를 피하기 위해 비동기 통신을 도입하는 등 서비스를 상호 격리시키는 방식이 도움이 될 수도 있다. 합리적인 시간 초과를 사용하면 느린 다운스트림 서비스로 몰리는 자원 경합을 피할 수 있으며, 회로 차단기 패턴 등으로 빠르게 실패를 일으켜서 배압 문제를 피할 수도 있다.  

서비스의 여러 사본을 실행하면 바람직한 상태 관리를 구현할 수 있는 플랫폼(예: 서비스가 중단되면 서비스를 다시 시작하게 보장할 수 있음)처럼, 인스턴스가 죽는 경우에 도움이 될 수 있다.  

회복탄력성은 단지 몇 가지 패턴을 구현하는 것으로 끝나지 않는다. 회복탄력성은 전체 작업 방식에 관한 것이며, 불가피하게 발생할 수 있는 예측 불가능한 문제를 처리하기 위해 준비할 뿐만 아니라 필요에 따라 업무 관행을 발전시키는 조직을 구축하는 것이다. 이 아이디어를 실천할 수 있는 구체적인 방법 중 하나는 운영 문제가 발생할 때 상황을 정리해 문서화하고 배운 내용을 꾸준히 기록하는 것이다. 초반의 문제를 해결하거나 우회하고 난 뒤 너무 빨리 다음 단계로 넘어가는 조직을 본 적이 많다. 물론 몇 개월이 지나면 동일한 문제는 다시 발생할 것이다.  

#### 5.11. 외톨이 서비스  
<br/>

보유한 놀라운 기술과 현재 구축 중인 믿기 어려울 만큼 복잡하며 확장 가능한 대규모 시스템을 고려하면, 여기서 가장 따분한 몇 가지 문제를 고민하는 상황은 이상해 보인다. 한 예로, 많은 조직이 자신들의 현재 역량, 위치, 소유자를 정확히 파악하는 데 어려움을 겪고 있다는 사실이다.  

마이크로서비스가 원래 목적에 더욱 집중하게 되면, 더 많은 서비스가 변경 없이 몇 주, 몇 달 또는 몇 년간 행복하게 운영되고 있음을 발견하게 될 것이다. 한편으로는 이런 상황이 바로 정확히 원하는 목표다. 독립적인 배포 가능성이 매력적인 개념인 이유는 시스템의 나머지 부분을 안정적으로 유지해주기 때문이다. 변경할 필요가 없는 시스템의 안정성을 유지한다는 개념은 멋지다.  

근본적으로 이런 서비스는 회사의 어느 누구도 소유하거나 책임을 지지 않기 때문에, 이런 서비스를 외톨이 서비스(Orphaned Services)라고 부른다.  

##### 5.11.1. 문제가 드러나는 방식  
<br/>

출처는 기억나지 않지만, 오래된 사무실의 벽장에서 낡은 서버가 발견되었다는 이야기를 들은 적이 있다. 어느 누구도 낡은 서버가 그곳에 있었다는 사실을 기억하지 못하지만, 이 서비는 무엇을 하든 지금도 행복하게 돌아가고 있다. 새로 발견된 컴퓨터가 어떤 일을 하고 있었는지 아무도 정확히 기억하지 못하기 때문에 사람들은 두려움에 컴퓨터를 끄지 못한다. 마이크로서비스도 일부는 마찬가지일 것이다. 마이크로서비스를 만들고 나서 (가정하자면) 잘 동작되고 있지만, 이런 서비스로 무엇을 해야 할지 모르는 똑같은 문제를 느끼며, 두려움 때문에 변경을 주저한다.  

근본적인 문제는 마이크로서비스가 작동을 멈추거나 변경이 필요한 경우, 사람들이 무엇을 해야 할지 몰라서 우왕좌왕한다는 점이다. 해당 서비스의 소스 코드가 어디에 있는지 몰라 난감했다고 이야기하는 여러 팀을 만나봤는데, 이는 정말 심각한 문제다.  

##### 5.11.2. 문제가 드러나는 시점  
<br/>

이 문제는 일반적으로 마이크로서비스를 꽤 오랫동안 사용해온 조직에서 발생한다. 즉 너무 오래 돼서 모두들 이 서비스가 어떤 작업을 수행했는지를 잊은 지 오래다. 이 마이크로서비스에 관련된 사람들은 자신이 한 일을 잊었거나 아마 이미 회사를 떠났을지도 모른다.  

##### 5.11.3. 잠재적인 해법  
<br/>

서비스의 집단 소유권을 행사하는 조직이 이런 문제에 덜 취약할 거라는 (검증되지 않은) 가설을 세웠다. 주된 이유는 개발자들이 서비스에서 서비스로 이동하고 변경할 수 있게 만드는 메커니즘을 이미 구현했어야 하기 때문이다. 이런 종류의 조직은 서비스 간 컨텍스트 전환 비용을 줄이기 위해 아마도 언어와 기술 선택을 이미 제한하고 있을 것이다. 또한 서비스 변경, 테스트, 배포와 관련해 공통 도구를 보유하고 있을 것이다. 서비스가 마지막으로 변경된 이후에 이런 공통 관행이 바뀌었다면 물론 이것은 도움이 되지 않을 수도 있다.  

이런 문제를 경험한 여러 회사와 대화를 나눠 보니, 결국 서비스를 둘러싼 메타데이터를 수집하는 데 도움이 되는 간단한 사내 레지스트리를 작성했다는 이야기를 들었다. 이런 레지스트리 중 몇몇은 단순히 소스 코드 저장소를 크롤링해 메타데이터 파일을 찾아 이를 기준으로 서비스 목록을 작성한다. 이 정보는 컨설(Consul)이나 etcd 같은 서비스 탐색 시스템에서 제공하는 실제 데이터와 병합되어, 어떤 항목이 실행 중인지, 그리고 누가 업무를 알고 있는지를 더 자세히 알 수 있게 해준다.  

&lt;파이낼셜 타임즈&gt;는 이 문제를 해결하기 위해 비즈 옵스(Biz Ops) 도구를 만들었다. 이 회사는 전 세계에 분산되어 일하는 팀이 개발한 서비스를 수백 개 보유하고 있다. 비즈 옵스 도구는 네트워크나 파일 서버 같은 IT 인프라스트럭처 서비스에 대한 정보 외에도 마이크로서비스에 대한 유용한 정보를 찾을 수 있는 단일 장소를 제공한다. 그래프 데이터베이스 위에 구축된 이 시스템은 수집하는 데이터와 정보를 모델링할 수 있는 방법에 대한 유연성이 상당히 뛰어나다.  

서비스 레지스트리 등이 도움을 줄 수 있지만 외톨이 서비스가 레지스트리 구성보다 선행하는 경우라면 어떻게 할까? 핵심은 새로 발견된 '외톨이' 서비스를 다른 서비스 관리 방법과 일치시키는 것이다. 이를 위해서는 (강한 소유권인 경우) 기존 팀에 소유권을 할당하거나, (집단 소유권인 경우) 개선 대상 서비스를 위한 작업 항목을 제시해야 한다.  

### 부록 B. 패턴 목록  
<br/>

+ 경계 컨텍스트 단위의 저장소(repository per bounded context)  
도메인의 다양한 부분에서 단일 저장소 계층을 분해하는 방식으로 서비스 분한을 더 쉽게 만든다.  

+ 공유 데이터베이스(shared database)  
하나의 데이터베이스는 둘 이상의 서비스 간에 공유된다.  

+ 교살자 무화과 애플리케이션(strangler fig application)  
기존의 모놀리스 주변을 새로운 마이크로서비스 아키텍처로 래핑한다. 모놀리스에서 마이크로서비스로 마이그레이션된 기능을 사용하기 위한 호출이 전환되며, 다른 호출은 변경되지 않은 채로 남아 있다.  

+ 다중 스키마 저장소(multischema storage)  
일반적으로 공유 데이터베이스에서 서비스별 데이터베이스 모델로 마이그레이션하는 동안 다른 데이터베이스들에 있는 데이터를 관리한다.  

+ 데이터베이스 래핑 서비스(database wrapping service)  
파사드 서비스가 기존의 공유 데이터베이스 앞에 배치되어, 서비스가 데이터베이스의 직접적인 사용으로부터 마이그레이션하게 만든다.  

+ 데이터베이스 뷰(database view)  
데이터베이스의 일부를 숨길 수 있도록 뷰는 기반 데이터베이스에서 투사된다.  

+ 데이터 소유권 변경(change data ownership)  
모놀리스에서 마이크로서비스로 진실의 원천을 옮긴다.  

+ 데이터 접근 계층으로 작동하는 모놀리스(monolith as data access layer)  
데이터베이스에 직접 접근하는 대신 API를 통해 모놀리스가 관리하는 데이터에 접근한다.  

+ 변경 데이터 캡처(change data capture)  
기반 데이터 저장소의 변경사항을 다른 이해관계자에게 전송한다.  

+ 병행 실행(parallel run)  
새로운 기능이 올바르게 작동하도록 기능이 동일한 2가지 구현을 나란히 실행한다.  

+ 서비스 인터페이스로서 데이터베이스(DaaS) 인터페이스(Database as a Service interface)  
전용 데이터베이스를 사용해 내부 서비스 데이터에 대한 읽기 전용 접근을 제공한다.  

+ 애플리케이션에서 데이터 동기화(synchronize data in application)  
단일 애플리케이션 내에서 2가지 진실의 원천 간에 데이터를 동기화한다.  

+ 예광탄 기록(tracer write)  
마이그레이션 과정에서 2가지 진실의 원천을 허용하면서 특정 진실의 원천에서 다른 진실의 원천으로 데이터를 점진적으로 마이그레이션한다.  

+ 외래 키를 코드로 이동(move foreign key to code)  
외래 키 관계의 관리와 강제를 단일 데이터베이스에서 서비스 계층으로 옮긴다.  

+ 전용 참조 데이터 스키마(dedicated reference data schema)  
모든 정적 참조 데이터를 저장하는 전용 데이터베이스. 다른 여러 서비스가 이 데이터베이스에 접근할 수 있다.  

+ 정적 참조 데이터 라이브러리(static reference data library)  
필요로 하는 각 마이크로서비스와 함께 패키지로 묶을 수 있는 라이브러리 또는 구성 파일로 정적 참조 데이터를 이동한다.  

+ 중복 정적 참조 데이터(duplicate static reference data)  
정적 참조 데이터를 마이크로서비스의 데이터베이스에 복사한다.  

+ 집계를 외부에 공개하는 모놀리스(aggregate exposing monolith)  
모놀리스가 관리하는 엔티티에 마이크로서비스가 접근할 수 있게 모놀리스에서 도메인 집계를 외부에 공개한다.  

+ 추상화에 의한 분기(branch by abstraction)  
동일한 코드베이스에 동일한 기능의 2가지 구현이 동시에 공존해 기존 구현을 대체할 수 있을 때까지 새로운 구현을 점진적으로 개발하게 만든다.  

+ 테이블 분할(split table)  
서비스 분해에 앞서 테이블을 두 부분으로 쪼갠다.  

+ 협업자 데코레이터(decorating collaborator)  
모놀리스로 전송된 요청과 결과로 다시 전송되는 응답을 중간에 훔쳐보는 방법으로 별도 마이크로서비스에서 실행되는 기능을 트리거한다.  

+ UI 컴포지션(UI composition)  
여러 작은 구성 요소를 조립해 단일 사용자 인터페이스를 표현한다.  

### 부록 C 한국어판 특별 부록. 기술의 진화로 짚어보는 마이크로서비스 도입의 허와 실 - 목표나 결과가 아닌, 여정으로서 바라보는 마이크로서비스  
<br/>

#### C.1. 유닉스 스타일의 파이프라인 구축 관점  
<br/>

유닉스 개발 과정에서 가장 중요한 철학 중 하나는 한 가지 일을 잘하는 작은 프로그램을 여러 개 연결해서 크고 복잡한 작업을 하는 파이프라인 작업 방식이다. 유닉스 설계에 기여한 더글러스 매클로이는 다음과 같이 유닉스 철학을 명세했다(https://archive.org/details/bstj57-6-1899/page/n3/mode/2up).  

(1) 각 프로그램을 한 가지만 잘하게 만든다. 새로운 작업을 하려면, 새로운 '기능'을 덧붙이는 방법으로 옛날 프로그램을 복잡하게 만드는 대신 새로 구현한다.  
(2) 모든 프로그램의 결과가 아직 알려지지 않은 다른 프로그램의 입력이 되게 기대한다.  
(3) 출력을 부가 정보로 어지럽히지 않는다. 엄격한 컬럼 형식이나 이진 입력 형식을 피한다. 상호 대화식 입력을 고집하지 않는다.  
(4) 소프트웨어 설계와 구현을 초기에 이상적으로는 몇 주 내에 시도하며, 운영체제도 예외는 아니다. 어설픈 부분은 버리고 재구현하는 과정에 주저하지 마라.  

초기 유닉스가 아니라 현대적인 마이크로서비스 관점에서 바라봐도 각 항목은 상당히 타당하다. 1번은 모든 것을 하나로 뭉뚱그려 놓은 모놀리스를 개별 계약으로 분해나는 방식을 떠올리게 만든다. 2번은 각 기능별로 분해된 마이크로서비스 사이에서 RESTful API 호출로 필요한 작업을 처리하는 방식을 떠올리게 만든다. 3번은 마이크로서비스에 대한 RESTful API 호출 결과 응답 상태를 나타내는 응답 코드와 실제 내용을 담은 JSON 객체로 구성된 형식을 떠올리게 만든다. 4번은 애자일 개발과 리팩터링에서 강조하는 내용과 일치한다. 마이크로서비스를 설명할 때 큰 기능을 여러 작은 기능으로 분해하는 방식을 많이 사용하게 되는데, 개별 기능이 유기적으로 결합되어 하나의 큰 기능으로 동작하는 방식은 정확하게 유닉스 파이프라인 방식과 일치한다.  

에릭 S. 레이먼드가 집필해서 2003년도에 출간된 「The Art of Unix Programming」에서 모놀리스(monolith)라는 단어는 총 16회 등장하며, 마이크로시비스 공동체가 나중에 강조하기 시작한 '똑똑한 종단점과 멍창한 파이프'라는 접근 방식을 강조한다. 애플리케이션은 독자적인 도메인 로직을 갖추고 요청을 받아들여 적절하게 비즈니스 로직을 적용한 다음에 응답을 만들어내는 전통적인 유닉스 관점에서 필터처럼 동작해야 마땅하다는 논리다. 유닉스 철학에 따라 프로세스 내부에서 직접적인 함수 호출을 대신해 파이프로 표준 입출력을 주고받는 개별 프로그램과 유사하게 최근에 마이크로서비스에서는 월드와이드웹의 원칙과 프로토콜을 사용해 HTTP 요청-응답으로 필요한 서비스를 요청하고 응답을 받는 RESTful API 형태의 서비스를 구성한다는 사실에 다시 한번 주목하면 좋겠다.  

#### C.2. 정보 은닉에 따른 설계 관점  
<br/>

정보 은닉(information hiding)이라는 개념은 구첵적인 구현에서 설계 결정을 분리하기 위한 원칙이며, 구조적인 프로그래밍과 객체지향 프로그래밍으로 이어지는 현대적인 소프트웨어 개발의 토대를 다지는 과정에서 중요한 영향을 미쳤다. 정보 은닉을 통해 추상화되는 생명력을 얻은 개념이 바로 모듈이다. 하지만 정보 은닉, 모듈화, 캡슐화와 같은 개념은 여전히 혼용해서 사용되고 있으며, 심지어 영문 위키백과의 정보 은닉 항목조차도 검증이 필요하다는 경고 문구가 뜨는 상황이므로 정확하게 짚고 넘어갈 필요가 있다.  

소프트웨어 공학의 태두인 데이비드 L. 파나스는 1972년에 발표한 기념비적인 논문인 「On the Criteria To Be Used in Decomposing Systems into Modules」(https://dl.acm.org/doi/10.1145/361598.361623)에서 큰 시스템을 프로그램 모듈로 분해하는 방법에 대해 기준을 제시했다. 파나스의 독창적인 아이디어는 모듈과 모듈화에 대한 정의라고 볼 수 있다. 파나스에 따르면 모듈은 하위 프로그램(서브루틴, 함수)가 아니라 책임을 할당하는 단위가 되어야 마땅하며, 모듈화는 독립적인 모듈을 대상으로 하는 작업을 시작하기 앞서 반드시 끝내야 하는 설계를 포함해야 한다. 이렇게 모듈화된 프로그램의 장점은 다음과 같다.  

(1) 관리성: 다른 모듈에 포함된 코드의 지식이 거의 없어도 모듈을 개발할 수 있으므로 개발 기간이 짧아져야 한다.  
(2) 제품 유연성: 다른 모듈을 변경할 필요 없이 특정 모듈에 대한 대규모 변경이 가능해야 한다.  
(3) 이해 용이성: 시스템에서 한 번에 모듈 하나만 연구가 가능해야 한다. 따라서 시스템을 이해하기가 더 쉬워지므로 전체 시스템에 대한 설계도 향상된다.  

모듈화 프로그래밍 기법이 등장하면서 전체 시스템에 대한 재조립 없이 필요한 모듈만 개발하고 재조립하고 대체할 수 있게 되었다. 이런 특성은 대규모 시스템 개발 과정에서 진가를 발휘하게 된다. 정보 은닉이 나오기 전까지는 물리적인 방식(즉 출력물 기준으로 72행 등)이나 자주 사용하는 유틸리티 기능을 포함한 함수 단위로 프로그램을 나눴기 때문에 복잡한 프로그램을 여러 개발자가 동시에 진행하기가 쉽지 않았다. 모듈과 함수 개념이 혼재된 상황에서는 모듈을 설계하기 위한 일관된 기준이 없기 때문에 경계를 명확하게 나눠서 작업을 할당하기가 쉽지 않았다. 하지만, 변하지 않는 공개된 계약인 인터페이스와 인터페이스 이면에 감춰진 구현 내역으로 분리하고 추상화된 작업 단위로 모듈을 바라봄에 따라 순차적으로 진행하는 방식에서 벗어나 작업을 개발자별로 나눠 동시에 진행하는 방식이 가능해졌다.  

마이크로서비스도 내부에서 어떤 프로그래밍 언어와 어떤 데이터베이스를 사용하는지 감추며 잘 정의된 API 종단점으로 외부 인터페이스를 정의하기 때문에 정보 은닉 설계 사상을 정통으로 계승했다고 볼 수 있다. 서비스의 경계를 확정하고 이를 기준으로 서비스를 분해하는 기법은 책임을 할당한다는 측면에서 정보 은닉에서 모듈을 나누는 기법과 상당히 유사하다는 사실에 주목할 필요가 있다.  

#### C.3. 분산 시스템 관점  
<br/>

모놀리스라고 해서 항상 모든 작업을 단일 시스템에서 수행하지는 않는다. 예를 들어 현대적인 모놀리스는 부하 분산기, 웹 서버, 애플리케이션 서버, 데이터베이스 서버를 작업 부하 패턴에 맞춰 다른 물리 서버나 가상 서버에 배포함으로써 확장이 가능하게 만드는 경우가 일반적이다. 작업을 여러 서버에 분산하는 노력도 마이크로서비스의 전유물이 아니다. 원격 프로시저 호출 규약인 RFC(Remote Procedure Call)는 1988년에 썬 마이크로시스템에서 RFC1057로 제안됐으며, 병렬 컴퓨팅에 널리 사용되는 MPI(Message Passing Interface)는 1992년 학회에서 제안됐다. 게다가 NFS(Network File System)로 대표되는 분산 파일 시스템은 썬 마이크로시스템즈가 1984년에 개발해서 지금까지도 널리 쓰이고 있기 때문에 역사와 전통이 깊다.  

하지만 분산 시스템 아키텍처가 저절로 마이크로서비스 아키텍처로 진화하지는 못한다. 앞서 설명한 기존의 분산 시스템 기술은 결합도가 상당히 높기 때문에 유연하게 개발하고 배포하기가 상당히 까다롭다는 문제점이 있다. 따라서 이런 문제점을 해소하기 위해 마이크로서비스 아키텍처는 필요에 따라 HTTP를 기반으로 하는 동기식 통신 방식(RESTful API)과 메시지 큐를 기반으로 하는 비동기식 통신 방식(이벤트 기반 통신 방식)을 조합해서 사용하며 복잡도를 줄이기 위해 '똑똑한 종단점과 멍청한 파이프'라는 원칙을 장려한다.  

하지만 여기서 중요한 고려사항이 하나 있다. 마이크로서비스를 통합하는 과정에서 이상적으로는 마이크로서비스 간의 통신을 최소화해야 하며, 마이크로서비스 간의 통신은 하나도 없는 경우가 최선이다. 하지만 이런 요건응 비현실적이므로 통합 과정에서 필연적으로 내부 통신이 일어나기 마련이다. 마이크로서비스의 목표에 따르면 내부 다른 서비스에 장애가 발생하더라도 자율적인 방식으로 자신의 서비스는 계속해서 제공해야 하므로, 비동기식 통신이 중요한 역할을 맡게 된다. 만일 마이크로서비스 내부 통신을 비동기식 통신이 아니라 동기식 통신을 사용한다면 어떤 일이 벌어질까? 다음과 같은 문제가 발생한다.  

+ 마이크로서비스 간 동기 통신이 연쇄 작용을 일으킬 경우 클라이언트 쪽에 대한 전체 대기 시간이 길어진다.
+ 마이크로서비스 간 동기 통신이 연쇄 작용을 일으키는 과정에서 연결 고리가 하나만 끊어지더라도 타임아웃이 걸릴 때까지 대기해야 하므로 성능에 나쁜 영향을 미친다.
+ 일부 마이크로서비스가 실패하는 경우 회복하지 않는 상황이 발생할지도 모른다.  

내부적으로 여러 마이크로서비스에 통신을 해야 하기 때문에 외부에서 접속하는 경우에도 분산 시스템을 제대로 활용할 수 있는 아키텍처를 수립할 필요가 있다. 마이크로서비스에서는 API 게이트웨이 패턴을 사용해 마이크로서비스의 특정 그룹에 대해 단일 진입점을 제공하는 방법을 사용한다. 만일 마이크로서비스 외부의 클라이언트가 API 게이트웨이 패턴을 사용하지 않고 개별로 내부 서비스와 통신하게 만들면 어떤 일이 벌어질까? 다음과 같은 문제가 발생한다.  

+ 강결합: 클라이언트가 마이크로서비스 내부와 강하게 결합되기 때문에 클라이어트에서 마이크로서비스의 분해 방식을 알아야 한다.
+ 호출 회수 증가: 클라이언트에서 단일 페이지를 구성하기 위해 여러 차례 서비스를 호출하므로 대기시간이 증가할 수 있다.
+ 보안: 모든 마이크로서비스가 외부에 노출될 경우 공격 표면적이 넓어지므로 보안이 취약해진다.  

이렇듯 분산 시스템은 마이크로서비스 아키텍처가 존재하게 만드는 중요한 기술이지만 가장 난이도가 높기 때문에 각별한 주의를 요구한다.  

#### C.4. '배포' 관점  
<br/>

#### C.5. 마이크로서비스에도 은총알은 없다  
<br/>

##### C.5.1. 마이크로서비스는 성공의 필요충분조건이 아니다.  
<br/>

마이크로서비스의 분산 시스템에 대한 경험이 풍부하지 않은 스타트업에서 처움부터 바로 마이크로서비스 아키텍처로 제품이나 서비스를 설계할 경우 시간은 지체되고 성능은 떨어지며 기능은 부족한 상황이 벌어지기 마련이다. 우선 동작하게 만들고, 다음으로 제대로 동작하게 고치고, 마지막으로 빠르게 동작하게 만들라는 격언이 있듯이 처움부터 마이크로서비스 아키텍처로 가기 전에 먼저 모놀리스 아키텍처부터 테스트하는 편이 비즈니스 경계면을 파악하고 마이크로서비스로 분해할 기준을 마련하는 과정에서 시행착오를 줄일 수 있다.  

또한 마이크로서비스 아키텍처는 팀 구조와 팀 문화에 서로 영향을 미치기 때문에 단순 기술 도입을 넘어서는 어려움이 존재한다. 마이크로서비스가 팀 자율성을 높이고 개발팀 확장을 가능하게 만들고 신기술 수용을 가속화하는 장점을 제공하지만 결국 이 모든 성과를 거두는 주체는 사람이므로, 팀의 체질 개선이 이뤄지지 않으면 기술을 쫓아다니다 정작 중요한 사업을 챙기지 못하기에 역풍에 직면하게 된다. 마이크로서비스는 목표가 아니며 수단이라는 사실을 인식하고 회사 목표에 맞는 아키텍처인지를 신중하게 고민할 필요가 있다.  

##### C.5.2. 분산 시스템의 난이도를 과소평가하지 마라  
<br/>

네트워크는 실패하고 네트워크 설정은 여기저기서 꼬이기 마련이므로 마이크로서비스는 특히 환경의 영향을 많이 받는다. 소프트웨어 일부가 동작하지 않는 경우 자체 문제인지 환경 문제인지부터 따지고 들어가야 한다. 모놀리스의 경우에는 개발과 운여이 분리되어 각각 전문성을 최대한 발휘하게 팀이 구축되어 있지만 마이크로서비스의 경우에는 개발과 운영이 합쳐진 데브옵스 팀일 가능성이 높으므로 경험이 충분히 쌓이기 전까지 복잡한 네트워크 장애를 분석하고 해소하기가 쉽지 않다.  

찰스 페로(Charles Perrow)가 주창한 정상 사고(Normal Accident)는 '비정상' 상황이 아닌 '정상' 상황에서 사소한 오류가 누적되면서 비선형적으로 연쇄 반응을 일으켜 치명적인 사고를 일으킨다는 이론이다(「Normal Accidents: Living with High-Risk Technologie」. Princeton University Press, 1999). 마이크로서비스의 특성인 분산 시스템은 복잡성을 내포하고 있기 때문에 특히 정상 사고를 일으킬 가능성이 매우 높다. 서비스 호출을 위한 통신에 실패하면 재시도한다 정도의 방어책으로는 복잡하게 얽힌 서비스에서 발생하는 다양한 문제를 해소할 수 없다. 메시지 큐를 사용한 내부 통신인 경우에는 실패에 대한 저항력이 높아지긴 하지만 메시지 통신 규약(스키마)이 변경되는 순간 개별 서비스 수정이 불가피한 상황에 놓이게 된다.  

##### C.5.3. 상태형 서비스인 경우에는 데이터베이스가 가장 큰 문제다  
<br/>

개별 서비스가 독자적인 상태를 유지하지 안흔 무상태형인 경우라면 영속적인 상태 저장이 필요하지 않기 때문에 서비스를 분해하기가 수월하다. 하지만 현실에서는 대부분 상태형 서비스일 가능성이 높으며, 이는 마이크로서비스 분해 과정에서 필연적으로 관계형 데이터베이스 테이블 분리를 암시한다. NoSQL을 사용해 이를 방어할 수 있다고 생각될지도 모르겠지만, 주요 비즈니스 로직이 SQL 쿼리로 되어 있을 경우라면 쉽지 않은 작업이 될 것이다. 특히 조인(JOIN) 연산과 분산 트랜잭션이 크나큰 장애물로 등장하는데, 애플리케이션 수준에서 신중하게 처리하지 않을 경우에 추적과 수정이 힘든 버그가 발생하게 된다.  

또한 상태가 없는 일반 프로그램과는 달리 상태를 담고 있는 데이터베이스는 동작 과정에서 끊임없이 변경되므로 무정지 상태에서 데이터베이스를 분해하거나 스키마에 변경을 가하기가 매우 어렵다. 또한 문제가 발생하거나 사업적인 판단에 의해 서비스를 원상 복구하는 과정에서 백업본을 사용해 데이터베이스를 되돌릴 경우 해당 운영 기간 동안 벌어질 상태 기록이 사라지는 문제도 발생하기에 원상 복구 과정에서 복잡한 마이그레이션 과정을 거쳐야 한다. 설상가상으로 데이터베이스를 분해해서 여러 서버로 분산했다면 이를 원상복구해서 하나로 합치는 작업은 매우 까다로울 것이다.  

##### C.5.4. 디버깅과 모니터링이 고통스럽다  
<br/>

모놀리스의 경우 문제가 발생했을 때 중단점을 걸어 상태를 확인하거나 로그 파일을 열어 증상이 일어날 때까지 추이를 비교적 쉽게 확인할 수 있다. 하지만 마이크로서비스의 경우 비즈니스 로직이 여러 서버에 분산되어 있기 때문에 어떤 서비스에서 시작되었는지부터 찾아내야 한다. 운이 좋아 문제를 일으킨 서비스의 위치를 파악했다고 하더라도 컨테이너 등으로 실행되었을 경우에는 사전에 모니터링 시스템을 구축해놓지 않는 이상 로그 파일 접근이나 프로세스 수준의 디버깅은 시간 소모적인 작업이 되거나 사실상 불가능할 가능성이 높다. 모놀리스의 경우 콜스택을 덤프하는 방법으로 함수 호출 추이를 직관적으로 볼 수 있지만, 마이크로서비스의 경우 개별 서비스 로그 파일을 모두 뒤져 연결하거나 APM(Application Performance Monitoring) 도구를 도입하지 않는 이상 호출 연쇄를 덤프할 방법이 마땅하지 않기에 사건을 재구성하기도 쉽지 않다.  

따라서 마이크로서비스로 이주하려는 팀이라면 스스로가 마이크로서비스 아키텍처에 적합한지 판단하는 동시에 나중에 발생할 고통을 완화하기 위해 분산된 환경에서 동작하는 모니터링 시스템부터 구축하는 편을 권장한다. 만일 초기에 모니터링 시스템 구축이 쉽지 않다고 판단되면 훨씬 더 난이도가 높은 마이크로서비스 이주는 다음으로 미뤄야 마땅할 것이다.  

##### C.5.5. 단위 테스트는 물론이고 자동화된 전 구간 테슽 방법이 마땅하지 않다  
<br/>

모놀리스의 경우에 단위 테스트는 클래스 단위나 모듈 단위로 진행된다. 전 구간 테스트는 스테이징 서버를 구축하고 나서 이를 대상으로 사용자의 행위를 흉내내어 원하는 결과를 얻는지 확인하는 방식으로 진행된다. 마이크로서비스의 경우에 단위 테스트는 개별 서비스 단위로 진행되며, 전 구간 테스트는 개별 서비스를 모두 배포한 다음에 이를 대상으로 사용자의 행위를 흉내내어 원하는 결과를 얻는지 확인하는 방식으로 진행된다. 여기까지는 큰 차이점이 없어 보인다. 하지만 한 단계만 아래로 내려가면 난이도가 급상승하고 있음을 느낄 것이다.  

앞서 언급했지만 단독으로 떨어져 동작하는 서비스는 없으며 다른 서비스와 긴밀하게 협력해서 동작하는 경우가 대부분이다. 따라서 내부적으로는 비동기식 데이터 버스를 통해 요청을 주고 받는 방식을 따르게 되는데, 분산 시스템의 특성으로 인해 통제할 수 없는 외부 요인에 영향을 받기 때문에 단위 테스트가 상당히 어려워진다. 어떤 문제가 발생하면 프로그램 탓인지 환경 탓인지를 구분해야 하는데, 만일 서로 영향을 미친다면? 전 구간 테스트의 경우에는 더욱 복잡한 상황을 초래한다. 개별 서비스를 맡은 여러 팀이 긴밀하게 협력해서 전 구간 테스트를 진행해야 하는데 이는 시간이 오래 걸리고 복잡한 과정을 거쳐야 가능해진다. 게다가 자율성을 강조하기 때문에 테스트 소유권도 분산된 가능성이 높아지고 환경과 다른 팀의 상황이 어떻게 될지 모르므로 테스트 케이스가 시간이 지날수록 점점 더 증가하고 테스트 케이스를 유지보수하는 노력도 함께 증가하므로 전 구간 테스트에 걸리는 시간이 점점 더 늘어나기 마련이다. 결국 이로 인해 느려진 개발 일정을 맞추기 위해 전 구간 테스트를 생략하려는 압력도 커진다.